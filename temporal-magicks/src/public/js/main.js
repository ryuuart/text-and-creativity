(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/three/build/three.cjs
  var require_three = __commonJS({
    "node_modules/three/build/three.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var REVISION = "138";
      var MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      };
      var TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      };
      var CullFaceNone = 0;
      var CullFaceBack = 1;
      var CullFaceFront = 2;
      var CullFaceFrontBack = 3;
      var BasicShadowMap = 0;
      var PCFShadowMap = 1;
      var PCFSoftShadowMap = 2;
      var VSMShadowMap = 3;
      var FrontSide = 0;
      var BackSide = 1;
      var DoubleSide = 2;
      var FlatShading = 1;
      var SmoothShading = 2;
      var NoBlending = 0;
      var NormalBlending = 1;
      var AdditiveBlending = 2;
      var SubtractiveBlending = 3;
      var MultiplyBlending = 4;
      var CustomBlending = 5;
      var AddEquation = 100;
      var SubtractEquation = 101;
      var ReverseSubtractEquation = 102;
      var MinEquation = 103;
      var MaxEquation = 104;
      var ZeroFactor = 200;
      var OneFactor = 201;
      var SrcColorFactor = 202;
      var OneMinusSrcColorFactor = 203;
      var SrcAlphaFactor = 204;
      var OneMinusSrcAlphaFactor = 205;
      var DstAlphaFactor = 206;
      var OneMinusDstAlphaFactor = 207;
      var DstColorFactor = 208;
      var OneMinusDstColorFactor = 209;
      var SrcAlphaSaturateFactor = 210;
      var NeverDepth = 0;
      var AlwaysDepth = 1;
      var LessDepth = 2;
      var LessEqualDepth = 3;
      var EqualDepth = 4;
      var GreaterEqualDepth = 5;
      var GreaterDepth = 6;
      var NotEqualDepth = 7;
      var MultiplyOperation = 0;
      var MixOperation = 1;
      var AddOperation = 2;
      var NoToneMapping = 0;
      var LinearToneMapping = 1;
      var ReinhardToneMapping = 2;
      var CineonToneMapping = 3;
      var ACESFilmicToneMapping = 4;
      var CustomToneMapping = 5;
      var UVMapping = 300;
      var CubeReflectionMapping = 301;
      var CubeRefractionMapping = 302;
      var EquirectangularReflectionMapping = 303;
      var EquirectangularRefractionMapping = 304;
      var CubeUVReflectionMapping = 306;
      var CubeUVRefractionMapping = 307;
      var RepeatWrapping = 1e3;
      var ClampToEdgeWrapping = 1001;
      var MirroredRepeatWrapping = 1002;
      var NearestFilter = 1003;
      var NearestMipmapNearestFilter = 1004;
      var NearestMipMapNearestFilter = 1004;
      var NearestMipmapLinearFilter = 1005;
      var NearestMipMapLinearFilter = 1005;
      var LinearFilter = 1006;
      var LinearMipmapNearestFilter = 1007;
      var LinearMipMapNearestFilter = 1007;
      var LinearMipmapLinearFilter = 1008;
      var LinearMipMapLinearFilter = 1008;
      var UnsignedByteType = 1009;
      var ByteType = 1010;
      var ShortType = 1011;
      var UnsignedShortType = 1012;
      var IntType = 1013;
      var UnsignedIntType = 1014;
      var FloatType = 1015;
      var HalfFloatType = 1016;
      var UnsignedShort4444Type = 1017;
      var UnsignedShort5551Type = 1018;
      var UnsignedInt248Type = 1020;
      var AlphaFormat = 1021;
      var RGBFormat = 1022;
      var RGBAFormat = 1023;
      var LuminanceFormat = 1024;
      var LuminanceAlphaFormat = 1025;
      var DepthFormat = 1026;
      var DepthStencilFormat = 1027;
      var RedFormat = 1028;
      var RedIntegerFormat = 1029;
      var RGFormat = 1030;
      var RGIntegerFormat = 1031;
      var RGBAIntegerFormat = 1033;
      var RGB_S3TC_DXT1_Format = 33776;
      var RGBA_S3TC_DXT1_Format = 33777;
      var RGBA_S3TC_DXT3_Format = 33778;
      var RGBA_S3TC_DXT5_Format = 33779;
      var RGB_PVRTC_4BPPV1_Format = 35840;
      var RGB_PVRTC_2BPPV1_Format = 35841;
      var RGBA_PVRTC_4BPPV1_Format = 35842;
      var RGBA_PVRTC_2BPPV1_Format = 35843;
      var RGB_ETC1_Format = 36196;
      var RGB_ETC2_Format = 37492;
      var RGBA_ETC2_EAC_Format = 37496;
      var RGBA_ASTC_4x4_Format = 37808;
      var RGBA_ASTC_5x4_Format = 37809;
      var RGBA_ASTC_5x5_Format = 37810;
      var RGBA_ASTC_6x5_Format = 37811;
      var RGBA_ASTC_6x6_Format = 37812;
      var RGBA_ASTC_8x5_Format = 37813;
      var RGBA_ASTC_8x6_Format = 37814;
      var RGBA_ASTC_8x8_Format = 37815;
      var RGBA_ASTC_10x5_Format = 37816;
      var RGBA_ASTC_10x6_Format = 37817;
      var RGBA_ASTC_10x8_Format = 37818;
      var RGBA_ASTC_10x10_Format = 37819;
      var RGBA_ASTC_12x10_Format = 37820;
      var RGBA_ASTC_12x12_Format = 37821;
      var RGBA_BPTC_Format = 36492;
      var LoopOnce = 2200;
      var LoopRepeat = 2201;
      var LoopPingPong = 2202;
      var InterpolateDiscrete = 2300;
      var InterpolateLinear = 2301;
      var InterpolateSmooth = 2302;
      var ZeroCurvatureEnding = 2400;
      var ZeroSlopeEnding = 2401;
      var WrapAroundEnding = 2402;
      var NormalAnimationBlendMode = 2500;
      var AdditiveAnimationBlendMode = 2501;
      var TrianglesDrawMode = 0;
      var TriangleStripDrawMode = 1;
      var TriangleFanDrawMode = 2;
      var LinearEncoding = 3e3;
      var sRGBEncoding = 3001;
      var BasicDepthPacking = 3200;
      var RGBADepthPacking = 3201;
      var TangentSpaceNormalMap = 0;
      var ObjectSpaceNormalMap = 1;
      var ZeroStencilOp = 0;
      var KeepStencilOp = 7680;
      var ReplaceStencilOp = 7681;
      var IncrementStencilOp = 7682;
      var DecrementStencilOp = 7683;
      var IncrementWrapStencilOp = 34055;
      var DecrementWrapStencilOp = 34056;
      var InvertStencilOp = 5386;
      var NeverStencilFunc = 512;
      var LessStencilFunc = 513;
      var EqualStencilFunc = 514;
      var LessEqualStencilFunc = 515;
      var GreaterStencilFunc = 516;
      var NotEqualStencilFunc = 517;
      var GreaterEqualStencilFunc = 518;
      var AlwaysStencilFunc = 519;
      var StaticDrawUsage = 35044;
      var DynamicDrawUsage = 35048;
      var StreamDrawUsage = 35040;
      var StaticReadUsage = 35045;
      var DynamicReadUsage = 35049;
      var StreamReadUsage = 35041;
      var StaticCopyUsage = 35046;
      var DynamicCopyUsage = 35050;
      var StreamCopyUsage = 35042;
      var GLSL1 = "100";
      var GLSL3 = "300 es";
      var _SRGBAFormat = 1035;
      var EventDispatcher = class {
        addEventListener(type, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners = this._listeners;
          if (listeners[type] === void 0) {
            listeners[type] = [];
          }
          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }
        }
        hasEventListener(type, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners = this._listeners;
          return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[type];
          if (listenerArray !== void 0) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
              listenerArray.splice(index, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
              array[i2].call(this, event);
            }
            event.target = null;
          }
        }
      };
      var _lut = [];
      for (let i2 = 0; i2 < 256; i2++) {
        _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
      }
      var _seed = 1234567;
      var DEG2RAD = Math.PI / 180;
      var RAD2DEG = 180 / Math.PI;
      function generateUUID() {
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
      }
      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function euclideanModulo(n2, m2) {
        return (n2 % m2 + m2) % m2;
      }
      function mapLinear(x2, a1, a2, b1, b2) {
        return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
      }
      function inverseLerp(x2, y2, value) {
        if (x2 !== y2) {
          return (value - x2) / (y2 - x2);
        } else {
          return 0;
        }
      }
      function lerp(x2, y2, t2) {
        return (1 - t2) * x2 + t2 * y2;
      }
      function damp(x2, y2, lambda, dt2) {
        return lerp(x2, y2, 1 - Math.exp(-lambda * dt2));
      }
      function pingpong(x2, length = 1) {
        return length - Math.abs(euclideanModulo(x2, length * 2) - length);
      }
      function smoothstep(x2, min, max) {
        if (x2 <= min)
          return 0;
        if (x2 >= max)
          return 1;
        x2 = (x2 - min) / (max - min);
        return x2 * x2 * (3 - 2 * x2);
      }
      function smootherstep(x2, min, max) {
        if (x2 <= min)
          return 0;
        if (x2 >= max)
          return 1;
        x2 = (x2 - min) / (max - min);
        return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
      }
      function randInt(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      }
      function randFloat(low, high) {
        return low + Math.random() * (high - low);
      }
      function randFloatSpread(range) {
        return range * (0.5 - Math.random());
      }
      function seededRandom(s2) {
        if (s2 !== void 0)
          _seed = s2 % 2147483647;
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
      }
      function degToRad(degrees) {
        return degrees * DEG2RAD;
      }
      function radToDeg(radians) {
        return radians * RAD2DEG;
      }
      function isPowerOfTwo(value) {
        return (value & value - 1) === 0 && value !== 0;
      }
      function ceilPowerOfTwo(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
      }
      function floorPowerOfTwo(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
      }
      function setQuaternionFromProperEuler(q2, a2, b2, c2, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c22 = cos(b2 / 2);
        const s2 = sin(b2 / 2);
        const c13 = cos((a2 + c2) / 2);
        const s13 = sin((a2 + c2) / 2);
        const c1_3 = cos((a2 - c2) / 2);
        const s1_3 = sin((a2 - c2) / 2);
        const c3_1 = cos((c2 - a2) / 2);
        const s3_1 = sin((c2 - a2) / 2);
        switch (order) {
          case "XYX":
            q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
            break;
          case "YZY":
            q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
            break;
          case "ZXZ":
            q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
            break;
          case "XZX":
            q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
            break;
          case "YXY":
            q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
            break;
          case "ZYZ":
            q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
      }
      var MathUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        DEG2RAD,
        RAD2DEG,
        generateUUID,
        clamp,
        euclideanModulo,
        mapLinear,
        inverseLerp,
        lerp,
        damp,
        pingpong,
        smoothstep,
        smootherstep,
        randInt,
        randFloat,
        randFloatSpread,
        seededRandom,
        degToRad,
        radToDeg,
        isPowerOfTwo,
        ceilPowerOfTwo,
        floorPowerOfTwo,
        setQuaternionFromProperEuler
      });
      var Vector2 = class {
        constructor(x2 = 0, y2 = 0) {
          this.x = x2;
          this.y = y2;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x2, y2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x2) {
          this.x = x2;
          return this;
        }
        setY(y2) {
          this.y = y2;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v2) {
          this.x = v2.x;
          this.y = v2.y;
          return this;
        }
        add(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v2, w2);
          }
          this.x += v2.x;
          this.y += v2.y;
          return this;
        }
        addScalar(s2) {
          this.x += s2;
          this.y += s2;
          return this;
        }
        addVectors(a2, b2) {
          this.x = a2.x + b2.x;
          this.y = a2.y + b2.y;
          return this;
        }
        addScaledVector(v2, s2) {
          this.x += v2.x * s2;
          this.y += v2.y * s2;
          return this;
        }
        sub(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v2, w2);
          }
          this.x -= v2.x;
          this.y -= v2.y;
          return this;
        }
        subScalar(s2) {
          this.x -= s2;
          this.y -= s2;
          return this;
        }
        subVectors(a2, b2) {
          this.x = a2.x - b2.x;
          this.y = a2.y - b2.y;
          return this;
        }
        multiply(v2) {
          this.x *= v2.x;
          this.y *= v2.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v2) {
          this.x /= v2.x;
          this.y /= v2.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m2) {
          const x2 = this.x, y2 = this.y;
          const e4 = m2.elements;
          this.x = e4[0] * x2 + e4[3] * y2 + e4[6];
          this.y = e4[1] * x2 + e4[4] * y2 + e4[7];
          return this;
        }
        min(v2) {
          this.x = Math.min(this.x, v2.x);
          this.y = Math.min(this.y, v2.y);
          return this;
        }
        max(v2) {
          this.x = Math.max(this.x, v2.x);
          this.y = Math.max(this.y, v2.y);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v2) {
          return this.x * v2.x + this.y * v2.y;
        }
        cross(v2) {
          return this.x * v2.y - this.y * v2.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle;
        }
        distanceTo(v2) {
          return Math.sqrt(this.distanceToSquared(v2));
        }
        distanceToSquared(v2) {
          const dx = this.x - v2.x, dy = this.y - v2.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v2) {
          return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v2, alpha) {
          this.x += (v2.x - this.x) * alpha;
          this.y += (v2.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          return this;
        }
        equals(v2) {
          return v2.x === this.x && v2.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          return this;
        }
        rotateAround(center, angle) {
          const c2 = Math.cos(angle), s2 = Math.sin(angle);
          const x2 = this.x - center.x;
          const y2 = this.y - center.y;
          this.x = x2 * c2 - y2 * s2 + center.x;
          this.y = x2 * s2 + y2 * c2 + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      };
      Vector2.prototype.isVector2 = true;
      var Matrix3 = class {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te2 = this.elements;
          te2[0] = n11;
          te2[1] = n21;
          te2[2] = n31;
          te2[3] = n12;
          te2[4] = n22;
          te2[5] = n32;
          te2[6] = n13;
          te2[7] = n23;
          te2[8] = n33;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        }
        copy(m2) {
          const te2 = this.elements;
          const me2 = m2.elements;
          te2[0] = me2[0];
          te2[1] = me2[1];
          te2[2] = me2[2];
          te2[3] = me2[3];
          te2[4] = me2[4];
          te2[5] = me2[5];
          te2[6] = me2[6];
          te2[7] = me2[7];
          te2[8] = me2[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m2) {
          const me2 = m2.elements;
          this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
          return this;
        }
        multiply(m2) {
          return this.multiplyMatrices(this, m2);
        }
        premultiply(m2) {
          return this.multiplyMatrices(m2, this);
        }
        multiplyMatrices(a2, b2) {
          const ae2 = a2.elements;
          const be2 = b2.elements;
          const te2 = this.elements;
          const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
          const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
          const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
          const b11 = be2[0], b12 = be2[3], b13 = be2[6];
          const b21 = be2[1], b22 = be2[4], b23 = be2[7];
          const b31 = be2[2], b32 = be2[5], b33 = be2[8];
          te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s2) {
          const te2 = this.elements;
          te2[0] *= s2;
          te2[3] *= s2;
          te2[6] *= s2;
          te2[1] *= s2;
          te2[4] *= s2;
          te2[7] *= s2;
          te2[2] *= s2;
          te2[5] *= s2;
          te2[8] *= s2;
          return this;
        }
        determinant() {
          const te2 = this.elements;
          const a2 = te2[0], b2 = te2[1], c2 = te2[2], d = te2[3], e4 = te2[4], f = te2[5], g2 = te2[6], h2 = te2[7], i2 = te2[8];
          return a2 * e4 * i2 - a2 * f * h2 - b2 * d * i2 + b2 * f * g2 + c2 * d * h2 - c2 * e4 * g2;
        }
        invert() {
          const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te2[0] = t11 * detInv;
          te2[1] = (n31 * n23 - n33 * n21) * detInv;
          te2[2] = (n32 * n21 - n31 * n22) * detInv;
          te2[3] = t12 * detInv;
          te2[4] = (n33 * n11 - n31 * n13) * detInv;
          te2[5] = (n31 * n12 - n32 * n11) * detInv;
          te2[6] = t13 * detInv;
          te2[7] = (n21 * n13 - n23 * n11) * detInv;
          te2[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp2;
          const m2 = this.elements;
          tmp2 = m2[1];
          m2[1] = m2[3];
          m2[3] = tmp2;
          tmp2 = m2[2];
          m2[2] = m2[6];
          m2[6] = tmp2;
          tmp2 = m2[5];
          m2[5] = m2[7];
          m2[7] = tmp2;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r2) {
          const m2 = this.elements;
          r2[0] = m2[0];
          r2[1] = m2[3];
          r2[2] = m2[6];
          r2[3] = m2[1];
          r2[4] = m2[4];
          r2[5] = m2[7];
          r2[6] = m2[2];
          r2[7] = m2[5];
          r2[8] = m2[8];
          return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
          const c2 = Math.cos(rotation);
          const s2 = Math.sin(rotation);
          this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
          return this;
        }
        scale(sx, sy) {
          const te2 = this.elements;
          te2[0] *= sx;
          te2[3] *= sx;
          te2[6] *= sx;
          te2[1] *= sy;
          te2[4] *= sy;
          te2[7] *= sy;
          return this;
        }
        rotate(theta) {
          const c2 = Math.cos(theta);
          const s2 = Math.sin(theta);
          const te2 = this.elements;
          const a11 = te2[0], a12 = te2[3], a13 = te2[6];
          const a21 = te2[1], a22 = te2[4], a23 = te2[7];
          te2[0] = c2 * a11 + s2 * a21;
          te2[3] = c2 * a12 + s2 * a22;
          te2[6] = c2 * a13 + s2 * a23;
          te2[1] = -s2 * a11 + c2 * a21;
          te2[4] = -s2 * a12 + c2 * a22;
          te2[7] = -s2 * a13 + c2 * a23;
          return this;
        }
        translate(tx, ty) {
          const te2 = this.elements;
          te2[0] += tx * te2[2];
          te2[3] += tx * te2[5];
          te2[6] += tx * te2[8];
          te2[1] += ty * te2[2];
          te2[4] += ty * te2[5];
          te2[7] += ty * te2[8];
          return this;
        }
        equals(matrix) {
          const te2 = this.elements;
          const me2 = matrix.elements;
          for (let i2 = 0; i2 < 9; i2++) {
            if (te2[i2] !== me2[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te2 = this.elements;
          array[offset] = te2[0];
          array[offset + 1] = te2[1];
          array[offset + 2] = te2[2];
          array[offset + 3] = te2[3];
          array[offset + 4] = te2[4];
          array[offset + 5] = te2[5];
          array[offset + 6] = te2[6];
          array[offset + 7] = te2[7];
          array[offset + 8] = te2[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      };
      Matrix3.prototype.isMatrix3 = true;
      function arrayNeedsUint32(array) {
        for (let i2 = array.length - 1; i2 >= 0; --i2) {
          if (array[i2] > 65535)
            return true;
        }
        return false;
      }
      var TYPED_ARRAYS = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      };
      function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
      }
      function createElementNS(name) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", name);
      }
      var _colorKeywords = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      var _hslA = {
        h: 0,
        s: 0,
        l: 0
      };
      var _hslB = {
        h: 0,
        s: 0,
        l: 0
      };
      function hue2rgb(p, q2, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p + (q2 - p) * 6 * t2;
        if (t2 < 1 / 2)
          return q2;
        if (t2 < 2 / 3)
          return p + (q2 - p) * 6 * (2 / 3 - t2);
        return p;
      }
      function SRGBToLinear(c2) {
        return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
      }
      function LinearToSRGB(c2) {
        return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
      }
      var Color = class {
        constructor(r2, g2, b2) {
          if (g2 === void 0 && b2 === void 0) {
            return this.set(r2);
          }
          return this.setRGB(r2, g2, b2);
        }
        set(value) {
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          return this;
        }
        setRGB(r2, g2, b2) {
          this.r = r2;
          this.g = g2;
          this.b = b2;
          return this;
        }
        setHSL(h2, s2, l2) {
          h2 = euclideanModulo(h2, 1);
          s2 = clamp(s2, 0, 1);
          l2 = clamp(l2, 0, 1);
          if (s2 === 0) {
            this.r = this.g = this.b = l2;
          } else {
            const p = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
            const q2 = 2 * l2 - p;
            this.r = hue2rgb(q2, p, h2 + 1 / 3);
            this.g = hue2rgb(q2, p, h2);
            this.b = hue2rgb(q2, p, h2 - 1 / 3);
          }
          return this;
        }
        setStyle(style) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m2;
          if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name = m2[1];
            const components = m2[2];
            switch (name) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                  handleAlpha(color[4]);
                  return this;
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                  handleAlpha(color[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  const h2 = parseFloat(color[1]) / 360;
                  const s2 = parseInt(color[2], 10) / 100;
                  const l2 = parseInt(color[3], 10) / 100;
                  handleAlpha(color[4]);
                  return this.setHSL(h2, s2, l2);
                }
                break;
            }
          } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m2[1];
            const size = hex.length;
            if (size === 3) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
              this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
              this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
              return this;
            } else if (size === 6) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
              this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
              this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
              return this;
            }
          }
          if (style && style.length > 0) {
            return this.setColorName(style);
          }
          return this;
        }
        setColorName(style) {
          const hex = _colorKeywords[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex() {
          return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(target) {
          const r2 = this.r, g2 = this.g, b2 = this.b;
          const max = Math.max(r2, g2, b2);
          const min = Math.min(r2, g2, b2);
          let hue, saturation;
          const lightness = (min + max) / 2;
          if (min === max) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r2:
                hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
                break;
              case g2:
                hue = (b2 - r2) / delta + 2;
                break;
              case b2:
                hue = (r2 - g2) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getStyle() {
          return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
        }
        offsetHSL(h2, s2, l2) {
          this.getHSL(_hslA);
          _hslA.h += h2;
          _hslA.s += s2;
          _hslA.l += l2;
          this.setHSL(_hslA.h, _hslA.s, _hslA.l);
          return this;
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s2) {
          this.r += s2;
          this.g += s2;
          this.b += s2;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s2) {
          this.r *= s2;
          this.g *= s2;
          this.b *= s2;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA);
          color.getHSL(_hslB);
          const h2 = lerp(_hslA.h, _hslB.h, alpha);
          const s2 = lerp(_hslA.s, _hslB.s, alpha);
          const l2 = lerp(_hslA.l, _hslB.l, alpha);
          this.setHSL(h2, s2, l2);
          return this;
        }
        equals(c2) {
          return c2.r === this.r && c2.g === this.g && c2.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);
          if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
          }
          return this;
        }
        toJSON() {
          return this.getHex();
        }
      };
      Color.NAMES = _colorKeywords;
      Color.prototype.isColor = true;
      Color.prototype.r = 1;
      Color.prototype.g = 1;
      Color.prototype.b = 1;
      var _canvas;
      var ImageUtils = class {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
          }
          let canvas2;
          if (image instanceof HTMLCanvasElement) {
            canvas2 = image;
          } else {
            if (_canvas === void 0)
              _canvas = createElementNS("canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas2 = _canvas;
          }
          if (canvas2.width > 2048 || canvas2.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas2.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas2.toDataURL("image/png");
          }
        }
        static sRGBToLinear(image) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const canvas2 = createElementNS("canvas");
            canvas2.width = image.width;
            canvas2.height = image.height;
            const context = canvas2.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            const imageData = context.getImageData(0, 0, image.width, image.height);
            const data = imageData.data;
            for (let i2 = 0; i2 < data.length; i2++) {
              data[i2] = SRGBToLinear(data[i2] / 255) * 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas2;
          } else if (image.data) {
            const data = image.data.slice(0);
            for (let i2 = 0; i2 < data.length; i2++) {
              if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
              } else {
                data[i2] = SRGBToLinear(data[i2]);
              }
            }
            return {
              data,
              width: image.width,
              height: image.height
            };
          } else {
            console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
            return image;
          }
        }
      };
      var Source = class {
        constructor(data = null) {
          this.uuid = generateUUID();
          this.data = data;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.images[this.uuid] !== void 0) {
            return meta.images[this.uuid];
          }
          const output = {
            uuid: this.uuid,
            url: ""
          };
          const data = this.data;
          if (data !== null) {
            let url;
            if (Array.isArray(data)) {
              url = [];
              for (let i2 = 0, l2 = data.length; i2 < l2; i2++) {
                if (data[i2].isDataTexture) {
                  url.push(serializeImage(data[i2].image));
                } else {
                  url.push(serializeImage(data[i2]));
                }
              }
            } else {
              url = serializeImage(data);
            }
            output.url = url;
          }
          if (!isRootObject) {
            meta.images[this.uuid] = output;
          }
          return output;
        }
      };
      function serializeImage(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          return ImageUtils.getDataURL(image);
        } else {
          if (image.data) {
            return {
              data: Array.prototype.slice.call(image.data),
              width: image.width,
              height: image.height,
              type: image.data.constructor.name
            };
          } else {
            console.warn("THREE.Texture: Unable to serialize Texture.");
            return {};
          }
        }
      }
      Source.prototype.isSource = true;
      var textureId = 0;
      var Texture = class extends EventDispatcher {
        constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
          super();
          Object.defineProperty(this, "id", {
            value: textureId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.source = new Source(image);
          this.mipmaps = [];
          this.mapping = mapping;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format;
          this.internalFormat = null;
          this.type = type;
          this.offset = new Vector2(0, 0);
          this.repeat = new Vector2(1, 1);
          this.center = new Vector2(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix3();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = encoding;
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
          this.needsPMREMUpdate = false;
        }
        get image() {
          return this.source.data;
        }
        set image(value) {
          this.source.data = value;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.source = source.source;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          this.needsUpdate = true;
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(meta).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (JSON.stringify(this.userData) !== "{}")
            output.userData = this.userData;
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true) {
            this.version++;
            this.source.needsUpdate = true;
          }
        }
      };
      Texture.DEFAULT_IMAGE = null;
      Texture.DEFAULT_MAPPING = UVMapping;
      Texture.prototype.isTexture = true;
      var Vector4 = class {
        constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
          this.x = x2;
          this.y = y2;
          this.z = z2;
          this.w = w2;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x2, y2, z2, w2) {
          this.x = x2;
          this.y = y2;
          this.z = z2;
          this.w = w2;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x2) {
          this.x = x2;
          return this;
        }
        setY(y2) {
          this.y = y2;
          return this;
        }
        setZ(z2) {
          this.z = z2;
          return this;
        }
        setW(w2) {
          this.w = w2;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v2) {
          this.x = v2.x;
          this.y = v2.y;
          this.z = v2.z;
          this.w = v2.w !== void 0 ? v2.w : 1;
          return this;
        }
        add(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v2, w2);
          }
          this.x += v2.x;
          this.y += v2.y;
          this.z += v2.z;
          this.w += v2.w;
          return this;
        }
        addScalar(s2) {
          this.x += s2;
          this.y += s2;
          this.z += s2;
          this.w += s2;
          return this;
        }
        addVectors(a2, b2) {
          this.x = a2.x + b2.x;
          this.y = a2.y + b2.y;
          this.z = a2.z + b2.z;
          this.w = a2.w + b2.w;
          return this;
        }
        addScaledVector(v2, s2) {
          this.x += v2.x * s2;
          this.y += v2.y * s2;
          this.z += v2.z * s2;
          this.w += v2.w * s2;
          return this;
        }
        sub(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v2, w2);
          }
          this.x -= v2.x;
          this.y -= v2.y;
          this.z -= v2.z;
          this.w -= v2.w;
          return this;
        }
        subScalar(s2) {
          this.x -= s2;
          this.y -= s2;
          this.z -= s2;
          this.w -= s2;
          return this;
        }
        subVectors(a2, b2) {
          this.x = a2.x - b2.x;
          this.y = a2.y - b2.y;
          this.z = a2.z - b2.z;
          this.w = a2.w - b2.w;
          return this;
        }
        multiply(v2) {
          this.x *= v2.x;
          this.y *= v2.y;
          this.z *= v2.z;
          this.w *= v2.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m2) {
          const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
          const e4 = m2.elements;
          this.x = e4[0] * x2 + e4[4] * y2 + e4[8] * z2 + e4[12] * w2;
          this.y = e4[1] * x2 + e4[5] * y2 + e4[9] * z2 + e4[13] * w2;
          this.z = e4[2] * x2 + e4[6] * y2 + e4[10] * z2 + e4[14] * w2;
          this.w = e4[3] * x2 + e4[7] * y2 + e4[11] * z2 + e4[15] * w2;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q2) {
          this.w = 2 * Math.acos(q2.w);
          const s2 = Math.sqrt(1 - q2.w * q2.w);
          if (s2 < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q2.x / s2;
            this.y = q2.y / s2;
            this.z = q2.z / s2;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m2) {
          let angle, x2, y2, z2;
          const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x2 = 0;
                y2 = 0.707106781;
                z2 = 0.707106781;
              } else {
                x2 = Math.sqrt(xx);
                y2 = xy / x2;
                z2 = xz / x2;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x2 = 0.707106781;
                y2 = 0;
                z2 = 0.707106781;
              } else {
                y2 = Math.sqrt(yy);
                x2 = xy / y2;
                z2 = yz / y2;
              }
            } else {
              if (zz < epsilon) {
                x2 = 0.707106781;
                y2 = 0.707106781;
                z2 = 0;
              } else {
                z2 = Math.sqrt(zz);
                x2 = xz / z2;
                y2 = yz / z2;
              }
            }
            this.set(x2, y2, z2, angle);
            return this;
          }
          let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s2) < 1e-3)
            s2 = 1;
          this.x = (m32 - m23) / s2;
          this.y = (m13 - m31) / s2;
          this.z = (m21 - m12) / s2;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v2) {
          this.x = Math.min(this.x, v2.x);
          this.y = Math.min(this.y, v2.y);
          this.z = Math.min(this.z, v2.z);
          this.w = Math.min(this.w, v2.w);
          return this;
        }
        max(v2) {
          this.x = Math.max(this.x, v2.x);
          this.y = Math.max(this.y, v2.y);
          this.z = Math.max(this.z, v2.z);
          this.w = Math.max(this.w, v2.w);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v2) {
          return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v2, alpha) {
          this.x += (v2.x - this.x) * alpha;
          this.y += (v2.y - this.y) * alpha;
          this.z += (v2.z - this.z) * alpha;
          this.w += (v2.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;
          return this;
        }
        equals(v2) {
          return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      };
      Vector4.prototype.isVector4 = true;
      var WebGLRenderTarget = class extends EventDispatcher {
        constructor(width, height, options = {}) {
          super();
          this.width = width;
          this.height = height;
          this.depth = 1;
          this.scissor = new Vector4(0, 0, width, height);
          this.scissorTest = false;
          this.viewport = new Vector4(0, 0, width, height);
          const image = {
            width,
            height,
            depth: 1
          };
          this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
          this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
          this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
          this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
          this.samples = options.samples !== void 0 ? options.samples : 0;
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.image = Object.assign({}, source.texture.image);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          if (source.depthTexture !== null)
            this.depthTexture = source.depthTexture.clone();
          this.samples = source.samples;
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      };
      WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
      var DataArrayTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataArrayTexture.prototype.isDataArrayTexture = true;
      var WebGLArrayRenderTarget = class extends WebGLRenderTarget {
        constructor(width, height, depth) {
          super(width, height);
          this.depth = depth;
          this.texture = new DataArrayTexture(null, width, height, depth);
          this.texture.isRenderTargetTexture = true;
        }
      };
      WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;
      var Data3DTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      Data3DTexture.prototype.isData3DTexture = true;
      var WebGL3DRenderTarget = class extends WebGLRenderTarget {
        constructor(width, height, depth) {
          super(width, height);
          this.depth = depth;
          this.texture = new Data3DTexture(null, width, height, depth);
          this.texture.isRenderTargetTexture = true;
        }
      };
      WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;
      var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
        constructor(width, height, count, options = {}) {
          super(width, height, options);
          const texture = this.texture;
          this.texture = [];
          for (let i2 = 0; i2 < count; i2++) {
            this.texture[i2] = texture.clone();
            this.texture[i2].isRenderTargetTexture = true;
          }
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for (let i2 = 0, il2 = this.texture.length; i2 < il2; i2++) {
              this.texture[i2].image.width = width;
              this.texture[i2].image.height = height;
              this.texture[i2].image.depth = depth;
            }
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
          return this;
        }
        copy(source) {
          this.dispose();
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.set(0, 0, this.width, this.height);
          this.scissor.set(0, 0, this.width, this.height);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          this.texture.length = 0;
          for (let i2 = 0, il2 = source.texture.length; i2 < il2; i2++) {
            this.texture[i2] = source.texture[i2].clone();
          }
          return this;
        }
      };
      WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
      var Quaternion = class {
        constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
          this._x = x2;
          this._y = y2;
          this._z = z2;
          this._w = w2;
        }
        static slerp(qa2, qb, qm, t2) {
          console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
          return qm.slerpQuaternions(qa2, qb, t2);
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t2 === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t2 === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s2 = 1 - t2;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
              s2 = Math.sin(s2 * len) / sin;
              t2 = Math.sin(t2 * len) / sin;
            }
            const tDir = t2 * dir;
            x0 = x0 * s2 + x1 * tDir;
            y0 = y0 * s2 + y1 * tDir;
            z0 = z0 * s2 + z1 * tDir;
            w0 = w0 * s2 + w1 * tDir;
            if (s2 === 1 - t2) {
              const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f;
              y0 *= f;
              z0 *= f;
              w0 *= f;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x2, y2, z2, w2) {
          this._x = x2;
          this._y = y2;
          this._z = z2;
          this._w = w2;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          if (!(euler && euler.isEuler)) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x2 / 2);
          const c2 = cos(y2 / 2);
          const c3 = cos(z2 / 2);
          const s1 = sin(x2 / 2);
          const s2 = sin(y2 / 2);
          const s3 = sin(z2 / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "YXZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "ZXY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "ZYX":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "YZX":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "XZY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle) {
          const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
          this._x = axis.x * s2;
          this._y = axis.y * s2;
          this._z = axis.z * s2;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m2) {
          const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s2 = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s2;
            this._x = (m32 - m23) * s2;
            this._y = (m13 - m31) * s2;
            this._z = (m21 - m12) * s2;
          } else if (m11 > m22 && m11 > m33) {
            const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s2;
            this._x = 0.25 * s2;
            this._y = (m12 + m21) / s2;
            this._z = (m13 + m31) / s2;
          } else if (m22 > m33) {
            const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s2;
            this._x = (m12 + m21) / s2;
            this._y = 0.25 * s2;
            this._z = (m23 + m32) / s2;
          } else {
            const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s2;
            this._x = (m13 + m31) / s2;
            this._y = (m23 + m32) / s2;
            this._z = 0.25 * s2;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r2 = vFrom.dot(vTo) + 1;
          if (r2 < Number.EPSILON) {
            r2 = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r2;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r2;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r2;
          }
          return this.normalize();
        }
        angleTo(q2) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
        }
        rotateTowards(q2, step) {
          const angle = this.angleTo(q2);
          if (angle === 0)
            return this;
          const t2 = Math.min(1, step / angle);
          this.slerp(q2, t2);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v2) {
          return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l2 = this.length();
          if (l2 === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l2 = 1 / l2;
            this._x = this._x * l2;
            this._y = this._y * l2;
            this._z = this._z * l2;
            this._w = this._w * l2;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q2, p) {
          if (p !== void 0) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q2, p);
          }
          return this.multiplyQuaternions(this, q2);
        }
        premultiply(q2) {
          return this.multiplyQuaternions(q2, this);
        }
        multiplyQuaternions(a2, b2) {
          const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
          const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb, t2) {
          if (t2 === 0)
            return this;
          if (t2 === 1)
            return this.copy(qb);
          const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
          let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
          if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this._w = w2;
            this._x = x2;
            this._y = y2;
            this._z = z2;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s2 = 1 - t2;
            this._w = s2 * w2 + t2 * this._w;
            this._x = s2 * x2 + t2 * this._x;
            this._y = s2 * y2 + t2 * this._y;
            this._z = s2 * z2 + t2 * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
          this._w = w2 * ratioA + this._w * ratioB;
          this._x = x2 * ratioA + this._x * ratioB;
          this._y = y2 * ratioA + this._y * ratioB;
          this._z = z2 * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa2, qb, t2) {
          return this.copy(qa2).slerp(qb, t2);
        }
        random() {
          const u1 = Math.random();
          const sqrt1u1 = Math.sqrt(1 - u1);
          const sqrtu1 = Math.sqrt(u1);
          const u2 = 2 * Math.PI * Math.random();
          const u3 = 2 * Math.PI * Math.random();
          return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);
          return this;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      };
      Quaternion.prototype.isQuaternion = true;
      var Vector3 = class {
        constructor(x2 = 0, y2 = 0, z2 = 0) {
          this.x = x2;
          this.y = y2;
          this.z = z2;
        }
        set(x2, y2, z2) {
          if (z2 === void 0)
            z2 = this.z;
          this.x = x2;
          this.y = y2;
          this.z = z2;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x2) {
          this.x = x2;
          return this;
        }
        setY(y2) {
          this.y = y2;
          return this;
        }
        setZ(z2) {
          this.z = z2;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v2) {
          this.x = v2.x;
          this.y = v2.y;
          this.z = v2.z;
          return this;
        }
        add(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v2, w2);
          }
          this.x += v2.x;
          this.y += v2.y;
          this.z += v2.z;
          return this;
        }
        addScalar(s2) {
          this.x += s2;
          this.y += s2;
          this.z += s2;
          return this;
        }
        addVectors(a2, b2) {
          this.x = a2.x + b2.x;
          this.y = a2.y + b2.y;
          this.z = a2.z + b2.z;
          return this;
        }
        addScaledVector(v2, s2) {
          this.x += v2.x * s2;
          this.y += v2.y * s2;
          this.z += v2.z * s2;
          return this;
        }
        sub(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v2, w2);
          }
          this.x -= v2.x;
          this.y -= v2.y;
          this.z -= v2.z;
          return this;
        }
        subScalar(s2) {
          this.x -= s2;
          this.y -= s2;
          this.z -= s2;
          return this;
        }
        subVectors(a2, b2) {
          this.x = a2.x - b2.x;
          this.y = a2.y - b2.y;
          this.z = a2.z - b2.z;
          return this;
        }
        multiply(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v2, w2);
          }
          this.x *= v2.x;
          this.y *= v2.y;
          this.z *= v2.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a2, b2) {
          this.x = a2.x * b2.x;
          this.y = a2.y * b2.y;
          this.z = a2.z * b2.z;
          return this;
        }
        applyEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
          return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m2) {
          const x2 = this.x, y2 = this.y, z2 = this.z;
          const e4 = m2.elements;
          this.x = e4[0] * x2 + e4[3] * y2 + e4[6] * z2;
          this.y = e4[1] * x2 + e4[4] * y2 + e4[7] * z2;
          this.z = e4[2] * x2 + e4[5] * y2 + e4[8] * z2;
          return this;
        }
        applyNormalMatrix(m2) {
          return this.applyMatrix3(m2).normalize();
        }
        applyMatrix4(m2) {
          const x2 = this.x, y2 = this.y, z2 = this.z;
          const e4 = m2.elements;
          const w2 = 1 / (e4[3] * x2 + e4[7] * y2 + e4[11] * z2 + e4[15]);
          this.x = (e4[0] * x2 + e4[4] * y2 + e4[8] * z2 + e4[12]) * w2;
          this.y = (e4[1] * x2 + e4[5] * y2 + e4[9] * z2 + e4[13]) * w2;
          this.z = (e4[2] * x2 + e4[6] * y2 + e4[10] * z2 + e4[14]) * w2;
          return this;
        }
        applyQuaternion(q2) {
          const x2 = this.x, y2 = this.y, z2 = this.z;
          const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
          const ix = qw * x2 + qy * z2 - qz * y2;
          const iy = qw * y2 + qz * x2 - qx * z2;
          const iz = qw * z2 + qx * y2 - qy * x2;
          const iw = -qx * x2 - qy * y2 - qz * z2;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m2) {
          const x2 = this.x, y2 = this.y, z2 = this.z;
          const e4 = m2.elements;
          this.x = e4[0] * x2 + e4[4] * y2 + e4[8] * z2;
          this.y = e4[1] * x2 + e4[5] * y2 + e4[9] * z2;
          this.z = e4[2] * x2 + e4[6] * y2 + e4[10] * z2;
          return this.normalize();
        }
        divide(v2) {
          this.x /= v2.x;
          this.y /= v2.y;
          this.z /= v2.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v2) {
          this.x = Math.min(this.x, v2.x);
          this.y = Math.min(this.y, v2.y);
          this.z = Math.min(this.z, v2.z);
          return this;
        }
        max(v2) {
          this.x = Math.max(this.x, v2.x);
          this.y = Math.max(this.y, v2.y);
          this.z = Math.max(this.z, v2.z);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v2) {
          return this.x * v2.x + this.y * v2.y + this.z * v2.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v2, alpha) {
          this.x += (v2.x - this.x) * alpha;
          this.y += (v2.y - this.y) * alpha;
          this.z += (v2.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          return this;
        }
        cross(v2, w2) {
          if (w2 !== void 0) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v2, w2);
          }
          return this.crossVectors(this, v2);
        }
        crossVectors(a2, b2) {
          const ax = a2.x, ay = a2.y, az = a2.z;
          const bx = b2.x, by = b2.y, bz = b2.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v2) {
          const denominator = v2.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v2.dot(this) / denominator;
          return this.copy(v2).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$c.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$c);
        }
        reflect(normal) {
          return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v2) {
          const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v2) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v2) {
          return Math.sqrt(this.distanceToSquared(v2));
        }
        distanceToSquared(v2) {
          const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v2) {
          return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
        }
        setFromSpherical(s2) {
          return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c2) {
          return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
        }
        setFromCylindricalCoords(radius, theta, y2) {
          this.x = radius * Math.sin(theta);
          this.y = y2;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m2) {
          const e4 = m2.elements;
          this.x = e4[12];
          this.y = e4[13];
          this.z = e4[14];
          return this;
        }
        setFromMatrixScale(m2) {
          const sx = this.setFromMatrixColumn(m2, 0).length();
          const sy = this.setFromMatrixColumn(m2, 1).length();
          const sz = this.setFromMatrixColumn(m2, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m2, index) {
          return this.fromArray(m2.elements, index * 4);
        }
        setFromMatrix3Column(m2, index) {
          return this.fromArray(m2.elements, index * 3);
        }
        setFromEuler(e4) {
          this.x = e4._x;
          this.y = e4._y;
          this.z = e4._z;
          return this;
        }
        equals(v2) {
          return v2.x === this.x && v2.y === this.y && v2.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const u2 = (Math.random() - 0.5) * 2;
          const t2 = Math.random() * Math.PI * 2;
          const f = Math.sqrt(1 - u2 ** 2);
          this.x = f * Math.cos(t2);
          this.y = f * Math.sin(t2);
          this.z = u2;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      };
      Vector3.prototype.isVector3 = true;
      var _vector$c = /* @__PURE__ */ new Vector3();
      var _quaternion$4 = /* @__PURE__ */ new Quaternion();
      var Box3 = class {
        constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromArray(array) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
            const x2 = array[i2];
            const y2 = array[i2 + 1];
            const z2 = array[i2 + 2];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (z2 < minZ)
              minZ = z2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
            if (z2 > maxZ)
              maxZ = z2;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromBufferAttribute(attribute) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
            const x2 = attribute.getX(i2);
            const y2 = attribute.getY(i2);
            const z2 = attribute.getZ(i2);
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (z2 < minZ)
              minZ = z2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
            if (z2 > maxZ)
              maxZ = z2;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il2 = points.length; i2 < il2; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object, precise = false) {
          this.makeEmpty();
          return this.expandByObject(object, precise);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object, precise = false) {
          object.updateWorldMatrix(false, false);
          const geometry = object.geometry;
          if (geometry !== void 0) {
            if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
              const position = geometry.attributes.position;
              for (let i2 = 0, l2 = position.count; i2 < l2; i2++) {
                _vector$b.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
                this.expandByPoint(_vector$b);
              }
            } else {
              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              _box$3.copy(geometry.boundingBox);
              _box$3.applyMatrix4(object.matrixWorld);
              this.union(_box$3);
            }
          }
          const children = object.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            this.expandByObject(children[i2], precise);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$b);
          return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);
          _v0$2.subVectors(triangle.a, _center);
          _v1$7.subVectors(triangle.b, _center);
          _v2$3.subVectors(triangle.c, _center);
          _f0.subVectors(_v1$7, _v0$2);
          _f1.subVectors(_v2$3, _v1$7);
          _f2.subVectors(_v0$2, _v2$3);
          let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
          return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        getBoundingSphere(target) {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b).length() * 0.5;
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      Box3.prototype.isBox3 = true;
      var _points = [/* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3()];
      var _vector$b = /* @__PURE__ */ new Vector3();
      var _box$3 = /* @__PURE__ */ new Box3();
      var _v0$2 = /* @__PURE__ */ new Vector3();
      var _v1$7 = /* @__PURE__ */ new Vector3();
      var _v2$3 = /* @__PURE__ */ new Vector3();
      var _f0 = /* @__PURE__ */ new Vector3();
      var _f1 = /* @__PURE__ */ new Vector3();
      var _f2 = /* @__PURE__ */ new Vector3();
      var _center = /* @__PURE__ */ new Vector3();
      var _extents = /* @__PURE__ */ new Vector3();
      var _triangleNormal = /* @__PURE__ */ new Vector3();
      var _testAxis = /* @__PURE__ */ new Vector3();
      function satForAxes(axes, v0, v1, v2, extents) {
        for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
          _testAxis.fromArray(axes, i2);
          const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
          const p0 = v0.dot(_testAxis);
          const p1 = v1.dot(_testAxis);
          const p2 = v2.dot(_testAxis);
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
            return false;
          }
        }
        return true;
      }
      var _box$2 = /* @__PURE__ */ new Box3();
      var _v1$6 = /* @__PURE__ */ new Vector3();
      var _toFarthestPoint = /* @__PURE__ */ new Vector3();
      var _toPoint = /* @__PURE__ */ new Vector3();
      var Sphere = class {
        constructor(center = new Vector3(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$2.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i2 = 0, il2 = points.length; i2 < il2; i2++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          _toPoint.subVectors(point, this.center);
          const lengthSq = _toPoint.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
          }
          return this;
        }
        union(sphere) {
          if (this.center.equals(sphere.center) === true) {
            _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
          } else {
            _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
          }
          this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
          this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var _vector$a = /* @__PURE__ */ new Vector3();
      var _segCenter = /* @__PURE__ */ new Vector3();
      var _segDir = /* @__PURE__ */ new Vector3();
      var _diff = /* @__PURE__ */ new Vector3();
      var _edge1 = /* @__PURE__ */ new Vector3();
      var _edge2 = /* @__PURE__ */ new Vector3();
      var _normal$1 = /* @__PURE__ */ new Vector3();
      var Ray = class {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t2, target) {
          return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
        }
        lookAt(v2) {
          this.direction.copy(v2).sub(this.origin).normalize();
          return this;
        }
        recast(t2) {
          this.origin.copy(this.at(t2, _vector$a));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return _vector$a.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c2 = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c2;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$a.subVectors(sphere.center, this.origin);
          const tca = _vector$a.dot(this.direction);
          const d2 = _vector$a.dot(_vector$a) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d2);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t2 >= 0 ? t2 : null;
        }
        intersectPlane(plane, target) {
          const t2 = this.distanceToPlane(plane);
          if (t2 === null) {
            return null;
          }
          return this.at(t2, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
          if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$a) !== null;
        }
        intersectTriangle(a2, b2, c2, backfaceCulling, target) {
          _edge1.subVectors(b2, a2);
          _edge2.subVectors(c2, a2);
          _normal$1.crossVectors(_edge1, _edge2);
          let DdN = this.direction.dot(_normal$1);
          let sign2;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign2 = 1;
          } else if (DdN < 0) {
            sign2 = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff.subVectors(this.origin, a2);
          const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign2 * _diff.dot(_normal$1);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var Matrix4 = class {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te2 = this.elements;
          te2[0] = n11;
          te2[4] = n12;
          te2[8] = n13;
          te2[12] = n14;
          te2[1] = n21;
          te2[5] = n22;
          te2[9] = n23;
          te2[13] = n24;
          te2[2] = n31;
          te2[6] = n32;
          te2[10] = n33;
          te2[14] = n34;
          te2[3] = n41;
          te2[7] = n42;
          te2[11] = n43;
          te2[15] = n44;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        clone() {
          return new Matrix4().fromArray(this.elements);
        }
        copy(m2) {
          const te2 = this.elements;
          const me2 = m2.elements;
          te2[0] = me2[0];
          te2[1] = me2[1];
          te2[2] = me2[2];
          te2[3] = me2[3];
          te2[4] = me2[4];
          te2[5] = me2[5];
          te2[6] = me2[6];
          te2[7] = me2[7];
          te2[8] = me2[8];
          te2[9] = me2[9];
          te2[10] = me2[10];
          te2[11] = me2[11];
          te2[12] = me2[12];
          te2[13] = me2[13];
          te2[14] = me2[14];
          te2[15] = me2[15];
          return this;
        }
        copyPosition(m2) {
          const te2 = this.elements, me2 = m2.elements;
          te2[12] = me2[12];
          te2[13] = me2[13];
          te2[14] = me2[14];
          return this;
        }
        setFromMatrix3(m2) {
          const me2 = m2.elements;
          this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
          return this;
        }
        extractRotation(m2) {
          const te2 = this.elements;
          const me2 = m2.elements;
          const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
          const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
          const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
          te2[0] = me2[0] * scaleX;
          te2[1] = me2[1] * scaleX;
          te2[2] = me2[2] * scaleX;
          te2[3] = 0;
          te2[4] = me2[4] * scaleY;
          te2[5] = me2[5] * scaleY;
          te2[6] = me2[6] * scaleY;
          te2[7] = 0;
          te2[8] = me2[8] * scaleZ;
          te2[9] = me2[9] * scaleZ;
          te2[10] = me2[10] * scaleZ;
          te2[11] = 0;
          te2[12] = 0;
          te2[13] = 0;
          te2[14] = 0;
          te2[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          }
          const te2 = this.elements;
          const x2 = euler.x, y2 = euler.y, z2 = euler.z;
          const a2 = Math.cos(x2), b2 = Math.sin(x2);
          const c2 = Math.cos(y2), d = Math.sin(y2);
          const e4 = Math.cos(z2), f = Math.sin(z2);
          if (euler.order === "XYZ") {
            const ae2 = a2 * e4, af2 = a2 * f, be2 = b2 * e4, bf2 = b2 * f;
            te2[0] = c2 * e4;
            te2[4] = -c2 * f;
            te2[8] = d;
            te2[1] = af2 + be2 * d;
            te2[5] = ae2 - bf2 * d;
            te2[9] = -b2 * c2;
            te2[2] = bf2 - ae2 * d;
            te2[6] = be2 + af2 * d;
            te2[10] = a2 * c2;
          } else if (euler.order === "YXZ") {
            const ce2 = c2 * e4, cf2 = c2 * f, de2 = d * e4, df2 = d * f;
            te2[0] = ce2 + df2 * b2;
            te2[4] = de2 * b2 - cf2;
            te2[8] = a2 * d;
            te2[1] = a2 * f;
            te2[5] = a2 * e4;
            te2[9] = -b2;
            te2[2] = cf2 * b2 - de2;
            te2[6] = df2 + ce2 * b2;
            te2[10] = a2 * c2;
          } else if (euler.order === "ZXY") {
            const ce2 = c2 * e4, cf2 = c2 * f, de2 = d * e4, df2 = d * f;
            te2[0] = ce2 - df2 * b2;
            te2[4] = -a2 * f;
            te2[8] = de2 + cf2 * b2;
            te2[1] = cf2 + de2 * b2;
            te2[5] = a2 * e4;
            te2[9] = df2 - ce2 * b2;
            te2[2] = -a2 * d;
            te2[6] = b2;
            te2[10] = a2 * c2;
          } else if (euler.order === "ZYX") {
            const ae2 = a2 * e4, af2 = a2 * f, be2 = b2 * e4, bf2 = b2 * f;
            te2[0] = c2 * e4;
            te2[4] = be2 * d - af2;
            te2[8] = ae2 * d + bf2;
            te2[1] = c2 * f;
            te2[5] = bf2 * d + ae2;
            te2[9] = af2 * d - be2;
            te2[2] = -d;
            te2[6] = b2 * c2;
            te2[10] = a2 * c2;
          } else if (euler.order === "YZX") {
            const ac2 = a2 * c2, ad2 = a2 * d, bc2 = b2 * c2, bd2 = b2 * d;
            te2[0] = c2 * e4;
            te2[4] = bd2 - ac2 * f;
            te2[8] = bc2 * f + ad2;
            te2[1] = f;
            te2[5] = a2 * e4;
            te2[9] = -b2 * e4;
            te2[2] = -d * e4;
            te2[6] = ad2 * f + bc2;
            te2[10] = ac2 - bd2 * f;
          } else if (euler.order === "XZY") {
            const ac2 = a2 * c2, ad2 = a2 * d, bc2 = b2 * c2, bd2 = b2 * d;
            te2[0] = c2 * e4;
            te2[4] = -f;
            te2[8] = d * e4;
            te2[1] = ac2 * f + bd2;
            te2[5] = a2 * e4;
            te2[9] = ad2 * f - bc2;
            te2[2] = bc2 * f - ad2;
            te2[6] = b2 * e4;
            te2[10] = bd2 * f + ac2;
          }
          te2[3] = 0;
          te2[7] = 0;
          te2[11] = 0;
          te2[12] = 0;
          te2[13] = 0;
          te2[14] = 0;
          te2[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q2) {
          return this.compose(_zero, q2, _one);
        }
        lookAt(eye, target, up2) {
          const te2 = this.elements;
          _z.subVectors(eye, target);
          if (_z.lengthSq() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up2, _z);
          if (_x.lengthSq() === 0) {
            if (Math.abs(up2.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up2, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          te2[0] = _x.x;
          te2[4] = _y.x;
          te2[8] = _z.x;
          te2[1] = _x.y;
          te2[5] = _y.y;
          te2[9] = _z.y;
          te2[2] = _x.z;
          te2[6] = _y.z;
          te2[10] = _z.z;
          return this;
        }
        multiply(m2, n2) {
          if (n2 !== void 0) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m2, n2);
          }
          return this.multiplyMatrices(this, m2);
        }
        premultiply(m2) {
          return this.multiplyMatrices(m2, this);
        }
        multiplyMatrices(a2, b2) {
          const ae2 = a2.elements;
          const be2 = b2.elements;
          const te2 = this.elements;
          const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
          const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
          const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
          const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
          const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
          const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
          const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
          const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
          te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s2) {
          const te2 = this.elements;
          te2[0] *= s2;
          te2[4] *= s2;
          te2[8] *= s2;
          te2[12] *= s2;
          te2[1] *= s2;
          te2[5] *= s2;
          te2[9] *= s2;
          te2[13] *= s2;
          te2[2] *= s2;
          te2[6] *= s2;
          te2[10] *= s2;
          te2[14] *= s2;
          te2[3] *= s2;
          te2[7] *= s2;
          te2[11] *= s2;
          te2[15] *= s2;
          return this;
        }
        determinant() {
          const te2 = this.elements;
          const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
          const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
          const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
          const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te2 = this.elements;
          let tmp2;
          tmp2 = te2[1];
          te2[1] = te2[4];
          te2[4] = tmp2;
          tmp2 = te2[2];
          te2[2] = te2[8];
          te2[8] = tmp2;
          tmp2 = te2[6];
          te2[6] = te2[9];
          te2[9] = tmp2;
          tmp2 = te2[3];
          te2[3] = te2[12];
          te2[12] = tmp2;
          tmp2 = te2[7];
          te2[7] = te2[13];
          te2[13] = tmp2;
          tmp2 = te2[11];
          te2[11] = te2[14];
          te2[14] = tmp2;
          return this;
        }
        setPosition(x2, y2, z2) {
          const te2 = this.elements;
          if (x2.isVector3) {
            te2[12] = x2.x;
            te2[13] = x2.y;
            te2[14] = x2.z;
          } else {
            te2[12] = x2;
            te2[13] = y2;
            te2[14] = z2;
          }
          return this;
        }
        invert() {
          const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te2[0] = t11 * detInv;
          te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te2[4] = t12 * detInv;
          te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te2[8] = t13 * detInv;
          te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te2[12] = t14 * detInv;
          te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v2) {
          const te2 = this.elements;
          const x2 = v2.x, y2 = v2.y, z2 = v2.z;
          te2[0] *= x2;
          te2[4] *= y2;
          te2[8] *= z2;
          te2[1] *= x2;
          te2[5] *= y2;
          te2[9] *= z2;
          te2[2] *= x2;
          te2[6] *= y2;
          te2[10] *= z2;
          te2[3] *= x2;
          te2[7] *= y2;
          te2[11] *= z2;
          return this;
        }
        getMaxScaleOnAxis() {
          const te2 = this.elements;
          const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
          const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
          const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x2, y2, z2) {
          this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
          return this;
        }
        makeRotationX(theta) {
          const c2 = Math.cos(theta), s2 = Math.sin(theta);
          this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationY(theta) {
          const c2 = Math.cos(theta), s2 = Math.sin(theta);
          this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationZ(theta) {
          const c2 = Math.cos(theta), s2 = Math.sin(theta);
          this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationAxis(axis, angle) {
          const c2 = Math.cos(angle);
          const s2 = Math.sin(angle);
          const t2 = 1 - c2;
          const x2 = axis.x, y2 = axis.y, z2 = axis.z;
          const tx = t2 * x2, ty = t2 * y2;
          this.set(tx * x2 + c2, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
          return this;
        }
        makeScale(x2, y2, z2) {
          this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
          return this;
        }
        compose(position, quaternion, scale) {
          const te2 = this.elements;
          const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
          const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
          const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
          const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
          const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
          const sx = scale.x, sy = scale.y, sz = scale.z;
          te2[0] = (1 - (yy + zz)) * sx;
          te2[1] = (xy + wz) * sx;
          te2[2] = (xz - wy) * sx;
          te2[3] = 0;
          te2[4] = (xy - wz) * sy;
          te2[5] = (1 - (xx + zz)) * sy;
          te2[6] = (yz + wx) * sy;
          te2[7] = 0;
          te2[8] = (xz + wy) * sz;
          te2[9] = (yz - wx) * sz;
          te2[10] = (1 - (xx + yy)) * sz;
          te2[11] = 0;
          te2[12] = position.x;
          te2[13] = position.y;
          te2[14] = position.z;
          te2[15] = 1;
          return this;
        }
        decompose(position, quaternion, scale) {
          const te2 = this.elements;
          let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
          const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
          const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position.x = te2[12];
          position.y = te2[13];
          position.z = te2[14];
          _m1$2.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$2.elements[0] *= invSX;
          _m1$2.elements[1] *= invSX;
          _m1$2.elements[2] *= invSX;
          _m1$2.elements[4] *= invSY;
          _m1$2.elements[5] *= invSY;
          _m1$2.elements[6] *= invSY;
          _m1$2.elements[8] *= invSZ;
          _m1$2.elements[9] *= invSZ;
          _m1$2.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$2);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
          if (far === void 0) {
            console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          }
          const te2 = this.elements;
          const x2 = 2 * near / (right - left);
          const y2 = 2 * near / (top - bottom);
          const a2 = (right + left) / (right - left);
          const b2 = (top + bottom) / (top - bottom);
          const c2 = -(far + near) / (far - near);
          const d = -2 * far * near / (far - near);
          te2[0] = x2;
          te2[4] = 0;
          te2[8] = a2;
          te2[12] = 0;
          te2[1] = 0;
          te2[5] = y2;
          te2[9] = b2;
          te2[13] = 0;
          te2[2] = 0;
          te2[6] = 0;
          te2[10] = c2;
          te2[14] = d;
          te2[3] = 0;
          te2[7] = 0;
          te2[11] = -1;
          te2[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
          const te2 = this.elements;
          const w2 = 1 / (right - left);
          const h2 = 1 / (top - bottom);
          const p = 1 / (far - near);
          const x2 = (right + left) * w2;
          const y2 = (top + bottom) * h2;
          const z2 = (far + near) * p;
          te2[0] = 2 * w2;
          te2[4] = 0;
          te2[8] = 0;
          te2[12] = -x2;
          te2[1] = 0;
          te2[5] = 2 * h2;
          te2[9] = 0;
          te2[13] = -y2;
          te2[2] = 0;
          te2[6] = 0;
          te2[10] = -2 * p;
          te2[14] = -z2;
          te2[3] = 0;
          te2[7] = 0;
          te2[11] = 0;
          te2[15] = 1;
          return this;
        }
        equals(matrix) {
          const te2 = this.elements;
          const me2 = matrix.elements;
          for (let i2 = 0; i2 < 16; i2++) {
            if (te2[i2] !== me2[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 16; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te2 = this.elements;
          array[offset] = te2[0];
          array[offset + 1] = te2[1];
          array[offset + 2] = te2[2];
          array[offset + 3] = te2[3];
          array[offset + 4] = te2[4];
          array[offset + 5] = te2[5];
          array[offset + 6] = te2[6];
          array[offset + 7] = te2[7];
          array[offset + 8] = te2[8];
          array[offset + 9] = te2[9];
          array[offset + 10] = te2[10];
          array[offset + 11] = te2[11];
          array[offset + 12] = te2[12];
          array[offset + 13] = te2[13];
          array[offset + 14] = te2[14];
          array[offset + 15] = te2[15];
          return array;
        }
      };
      Matrix4.prototype.isMatrix4 = true;
      var _v1$5 = /* @__PURE__ */ new Vector3();
      var _m1$2 = /* @__PURE__ */ new Matrix4();
      var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
      var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
      var _x = /* @__PURE__ */ new Vector3();
      var _y = /* @__PURE__ */ new Vector3();
      var _z = /* @__PURE__ */ new Vector3();
      var _matrix$1 = /* @__PURE__ */ new Matrix4();
      var _quaternion$3 = /* @__PURE__ */ new Quaternion();
      var Euler = class {
        constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
          this._x = x2;
          this._y = y2;
          this._z = z2;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x2, y2, z2, order = this._order) {
          this._x = x2;
          this._y = y2;
          this._z = z2;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m2, order = this._order, update = true) {
          const te2 = m2.elements;
          const m11 = te2[0], m12 = te2[4], m13 = te2[8];
          const m21 = te2[1], m22 = te2[5], m23 = te2[9];
          const m31 = te2[2], m32 = te2[6], m33 = te2[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q2, order, update) {
          _matrix$1.makeRotationFromQuaternion(q2);
          return this.setFromRotationMatrix(_matrix$1, order, update);
        }
        setFromVector3(v2, order = this._order) {
          return this.set(v2.x, v2.y, v2.z, order);
        }
        reorder(newOrder) {
          _quaternion$3.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      };
      Euler.prototype.isEuler = true;
      Euler.DefaultOrder = "XYZ";
      Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      var Layers = class {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = (1 << channel | 0) >>> 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
        isEnabled(channel) {
          return (this.mask & (1 << channel | 0)) !== 0;
        }
      };
      var _object3DId = 0;
      var _v1$4 = /* @__PURE__ */ new Vector3();
      var _q1 = /* @__PURE__ */ new Quaternion();
      var _m1$1 = /* @__PURE__ */ new Matrix4();
      var _target = /* @__PURE__ */ new Vector3();
      var _position$3 = /* @__PURE__ */ new Vector3();
      var _scale$2 = /* @__PURE__ */ new Vector3();
      var _quaternion$2 = /* @__PURE__ */ new Quaternion();
      var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
      var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
      var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
      var _addedEvent = {
        type: "added"
      };
      var _removedEvent = {
        type: "removed"
      };
      var Object3D = class extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _object3DId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = Object3D.DefaultUp.clone();
          const position = new Vector3();
          const rotation = new Euler();
          const quaternion = new Quaternion();
          const scale = new Vector3(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
          }
          function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, false);
          }
          rotation._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale
            },
            modelViewMatrix: {
              value: new Matrix4()
            },
            normalMatrix: {
              value: new Matrix3()
            }
          });
          this.matrix = new Matrix4();
          this.matrixWorld = new Matrix4();
          this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = false;
          this.layers = new Layers();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q2) {
          this.quaternion.premultiply(q2);
          return this;
        }
        setRotationFromAxisAngle(axis, angle) {
          this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m2) {
          this.quaternion.setFromRotationMatrix(m2);
        }
        setRotationFromQuaternion(q2) {
          this.quaternion.copy(q2);
        }
        rotateOnAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(_q1);
          return this;
        }
        rotateOnWorldAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(_q1);
          return this;
        }
        rotateX(angle) {
          return this.rotateOnAxis(_xAxis, angle);
        }
        rotateY(angle) {
          return this.rotateOnAxis(_yAxis, angle);
        }
        rotateZ(angle) {
          return this.rotateOnAxis(_zAxis, angle);
        }
        translateOnAxis(axis, distance) {
          _v1$4.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$4.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x2, y2, z2) {
          if (x2.isVector3) {
            _target.copy(x2);
          } else {
            _target.set(x2, y2, z2);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$3.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$1.lookAt(_position$3, _target, this.up);
          } else {
            _m1$1.lookAt(_target, _position$3, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$1);
          if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.add(arguments[i2]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.remove(arguments[i2]);
            }
            return this;
          }
          const index = this.children.indexOf(object);
          if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          for (let i2 = 0; i2 < this.children.length; i2++) {
            const object = this.children[i2];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
          }
          this.children.length = 0;
          return this;
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$1.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$1);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id2) {
          return this.getObjectByProperty("id", id2);
        }
        getObjectByName(name) {
          return this.getObjectByProperty("name", name);
        }
        getObjectByProperty(name, value) {
          if (this[name] === value)
            return this;
          for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
            const child = this.children[i2];
            const object = child.getObjectByProperty(name, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, target, _scale$2);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, _quaternion$2, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e4 = this.matrixWorld.elements;
          return target.set(e4[8], e4[9], e4[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            children[i2].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            children[i2].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            children[i2].updateMatrixWorld(force);
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
              children[i2].updateWorldMatrix(false, true);
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {}
            };
            output.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (JSON.stringify(this.userData) !== "{}")
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
                  const shape = shapes[i2];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
                uuids.push(serialize(meta.materials, this.material[i2]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i2 = 0; i2 < this.children.length; i2++) {
              object.children.push(this.children[i2].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i2 = 0; i2 < this.animations.length; i2++) {
              const animation = this.animations[i2];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            const nodes = extractFromCache(meta.nodes);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
            if (nodes.length > 0)
              output.nodes = nodes;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values.push(data);
            }
            return values;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i2 = 0; i2 < source.children.length; i2++) {
              const child = source.children[i2];
              this.add(child.clone());
            }
          }
          return this;
        }
      };
      Object3D.DefaultUp = new Vector3(0, 1, 0);
      Object3D.DefaultMatrixAutoUpdate = true;
      Object3D.prototype.isObject3D = true;
      var _v0$1 = /* @__PURE__ */ new Vector3();
      var _v1$3 = /* @__PURE__ */ new Vector3();
      var _v2$2 = /* @__PURE__ */ new Vector3();
      var _v3$1 = /* @__PURE__ */ new Vector3();
      var _vab = /* @__PURE__ */ new Vector3();
      var _vac = /* @__PURE__ */ new Vector3();
      var _vbc = /* @__PURE__ */ new Vector3();
      var _vap = /* @__PURE__ */ new Vector3();
      var _vbp = /* @__PURE__ */ new Vector3();
      var _vcp = /* @__PURE__ */ new Vector3();
      var Triangle = class {
        constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
        }
        static getNormal(a2, b2, c2, target) {
          target.subVectors(c2, b2);
          _v0$1.subVectors(a2, b2);
          target.cross(_v0$1);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        static getBarycoord(point, a2, b2, c2, target) {
          _v0$1.subVectors(c2, a2);
          _v1$3.subVectors(b2, a2);
          _v2$2.subVectors(point, a2);
          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$2);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$2);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u2 - v2, v2, u2);
        }
        static containsPoint(point, a2, b2, c2) {
          this.getBarycoord(point, a2, b2, c2, _v3$1);
          return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
        }
        static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3$1);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3$1.x);
          target.addScaledVector(uv2, _v3$1.y);
          target.addScaledVector(uv3, _v3$1.z);
          return target;
        }
        static isFrontFacing(a2, b2, c2, direction) {
          _v0$1.subVectors(c2, b2);
          _v1$3.subVectors(a2, b2);
          return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        }
        set(a2, b2, c2) {
          this.a.copy(a2);
          this.b.copy(b2);
          this.c.copy(c2);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);
          return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i2) {
          this.a.fromBufferAttribute(attribute, i0);
          this.b.fromBufferAttribute(attribute, i1);
          this.c.fromBufferAttribute(attribute, i2);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);
          return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        containsPoint(point) {
          return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p, target) {
          const a2 = this.a, b2 = this.b, c2 = this.c;
          let v2, w2;
          _vab.subVectors(b2, a2);
          _vac.subVectors(c2, a2);
          _vap.subVectors(p, a2);
          const d1 = _vab.dot(_vap);
          const d2 = _vac.dot(_vap);
          if (d1 <= 0 && d2 <= 0) {
            return target.copy(a2);
          }
          _vbp.subVectors(p, b2);
          const d3 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d3 >= 0 && d4 <= d3) {
            return target.copy(b2);
          }
          const vc2 = d1 * d4 - d3 * d2;
          if (vc2 <= 0 && d1 >= 0 && d3 <= 0) {
            v2 = d1 / (d1 - d3);
            return target.copy(a2).addScaledVector(_vab, v2);
          }
          _vcp.subVectors(p, c2);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c2);
          }
          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w2 = d2 / (d2 - d6);
            return target.copy(a2).addScaledVector(_vac, w2);
          }
          const va2 = d3 * d6 - d5 * d4;
          if (va2 <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c2, b2);
            w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b2).addScaledVector(_vbc, w2);
          }
          const denom = 1 / (va2 + vb + vc2);
          v2 = vb * denom;
          w2 = vc2 * denom;
          return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      };
      var materialId = 0;
      var Material = class extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: materialId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Material";
          this.fog = true;
          this.blending = NormalBlending;
          this.side = FrontSide;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.blendSrc = SrcAlphaFactor;
          this.blendDst = OneMinusSrcAlphaFactor;
          this.blendEquation = AddEquation;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = LessEqualDepth;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp;
          this.stencilZFail = KeepStencilOp;
          this.stencilZPass = KeepStencilOp;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(value) {
          if (this._alphaTest > 0 !== value > 0) {
            this.version++;
          }
          this._alphaTest = value;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values) {
          if (values === void 0)
            return;
          for (const key in values) {
            const newValue = values[key];
            if (newValue === void 0) {
              console.warn("THREE.Material: '" + key + "' parameter is undefined.");
              continue;
            }
            if (key === "shading") {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
              this.flatShading = newValue === FlatShading ? true : false;
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (isRootObject) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen !== void 0)
            data.sheen = this.sheen;
          if (this.sheenColor && this.sheenColor.isColor)
            data.sheenColor = this.sheenColor.getHex();
          if (this.sheenRoughness !== void 0)
            data.sheenRoughness = this.sheenRoughness;
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.specularIntensity !== void 0)
            data.specularIntensity = this.specularIntensity;
          if (this.specularColor && this.specularColor.isColor)
            data.specularColor = this.specularColor.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
          if (this.specularColorMap && this.specularColorMap.isTexture)
            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending)
            data.blending = this.blending;
          if (this.side !== FrontSide)
            data.side = this.side;
          if (this.vertexColors)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.transparent === true)
            data.transparent = this.transparent;
          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;
          data.colorWrite = this.colorWrite;
          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;
          if (this.rotation !== void 0 && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth !== void 0 && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = this.alphaToCoverage;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
          if (this.wireframe === true)
            data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.flatShading === true)
            data.flatShading = this.flatShading;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (JSON.stringify(this.userData) !== "{}")
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values.push(data2);
            }
            return values;
          }
          if (isRootObject) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.fog = source.fog;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n2 = srcPlanes.length;
            dstPlanes = new Array(n2);
            for (let i2 = 0; i2 !== n2; ++i2) {
              dstPlanes[i2] = srcPlanes[i2].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      Material.prototype.isMaterial = true;
      Material.fromType = function() {
        return null;
      };
      var MeshBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
      var _vector$9 = /* @__PURE__ */ new Vector3();
      var _vector2$1 = /* @__PURE__ */ new Vector2();
      var BufferAttribute = class {
        constructor(array, itemSize, normalized) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized === true;
          this.usage = StaticDrawUsage;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        copyColorsArray(colors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l2 = colors.length; i2 < l2; i2++) {
            let color = colors[i2];
            if (color === void 0) {
              console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
              color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
          }
          return this;
        }
        copyVector2sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
              vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
          }
          return this;
        }
        copyVector3sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
              vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
          }
          return this;
        }
        copyVector4sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
              vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
          }
          return this;
        }
        applyMatrix3(m2) {
          if (this.itemSize === 2) {
            for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
              _vector2$1.fromBufferAttribute(this, i2);
              _vector2$1.applyMatrix3(m2);
              this.setXY(i2, _vector2$1.x, _vector2$1.y);
            }
          } else if (this.itemSize === 3) {
            for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
              _vector$9.fromBufferAttribute(this, i2);
              _vector$9.applyMatrix3(m2);
              this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
            }
          }
          return this;
        }
        applyMatrix4(m2) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.applyMatrix4(m2);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        applyNormalMatrix(m2) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.applyNormalMatrix(m2);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        transformDirection(m2) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.transformDirection(m2);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getX(index) {
          return this.array[index * this.itemSize];
        }
        setX(index, x2) {
          this.array[index * this.itemSize] = x2;
          return this;
        }
        getY(index) {
          return this.array[index * this.itemSize + 1];
        }
        setY(index, y2) {
          this.array[index * this.itemSize + 1] = y2;
          return this;
        }
        getZ(index) {
          return this.array[index * this.itemSize + 2];
        }
        setZ(index, z2) {
          this.array[index * this.itemSize + 2] = z2;
          return this;
        }
        getW(index) {
          return this.array[index * this.itemSize + 3];
        }
        setW(index, w2) {
          this.array[index * this.itemSize + 3] = w2;
          return this;
        }
        setXY(index, x2, y2) {
          index *= this.itemSize;
          this.array[index + 0] = x2;
          this.array[index + 1] = y2;
          return this;
        }
        setXYZ(index, x2, y2, z2) {
          index *= this.itemSize;
          this.array[index + 0] = x2;
          this.array[index + 1] = y2;
          this.array[index + 2] = z2;
          return this;
        }
        setXYZW(index, x2, y2, z2, w2) {
          index *= this.itemSize;
          this.array[index + 0] = x2;
          this.array[index + 1] = y2;
          this.array[index + 2] = z2;
          this.array[index + 3] = w2;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
      };
      BufferAttribute.prototype.isBufferAttribute = true;
      var Int8BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int8Array(array), itemSize, normalized);
        }
      };
      var Uint8BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8Array(array), itemSize, normalized);
        }
      };
      var Uint8ClampedBufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8ClampedArray(array), itemSize, normalized);
        }
      };
      var Int16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int16Array(array), itemSize, normalized);
        }
      };
      var Uint16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      var Int32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int32Array(array), itemSize, normalized);
        }
      };
      var Uint32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      };
      var Float16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
      var Float32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      };
      var Float64BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float64Array(array), itemSize, normalized);
        }
      };
      var _id$1 = 0;
      var _m1 = /* @__PURE__ */ new Matrix4();
      var _obj = /* @__PURE__ */ new Object3D();
      var _offset = /* @__PURE__ */ new Vector3();
      var _box$1 = /* @__PURE__ */ new Box3();
      var _boxMorphTargets = /* @__PURE__ */ new Box3();
      var _vector$8 = /* @__PURE__ */ new Vector3();
      var BufferGeometry = class extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _id$1++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = {
            start: 0,
            count: Infinity
          };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (Array.isArray(index)) {
            this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
          } else {
            this.index = index;
          }
          return this;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        setAttribute(name, attribute) {
          this.attributes[name] = attribute;
          return this;
        }
        deleteAttribute(name) {
          delete this.attributes[name];
          return this;
        }
        hasAttribute(name) {
          return this.attributes[name] !== void 0;
        }
        addGroup(start, count, materialIndex = 0) {
          this.groups.push({
            start,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start, count) {
          this.drawRange.start = start;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position = this.attributes.position;
          if (position !== void 0) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q2) {
          _m1.makeRotationFromQuaternion(q2);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateX(angle) {
          _m1.makeRotationX(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateY(angle) {
          _m1.makeRotationY(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateZ(angle) {
          _m1.makeRotationZ(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        translate(x2, y2, z2) {
          _m1.makeTranslation(x2, y2, z2);
          this.applyMatrix4(_m1);
          return this;
        }
        scale(x2, y2, z2) {
          _m1.makeScale(x2, y2, z2);
          this.applyMatrix4(_m1);
          return this;
        }
        lookAt(vector) {
          _obj.lookAt(vector);
          _obj.updateMatrix();
          this.applyMatrix4(_obj.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset).negate();
          this.translate(_offset.x, _offset.y, _offset.z);
          return this;
        }
        setFromPoints(points) {
          const position = [];
          for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
            const point = points[i2];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute(position, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
            return;
          }
          if (position !== void 0) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                  this.boundingBox.expandByPoint(_vector$8);
                  _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                  this.boundingBox.expandByPoint(_vector$8);
                } else {
                  this.boundingBox.expandByPoint(_box$1.min);
                  this.boundingBox.expandByPoint(_box$1.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
          }
          if (position) {
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                  _box$1.expandByPoint(_vector$8);
                  _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                  _box$1.expandByPoint(_vector$8);
                } else {
                  _box$1.expandByPoint(_boxMorphTargets.min);
                  _box$1.expandByPoint(_boxMorphTargets.max);
                }
              }
            }
            _box$1.getCenter(center);
            let maxRadiusSq = 0;
            for (let i2 = 0, il2 = position.count; i2 < il2; i2++) {
              _vector$8.fromBufferAttribute(position, i2);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
            if (morphAttributesPosition) {
              for (let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j2 = 0, jl2 = morphAttribute.count; j2 < jl2; j2++) {
                  _vector$8.fromBufferAttribute(morphAttribute, j2);
                  if (morphTargetsRelative) {
                    _offset.fromBufferAttribute(position, j2);
                    _vector$8.add(_offset);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeTangents() {
          const index = this.index;
          const attributes = this.attributes;
          if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (this.hasAttribute("tangent") === false) {
            this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
          }
          const tangents = this.getAttribute("tangent").array;
          const tan1 = [], tan2 = [];
          for (let i2 = 0; i2 < nVertices; i2++) {
            tan1[i2] = new Vector3();
            tan2[i2] = new Vector3();
          }
          const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
          function handleTriangle(a2, b2, c2) {
            vA.fromArray(positions, a2 * 3);
            vB.fromArray(positions, b2 * 3);
            vC.fromArray(positions, c2 * 3);
            uvA.fromArray(uvs, a2 * 2);
            uvB.fromArray(uvs, b2 * 2);
            uvC.fromArray(uvs, c2 * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r2))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
            tan1[a2].add(sdir);
            tan1[b2].add(sdir);
            tan1[c2].add(sdir);
            tan2[a2].add(tdir);
            tan2[b2].add(tdir);
            tan2[c2].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i2 = 0, il2 = groups.length; i2 < il2; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
              handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
            }
          }
          const tmp2 = new Vector3(), tmp22 = new Vector3();
          const n2 = new Vector3(), n22 = new Vector3();
          function handleVertex(v2) {
            n2.fromArray(normals, v2 * 3);
            n22.copy(n2);
            const t2 = tan1[v2];
            tmp2.copy(t2);
            tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
            tmp22.crossVectors(n22, t2);
            const test = tmp22.dot(tan2[v2]);
            const w2 = test < 0 ? -1 : 1;
            tangents[v2 * 4] = tmp2.x;
            tangents[v2 * 4 + 1] = tmp2.y;
            tangents[v2 * 4 + 2] = tmp2.z;
            tangents[v2 * 4 + 3] = w2;
          }
          for (let i2 = 0, il2 = groups.length; i2 < il2; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
              handleVertex(indices[j2 + 0]);
              handleVertex(indices[j2 + 1]);
              handleVertex(indices[j2 + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i2 = 0, il2 = normalAttribute.count; i2 < il2; i2++) {
                normalAttribute.setXYZ(i2, 0, 0, 0);
              }
            }
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            if (index) {
              for (let i2 = 0, il2 = index.count; i2 < il2; i2 += 3) {
                const vA = index.getX(i2 + 0);
                const vB = index.getX(i2 + 1);
                const vC = index.getX(i2 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i2 = 0, il2 = positionAttribute.count; i2 < il2; i2 += 3) {
                pA.fromBufferAttribute(positionAttribute, i2 + 0);
                pB.fromBufferAttribute(positionAttribute, i2 + 1);
                pC.fromBufferAttribute(positionAttribute, i2 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        merge(geometry, offset) {
          if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
          }
          if (offset === void 0) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            if (geometry.attributes[key] === void 0)
              continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
              attributeArray1[j2] = attributeArray2[i2];
            }
          }
          return this;
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i2 = 0, il2 = normals.count; i2 < il2; i2++) {
            _vector$8.fromBufferAttribute(normals, i2);
            _vector$8.normalize();
            normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
              if (attribute.isInterleavedBufferAttribute) {
                index = indices2[i2] * attribute.data.stride + attribute.offset;
              } else {
                index = indices2[i2] * itemSize;
              }
              for (let j2 = 0; j2 < itemSize; j2++) {
                array2[index2++] = array[index++];
              }
            }
            return new BufferAttribute(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new BufferGeometry();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {
              const attribute = morphAttribute[i2];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
            const group = groups[i2];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = {
            attributes: {}
          };
          const index = this.index;
          if (index !== null) {
            data.data.index = {
              type: index.array.constructor.name,
              array: Array.prototype.slice.call(index.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i2 = 0, il2 = attributeArray.length; i2 < il2; i2++) {
              const attribute = attributeArray[i2];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index = source.index;
          if (index !== null) {
            this.setIndex(index.clone(data));
          }
          const attributes = source.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
              array.push(morphAttribute[i2].clone(data));
            }
            this.morphAttributes[name] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
            const group = groups[i2];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          if (source.parameters !== void 0)
            this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      };
      BufferGeometry.prototype.isBufferGeometry = true;
      var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
      var _ray$2 = /* @__PURE__ */ new Ray();
      var _sphere$3 = /* @__PURE__ */ new Sphere();
      var _vA$1 = /* @__PURE__ */ new Vector3();
      var _vB$1 = /* @__PURE__ */ new Vector3();
      var _vC$1 = /* @__PURE__ */ new Vector3();
      var _tempA = /* @__PURE__ */ new Vector3();
      var _tempB = /* @__PURE__ */ new Vector3();
      var _tempC = /* @__PURE__ */ new Vector3();
      var _morphA = /* @__PURE__ */ new Vector3();
      var _morphB = /* @__PURE__ */ new Vector3();
      var _morphC = /* @__PURE__ */ new Vector3();
      var _uvA$1 = /* @__PURE__ */ new Vector2();
      var _uvB$1 = /* @__PURE__ */ new Vector2();
      var _uvC$1 = /* @__PURE__ */ new Vector2();
      var _intersectionPoint = /* @__PURE__ */ new Vector3();
      var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
      var Mesh = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
          super();
          this.type = "Mesh";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
                  const name = morphAttribute[m2].name || String(m2);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m2;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$3.copy(geometry.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$3) === false)
            return;
          _inverseMatrix$2.copy(matrixWorld).invert();
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
          if (geometry.boundingBox !== null) {
            if (_ray$2.intersectsBox(geometry.boundingBox) === false)
              return;
          }
          let intersection;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
              if (Array.isArray(material)) {
                for (let i2 = 0, il2 = groups.length; i2 < il2; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j2 = start, jl2 = end; j2 < jl2; j2 += 3) {
                    const a2 = index.getX(j2);
                    const b2 = index.getX(j2 + 1);
                    const c2 = index.getX(j2 + 2);
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j2 / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for (let i2 = start, il2 = end; i2 < il2; i2 += 3) {
                  const a2 = index.getX(i2);
                  const b2 = index.getX(i2 + 1);
                  const c2 = index.getX(i2 + 2);
                  intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            } else if (position !== void 0) {
              if (Array.isArray(material)) {
                for (let i2 = 0, il2 = groups.length; i2 < il2; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j2 = start, jl2 = end; j2 < jl2; j2 += 3) {
                    const a2 = j2;
                    const b2 = j2 + 1;
                    const c2 = j2 + 2;
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j2 / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(position.count, drawRange.start + drawRange.count);
                for (let i2 = start, il2 = end; i2 < il2; i2 += 3) {
                  const a2 = i2;
                  const b2 = i2 + 1;
                  const c2 = i2 + 2;
                  intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      };
      Mesh.prototype.isMesh = true;
      function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
        let intersect;
        if (material.side === BackSide) {
          intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
        }
        if (intersect === null)
          return null;
        _intersectionPointWorld.copy(point);
        _intersectionPointWorld.applyMatrix4(object.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance,
          point: _intersectionPointWorld.clone(),
          object
        };
      }
      function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
        _vA$1.fromBufferAttribute(position, a2);
        _vB$1.fromBufferAttribute(position, b2);
        _vC$1.fromBufferAttribute(position, c2);
        const morphInfluences = object.morphTargetInfluences;
        if (morphPosition && morphInfluences) {
          _morphA.set(0, 0, 0);
          _morphB.set(0, 0, 0);
          _morphC.set(0, 0, 0);
          for (let i2 = 0, il2 = morphPosition.length; i2 < il2; i2++) {
            const influence = morphInfluences[i2];
            const morphAttribute = morphPosition[i2];
            if (influence === 0)
              continue;
            _tempA.fromBufferAttribute(morphAttribute, a2);
            _tempB.fromBufferAttribute(morphAttribute, b2);
            _tempC.fromBufferAttribute(morphAttribute, c2);
            if (morphTargetsRelative) {
              _morphA.addScaledVector(_tempA, influence);
              _morphB.addScaledVector(_tempB, influence);
              _morphC.addScaledVector(_tempC, influence);
            } else {
              _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
              _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
              _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
            }
          }
          _vA$1.add(_morphA);
          _vB$1.add(_morphB);
          _vC$1.add(_morphC);
        }
        if (object.isSkinnedMesh) {
          object.boneTransform(a2, _vA$1);
          object.boneTransform(b2, _vB$1);
          object.boneTransform(c2, _vC$1);
        }
        const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
        if (intersection) {
          if (uv) {
            _uvA$1.fromBufferAttribute(uv, a2);
            _uvB$1.fromBufferAttribute(uv, b2);
            _uvC$1.fromBufferAttribute(uv, c2);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
          }
          if (uv2) {
            _uvA$1.fromBufferAttribute(uv2, a2);
            _uvB$1.fromBufferAttribute(uv2, b2);
            _uvC$1.fromBufferAttribute(uv2, c2);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
          }
          const face = {
            a: a2,
            b: b2,
            c: c2,
            normal: new Vector3(),
            materialIndex: 0
          };
          Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
          intersection.face = face;
        }
        return intersection;
      }
      var BoxGeometry = class extends BufferGeometry {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width2 / gridX;
            const segmentHeight = height2 / gridY;
            const widthHalf = width2 / 2;
            const heightHalf = height2 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            for (let iy = 0; iy < gridY1; iy++) {
              const y2 = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x2 = ix * segmentWidth - widthHalf;
                vector[u2] = x2 * udir;
                vector[v2] = y2 * vdir;
                vector[w2] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u2] = 0;
                vector[v2] = 0;
                vector[w2] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a2 = numberOfVertices + ix + gridX1 * iy;
                const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
                const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a2, b2, d);
                indices.push(b2, c2, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        static fromJSON(data) {
          return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      };
      function cloneUniforms(src) {
        const dst = {};
        for (const u2 in src) {
          dst[u2] = {};
          for (const p in src[u2]) {
            const property = src[u2][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
              dst[u2][p] = property.clone();
            } else if (Array.isArray(property)) {
              dst[u2][p] = property.slice();
            } else {
              dst[u2][p] = property;
            }
          }
        }
        return dst;
      }
      function mergeUniforms(uniforms) {
        const merged = {};
        for (let u2 = 0; u2 < uniforms.length; u2++) {
          const tmp2 = cloneUniforms(uniforms[u2]);
          for (const p in tmp2) {
            merged[p] = tmp2[p];
          }
        }
        return merged;
      }
      var UniformsUtils = {
        clone: cloneUniforms,
        merge: mergeUniforms
      };
      var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      var ShaderMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.vertexShader = default_vertex;
          this.fragmentShader = default_fragment;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv2": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            if (parameters.attributes !== void 0) {
              console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
            }
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms(source.uniforms);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name in this.uniforms) {
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      };
      ShaderMaterial.prototype.isShaderMaterial = true;
      var Camera = class extends Object3D {
        constructor() {
          super();
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix4();
          this.projectionMatrix = new Matrix4();
          this.projectionMatrixInverse = new Matrix4();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e4 = this.matrixWorld.elements;
          return target.set(-e4[8], -e4[9], -e4[10]).normalize();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Camera.prototype.isCamera = true;
      var PerspectiveCamera = class extends Camera {
        constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
          super();
          this.type = "PerspectiveCamera";
          this.fov = fov2;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect2;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x2;
          this.view.offsetY = y2;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
          let height = 2 * top;
          let width = this.aspect * height;
          let left = -0.5 * width;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      };
      PerspectiveCamera.prototype.isPerspectiveCamera = true;
      var fov = 90;
      var aspect = 1;
      var CubeCamera = class extends Object3D {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
          }
          this.renderTarget = renderTarget;
          const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
          cameraPX.layers = this.layers;
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(new Vector3(1, 0, 0));
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
          cameraNX.layers = this.layers;
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(new Vector3(-1, 0, 0));
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
          cameraPY.layers = this.layers;
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(new Vector3(0, 1, 0));
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
          cameraNY.layers = this.layers;
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(new Vector3(0, -1, 0));
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraPZ.layers = this.layers;
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(new Vector3(0, 0, 1));
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraNZ.layers = this.layers;
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(new Vector3(0, 0, -1));
          this.add(cameraNZ);
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const renderTarget = this.renderTarget;
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentXrEnabled = renderer.xr.enabled;
          const currentRenderTarget = renderer.getRenderTarget();
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget);
          renderer.xr.enabled = currentXrEnabled;
          renderTarget.texture.needsPMREMUpdate = true;
        }
      };
      var CubeTexture = class extends Texture {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      };
      CubeTexture.prototype.isCubeTexture = true;
      var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
        constructor(size, options = {}) {
          super(size, size, options);
          const image = {
            width: size,
            height: size,
            depth: 1
          };
          const images = [image, image, image, image, image, image];
          this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.format = RGBAFormat;
          this.texture.encoding = texture.encoding;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          };
          const geometry = new BoxGeometry(5, 5, 5);
          const material = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
          });
          material.uniforms.tEquirect.value = texture;
          const mesh = new Mesh(geometry, material);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter)
            texture.minFilter = LinearFilter;
          const camera = new CubeCamera(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i2 = 0; i2 < 6; i2++) {
            renderer.setRenderTarget(this, i2);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      };
      WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
      var _vector1 = /* @__PURE__ */ new Vector3();
      var _vector2 = /* @__PURE__ */ new Vector3();
      var _normalMatrix = /* @__PURE__ */ new Matrix3();
      var Plane = class {
        constructor(normal = new Vector3(1, 0, 0), constant = 0) {
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x2, y2, z2, w2) {
          this.normal.set(x2, y2, z2);
          this.constant = w2;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a2, b2, c2) {
          const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a2);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector1);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t2 < 0 || t2 > 1) {
            return null;
          }
          return target.copy(direction).multiplyScalar(t2).add(line.start);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Plane.prototype.isPlane = true;
      var _sphere$2 = /* @__PURE__ */ new Sphere();
      var _vector$7 = /* @__PURE__ */ new Vector3();
      var Frustum = class {
        constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
          this.planes = [p0, p1, p2, p3, p4, p5];
        }
        set(p0, p1, p2, p3, p4, p5) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p5);
          return this;
        }
        copy(frustum) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            planes[i2].copy(frustum.planes[i2]);
          }
          return this;
        }
        setFromProjectionMatrix(m2) {
          const planes = this.planes;
          const me2 = m2.elements;
          const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
          const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
          const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
          const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
          return this;
        }
        intersectsObject(object) {
          const geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSprite(sprite) {
          _sphere$2.center.set(0, 0, 0);
          _sphere$2.radius = 0.7071067811865476;
          _sphere$2.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i2 = 0; i2 < 6; i2++) {
            const distance = planes[i2].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            const plane = planes[i2];
            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$7) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            if (planes[i2].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      function WebGLAnimation() {
        let context = null;
        let isAnimating = false;
        let animationLoop = null;
        let requestId = null;
        function onAnimationFrame(time, frame) {
          animationLoop(time, frame);
          requestId = context.requestAnimationFrame(onAnimationFrame);
        }
        return {
          start: function() {
            if (isAnimating === true)
              return;
            if (animationLoop === null)
              return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
          },
          stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
          },
          setAnimationLoop: function(callback) {
            animationLoop = callback;
          },
          setContext: function(value) {
            context = value;
          }
        };
      }
      function WebGLAttributes(gl2, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        const buffers = /* @__PURE__ */ new WeakMap();
        function createBuffer(attribute, bufferType) {
          const array = attribute.array;
          const usage = attribute.usage;
          const buffer = gl2.createBuffer();
          gl2.bindBuffer(bufferType, buffer);
          gl2.bufferData(bufferType, array, usage);
          attribute.onUploadCallback();
          let type;
          if (array instanceof Float32Array) {
            type = gl2.FLOAT;
          } else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
              if (isWebGL2) {
                type = gl2.HALF_FLOAT;
              } else {
                throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
              }
            } else {
              type = gl2.UNSIGNED_SHORT;
            }
          } else if (array instanceof Int16Array) {
            type = gl2.SHORT;
          } else if (array instanceof Uint32Array) {
            type = gl2.UNSIGNED_INT;
          } else if (array instanceof Int32Array) {
            type = gl2.INT;
          } else if (array instanceof Int8Array) {
            type = gl2.BYTE;
          } else if (array instanceof Uint8Array) {
            type = gl2.UNSIGNED_BYTE;
          } else if (array instanceof Uint8ClampedArray) {
            type = gl2.UNSIGNED_BYTE;
          } else {
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
          }
          return {
            buffer,
            type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
          };
        }
        function updateBuffer(buffer, attribute, bufferType) {
          const array = attribute.array;
          const updateRange = attribute.updateRange;
          gl2.bindBuffer(bufferType, buffer);
          if (updateRange.count === -1) {
            gl2.bufferSubData(bufferType, 0, array);
          } else {
            if (isWebGL2) {
              gl2.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            } else {
              gl2.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            }
            updateRange.count = -1;
          }
        }
        function get(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          return buffers.get(attribute);
        }
        function remove(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data) {
            gl2.deleteBuffer(data.buffer);
            buffers.delete(attribute);
          }
        }
        function update(attribute, bufferType) {
          if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) {
              buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
              });
            }
            return;
          }
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data === void 0) {
            buffers.set(attribute, createBuffer(attribute, bufferType));
          } else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
          }
        }
        return {
          get,
          remove,
          update
        };
      }
      var PlaneGeometry = class extends BufferGeometry {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width,
            height,
            widthSegments,
            heightSegments
          };
          const width_half = width / 2;
          const height_half = height / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width / gridX;
          const segment_height = height / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y2 = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x2 = ix * segment_width - width_half;
              vertices.push(x2, -y2, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a2 = ix + gridX1 * iy;
              const b2 = ix + gridX1 * (iy + 1);
              const c2 = ix + 1 + gridX1 * (iy + 1);
              const d = ix + 1 + gridX1 * iy;
              indices.push(a2, b2, d);
              indices.push(b2, c2, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      };
      var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
      var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
      var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
      var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
      var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      var begin_vertex = "vec3 transformed = vec3( position );";
      var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
      var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
      var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
      var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
      var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
      var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
      var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
      var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
      var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
      var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
      var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
      var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
      var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
      var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
      var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(		0, 1,		0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
      var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
      var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
      var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ]\n		#endif\n	}\n#endif";
      var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
      var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			float texelIndex = float( vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
      var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
      var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
      var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
      var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
      var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
      var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
      var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
      var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
      var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
      var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n							f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n							f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
      var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
      var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,	1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
      var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
      var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
      var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
      var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
      var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
      var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
      var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
      var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
      var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
      var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      var ShaderChunk = {
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        alphatest_pars_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        encodings_fragment,
        encodings_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_fragment,
        lightmap_pars_fragment,
        lights_lambert_vertex,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphcolor_vertex,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normal_pars_fragment,
        normal_pars_vertex,
        normal_vertex,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        output_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        uv2_pars_fragment,
        uv2_pars_vertex,
        uv2_vertex,
        worldpos_vertex,
        background_vert: vertex$g,
        background_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
      };
      var UniformsLib = {
        common: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          uvTransform: {
            value: new Matrix3()
          },
          uv2Transform: {
            value: new Matrix3()
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalScale: {
            value: new Vector2(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new Color(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotShadowMap: {
            value: []
          },
          spotShadowMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Matrix3()
          }
        },
        sprite: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Vector2(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Matrix3()
          }
        }
      };
      var ShaderLib = {
        basic: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            }
          }]),
          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            },
            specular: {
              value: new Color(1118481)
            },
            shininess: {
              value: 30
            }
          }]),
          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            },
            roughness: {
              value: 1
            },
            metalness: {
              value: 0
            },
            envMapIntensity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            }
          }]),
          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
              value: null
            }
          }]),
          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
          uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
              value: 1
            },
            dashSize: {
              value: 1
            },
            totalSize: {
              value: 2
            }
          }]),
          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.meshnormal_vert,
          fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
          uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Matrix3()
            },
            t2D: {
              value: null
            }
          },
          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag
        },
        cube: {
          uniforms: mergeUniforms([UniformsLib.envmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
              value: new Vector3()
            },
            nearDistance: {
              value: 1
            },
            farDistance: {
              value: 1e3
            }
          }]),
          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
          uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
              value: new Color(0)
            },
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag
        }
      };
      ShaderLib.physical = {
        uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatNormalScale: {
            value: new Vector2(1, 1)
          },
          clearcoatNormalMap: {
            value: null
          },
          sheen: {
            value: 0
          },
          sheenColor: {
            value: new Color(0)
          },
          sheenColorMap: {
            value: null
          },
          sheenRoughness: {
            value: 1
          },
          sheenRoughnessMap: {
            value: null
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new Vector2()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Color(0)
          },
          specularIntensity: {
            value: 1
          },
          specularIntensityMap: {
            value: null
          },
          specularColor: {
            value: new Color(1, 1, 1)
          },
          specularColorMap: {
            value: null
          }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      };
      function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
        const clearColor = new Color(0);
        let clearAlpha = alpha === true ? 0 : 1;
        let planeMesh;
        let boxMesh;
        let currentBackground = null;
        let currentBackgroundVersion = 0;
        let currentTonemapping = null;
        function render(renderList, scene) {
          let forceClear = false;
          let background = scene.isScene === true ? scene.background : null;
          if (background && background.isTexture) {
            background = cubemaps.get(background);
          }
          const xr2 = renderer.xr;
          const session = xr2.getSession && xr2.getSession();
          if (session && session.environmentBlendMode === "additive") {
            background = null;
          }
          if (background === null) {
            setClear(clearColor, clearAlpha);
          } else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
          }
          if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
          }
          if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === void 0) {
              boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                vertexShader: ShaderLib.cube.vertexShader,
                fragmentShader: ShaderLib.cube.fragmentShader,
                side: BackSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              boxMesh.geometry.deleteAttribute("normal");
              boxMesh.geometry.deleteAttribute("uv");
              boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
                this.matrixWorld.copyPosition(camera.matrixWorld);
              };
              Object.defineProperty(boxMesh.material, "envMap", {
                get: function() {
                  return this.uniforms.envMap.value;
                }
              });
              objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              boxMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
          } else if (background && background.isTexture) {
            if (planeMesh === void 0) {
              planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              planeMesh.geometry.deleteAttribute("normal");
              Object.defineProperty(planeMesh.material, "map", {
                get: function() {
                  return this.uniforms.t2D.value;
                }
              });
              objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) {
              background.updateMatrix();
            }
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              planeMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
          }
        }
        function setClear(color, alpha2) {
          state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
        }
        return {
          getClearColor: function() {
            return clearColor;
          },
          setClearColor: function(color, alpha2 = 1) {
            clearColor.set(color);
            clearAlpha = alpha2;
            setClear(clearColor, clearAlpha);
          },
          getClearAlpha: function() {
            return clearAlpha;
          },
          setClearAlpha: function(alpha2) {
            clearAlpha = alpha2;
            setClear(clearColor, clearAlpha);
          },
          render
        };
      }
      function WebGLBindingStates(gl2, extensions, attributes, capabilities) {
        const maxVertexAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
        const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
        const vaoAvailable = capabilities.isWebGL2 || extension !== null;
        const bindingStates = {};
        const defaultState = createBindingState(null);
        let currentState = defaultState;
        function setup(object, material, program, geometry, index) {
          let updateBuffers = false;
          if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
              currentState = state;
              bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers)
              saveCache(geometry, index);
          } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
              currentState.geometry = geometry.id;
              currentState.program = program.id;
              currentState.wireframe = wireframe;
              updateBuffers = true;
            }
          }
          if (object.isInstancedMesh === true) {
            updateBuffers = true;
          }
          if (index !== null) {
            attributes.update(index, gl2.ELEMENT_ARRAY_BUFFER);
          }
          if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) {
              gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
            }
          }
        }
        function createVertexArrayObject() {
          if (capabilities.isWebGL2)
            return gl2.createVertexArray();
          return extension.createVertexArrayOES();
        }
        function bindVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl2.bindVertexArray(vao);
          return extension.bindVertexArrayOES(vao);
        }
        function deleteVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl2.deleteVertexArray(vao);
          return extension.deleteVertexArrayOES(vao);
        }
        function getBindingState(geometry, program, material) {
          const wireframe = material.wireframe === true;
          let programMap = bindingStates[geometry.id];
          if (programMap === void 0) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
          }
          let stateMap = programMap[program.id];
          if (stateMap === void 0) {
            stateMap = {};
            programMap[program.id] = stateMap;
          }
          let state = stateMap[wireframe];
          if (state === void 0) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
          }
          return state;
        }
        function createBindingState(vao) {
          const newAttributes = [];
          const enabledAttributes = [];
          const attributeDivisors = [];
          for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
            newAttributes[i2] = 0;
            enabledAttributes[i2] = 0;
            attributeDivisors[i2] = 0;
          }
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes,
            enabledAttributes,
            attributeDivisors,
            object: vao,
            attributes: {},
            index: null
          };
        }
        function needsUpdate(geometry, index) {
          const cachedAttributes = currentState.attributes;
          const geometryAttributes = geometry.attributes;
          let attributesNum = 0;
          for (const key in geometryAttributes) {
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === void 0)
              return true;
            if (cachedAttribute.attribute !== geometryAttribute)
              return true;
            if (cachedAttribute.data !== geometryAttribute.data)
              return true;
            attributesNum++;
          }
          if (currentState.attributesNum !== attributesNum)
            return true;
          if (currentState.index !== index)
            return true;
          return false;
        }
        function saveCache(geometry, index) {
          const cache = {};
          const attributes2 = geometry.attributes;
          let attributesNum = 0;
          for (const key in attributes2) {
            const attribute = attributes2[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) {
              data.data = attribute.data;
            }
            cache[key] = data;
            attributesNum++;
          }
          currentState.attributes = cache;
          currentState.attributesNum = attributesNum;
          currentState.index = index;
        }
        function initAttributes() {
          const newAttributes = currentState.newAttributes;
          for (let i2 = 0, il2 = newAttributes.length; i2 < il2; i2++) {
            newAttributes[i2] = 0;
          }
        }
        function enableAttribute(attribute) {
          enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          const attributeDivisors = currentState.attributeDivisors;
          newAttributes[attribute] = 1;
          if (enabledAttributes[attribute] === 0) {
            gl2.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
          }
          if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension2 = capabilities.isWebGL2 ? gl2 : extensions.get("ANGLE_instanced_arrays");
            extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
          }
        }
        function disableUnusedAttributes() {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          for (let i2 = 0, il2 = enabledAttributes.length; i2 < il2; i2++) {
            if (enabledAttributes[i2] !== newAttributes[i2]) {
              gl2.disableVertexAttribArray(i2);
              enabledAttributes[i2] = 0;
            }
          }
        }
        function vertexAttribPointer(index, size, type, normalized, stride, offset) {
          if (capabilities.isWebGL2 === true && (type === gl2.INT || type === gl2.UNSIGNED_INT)) {
            gl2.vertexAttribIPointer(index, size, type, stride, offset);
          } else {
            gl2.vertexAttribPointer(index, size, type, normalized, stride, offset);
          }
        }
        function setupVertexAttributes(object, material, program, geometry) {
          if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get("ANGLE_instanced_arrays") === null)
              return;
          }
          initAttributes();
          const geometryAttributes = geometry.attributes;
          const programAttributes = program.getAttributes();
          const materialDefaultAttributeValues = material.defaultAttributeValues;
          for (const name in programAttributes) {
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
              let geometryAttribute = geometryAttributes[name];
              if (geometryAttribute === void 0) {
                if (name === "instanceMatrix" && object.instanceMatrix)
                  geometryAttribute = object.instanceMatrix;
                if (name === "instanceColor" && object.instanceColor)
                  geometryAttribute = object.instanceColor;
              }
              if (geometryAttribute !== void 0) {
                const normalized = geometryAttribute.normalized;
                const size = geometryAttribute.itemSize;
                const attribute = attributes.get(geometryAttribute);
                if (attribute === void 0)
                  continue;
                const buffer = attribute.buffer;
                const type = attribute.type;
                const bytesPerElement = attribute.bytesPerElement;
                if (geometryAttribute.isInterleavedBufferAttribute) {
                  const data = geometryAttribute.data;
                  const stride = data.stride;
                  const offset = geometryAttribute.offset;
                  if (data.isInstancedInterleavedBuffer) {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
                    }
                    if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                      geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                    }
                  } else {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttribute(programAttribute.location + i2);
                    }
                  }
                  gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
                  }
                } else {
                  if (geometryAttribute.isInstancedBufferAttribute) {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
                    }
                    if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                      geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                    }
                  } else {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttribute(programAttribute.location + i2);
                    }
                  }
                  gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
                  }
                }
              } else if (materialDefaultAttributeValues !== void 0) {
                const value = materialDefaultAttributeValues[name];
                if (value !== void 0) {
                  switch (value.length) {
                    case 2:
                      gl2.vertexAttrib2fv(programAttribute.location, value);
                      break;
                    case 3:
                      gl2.vertexAttrib3fv(programAttribute.location, value);
                      break;
                    case 4:
                      gl2.vertexAttrib4fv(programAttribute.location, value);
                      break;
                    default:
                      gl2.vertexAttrib1fv(programAttribute.location, value);
                  }
                }
              }
            }
          }
          disableUnusedAttributes();
        }
        function dispose() {
          reset();
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            for (const programId in programMap) {
              const stateMap = programMap[programId];
              for (const wireframe in stateMap) {
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
              }
              delete programMap[programId];
            }
            delete bindingStates[geometryId];
          }
        }
        function releaseStatesOfGeometry(geometry) {
          if (bindingStates[geometry.id] === void 0)
            return;
          const programMap = bindingStates[geometry.id];
          for (const programId in programMap) {
            const stateMap = programMap[programId];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[programId];
          }
          delete bindingStates[geometry.id];
        }
        function releaseStatesOfProgram(program) {
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === void 0)
              continue;
            const stateMap = programMap[program.id];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[program.id];
          }
        }
        function reset() {
          resetDefaultState();
          if (currentState === defaultState)
            return;
          currentState = defaultState;
          bindVertexArrayObject(currentState.object);
        }
        function resetDefaultState() {
          defaultState.geometry = null;
          defaultState.program = null;
          defaultState.wireframe = false;
        }
        return {
          setup,
          reset,
          resetDefaultState,
          dispose,
          releaseStatesOfGeometry,
          releaseStatesOfProgram,
          initAttributes,
          enableAttribute,
          disableUnusedAttributes
        };
      }
      function WebGLBufferRenderer(gl2, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        function render(start, count) {
          gl2.drawArrays(mode, start, count);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl2;
            methodName = "drawArraysInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawArraysInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, start, count, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
      }
      function WebGLCapabilities(gl2, extensions, parameters) {
        let maxAnisotropy;
        function getMaxAnisotropy() {
          if (maxAnisotropy !== void 0)
            return maxAnisotropy;
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            maxAnisotropy = gl2.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else {
            maxAnisotropy = 0;
          }
          return maxAnisotropy;
        }
        function getMaxPrecision(precision2) {
          if (precision2 === "highp") {
            if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.HIGH_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.HIGH_FLOAT).precision > 0) {
              return "highp";
            }
            precision2 = "mediump";
          }
          if (precision2 === "mediump") {
            if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.MEDIUM_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.MEDIUM_FLOAT).precision > 0) {
              return "mediump";
            }
          }
          return "lowp";
        }
        const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl2 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl2 instanceof WebGL2ComputeRenderingContext;
        let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
        const maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
          console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
          precision = maxPrecision;
        }
        const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
        const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        const maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
        const maxVertexTextures = gl2.getParameter(gl2.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        const maxTextureSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
        const maxCubemapSize = gl2.getParameter(gl2.MAX_CUBE_MAP_TEXTURE_SIZE);
        const maxAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
        const maxVertexUniforms = gl2.getParameter(gl2.MAX_VERTEX_UNIFORM_VECTORS);
        const maxVaryings = gl2.getParameter(gl2.MAX_VARYING_VECTORS);
        const maxFragmentUniforms = gl2.getParameter(gl2.MAX_FRAGMENT_UNIFORM_VECTORS);
        const vertexTextures = maxVertexTextures > 0;
        const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
        const floatVertexTextures = vertexTextures && floatFragmentTextures;
        const maxSamples = isWebGL2 ? gl2.getParameter(gl2.MAX_SAMPLES) : 0;
        return {
          isWebGL2,
          drawBuffers,
          getMaxAnisotropy,
          getMaxPrecision,
          precision,
          logarithmicDepthBuffer,
          maxTextures,
          maxVertexTextures,
          maxTextureSize,
          maxCubemapSize,
          maxAttributes,
          maxVertexUniforms,
          maxVaryings,
          maxFragmentUniforms,
          vertexTextures,
          floatFragmentTextures,
          floatVertexTextures,
          maxSamples
        };
      }
      function WebGLClipping(properties) {
        const scope = this;
        let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
        const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
          value: null,
          needsUpdate: false
        };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
          const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
          localClippingEnabled = enableLocalClipping;
          globalState = projectPlanes(planes, camera, 0);
          numGlobalPlanes = planes.length;
          return enabled;
        };
        this.beginShadows = function() {
          renderingShadows = true;
          projectPlanes(null);
        };
        this.endShadows = function() {
          renderingShadows = false;
          resetGlobalState();
        };
        this.setState = function(material, camera, useCache) {
          const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
          const materialProperties = properties.get(material);
          if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) {
              projectPlanes(null);
            } else {
              resetGlobalState();
            }
          } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for (let i2 = 0; i2 !== lGlobal; ++i2) {
              dstArray[i2] = globalState[i2];
            }
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
          }
        };
        function resetGlobalState() {
          if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
          }
          scope.numPlanes = numGlobalPlanes;
          scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
          const nPlanes = planes !== null ? planes.length : 0;
          let dstArray = null;
          if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
              const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
              viewNormalMatrix.getNormalMatrix(viewMatrix);
              if (dstArray === null || dstArray.length < flatSize) {
                dstArray = new Float32Array(flatSize);
              }
              for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
                plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
                plane.normal.toArray(dstArray, i4);
                dstArray[i4 + 3] = plane.constant;
              }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
          }
          scope.numPlanes = nPlanes;
          scope.numIntersection = 0;
          return dstArray;
        }
      }
      function WebGLCubeMaps(renderer) {
        let cubemaps = /* @__PURE__ */ new WeakMap();
        function mapTextureMapping(texture, mapping) {
          if (mapping === EquirectangularReflectionMapping) {
            texture.mapping = CubeReflectionMapping;
          } else if (mapping === EquirectangularRefractionMapping) {
            texture.mapping = CubeRefractionMapping;
          }
          return texture;
        }
        function get(texture) {
          if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
              if (cubemaps.has(texture)) {
                const cubemap = cubemaps.get(texture).texture;
                return mapTextureMapping(cubemap, texture.mapping);
              } else {
                const image = texture.image;
                if (image && image.height > 0) {
                  const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                  renderTarget.fromEquirectangularTexture(renderer, texture);
                  cubemaps.set(texture, renderTarget);
                  texture.addEventListener("dispose", onTextureDispose);
                  return mapTextureMapping(renderTarget.texture, texture.mapping);
                } else {
                  return null;
                }
              }
            }
          }
          return texture;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemap = cubemaps.get(texture);
          if (cubemap !== void 0) {
            cubemaps.delete(texture);
            cubemap.dispose();
          }
        }
        function dispose() {
          cubemaps = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      var OrthographicCamera = class extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x2;
          this.view.offsetY = y2;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      };
      OrthographicCamera.prototype.isOrthographicCamera = true;
      var LOD_MIN = 4;
      var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      var MAX_SAMPLES = 20;
      var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
      var _clearColor = /* @__PURE__ */ new Color();
      var _oldTarget = null;
      var PHI = (1 + Math.sqrt(5)) / 2;
      var INV_PHI = 1 / PHI;
      var _axisDirections = [/* @__PURE__ */ new Vector3(1, 1, 1), /* @__PURE__ */ new Vector3(-1, 1, 1), /* @__PURE__ */ new Vector3(1, 1, -1), /* @__PURE__ */ new Vector3(-1, 1, -1), /* @__PURE__ */ new Vector3(0, PHI, INV_PHI), /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI), /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI), /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI), /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0), /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)];
      var PMREMGenerator = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._lodMax = 0;
          this._cubeSize = 0;
          this._lodPlanes = [];
          this._sizeLods = [];
          this._sigmas = [];
          this._blurMaterial = null;
          this._cubemapMaterial = null;
          this._equirectMaterial = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget = this._renderer.getRenderTarget();
          this._setSize(256);
          const cubeUVRenderTarget = this._allocateTargets();
          cubeUVRenderTarget.depthBuffer = true;
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        fromEquirectangular(equirectangular, renderTarget = null) {
          return this._fromTexture(equirectangular, renderTarget);
        }
        fromCubemap(cubemap, renderTarget = null) {
          return this._fromTexture(cubemap, renderTarget);
        }
        compileCubemapShader() {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial();
            this._compileMaterial(this._cubemapMaterial);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial();
            this._compileMaterial(this._equirectMaterial);
          }
        }
        dispose() {
          this._dispose();
          if (this._cubemapMaterial !== null)
            this._cubemapMaterial.dispose();
          if (this._equirectMaterial !== null)
            this._equirectMaterial.dispose();
        }
        _setSize(cubeSize) {
          this._lodMax = Math.floor(Math.log2(cubeSize));
          this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial.dispose();
          if (this._pingPongRenderTarget !== null)
            this._pingPongRenderTarget.dispose();
          for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
            this._lodPlanes[i2].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._renderer.setRenderTarget(_oldTarget);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture, renderTarget) {
          if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
            this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
          } else {
            this._setSize(texture.image.width / 4);
          }
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = renderTarget || this._allocateTargets();
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets() {
          const width = 3 * Math.max(this._cubeSize, 16 * 7);
          const height = 4 * this._cubeSize - 32;
          const params = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            encoding: LinearEncoding,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget(width, height, params);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
            if (this._pingPongRenderTarget !== null) {
              this._dispose();
            }
            this._pingPongRenderTarget = _createRenderTarget(width, height, params);
            const {
              _lodMax
            } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas
            } = _createPlanes(_lodMax));
            this._blurMaterial = _getBlurShader(_lodMax, width, height);
          }
          return cubeUVRenderTarget;
        }
        _compileMaterial(material) {
          const tmpMesh = new Mesh(this._lodPlanes[0], material);
          this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov2 = 90;
          const aspect2 = 1;
          const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor);
          renderer.toneMapping = NoToneMapping;
          renderer.autoClear = false;
          const backgroundMaterial = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: false,
            depthTest: false
          });
          const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background);
              scene.background = null;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor);
            useSolidColor = true;
          }
          for (let i2 = 0; i2 < 6; i2++) {
            const col = i2 % 3;
            if (col === 0) {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(forwardSign[i2], 0, 0);
            } else if (col === 1) {
              cubeCamera.up.set(0, 0, upSign[i2]);
              cubeCamera.lookAt(0, forwardSign[i2], 0);
            } else {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i2]);
            }
            const size = this._cubeSize;
            _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          backgroundBox.geometry.dispose();
          backgroundBox.material.dispose();
          renderer.toneMapping = toneMapping;
          renderer.autoClear = originalAutoClear;
          scene.background = background;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
          if (isCubeTexture) {
            if (this._cubemapMaterial === null) {
              this._cubemapMaterial = _getCubemapMaterial();
            }
            this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
          } else {
            if (this._equirectMaterial === null) {
              this._equirectMaterial = _getEquirectMaterial();
            }
          }
          const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
          const mesh = new Mesh(this._lodPlanes[0], material);
          const uniforms = material.uniforms;
          uniforms["envMap"].value = texture;
          const size = this._cubeSize;
          _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i2 = 1; i2 < this._lodPlanes.length; i2++) {
            const sigma = Math.sqrt(this._sigmas[i2] * this._sigmas[i2] - this._sigmas[i2 - 1] * this._sigmas[i2 - 1]);
            const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
          this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error("blur direction must be either latitudinal or longitudinal!");
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = this._sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
          if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
          }
          const weights = [];
          let sum = 0;
          for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
            const x3 = i2 / sigmaPixels;
            const weight = Math.exp(-x3 * x3 / 2);
            weights.push(weight);
            if (i2 === 0) {
              sum += weight;
            } else if (i2 < samples) {
              sum += 2 * weight;
            }
          }
          for (let i2 = 0; i2 < weights.length; i2++) {
            weights[i2] = weights[i2] / sum;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          const {
            _lodMax
          } = this;
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = _lodMax - lodIn;
          const outputSize = this._sizeLods[lodOut];
          const x2 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
          const y2 = 4 * (this._cubeSize - outputSize);
          _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);
        }
      };
      function _createPlanes(lodMax) {
        const lodPlanes = [];
        const sizeLods = [];
        const sigmas = [];
        let lod = lodMax;
        const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
        for (let i2 = 0; i2 < totalLods; i2++) {
          const sizeLod = Math.pow(2, lod);
          sizeLods.push(sizeLod);
          let sigma = 1 / sizeLod;
          if (i2 > lodMax - LOD_MIN) {
            sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
          } else if (i2 === 0) {
            sigma = 0;
          }
          sigmas.push(sigma);
          const texelSize = 1 / (sizeLod - 1);
          const min = -texelSize / 2;
          const max = 1 + texelSize / 2;
          const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
          const cubeFaces = 6;
          const vertices = 6;
          const positionSize = 3;
          const uvSize = 2;
          const faceIndexSize = 1;
          const position = new Float32Array(positionSize * vertices * cubeFaces);
          const uv = new Float32Array(uvSize * vertices * cubeFaces);
          const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
          for (let face = 0; face < cubeFaces; face++) {
            const x2 = face % 3 * 2 / 3 - 1;
            const y2 = face > 2 ? 0 : -1;
            const coordinates = [x2, y2, 0, x2 + 2 / 3, y2, 0, x2 + 2 / 3, y2 + 1, 0, x2, y2, 0, x2 + 2 / 3, y2 + 1, 0, x2, y2 + 1, 0];
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [face, face, face, face, face, face];
            faceIndex.set(fill, faceIndexSize * vertices * face);
          }
          const planes = new BufferGeometry();
          planes.setAttribute("position", new BufferAttribute(position, positionSize));
          planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
          planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
          lodPlanes.push(planes);
          if (lod > LOD_MIN) {
            lod--;
          }
        }
        return {
          lodPlanes,
          sizeLods,
          sigmas
        };
      }
      function _createRenderTarget(width, height, params) {
        const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
      }
      function _setViewport(target, x2, y2, width, height) {
        target.viewport.set(x2, y2, width, height);
        target.scissor.set(x2, y2, width, height);
      }
      function _getBlurShader(lodMax, width, height) {
        const weights = new Float32Array(MAX_SAMPLES);
        const poleAxis = new Vector3(0, 1, 0);
        const shaderMaterial = new ShaderMaterial({
          name: "SphericalGaussianBlur",
          defines: {
            "n": MAX_SAMPLES,
            "CUBEUV_TEXEL_WIDTH": 1 / width,
            "CUBEUV_TEXEL_HEIGHT": 1 / height,
            "CUBEUV_MAX_MIP": `${lodMax}.0`
          },
          uniforms: {
            "envMap": {
              value: null
            },
            "samples": {
              value: 1
            },
            "weights": {
              value: weights
            },
            "latitudinal": {
              value: false
            },
            "dTheta": {
              value: 0
            },
            "mipInt": {
              value: 0
            },
            "poleAxis": {
              value: poleAxis
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getEquirectMaterial() {
        return new ShaderMaterial({
          name: "EquirectangularToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
      }
      function _getCubemapMaterial() {
        return new ShaderMaterial({
          name: "CubemapToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "flipEnvMap": {
              value: -1
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
      }
      function _getCommonVertexShader() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function WebGLCubeUVMaps(renderer) {
        let cubeUVmaps = /* @__PURE__ */ new WeakMap();
        let pmremGenerator = null;
        function get(texture) {
          if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
            const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
            if (isEquirectMap || isCubeMap) {
              if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
                texture.needsPMREMUpdate = false;
                let renderTarget = cubeUVmaps.get(texture);
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
                cubeUVmaps.set(texture, renderTarget);
                return renderTarget.texture;
              } else {
                if (cubeUVmaps.has(texture)) {
                  return cubeUVmaps.get(texture).texture;
                } else {
                  const image = texture.image;
                  if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                    if (pmremGenerator === null)
                      pmremGenerator = new PMREMGenerator(renderer);
                    const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                    cubeUVmaps.set(texture, renderTarget);
                    texture.addEventListener("dispose", onTextureDispose);
                    return renderTarget.texture;
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return texture;
        }
        function isCubeTextureComplete(image) {
          let count = 0;
          const length = 6;
          for (let i2 = 0; i2 < length; i2++) {
            if (image[i2] !== void 0)
              count++;
          }
          return count === length;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemapUV = cubeUVmaps.get(texture);
          if (cubemapUV !== void 0) {
            cubeUVmaps.delete(texture);
            cubemapUV.dispose();
          }
        }
        function dispose() {
          cubeUVmaps = /* @__PURE__ */ new WeakMap();
          if (pmremGenerator !== null) {
            pmremGenerator.dispose();
            pmremGenerator = null;
          }
        }
        return {
          get,
          dispose
        };
      }
      function WebGLExtensions(gl2) {
        const extensions = {};
        function getExtension(name) {
          if (extensions[name] !== void 0) {
            return extensions[name];
          }
          let extension;
          switch (name) {
            case "WEBGL_depth_texture":
              extension = gl2.getExtension("WEBGL_depth_texture") || gl2.getExtension("MOZ_WEBGL_depth_texture") || gl2.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              extension = gl2.getExtension("EXT_texture_filter_anisotropic") || gl2.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              extension = gl2.getExtension("WEBGL_compressed_texture_s3tc") || gl2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              extension = gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              extension = gl2.getExtension(name);
          }
          extensions[name] = extension;
          return extension;
        }
        return {
          has: function(name) {
            return getExtension(name) !== null;
          },
          init: function(capabilities) {
            if (capabilities.isWebGL2) {
              getExtension("EXT_color_buffer_float");
            } else {
              getExtension("WEBGL_depth_texture");
              getExtension("OES_texture_float");
              getExtension("OES_texture_half_float");
              getExtension("OES_texture_half_float_linear");
              getExtension("OES_standard_derivatives");
              getExtension("OES_element_index_uint");
              getExtension("OES_vertex_array_object");
              getExtension("ANGLE_instanced_arrays");
            }
            getExtension("OES_texture_float_linear");
            getExtension("EXT_color_buffer_half_float");
            getExtension("WEBGL_multisampled_render_to_texture");
          },
          get: function(name) {
            const extension = getExtension(name);
            if (extension === null) {
              console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            }
            return extension;
          }
        };
      }
      function WebGLGeometries(gl2, attributes, info, bindingStates) {
        const geometries = {};
        const wireframeAttributes = /* @__PURE__ */ new WeakMap();
        function onGeometryDispose(event) {
          const geometry = event.target;
          if (geometry.index !== null) {
            attributes.remove(geometry.index);
          }
          for (const name in geometry.attributes) {
            attributes.remove(geometry.attributes[name]);
          }
          geometry.removeEventListener("dispose", onGeometryDispose);
          delete geometries[geometry.id];
          const attribute = wireframeAttributes.get(geometry);
          if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry);
          }
          bindingStates.releaseStatesOfGeometry(geometry);
          if (geometry.isInstancedBufferGeometry === true) {
            delete geometry._maxInstanceCount;
          }
          info.memory.geometries--;
        }
        function get(object, geometry) {
          if (geometries[geometry.id] === true)
            return geometry;
          geometry.addEventListener("dispose", onGeometryDispose);
          geometries[geometry.id] = true;
          info.memory.geometries++;
          return geometry;
        }
        function update(geometry) {
          const geometryAttributes = geometry.attributes;
          for (const name in geometryAttributes) {
            attributes.update(geometryAttributes[name], gl2.ARRAY_BUFFER);
          }
          const morphAttributes = geometry.morphAttributes;
          for (const name in morphAttributes) {
            const array = morphAttributes[name];
            for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
              attributes.update(array[i2], gl2.ARRAY_BUFFER);
            }
          }
        }
        function updateWireframeAttribute(geometry) {
          const indices = [];
          const geometryIndex = geometry.index;
          const geometryPosition = geometry.attributes.position;
          let version = 0;
          if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
              const a2 = array[i2 + 0];
              const b2 = array[i2 + 1];
              const c2 = array[i2 + 2];
              indices.push(a2, b2, b2, c2, c2, a2);
            }
          } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
              const a2 = i2 + 0;
              const b2 = i2 + 1;
              const c2 = i2 + 2;
              indices.push(a2, b2, b2, c2, c2, a2);
            }
          }
          const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
          attribute.version = version;
          const previousAttribute = wireframeAttributes.get(geometry);
          if (previousAttribute)
            attributes.remove(previousAttribute);
          wireframeAttributes.set(geometry, attribute);
        }
        function getWireframeAttribute(geometry) {
          const currentAttribute = wireframeAttributes.get(geometry);
          if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) {
              if (currentAttribute.version < geometryIndex.version) {
                updateWireframeAttribute(geometry);
              }
            }
          } else {
            updateWireframeAttribute(geometry);
          }
          return wireframeAttributes.get(geometry);
        }
        return {
          get,
          update,
          getWireframeAttribute
        };
      }
      function WebGLIndexedBufferRenderer(gl2, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        let type, bytesPerElement;
        function setIndex(value) {
          type = value.type;
          bytesPerElement = value.bytesPerElement;
        }
        function render(start, count) {
          gl2.drawElements(mode, count, type, start * bytesPerElement);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl2;
            methodName = "drawElementsInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawElementsInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, count, type, start * bytesPerElement, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
      }
      function WebGLInfo(gl2) {
        const memory = {
          geometries: 0,
          textures: 0
        };
        const render = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function update(count, mode, instanceCount) {
          render.calls++;
          switch (mode) {
            case gl2.TRIANGLES:
              render.triangles += instanceCount * (count / 3);
              break;
            case gl2.LINES:
              render.lines += instanceCount * (count / 2);
              break;
            case gl2.LINE_STRIP:
              render.lines += instanceCount * (count - 1);
              break;
            case gl2.LINE_LOOP:
              render.lines += instanceCount * count;
              break;
            case gl2.POINTS:
              render.points += instanceCount * count;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
              break;
          }
        }
        function reset() {
          render.frame++;
          render.calls = 0;
          render.triangles = 0;
          render.points = 0;
          render.lines = 0;
        }
        return {
          memory,
          render,
          programs: null,
          autoReset: true,
          reset,
          update
        };
      }
      function numericalSort(a2, b2) {
        return a2[0] - b2[0];
      }
      function absNumericalSort(a2, b2) {
        return Math.abs(b2[1]) - Math.abs(a2[1]);
      }
      function denormalize(morph, attribute) {
        let denominator = 1;
        const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
        if (array instanceof Int8Array)
          denominator = 127;
        else if (array instanceof Int16Array)
          denominator = 32767;
        else if (array instanceof Int32Array)
          denominator = 2147483647;
        else
          console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
        morph.divideScalar(denominator);
      }
      function WebGLMorphtargets(gl2, capabilities, textures) {
        const influencesList = {};
        const morphInfluences = new Float32Array(8);
        const morphTextures = /* @__PURE__ */ new WeakMap();
        const morph = new Vector4();
        const workInfluences = [];
        for (let i2 = 0; i2 < 8; i2++) {
          workInfluences[i2] = [i2, 0];
        }
        function update(object, geometry, material, program) {
          const objectInfluences = object.morphTargetInfluences;
          if (capabilities.isWebGL2 === true) {
            const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
            let entry = morphTextures.get(geometry);
            if (entry === void 0 || entry.count !== morphTargetsCount) {
              let disposeTexture = function() {
                texture.dispose();
                morphTextures.delete(geometry);
                geometry.removeEventListener("dispose", disposeTexture);
              };
              if (entry !== void 0)
                entry.texture.dispose();
              const hasMorphPosition = geometry.morphAttributes.position !== void 0;
              const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
              const hasMorphColors = geometry.morphAttributes.color !== void 0;
              const morphTargets = geometry.morphAttributes.position || [];
              const morphNormals = geometry.morphAttributes.normal || [];
              const morphColors = geometry.morphAttributes.color || [];
              let vertexDataCount = 0;
              if (hasMorphPosition === true)
                vertexDataCount = 1;
              if (hasMorphNormals === true)
                vertexDataCount = 2;
              if (hasMorphColors === true)
                vertexDataCount = 3;
              let width = geometry.attributes.position.count * vertexDataCount;
              let height = 1;
              if (width > capabilities.maxTextureSize) {
                height = Math.ceil(width / capabilities.maxTextureSize);
                width = capabilities.maxTextureSize;
              }
              const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
              const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
              texture.format = RGBAFormat;
              texture.type = FloatType;
              texture.needsUpdate = true;
              const vertexDataStride = vertexDataCount * 4;
              for (let i2 = 0; i2 < morphTargetsCount; i2++) {
                const morphTarget = morphTargets[i2];
                const morphNormal = morphNormals[i2];
                const morphColor = morphColors[i2];
                const offset = width * height * 4 * i2;
                for (let j2 = 0; j2 < morphTarget.count; j2++) {
                  const stride = j2 * vertexDataStride;
                  if (hasMorphPosition === true) {
                    morph.fromBufferAttribute(morphTarget, j2);
                    if (morphTarget.normalized === true)
                      denormalize(morph, morphTarget);
                    buffer[offset + stride + 0] = morph.x;
                    buffer[offset + stride + 1] = morph.y;
                    buffer[offset + stride + 2] = morph.z;
                    buffer[offset + stride + 3] = 0;
                  }
                  if (hasMorphNormals === true) {
                    morph.fromBufferAttribute(morphNormal, j2);
                    if (morphNormal.normalized === true)
                      denormalize(morph, morphNormal);
                    buffer[offset + stride + 4] = morph.x;
                    buffer[offset + stride + 5] = morph.y;
                    buffer[offset + stride + 6] = morph.z;
                    buffer[offset + stride + 7] = 0;
                  }
                  if (hasMorphColors === true) {
                    morph.fromBufferAttribute(morphColor, j2);
                    if (morphColor.normalized === true)
                      denormalize(morph, morphNormal);
                    buffer[offset + stride + 8] = morph.x;
                    buffer[offset + stride + 9] = morph.y;
                    buffer[offset + stride + 10] = morph.z;
                    buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
                  }
                }
              }
              entry = {
                count: morphTargetsCount,
                texture,
                size: new Vector2(width, height)
              };
              morphTextures.set(geometry, entry);
              geometry.addEventListener("dispose", disposeTexture);
            }
            let morphInfluencesSum = 0;
            for (let i2 = 0; i2 < objectInfluences.length; i2++) {
              morphInfluencesSum += objectInfluences[i2];
            }
            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl2, "morphTargetInfluences", objectInfluences);
            program.getUniforms().setValue(gl2, "morphTargetsTexture", entry.texture, textures);
            program.getUniforms().setValue(gl2, "morphTargetsTextureSize", entry.size);
          } else {
            const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
            let influences = influencesList[geometry.id];
            if (influences === void 0 || influences.length !== length) {
              influences = [];
              for (let i2 = 0; i2 < length; i2++) {
                influences[i2] = [i2, 0];
              }
              influencesList[geometry.id] = influences;
            }
            for (let i2 = 0; i2 < length; i2++) {
              const influence = influences[i2];
              influence[0] = i2;
              influence[1] = objectInfluences[i2];
            }
            influences.sort(absNumericalSort);
            for (let i2 = 0; i2 < 8; i2++) {
              if (i2 < length && influences[i2][1]) {
                workInfluences[i2][0] = influences[i2][0];
                workInfluences[i2][1] = influences[i2][1];
              } else {
                workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
                workInfluences[i2][1] = 0;
              }
            }
            workInfluences.sort(numericalSort);
            const morphTargets = geometry.morphAttributes.position;
            const morphNormals = geometry.morphAttributes.normal;
            let morphInfluencesSum = 0;
            for (let i2 = 0; i2 < 8; i2++) {
              const influence = workInfluences[i2];
              const index = influence[0];
              const value = influence[1];
              if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
                  geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
                }
                if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
                  geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
                }
                morphInfluences[i2] = value;
                morphInfluencesSum += value;
              } else {
                if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
                  geometry.deleteAttribute("morphTarget" + i2);
                }
                if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
                  geometry.deleteAttribute("morphNormal" + i2);
                }
                morphInfluences[i2] = 0;
              }
            }
            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl2, "morphTargetInfluences", morphInfluences);
          }
        }
        return {
          update
        };
      }
      function WebGLObjects(gl2, geometries, attributes, info) {
        let updateMap = /* @__PURE__ */ new WeakMap();
        function update(object) {
          const frame = info.render.frame;
          const geometry = object.geometry;
          const buffergeometry = geometries.get(object, geometry);
          if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
          }
          if (object.isInstancedMesh) {
            if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
              object.addEventListener("dispose", onInstancedMeshDispose);
            }
            attributes.update(object.instanceMatrix, gl2.ARRAY_BUFFER);
            if (object.instanceColor !== null) {
              attributes.update(object.instanceColor, gl2.ARRAY_BUFFER);
            }
          }
          return buffergeometry;
        }
        function dispose() {
          updateMap = /* @__PURE__ */ new WeakMap();
        }
        function onInstancedMeshDispose(event) {
          const instancedMesh = event.target;
          instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
          attributes.remove(instancedMesh.instanceMatrix);
          if (instancedMesh.instanceColor !== null)
            attributes.remove(instancedMesh.instanceColor);
        }
        return {
          update,
          dispose
        };
      }
      var emptyTexture = new Texture();
      var emptyArrayTexture = new DataArrayTexture();
      var empty3dTexture = new Data3DTexture();
      var emptyCubeTexture = new CubeTexture();
      var arrayCacheF32 = [];
      var arrayCacheI32 = [];
      var mat4array = new Float32Array(16);
      var mat3array = new Float32Array(9);
      var mat2array = new Float32Array(4);
      function flatten(array, nBlocks, blockSize) {
        const firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
          return array;
        const n2 = nBlocks * blockSize;
        let r2 = arrayCacheF32[n2];
        if (r2 === void 0) {
          r2 = new Float32Array(n2);
          arrayCacheF32[n2] = r2;
        }
        if (nBlocks !== 0) {
          firstElem.toArray(r2, 0);
          for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
            offset += blockSize;
            array[i2].toArray(r2, offset);
          }
        }
        return r2;
      }
      function arraysEqual(a2, b2) {
        if (a2.length !== b2.length)
          return false;
        for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
          if (a2[i2] !== b2[i2])
            return false;
        }
        return true;
      }
      function copyArray(a2, b2) {
        for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
          a2[i2] = b2[i2];
        }
      }
      function allocTexUnits(textures, n2) {
        let r2 = arrayCacheI32[n2];
        if (r2 === void 0) {
          r2 = new Int32Array(n2);
          arrayCacheI32[n2] = r2;
        }
        for (let i2 = 0; i2 !== n2; ++i2) {
          r2[i2] = textures.allocateTextureUnit();
        }
        return r2;
      }
      function setValueV1f(gl2, v2) {
        const cache = this.cache;
        if (cache[0] === v2)
          return;
        gl2.uniform1f(this.addr, v2);
        cache[0] = v2;
      }
      function setValueV2f(gl2, v2) {
        const cache = this.cache;
        if (v2.x !== void 0) {
          if (cache[0] !== v2.x || cache[1] !== v2.y) {
            gl2.uniform2f(this.addr, v2.x, v2.y);
            cache[0] = v2.x;
            cache[1] = v2.y;
          }
        } else {
          if (arraysEqual(cache, v2))
            return;
          gl2.uniform2fv(this.addr, v2);
          copyArray(cache, v2);
        }
      }
      function setValueV3f(gl2, v2) {
        const cache = this.cache;
        if (v2.x !== void 0) {
          if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
            gl2.uniform3f(this.addr, v2.x, v2.y, v2.z);
            cache[0] = v2.x;
            cache[1] = v2.y;
            cache[2] = v2.z;
          }
        } else if (v2.r !== void 0) {
          if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
            gl2.uniform3f(this.addr, v2.r, v2.g, v2.b);
            cache[0] = v2.r;
            cache[1] = v2.g;
            cache[2] = v2.b;
          }
        } else {
          if (arraysEqual(cache, v2))
            return;
          gl2.uniform3fv(this.addr, v2);
          copyArray(cache, v2);
        }
      }
      function setValueV4f(gl2, v2) {
        const cache = this.cache;
        if (v2.x !== void 0) {
          if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
            gl2.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
            cache[0] = v2.x;
            cache[1] = v2.y;
            cache[2] = v2.z;
            cache[3] = v2.w;
          }
        } else {
          if (arraysEqual(cache, v2))
            return;
          gl2.uniform4fv(this.addr, v2);
          copyArray(cache, v2);
        }
      }
      function setValueM2(gl2, v2) {
        const cache = this.cache;
        const elements = v2.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v2))
            return;
          gl2.uniformMatrix2fv(this.addr, false, v2);
          copyArray(cache, v2);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat2array.set(elements);
          gl2.uniformMatrix2fv(this.addr, false, mat2array);
          copyArray(cache, elements);
        }
      }
      function setValueM3(gl2, v2) {
        const cache = this.cache;
        const elements = v2.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v2))
            return;
          gl2.uniformMatrix3fv(this.addr, false, v2);
          copyArray(cache, v2);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat3array.set(elements);
          gl2.uniformMatrix3fv(this.addr, false, mat3array);
          copyArray(cache, elements);
        }
      }
      function setValueM4(gl2, v2) {
        const cache = this.cache;
        const elements = v2.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v2))
            return;
          gl2.uniformMatrix4fv(this.addr, false, v2);
          copyArray(cache, v2);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat4array.set(elements);
          gl2.uniformMatrix4fv(this.addr, false, mat4array);
          copyArray(cache, elements);
        }
      }
      function setValueV1i(gl2, v2) {
        const cache = this.cache;
        if (cache[0] === v2)
          return;
        gl2.uniform1i(this.addr, v2);
        cache[0] = v2;
      }
      function setValueV2i(gl2, v2) {
        const cache = this.cache;
        if (arraysEqual(cache, v2))
          return;
        gl2.uniform2iv(this.addr, v2);
        copyArray(cache, v2);
      }
      function setValueV3i(gl2, v2) {
        const cache = this.cache;
        if (arraysEqual(cache, v2))
          return;
        gl2.uniform3iv(this.addr, v2);
        copyArray(cache, v2);
      }
      function setValueV4i(gl2, v2) {
        const cache = this.cache;
        if (arraysEqual(cache, v2))
          return;
        gl2.uniform4iv(this.addr, v2);
        copyArray(cache, v2);
      }
      function setValueV1ui(gl2, v2) {
        const cache = this.cache;
        if (cache[0] === v2)
          return;
        gl2.uniform1ui(this.addr, v2);
        cache[0] = v2;
      }
      function setValueV2ui(gl2, v2) {
        const cache = this.cache;
        if (arraysEqual(cache, v2))
          return;
        gl2.uniform2uiv(this.addr, v2);
        copyArray(cache, v2);
      }
      function setValueV3ui(gl2, v2) {
        const cache = this.cache;
        if (arraysEqual(cache, v2))
          return;
        gl2.uniform3uiv(this.addr, v2);
        copyArray(cache, v2);
      }
      function setValueV4ui(gl2, v2) {
        const cache = this.cache;
        if (arraysEqual(cache, v2))
          return;
        gl2.uniform4uiv(this.addr, v2);
        copyArray(cache, v2);
      }
      function setValueT1(gl2, v2, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl2.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture2D(v2 || emptyTexture, unit);
      }
      function setValueT3D1(gl2, v2, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl2.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture3D(v2 || empty3dTexture, unit);
      }
      function setValueT6(gl2, v2, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl2.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTextureCube(v2 || emptyCubeTexture, unit);
      }
      function setValueT2DArray1(gl2, v2, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl2.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
      }
      function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValueV1f;
          case 35664:
            return setValueV2f;
          case 35665:
            return setValueV3f;
          case 35666:
            return setValueV4f;
          case 35674:
            return setValueM2;
          case 35675:
            return setValueM3;
          case 35676:
            return setValueM4;
          case 5124:
          case 35670:
            return setValueV1i;
          case 35667:
          case 35671:
            return setValueV2i;
          case 35668:
          case 35672:
            return setValueV3i;
          case 35669:
          case 35673:
            return setValueV4i;
          case 5125:
            return setValueV1ui;
          case 36294:
            return setValueV2ui;
          case 36295:
            return setValueV3ui;
          case 36296:
            return setValueV4ui;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3D1;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArray1;
        }
      }
      function setValueV1fArray(gl2, v2) {
        gl2.uniform1fv(this.addr, v2);
      }
      function setValueV2fArray(gl2, v2) {
        const data = flatten(v2, this.size, 2);
        gl2.uniform2fv(this.addr, data);
      }
      function setValueV3fArray(gl2, v2) {
        const data = flatten(v2, this.size, 3);
        gl2.uniform3fv(this.addr, data);
      }
      function setValueV4fArray(gl2, v2) {
        const data = flatten(v2, this.size, 4);
        gl2.uniform4fv(this.addr, data);
      }
      function setValueM2Array(gl2, v2) {
        const data = flatten(v2, this.size, 4);
        gl2.uniformMatrix2fv(this.addr, false, data);
      }
      function setValueM3Array(gl2, v2) {
        const data = flatten(v2, this.size, 9);
        gl2.uniformMatrix3fv(this.addr, false, data);
      }
      function setValueM4Array(gl2, v2) {
        const data = flatten(v2, this.size, 16);
        gl2.uniformMatrix4fv(this.addr, false, data);
      }
      function setValueV1iArray(gl2, v2) {
        gl2.uniform1iv(this.addr, v2);
      }
      function setValueV2iArray(gl2, v2) {
        gl2.uniform2iv(this.addr, v2);
      }
      function setValueV3iArray(gl2, v2) {
        gl2.uniform3iv(this.addr, v2);
      }
      function setValueV4iArray(gl2, v2) {
        gl2.uniform4iv(this.addr, v2);
      }
      function setValueV1uiArray(gl2, v2) {
        gl2.uniform1uiv(this.addr, v2);
      }
      function setValueV2uiArray(gl2, v2) {
        gl2.uniform2uiv(this.addr, v2);
      }
      function setValueV3uiArray(gl2, v2) {
        gl2.uniform3uiv(this.addr, v2);
      }
      function setValueV4uiArray(gl2, v2) {
        gl2.uniform4uiv(this.addr, v2);
      }
      function setValueT1Array(gl2, v2, textures) {
        const n2 = v2.length;
        const units = allocTexUnits(textures, n2);
        gl2.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n2; ++i2) {
          textures.setTexture2D(v2[i2] || emptyTexture, units[i2]);
        }
      }
      function setValueT3DArray(gl2, v2, textures) {
        const n2 = v2.length;
        const units = allocTexUnits(textures, n2);
        gl2.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n2; ++i2) {
          textures.setTexture3D(v2[i2] || empty3dTexture, units[i2]);
        }
      }
      function setValueT6Array(gl2, v2, textures) {
        const n2 = v2.length;
        const units = allocTexUnits(textures, n2);
        gl2.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n2; ++i2) {
          textures.setTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
        }
      }
      function setValueT2DArrayArray(gl2, v2, textures) {
        const n2 = v2.length;
        const units = allocTexUnits(textures, n2);
        gl2.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n2; ++i2) {
          textures.setTexture2DArray(v2[i2] || emptyArrayTexture, units[i2]);
        }
      }
      function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValueV1fArray;
          case 35664:
            return setValueV2fArray;
          case 35665:
            return setValueV3fArray;
          case 35666:
            return setValueV4fArray;
          case 35674:
            return setValueM2Array;
          case 35675:
            return setValueM3Array;
          case 35676:
            return setValueM4Array;
          case 5124:
          case 35670:
            return setValueV1iArray;
          case 35667:
          case 35671:
            return setValueV2iArray;
          case 35668:
          case 35672:
            return setValueV3iArray;
          case 35669:
          case 35673:
            return setValueV4iArray;
          case 5125:
            return setValueV1uiArray;
          case 36294:
            return setValueV2uiArray;
          case 36295:
            return setValueV3uiArray;
          case 36296:
            return setValueV4uiArray;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1Array;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3DArray;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6Array;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArrayArray;
        }
      }
      function SingleUniform(id2, activeInfo, addr) {
        this.id = id2;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter(activeInfo.type);
      }
      function PureArrayUniform(id2, activeInfo, addr) {
        this.id = id2;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
      }
      PureArrayUniform.prototype.updateCache = function(data) {
        const cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) {
          this.cache = new Float32Array(data.length);
        }
        copyArray(cache, data);
      };
      function StructuredUniform(id2) {
        this.id = id2;
        this.seq = [];
        this.map = {};
      }
      StructuredUniform.prototype.setValue = function(gl2, value, textures) {
        const seq = this.seq;
        for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
          const u2 = seq[i2];
          u2.setValue(gl2, value[u2.id], textures);
        }
      };
      var RePathPart = /(\w+)(\])?(\[|\.)?/g;
      function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
      }
      function parseUniform(activeInfo, addr, container) {
        const path = activeInfo.name, pathLength = path.length;
        RePathPart.lastIndex = 0;
        while (true) {
          const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
          let id2 = match[1];
          const idIsIndex = match[2] === "]", subscript = match[3];
          if (idIsIndex)
            id2 = id2 | 0;
          if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
            addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
            break;
          } else {
            const map = container.map;
            let next = map[id2];
            if (next === void 0) {
              next = new StructuredUniform(id2);
              addUniform(container, next);
            }
            container = next;
          }
        }
      }
      function WebGLUniforms(gl2, program) {
        this.seq = [];
        this.map = {};
        const n2 = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
        for (let i2 = 0; i2 < n2; ++i2) {
          const info = gl2.getActiveUniform(program, i2), addr = gl2.getUniformLocation(program, info.name);
          parseUniform(info, addr, this);
        }
      }
      WebGLUniforms.prototype.setValue = function(gl2, name, value, textures) {
        const u2 = this.map[name];
        if (u2 !== void 0)
          u2.setValue(gl2, value, textures);
      };
      WebGLUniforms.prototype.setOptional = function(gl2, object, name) {
        const v2 = object[name];
        if (v2 !== void 0)
          this.setValue(gl2, name, v2);
      };
      WebGLUniforms.upload = function(gl2, seq, values, textures) {
        for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
          const u2 = seq[i2], v2 = values[u2.id];
          if (v2.needsUpdate !== false) {
            u2.setValue(gl2, v2.value, textures);
          }
        }
      };
      WebGLUniforms.seqWithValue = function(seq, values) {
        const r2 = [];
        for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
          const u2 = seq[i2];
          if (u2.id in values)
            r2.push(u2);
        }
        return r2;
      };
      function WebGLShader(gl2, type, string) {
        const shader = gl2.createShader(type);
        gl2.shaderSource(shader, string);
        gl2.compileShader(shader);
        return shader;
      }
      var programIdCount = 0;
      function addLineNumbers(string) {
        const lines = string.split("\n");
        for (let i2 = 0; i2 < lines.length; i2++) {
          lines[i2] = i2 + 1 + ": " + lines[i2];
        }
        return lines.join("\n");
      }
      function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return ["Linear", "( value )"];
          case sRGBEncoding:
            return ["sRGB", "( value )"];
          default:
            console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
            return ["Linear", "( value )"];
        }
      }
      function getShaderErrors(gl2, shader, type) {
        const status = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
        const errors = gl2.getShaderInfoLog(shader).trim();
        if (status && errors === "")
          return "";
        return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl2.getShaderSource(shader));
      }
      function getTexelEncodingFunction(functionName, encoding) {
        const components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
      }
      function getToneMappingFunction(functionName, toneMapping) {
        let toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;
          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;
          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;
          case ACESFilmicToneMapping:
            toneMappingName = "ACESFilmic";
            break;
          case CustomToneMapping:
            toneMappingName = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
            toneMappingName = "Linear";
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
      }
      function generateExtensions(parameters) {
        const chunks = [parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
        return chunks.filter(filterEmptyLine).join("\n");
      }
      function generateDefines(defines) {
        const chunks = [];
        for (const name in defines) {
          const value = defines[name];
          if (value === false)
            continue;
          chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
      }
      function fetchAttributeLocations(gl2, program) {
        const attributes = {};
        const n2 = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
        for (let i2 = 0; i2 < n2; i2++) {
          const info = gl2.getActiveAttrib(program, i2);
          const name = info.name;
          let locationSize = 1;
          if (info.type === gl2.FLOAT_MAT2)
            locationSize = 2;
          if (info.type === gl2.FLOAT_MAT3)
            locationSize = 3;
          if (info.type === gl2.FLOAT_MAT4)
            locationSize = 4;
          attributes[name] = {
            type: info.type,
            location: gl2.getAttribLocation(program, name),
            locationSize
          };
        }
        return attributes;
      }
      function filterEmptyLine(string) {
        return string !== "";
      }
      function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
      }
      function replaceClippingPlaneNums(string, parameters) {
        return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
      }
      var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function resolveIncludes(string) {
        return string.replace(includePattern, includeReplacer);
      }
      function includeReplacer(match, include) {
        const string = ShaderChunk[include];
        if (string === void 0) {
          throw new Error("Can not resolve #include <" + include + ">");
        }
        return resolveIncludes(string);
      }
      var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
      var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function unrollLoops(string) {
        return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
      }
      function deprecatedLoopReplacer(match, start, end, snippet) {
        console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
        return loopReplacer(match, start, end, snippet);
      }
      function loopReplacer(match, start, end, snippet) {
        let string = "";
        for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
          string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
        }
        return string;
      }
      function generatePrecision(parameters) {
        let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
        if (parameters.precision === "highp") {
          precisionstring += "\n#define HIGH_PRECISION";
        } else if (parameters.precision === "mediump") {
          precisionstring += "\n#define MEDIUM_PRECISION";
        } else if (parameters.precision === "lowp") {
          precisionstring += "\n#define LOW_PRECISION";
        }
        return precisionstring;
      }
      function generateShadowMapTypeDefine(parameters) {
        let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        if (parameters.shadowMapType === PCFShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
        } else if (parameters.shadowMapType === VSMShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
        }
        return shadowMapTypeDefine;
      }
      function generateEnvMapTypeDefine(parameters) {
        let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeReflectionMapping:
            case CubeRefractionMapping:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE";
              break;
            case CubeUVReflectionMapping:
            case CubeUVRefractionMapping:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        }
        return envMapTypeDefine;
      }
      function generateEnvMapModeDefine(parameters) {
        let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeRefractionMapping:
            case CubeUVRefractionMapping:
              envMapModeDefine = "ENVMAP_MODE_REFRACTION";
              break;
          }
        }
        return envMapModeDefine;
      }
      function generateEnvMapBlendingDefine(parameters) {
        let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
        if (parameters.envMap) {
          switch (parameters.combine) {
            case MultiplyOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case MixOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
              break;
            case AddOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
              break;
          }
        }
        return envMapBlendingDefine;
      }
      function generateCubeUVSize(parameters) {
        const imageHeight = parameters.envMapCubeUVHeight;
        if (imageHeight === null)
          return null;
        const maxMip = Math.log2(imageHeight / 32 + 1) + 3;
        const texelHeight = 1 / imageHeight;
        const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
        return {
          texelWidth,
          texelHeight,
          maxMip
        };
      }
      function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
        const gl2 = renderer.getContext();
        const defines = parameters.defines;
        let vertexShader = parameters.vertexShader;
        let fragmentShader = parameters.fragmentShader;
        const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
        const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
        const envMapModeDefine = generateEnvMapModeDefine(parameters);
        const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
        const envMapCubeUVSize = generateCubeUVSize(parameters);
        const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
        const customDefines = generateDefines(defines);
        const program = gl2.createProgram();
        let prefixVertex, prefixFragment;
        let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
        if (parameters.isRawShaderMaterial) {
          prefixVertex = [customDefines].filter(filterEmptyLine).join("\n");
          if (prefixVertex.length > 0) {
            prefixVertex += "\n";
          }
          prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join("\n");
          if (prefixFragment.length > 0) {
            prefixFragment += "\n";
          }
        } else {
          prefixVertex = [generatePrecision(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.transmission ? "#define USE_TRANSMISSION" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "", parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "", parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "", parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n");
          prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
            envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
            envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.alphaTest ? "#define USE_ALPHATEST" : "",
            parameters.sheen ? "#define USE_SHEEN" : "",
            parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            parameters.transmission ? "#define USE_TRANSMISSION" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
            parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            parameters.opaque ? "#define OPAQUE" : "",
            ShaderChunk["encodings_pars_fragment"],
            getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
            parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
            "\n"
          ].filter(filterEmptyLine).join("\n");
        }
        vertexShader = resolveIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
        fragmentShader = resolveIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
        if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
          versionString = "#version 300 es\n";
          prefixVertex = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
          prefixFragment = ["#define varying in", parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
        }
        const vertexGlsl = versionString + prefixVertex + vertexShader;
        const fragmentGlsl = versionString + prefixFragment + fragmentShader;
        const glVertexShader = WebGLShader(gl2, gl2.VERTEX_SHADER, vertexGlsl);
        const glFragmentShader = WebGLShader(gl2, gl2.FRAGMENT_SHADER, fragmentGlsl);
        gl2.attachShader(program, glVertexShader);
        gl2.attachShader(program, glFragmentShader);
        if (parameters.index0AttributeName !== void 0) {
          gl2.bindAttribLocation(program, 0, parameters.index0AttributeName);
        } else if (parameters.morphTargets === true) {
          gl2.bindAttribLocation(program, 0, "position");
        }
        gl2.linkProgram(program);
        if (renderer.debug.checkShaderErrors) {
          const programLog = gl2.getProgramInfoLog(program).trim();
          const vertexLog = gl2.getShaderInfoLog(glVertexShader).trim();
          const fragmentLog = gl2.getShaderInfoLog(glFragmentShader).trim();
          let runnable = true;
          let haveDiagnostics = true;
          if (gl2.getProgramParameter(program, gl2.LINK_STATUS) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl2, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl2, glFragmentShader, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + gl2.getError() + " - VALIDATE_STATUS " + gl2.getProgramParameter(program, gl2.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
          } else if (programLog !== "") {
            console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
          } else if (vertexLog === "" || fragmentLog === "") {
            haveDiagnostics = false;
          }
          if (haveDiagnostics) {
            this.diagnostics = {
              runnable,
              programLog,
              vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
              },
              fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
              }
            };
          }
        }
        gl2.deleteShader(glVertexShader);
        gl2.deleteShader(glFragmentShader);
        let cachedUniforms;
        this.getUniforms = function() {
          if (cachedUniforms === void 0) {
            cachedUniforms = new WebGLUniforms(gl2, program);
          }
          return cachedUniforms;
        };
        let cachedAttributes;
        this.getAttributes = function() {
          if (cachedAttributes === void 0) {
            cachedAttributes = fetchAttributeLocations(gl2, program);
          }
          return cachedAttributes;
        };
        this.destroy = function() {
          bindingStates.releaseStatesOfProgram(this);
          gl2.deleteProgram(program);
          this.program = void 0;
        };
        this.name = parameters.shaderName;
        this.id = programIdCount++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      }
      var _id = 0;
      var WebGLShaderCache = class {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map();
          this.materialCache = /* @__PURE__ */ new Map();
        }
        update(material) {
          const vertexShader = material.vertexShader;
          const fragmentShader = material.fragmentShader;
          const vertexShaderStage = this._getShaderStage(vertexShader);
          const fragmentShaderStage = this._getShaderStage(fragmentShader);
          const materialShaders = this._getShaderCacheForMaterial(material);
          if (materialShaders.has(vertexShaderStage) === false) {
            materialShaders.add(vertexShaderStage);
            vertexShaderStage.usedTimes++;
          }
          if (materialShaders.has(fragmentShaderStage) === false) {
            materialShaders.add(fragmentShaderStage);
            fragmentShaderStage.usedTimes++;
          }
          return this;
        }
        remove(material) {
          const materialShaders = this.materialCache.get(material);
          for (const shaderStage of materialShaders) {
            shaderStage.usedTimes--;
            if (shaderStage.usedTimes === 0)
              this.shaderCache.delete(shaderStage);
          }
          this.materialCache.delete(material);
          return this;
        }
        getVertexShaderID(material) {
          return this._getShaderStage(material.vertexShader).id;
        }
        getFragmentShaderID(material) {
          return this._getShaderStage(material.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear();
          this.materialCache.clear();
        }
        _getShaderCacheForMaterial(material) {
          const cache = this.materialCache;
          if (cache.has(material) === false) {
            cache.set(material, /* @__PURE__ */ new Set());
          }
          return cache.get(material);
        }
        _getShaderStage(code) {
          const cache = this.shaderCache;
          if (cache.has(code) === false) {
            const stage = new WebGLShaderStage();
            cache.set(code, stage);
          }
          return cache.get(code);
        }
      };
      var WebGLShaderStage = class {
        constructor() {
          this.id = _id++;
          this.usedTimes = 0;
        }
      };
      function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
        const _programLayers = new Layers();
        const _customShaders = new WebGLShaderCache();
        const programs = [];
        const isWebGL2 = capabilities.isWebGL2;
        const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        const floatVertexTextures = capabilities.floatVertexTextures;
        const maxVertexUniforms = capabilities.maxVertexUniforms;
        const vertexTextures = capabilities.vertexTextures;
        let precision = capabilities.precision;
        const shaderIDs = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function getMaxBones(object) {
          const skeleton = object.skeleton;
          const bones = skeleton.bones;
          if (floatVertexTextures) {
            return 1024;
          } else {
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
              console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
              return 0;
            }
            return maxBones;
          }
        }
        function getParameters(material, lights, shadows, scene, object) {
          const fog = scene.fog;
          const geometry = object.geometry;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
          const envMapCubeUVHeight = !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping) ? envMap.image.height : null;
          const shaderID = shaderIDs[material.type];
          const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
          if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) {
              console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
            }
          }
          const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
          const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
          let morphTextureStride = 0;
          if (geometry.morphAttributes.position !== void 0)
            morphTextureStride = 1;
          if (geometry.morphAttributes.normal !== void 0)
            morphTextureStride = 2;
          if (geometry.morphAttributes.color !== void 0)
            morphTextureStride = 3;
          let vertexShader, fragmentShader;
          let customVertexShaderID, customFragmentShaderID;
          if (shaderID) {
            const shader = ShaderLib[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
          } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
            _customShaders.update(material);
            customVertexShaderID = _customShaders.getVertexShaderID(material);
            customFragmentShaderID = _customShaders.getFragmentShaderID(material);
          }
          const currentRenderTarget = renderer.getRenderTarget();
          const useAlphaTest = material.alphaTest > 0;
          const useClearcoat = material.clearcoat > 0;
          const parameters = {
            isWebGL2,
            shaderID,
            shaderName: material.type,
            vertexShader,
            fragmentShader,
            defines: material.defines,
            customVertexShaderID,
            customFragmentShaderID,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
            map: !!material.map,
            matcap: !!material.matcap,
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapCubeUVHeight,
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
            clearcoat: useClearcoat,
            clearcoatMap: useClearcoat && !!material.clearcoatMap,
            clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            specularIntensityMap: !!material.specularIntensityMap,
            specularColorMap: !!material.specularColorMap,
            opaque: material.transparent === false && material.blending === NormalBlending,
            alphaMap: !!material.alphaMap,
            alphaTest: useAlphaTest,
            gradientMap: !!material.gradientMap,
            sheen: material.sheen > 0,
            sheenColorMap: !!material.sheenColorMap,
            sheenRoughnessMap: !!material.sheenRoughnessMap,
            transmission: material.transmission > 0,
            transmissionMap: !!material.transmissionMap,
            thicknessMap: !!material.thicknessMap,
            combine: material.combine,
            vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
            vertexColors: material.vertexColors,
            vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true && maxBones > 0,
            maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: geometry.morphAttributes.position !== void 0,
            morphNormals: geometry.morphAttributes.normal !== void 0,
            morphColors: geometry.morphAttributes.color !== void 0,
            morphTargetsCount,
            morphTextureStride,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
            customProgramCacheKey: material.customProgramCacheKey()
          };
          return parameters;
        }
        function getProgramCacheKey(parameters) {
          const array = [];
          if (parameters.shaderID) {
            array.push(parameters.shaderID);
          } else {
            array.push(parameters.customVertexShaderID);
            array.push(parameters.customFragmentShaderID);
          }
          if (parameters.defines !== void 0) {
            for (const name in parameters.defines) {
              array.push(name);
              array.push(parameters.defines[name]);
            }
          }
          if (parameters.isRawShaderMaterial === false) {
            getProgramCacheKeyParameters(array, parameters);
            getProgramCacheKeyBooleans(array, parameters);
            array.push(renderer.outputEncoding);
          }
          array.push(parameters.customProgramCacheKey);
          return array.join();
        }
        function getProgramCacheKeyParameters(array, parameters) {
          array.push(parameters.precision);
          array.push(parameters.outputEncoding);
          array.push(parameters.envMapMode);
          array.push(parameters.envMapCubeUVHeight);
          array.push(parameters.combine);
          array.push(parameters.vertexUvs);
          array.push(parameters.fogExp2);
          array.push(parameters.sizeAttenuation);
          array.push(parameters.maxBones);
          array.push(parameters.morphTargetsCount);
          array.push(parameters.morphAttributeCount);
          array.push(parameters.numDirLights);
          array.push(parameters.numPointLights);
          array.push(parameters.numSpotLights);
          array.push(parameters.numHemiLights);
          array.push(parameters.numRectAreaLights);
          array.push(parameters.numDirLightShadows);
          array.push(parameters.numPointLightShadows);
          array.push(parameters.numSpotLightShadows);
          array.push(parameters.shadowMapType);
          array.push(parameters.toneMapping);
          array.push(parameters.numClippingPlanes);
          array.push(parameters.numClipIntersection);
        }
        function getProgramCacheKeyBooleans(array, parameters) {
          _programLayers.disableAll();
          if (parameters.isWebGL2)
            _programLayers.enable(0);
          if (parameters.supportsVertexTextures)
            _programLayers.enable(1);
          if (parameters.instancing)
            _programLayers.enable(2);
          if (parameters.instancingColor)
            _programLayers.enable(3);
          if (parameters.map)
            _programLayers.enable(4);
          if (parameters.matcap)
            _programLayers.enable(5);
          if (parameters.envMap)
            _programLayers.enable(6);
          if (parameters.lightMap)
            _programLayers.enable(7);
          if (parameters.aoMap)
            _programLayers.enable(8);
          if (parameters.emissiveMap)
            _programLayers.enable(9);
          if (parameters.bumpMap)
            _programLayers.enable(10);
          if (parameters.normalMap)
            _programLayers.enable(11);
          if (parameters.objectSpaceNormalMap)
            _programLayers.enable(12);
          if (parameters.tangentSpaceNormalMap)
            _programLayers.enable(13);
          if (parameters.clearcoat)
            _programLayers.enable(14);
          if (parameters.clearcoatMap)
            _programLayers.enable(15);
          if (parameters.clearcoatRoughnessMap)
            _programLayers.enable(16);
          if (parameters.clearcoatNormalMap)
            _programLayers.enable(17);
          if (parameters.displacementMap)
            _programLayers.enable(18);
          if (parameters.specularMap)
            _programLayers.enable(19);
          if (parameters.roughnessMap)
            _programLayers.enable(20);
          if (parameters.metalnessMap)
            _programLayers.enable(21);
          if (parameters.gradientMap)
            _programLayers.enable(22);
          if (parameters.alphaMap)
            _programLayers.enable(23);
          if (parameters.alphaTest)
            _programLayers.enable(24);
          if (parameters.vertexColors)
            _programLayers.enable(25);
          if (parameters.vertexAlphas)
            _programLayers.enable(26);
          if (parameters.vertexUvs)
            _programLayers.enable(27);
          if (parameters.vertexTangents)
            _programLayers.enable(28);
          if (parameters.uvsVertexOnly)
            _programLayers.enable(29);
          if (parameters.fog)
            _programLayers.enable(30);
          array.push(_programLayers.mask);
          _programLayers.disableAll();
          if (parameters.useFog)
            _programLayers.enable(0);
          if (parameters.flatShading)
            _programLayers.enable(1);
          if (parameters.logarithmicDepthBuffer)
            _programLayers.enable(2);
          if (parameters.skinning)
            _programLayers.enable(3);
          if (parameters.useVertexTexture)
            _programLayers.enable(4);
          if (parameters.morphTargets)
            _programLayers.enable(5);
          if (parameters.morphNormals)
            _programLayers.enable(6);
          if (parameters.morphColors)
            _programLayers.enable(7);
          if (parameters.premultipliedAlpha)
            _programLayers.enable(8);
          if (parameters.shadowMapEnabled)
            _programLayers.enable(9);
          if (parameters.physicallyCorrectLights)
            _programLayers.enable(10);
          if (parameters.doubleSided)
            _programLayers.enable(11);
          if (parameters.flipSided)
            _programLayers.enable(12);
          if (parameters.depthPacking)
            _programLayers.enable(13);
          if (parameters.dithering)
            _programLayers.enable(14);
          if (parameters.specularIntensityMap)
            _programLayers.enable(15);
          if (parameters.specularColorMap)
            _programLayers.enable(16);
          if (parameters.transmission)
            _programLayers.enable(17);
          if (parameters.transmissionMap)
            _programLayers.enable(18);
          if (parameters.thicknessMap)
            _programLayers.enable(19);
          if (parameters.sheen)
            _programLayers.enable(20);
          if (parameters.sheenColorMap)
            _programLayers.enable(21);
          if (parameters.sheenRoughnessMap)
            _programLayers.enable(22);
          if (parameters.decodeVideoTexture)
            _programLayers.enable(23);
          if (parameters.opaque)
            _programLayers.enable(24);
          array.push(_programLayers.mask);
        }
        function getUniforms(material) {
          const shaderID = shaderIDs[material.type];
          let uniforms;
          if (shaderID) {
            const shader = ShaderLib[shaderID];
            uniforms = UniformsUtils.clone(shader.uniforms);
          } else {
            uniforms = material.uniforms;
          }
          return uniforms;
        }
        function acquireProgram(parameters, cacheKey) {
          let program;
          for (let p = 0, pl2 = programs.length; p < pl2; p++) {
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
              program = preexistingProgram;
              ++program.usedTimes;
              break;
            }
          }
          if (program === void 0) {
            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
          }
          return program;
        }
        function releaseProgram(program) {
          if (--program.usedTimes === 0) {
            const i2 = programs.indexOf(program);
            programs[i2] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
          }
        }
        function releaseShaderCache(material) {
          _customShaders.remove(material);
        }
        function dispose() {
          _customShaders.dispose();
        }
        return {
          getParameters,
          getProgramCacheKey,
          getUniforms,
          acquireProgram,
          releaseProgram,
          releaseShaderCache,
          programs,
          dispose
        };
      }
      function WebGLProperties() {
        let properties = /* @__PURE__ */ new WeakMap();
        function get(object) {
          let map = properties.get(object);
          if (map === void 0) {
            map = {};
            properties.set(object, map);
          }
          return map;
        }
        function remove(object) {
          properties.delete(object);
        }
        function update(object, key, value) {
          properties.get(object)[key] = value;
        }
        function dispose() {
          properties = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          remove,
          update,
          dispose
        };
      }
      function painterSortStable(a2, b2) {
        if (a2.groupOrder !== b2.groupOrder) {
          return a2.groupOrder - b2.groupOrder;
        } else if (a2.renderOrder !== b2.renderOrder) {
          return a2.renderOrder - b2.renderOrder;
        } else if (a2.material.id !== b2.material.id) {
          return a2.material.id - b2.material.id;
        } else if (a2.z !== b2.z) {
          return a2.z - b2.z;
        } else {
          return a2.id - b2.id;
        }
      }
      function reversePainterSortStable(a2, b2) {
        if (a2.groupOrder !== b2.groupOrder) {
          return a2.groupOrder - b2.groupOrder;
        } else if (a2.renderOrder !== b2.renderOrder) {
          return a2.renderOrder - b2.renderOrder;
        } else if (a2.z !== b2.z) {
          return b2.z - a2.z;
        } else {
          return a2.id - b2.id;
        }
      }
      function WebGLRenderList() {
        const renderItems = [];
        let renderItemsIndex = 0;
        const opaque = [];
        const transmissive = [];
        const transparent = [];
        function init() {
          renderItemsIndex = 0;
          opaque.length = 0;
          transmissive.length = 0;
          transparent.length = 0;
        }
        function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
          let renderItem = renderItems[renderItemsIndex];
          if (renderItem === void 0) {
            renderItem = {
              id: object.id,
              object,
              geometry,
              material,
              groupOrder,
              renderOrder: object.renderOrder,
              z: z2,
              group
            };
            renderItems[renderItemsIndex] = renderItem;
          } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z2;
            renderItem.group = group;
          }
          renderItemsIndex++;
          return renderItem;
        }
        function push(object, geometry, material, groupOrder, z2, group) {
          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
          if (material.transmission > 0) {
            transmissive.push(renderItem);
          } else if (material.transparent === true) {
            transparent.push(renderItem);
          } else {
            opaque.push(renderItem);
          }
        }
        function unshift(object, geometry, material, groupOrder, z2, group) {
          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
          if (material.transmission > 0) {
            transmissive.unshift(renderItem);
          } else if (material.transparent === true) {
            transparent.unshift(renderItem);
          } else {
            opaque.unshift(renderItem);
          }
        }
        function sort(customOpaqueSort, customTransparentSort) {
          if (opaque.length > 1)
            opaque.sort(customOpaqueSort || painterSortStable);
          if (transmissive.length > 1)
            transmissive.sort(customTransparentSort || reversePainterSortStable);
          if (transparent.length > 1)
            transparent.sort(customTransparentSort || reversePainterSortStable);
        }
        function finish() {
          for (let i2 = renderItemsIndex, il2 = renderItems.length; i2 < il2; i2++) {
            const renderItem = renderItems[i2];
            if (renderItem.id === null)
              break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.group = null;
          }
        }
        return {
          opaque,
          transmissive,
          transparent,
          init,
          push,
          unshift,
          finish,
          sort
        };
      }
      function WebGLRenderLists() {
        let lists = /* @__PURE__ */ new WeakMap();
        function get(scene, renderCallDepth) {
          let list;
          if (lists.has(scene) === false) {
            list = new WebGLRenderList();
            lists.set(scene, [list]);
          } else {
            if (renderCallDepth >= lists.get(scene).length) {
              list = new WebGLRenderList();
              lists.get(scene).push(list);
            } else {
              list = lists.get(scene)[renderCallDepth];
            }
          }
          return list;
        }
        function dispose() {
          lists = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      function UniformsCache() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  direction: new Vector3(),
                  color: new Color()
                };
                break;
              case "SpotLight":
                uniforms = {
                  position: new Vector3(),
                  direction: new Vector3(),
                  color: new Color(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                uniforms = {
                  position: new Vector3(),
                  color: new Color(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                uniforms = {
                  direction: new Vector3(),
                  skyColor: new Color(),
                  groundColor: new Color()
                };
                break;
              case "RectAreaLight":
                uniforms = {
                  color: new Color(),
                  position: new Vector3(),
                  halfWidth: new Vector3(),
                  halfHeight: new Vector3()
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      function ShadowUniformsCache() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector2()
                };
                break;
              case "SpotLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector2()
                };
                break;
              case "PointLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector2(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      var nextVersion = 0;
      function shadowCastingLightsFirst(lightA, lightB) {
        return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
      }
      function WebGLLights(extensions, capabilities) {
        const cache = new UniformsCache();
        const shadowCache = ShadowUniformsCache();
        const state = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: []
        };
        for (let i2 = 0; i2 < 9; i2++)
          state.probe.push(new Vector3());
        const vector3 = new Vector3();
        const matrix4 = new Matrix4();
        const matrix42 = new Matrix4();
        function setup(lights, physicallyCorrectLights) {
          let r2 = 0, g2 = 0, b2 = 0;
          for (let i2 = 0; i2 < 9; i2++)
            state.probe[i2].set(0, 0, 0);
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          let numDirectionalShadows = 0;
          let numPointShadows = 0;
          let numSpotShadows = 0;
          lights.sort(shadowCastingLightsFirst);
          const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
          for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
            const light = lights[i2];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
              r2 += color.r * intensity * scaleFactor;
              g2 += color.g * intensity * scaleFactor;
              b2 += color.b * intensity * scaleFactor;
            } else if (light.isLightProbe) {
              for (let j2 = 0; j2 < 9; j2++) {
                state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
              }
            } else if (light.isDirectionalLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state.directionalShadow[directionalLength] = shadowUniforms;
                state.directionalShadowMap[directionalLength] = shadowMap;
                state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                numDirectionalShadows++;
              }
              state.directional[directionalLength] = uniforms;
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = cache.get(light);
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
              uniforms.distance = distance;
              uniforms.coneCos = Math.cos(light.angle);
              uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state.spotShadow[spotLength] = shadowUniforms;
                state.spotShadowMap[spotLength] = shadowMap;
                state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                numSpotShadows++;
              }
              state.spot[spotLength] = uniforms;
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(color).multiplyScalar(intensity);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              state.rectArea[rectAreaLength] = uniforms;
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
              uniforms.distance = light.distance;
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                shadowUniforms.shadowCameraNear = shadow.camera.near;
                shadowUniforms.shadowCameraFar = shadow.camera.far;
                state.pointShadow[pointLength] = shadowUniforms;
                state.pointShadowMap[pointLength] = shadowMap;
                state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                numPointShadows++;
              }
              state.point[pointLength] = uniforms;
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = cache.get(light);
              uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
              uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
              state.hemi[hemiLength] = uniforms;
              hemiLength++;
            }
          }
          if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
              state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
              state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
            } else {
              if (extensions.has("OES_texture_float_linear") === true) {
                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
              } else if (extensions.has("OES_texture_half_float_linear") === true) {
                state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
              } else {
                console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
              }
            }
          }
          state.ambient[0] = r2;
          state.ambient[1] = g2;
          state.ambient[2] = b2;
          const hash = state.hash;
          if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
          }
        }
        function setupView(lights, camera) {
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          const viewMatrix = camera.matrixWorldInverse;
          for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
            const light = lights[i2];
            if (light.isDirectionalLight) {
              const uniforms = state.directional[directionalLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = state.spot[spotLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = state.rectArea[rectAreaLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              matrix42.identity();
              matrix4.copy(light.matrixWorld);
              matrix4.premultiply(viewMatrix);
              matrix42.extractRotation(matrix4);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              uniforms.halfWidth.applyMatrix4(matrix42);
              uniforms.halfHeight.applyMatrix4(matrix42);
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = state.point[pointLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = state.hemi[hemiLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              uniforms.direction.transformDirection(viewMatrix);
              uniforms.direction.normalize();
              hemiLength++;
            }
          }
        }
        return {
          setup,
          setupView,
          state
        };
      }
      function WebGLRenderState(extensions, capabilities) {
        const lights = new WebGLLights(extensions, capabilities);
        const lightsArray = [];
        const shadowsArray = [];
        function init() {
          lightsArray.length = 0;
          shadowsArray.length = 0;
        }
        function pushLight(light) {
          lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
          shadowsArray.push(shadowLight);
        }
        function setupLights(physicallyCorrectLights) {
          lights.setup(lightsArray, physicallyCorrectLights);
        }
        function setupLightsView(camera) {
          lights.setupView(lightsArray, camera);
        }
        const state = {
          lightsArray,
          shadowsArray,
          lights
        };
        return {
          init,
          state,
          setupLights,
          setupLightsView,
          pushLight,
          pushShadow
        };
      }
      function WebGLRenderStates(extensions, capabilities) {
        let renderStates = /* @__PURE__ */ new WeakMap();
        function get(scene, renderCallDepth = 0) {
          let renderState;
          if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, [renderState]);
          } else {
            if (renderCallDepth >= renderStates.get(scene).length) {
              renderState = new WebGLRenderState(extensions, capabilities);
              renderStates.get(scene).push(renderState);
            } else {
              renderState = renderStates.get(scene)[renderCallDepth];
            }
          }
          return renderState;
        }
        function dispose() {
          renderStates = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      var MeshDepthMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      };
      MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
      var MeshDistanceMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new Vector3();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.referencePosition.copy(source.referencePosition);
          this.nearDistance = source.nearDistance;
          this.farDistance = source.farDistance;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      };
      MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
      var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function WebGLShadowMap(_renderer, _objects, _capabilities) {
        let _frustum = new Frustum();
        const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({
          depthPacking: RGBADepthPacking
        }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
        const shadowSide = {
          0: BackSide,
          1: FrontSide,
          2: DoubleSide
        };
        const shadowMaterialVertical = new ShaderMaterial({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Vector2()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: vertex,
          fragmentShader: fragment
        });
        const shadowMaterialHorizontal = shadowMaterialVertical.clone();
        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
        const fullScreenTri = new BufferGeometry();
        fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
        const scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.render = function(lights, scene, camera) {
          if (scope.enabled === false)
            return;
          if (scope.autoUpdate === false && scope.needsUpdate === false)
            return;
          if (lights.length === 0)
            return;
          const currentRenderTarget = _renderer.getRenderTarget();
          const activeCubeFace = _renderer.getActiveCubeFace();
          const activeMipmapLevel = _renderer.getActiveMipmapLevel();
          const _state = _renderer.state;
          _state.setBlending(NoBlending);
          _state.buffers.color.setClear(1, 1, 1, 1);
          _state.buffers.depth.setTest(true);
          _state.setScissorTest(false);
          for (let i2 = 0, il2 = lights.length; i2 < il2; i2++) {
            const light = lights[i2];
            const shadow = light.shadow;
            if (shadow === void 0) {
              console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
              continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false)
              continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
              if (_shadowMapSize.x > _maxTextureSize) {
                _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                shadow.mapSize.x = _viewportSize.x;
              }
              if (_shadowMapSize.y > _maxTextureSize) {
                _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                shadow.mapSize.y = _viewportSize.y;
              }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
              const pars = {
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                format: RGBAFormat
              };
              shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
              const pars = {
                minFilter: NearestFilter,
                magFilter: NearestFilter,
                format: RGBAFormat
              };
              shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for (let vp2 = 0; vp2 < viewportCount; vp2++) {
              const viewport = shadow.getViewport(vp2);
              _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
              _state.viewport(_viewport);
              shadow.updateMatrices(light, vp2);
              _frustum = shadow.getFrustum();
              renderObject(scene, camera, shadow.camera, light, this.type);
            }
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
              VSMPass(shadow, camera);
            }
            shadow.needsUpdate = false;
          }
          scope.needsUpdate = false;
          _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
        };
        function VSMPass(shadow, camera) {
          const geometry = _objects.update(fullScreenMesh);
          if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
            shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialVertical.needsUpdate = true;
            shadowMaterialHorizontal.needsUpdate = true;
          }
          shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
          shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialVertical.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.mapPass);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
          shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
          shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
        }
        function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
          let result = null;
          const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
          if (customMaterial !== void 0) {
            result = customMaterial;
          } else {
            result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
          }
          if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === void 0) {
              materialsForVariant = {};
              _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === void 0) {
              cachedMaterial = result.clone();
              materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
          }
          result.visible = material.visible;
          result.wireframe = material.wireframe;
          if (type === VSMShadowMap) {
            result.side = material.shadowSide !== null ? material.shadowSide : material.side;
          } else {
            result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
          }
          result.alphaMap = material.alphaMap;
          result.alphaTest = material.alphaTest;
          result.clipShadows = material.clipShadows;
          result.clippingPlanes = material.clippingPlanes;
          result.clipIntersection = material.clipIntersection;
          result.displacementMap = material.displacementMap;
          result.displacementScale = material.displacementScale;
          result.displacementBias = material.displacementBias;
          result.wireframeLinewidth = material.wireframeLinewidth;
          result.linewidth = material.linewidth;
          if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
          }
          return result;
        }
        function renderObject(object, camera, shadowCamera, light, type) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
              object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              const geometry = _objects.update(object);
              const material = object.material;
              if (Array.isArray(material)) {
                const groups = geometry.groups;
                for (let k2 = 0, kl2 = groups.length; k2 < kl2; k2++) {
                  const group = groups[k2];
                  const groupMaterial = material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                  }
                }
              } else if (material.visible) {
                const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            renderObject(children[i2], camera, shadowCamera, light, type);
          }
        }
      }
      function WebGLState(gl2, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function ColorBuffer() {
          let locked = false;
          const color = new Vector4();
          let currentColorMask = null;
          const currentColorClear = new Vector4(0, 0, 0, 0);
          return {
            setMask: function(colorMask) {
              if (currentColorMask !== colorMask && !locked) {
                gl2.colorMask(colorMask, colorMask, colorMask, colorMask);
                currentColorMask = colorMask;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
              if (premultipliedAlpha === true) {
                r2 *= a2;
                g2 *= a2;
                b2 *= a2;
              }
              color.set(r2, g2, b2, a2);
              if (currentColorClear.equals(color) === false) {
                gl2.clearColor(r2, g2, b2, a2);
                currentColorClear.copy(color);
              }
            },
            reset: function() {
              locked = false;
              currentColorMask = null;
              currentColorClear.set(-1, 0, 0, 0);
            }
          };
        }
        function DepthBuffer() {
          let locked = false;
          let currentDepthMask = null;
          let currentDepthFunc = null;
          let currentDepthClear = null;
          return {
            setTest: function(depthTest) {
              if (depthTest) {
                enable(gl2.DEPTH_TEST);
              } else {
                disable(gl2.DEPTH_TEST);
              }
            },
            setMask: function(depthMask) {
              if (currentDepthMask !== depthMask && !locked) {
                gl2.depthMask(depthMask);
                currentDepthMask = depthMask;
              }
            },
            setFunc: function(depthFunc) {
              if (currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                  switch (depthFunc) {
                    case NeverDepth:
                      gl2.depthFunc(gl2.NEVER);
                      break;
                    case AlwaysDepth:
                      gl2.depthFunc(gl2.ALWAYS);
                      break;
                    case LessDepth:
                      gl2.depthFunc(gl2.LESS);
                      break;
                    case LessEqualDepth:
                      gl2.depthFunc(gl2.LEQUAL);
                      break;
                    case EqualDepth:
                      gl2.depthFunc(gl2.EQUAL);
                      break;
                    case GreaterEqualDepth:
                      gl2.depthFunc(gl2.GEQUAL);
                      break;
                    case GreaterDepth:
                      gl2.depthFunc(gl2.GREATER);
                      break;
                    case NotEqualDepth:
                      gl2.depthFunc(gl2.NOTEQUAL);
                      break;
                    default:
                      gl2.depthFunc(gl2.LEQUAL);
                  }
                } else {
                  gl2.depthFunc(gl2.LEQUAL);
                }
                currentDepthFunc = depthFunc;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(depth) {
              if (currentDepthClear !== depth) {
                gl2.clearDepth(depth);
                currentDepthClear = depth;
              }
            },
            reset: function() {
              locked = false;
              currentDepthMask = null;
              currentDepthFunc = null;
              currentDepthClear = null;
            }
          };
        }
        function StencilBuffer() {
          let locked = false;
          let currentStencilMask = null;
          let currentStencilFunc = null;
          let currentStencilRef = null;
          let currentStencilFuncMask = null;
          let currentStencilFail = null;
          let currentStencilZFail = null;
          let currentStencilZPass = null;
          let currentStencilClear = null;
          return {
            setTest: function(stencilTest) {
              if (!locked) {
                if (stencilTest) {
                  enable(gl2.STENCIL_TEST);
                } else {
                  disable(gl2.STENCIL_TEST);
                }
              }
            },
            setMask: function(stencilMask) {
              if (currentStencilMask !== stencilMask && !locked) {
                gl2.stencilMask(stencilMask);
                currentStencilMask = stencilMask;
              }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
              if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                gl2.stencilFunc(stencilFunc, stencilRef, stencilMask);
                currentStencilFunc = stencilFunc;
                currentStencilRef = stencilRef;
                currentStencilFuncMask = stencilMask;
              }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
              if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                gl2.stencilOp(stencilFail, stencilZFail, stencilZPass);
                currentStencilFail = stencilFail;
                currentStencilZFail = stencilZFail;
                currentStencilZPass = stencilZPass;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(stencil) {
              if (currentStencilClear !== stencil) {
                gl2.clearStencil(stencil);
                currentStencilClear = stencil;
              }
            },
            reset: function() {
              locked = false;
              currentStencilMask = null;
              currentStencilFunc = null;
              currentStencilRef = null;
              currentStencilFuncMask = null;
              currentStencilFail = null;
              currentStencilZFail = null;
              currentStencilZPass = null;
              currentStencilClear = null;
            }
          };
        }
        const colorBuffer = new ColorBuffer();
        const depthBuffer = new DepthBuffer();
        const stencilBuffer = new StencilBuffer();
        let enabledCapabilities = {};
        let currentBoundFramebuffers = {};
        let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
        let defaultDrawbuffers = [];
        let currentProgram = null;
        let currentBlendingEnabled = false;
        let currentBlending = null;
        let currentBlendEquation = null;
        let currentBlendSrc = null;
        let currentBlendDst = null;
        let currentBlendEquationAlpha = null;
        let currentBlendSrcAlpha = null;
        let currentBlendDstAlpha = null;
        let currentPremultipledAlpha = false;
        let currentFlipSided = null;
        let currentCullFace = null;
        let currentLineWidth = null;
        let currentPolygonOffsetFactor = null;
        let currentPolygonOffsetUnits = null;
        const maxTextures = gl2.getParameter(gl2.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let lineWidthAvailable = false;
        let version = 0;
        const glVersion = gl2.getParameter(gl2.VERSION);
        if (glVersion.indexOf("WebGL") !== -1) {
          version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 1;
        } else if (glVersion.indexOf("OpenGL ES") !== -1) {
          version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 2;
        }
        let currentTextureSlot = null;
        let currentBoundTextures = {};
        const scissorParam = gl2.getParameter(gl2.SCISSOR_BOX);
        const viewportParam = gl2.getParameter(gl2.VIEWPORT);
        const currentScissor = new Vector4().fromArray(scissorParam);
        const currentViewport = new Vector4().fromArray(viewportParam);
        function createTexture(type, target, count) {
          const data = new Uint8Array(4);
          const texture = gl2.createTexture();
          gl2.bindTexture(type, texture);
          gl2.texParameteri(type, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
          gl2.texParameteri(type, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
          for (let i2 = 0; i2 < count; i2++) {
            gl2.texImage2D(target + i2, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
          }
          return texture;
        }
        const emptyTextures = {};
        emptyTextures[gl2.TEXTURE_2D] = createTexture(gl2.TEXTURE_2D, gl2.TEXTURE_2D, 1);
        emptyTextures[gl2.TEXTURE_CUBE_MAP] = createTexture(gl2.TEXTURE_CUBE_MAP, gl2.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(gl2.DEPTH_TEST);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(gl2.CULL_FACE);
        setBlending(NoBlending);
        function enable(id2) {
          if (enabledCapabilities[id2] !== true) {
            gl2.enable(id2);
            enabledCapabilities[id2] = true;
          }
        }
        function disable(id2) {
          if (enabledCapabilities[id2] !== false) {
            gl2.disable(id2);
            enabledCapabilities[id2] = false;
          }
        }
        function bindFramebuffer(target, framebuffer) {
          if (currentBoundFramebuffers[target] !== framebuffer) {
            gl2.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
              if (target === gl2.DRAW_FRAMEBUFFER) {
                currentBoundFramebuffers[gl2.FRAMEBUFFER] = framebuffer;
              }
              if (target === gl2.FRAMEBUFFER) {
                currentBoundFramebuffers[gl2.DRAW_FRAMEBUFFER] = framebuffer;
              }
            }
            return true;
          }
          return false;
        }
        function drawBuffers(renderTarget, framebuffer) {
          let drawBuffers2 = defaultDrawbuffers;
          let needsUpdate = false;
          if (renderTarget) {
            drawBuffers2 = currentDrawbuffers.get(framebuffer);
            if (drawBuffers2 === void 0) {
              drawBuffers2 = [];
              currentDrawbuffers.set(framebuffer, drawBuffers2);
            }
            if (renderTarget.isWebGLMultipleRenderTargets) {
              const textures = renderTarget.texture;
              if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl2.COLOR_ATTACHMENT0) {
                for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
                  drawBuffers2[i2] = gl2.COLOR_ATTACHMENT0 + i2;
                }
                drawBuffers2.length = textures.length;
                needsUpdate = true;
              }
            } else {
              if (drawBuffers2[0] !== gl2.COLOR_ATTACHMENT0) {
                drawBuffers2[0] = gl2.COLOR_ATTACHMENT0;
                needsUpdate = true;
              }
            }
          } else {
            if (drawBuffers2[0] !== gl2.BACK) {
              drawBuffers2[0] = gl2.BACK;
              needsUpdate = true;
            }
          }
          if (needsUpdate) {
            if (capabilities.isWebGL2) {
              gl2.drawBuffers(drawBuffers2);
            } else {
              extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
            }
          }
        }
        function useProgram(program) {
          if (currentProgram !== program) {
            gl2.useProgram(program);
            currentProgram = program;
            return true;
          }
          return false;
        }
        const equationToGL = {
          [AddEquation]: gl2.FUNC_ADD,
          [SubtractEquation]: gl2.FUNC_SUBTRACT,
          [ReverseSubtractEquation]: gl2.FUNC_REVERSE_SUBTRACT
        };
        if (isWebGL2) {
          equationToGL[MinEquation] = gl2.MIN;
          equationToGL[MaxEquation] = gl2.MAX;
        } else {
          const extension = extensions.get("EXT_blend_minmax");
          if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
          }
        }
        const factorToGL = {
          [ZeroFactor]: gl2.ZERO,
          [OneFactor]: gl2.ONE,
          [SrcColorFactor]: gl2.SRC_COLOR,
          [SrcAlphaFactor]: gl2.SRC_ALPHA,
          [SrcAlphaSaturateFactor]: gl2.SRC_ALPHA_SATURATE,
          [DstColorFactor]: gl2.DST_COLOR,
          [DstAlphaFactor]: gl2.DST_ALPHA,
          [OneMinusSrcColorFactor]: gl2.ONE_MINUS_SRC_COLOR,
          [OneMinusSrcAlphaFactor]: gl2.ONE_MINUS_SRC_ALPHA,
          [OneMinusDstColorFactor]: gl2.ONE_MINUS_DST_COLOR,
          [OneMinusDstAlphaFactor]: gl2.ONE_MINUS_DST_ALPHA
        };
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
          if (blending === NoBlending) {
            if (currentBlendingEnabled === true) {
              disable(gl2.BLEND);
              currentBlendingEnabled = false;
            }
            return;
          }
          if (currentBlendingEnabled === false) {
            enable(gl2.BLEND);
            currentBlendingEnabled = true;
          }
          if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
              if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                gl2.blendEquation(gl2.FUNC_ADD);
                currentBlendEquation = AddEquation;
                currentBlendEquationAlpha = AddEquation;
              }
              if (premultipliedAlpha) {
                switch (blending) {
                  case NormalBlending:
                    gl2.blendFuncSeparate(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending:
                    gl2.blendFunc(gl2.ONE, gl2.ONE);
                    break;
                  case SubtractiveBlending:
                    gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
                    break;
                  case MultiplyBlending:
                    gl2.blendFuncSeparate(gl2.ZERO, gl2.SRC_COLOR, gl2.ZERO, gl2.SRC_ALPHA);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              } else {
                switch (blending) {
                  case NormalBlending:
                    gl2.blendFuncSeparate(gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending:
                    gl2.blendFunc(gl2.SRC_ALPHA, gl2.ONE);
                    break;
                  case SubtractiveBlending:
                    gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
                    break;
                  case MultiplyBlending:
                    gl2.blendFunc(gl2.ZERO, gl2.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              }
              currentBlendSrc = null;
              currentBlendDst = null;
              currentBlendSrcAlpha = null;
              currentBlendDstAlpha = null;
              currentBlending = blending;
              currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
          }
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl2.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl2.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
          currentBlending = blending;
          currentPremultipledAlpha = null;
        }
        function setMaterial(material, frontFaceCW) {
          material.side === DoubleSide ? disable(gl2.CULL_FACE) : enable(gl2.CULL_FACE);
          let flipSided = material.side === BackSide;
          if (frontFaceCW)
            flipSided = !flipSided;
          setFlipSided(flipSided);
          material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
          depthBuffer.setFunc(material.depthFunc);
          depthBuffer.setTest(material.depthTest);
          depthBuffer.setMask(material.depthWrite);
          colorBuffer.setMask(material.colorWrite);
          const stencilWrite = material.stencilWrite;
          stencilBuffer.setTest(stencilWrite);
          if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
          }
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
          material.alphaToCoverage === true ? enable(gl2.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function setFlipSided(flipSided) {
          if (currentFlipSided !== flipSided) {
            if (flipSided) {
              gl2.frontFace(gl2.CW);
            } else {
              gl2.frontFace(gl2.CCW);
            }
            currentFlipSided = flipSided;
          }
        }
        function setCullFace(cullFace) {
          if (cullFace !== CullFaceNone) {
            enable(gl2.CULL_FACE);
            if (cullFace !== currentCullFace) {
              if (cullFace === CullFaceBack) {
                gl2.cullFace(gl2.BACK);
              } else if (cullFace === CullFaceFront) {
                gl2.cullFace(gl2.FRONT);
              } else {
                gl2.cullFace(gl2.FRONT_AND_BACK);
              }
            }
          } else {
            disable(gl2.CULL_FACE);
          }
          currentCullFace = cullFace;
        }
        function setLineWidth(width) {
          if (width !== currentLineWidth) {
            if (lineWidthAvailable)
              gl2.lineWidth(width);
            currentLineWidth = width;
          }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
          if (polygonOffset) {
            enable(gl2.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
              gl2.polygonOffset(factor, units);
              currentPolygonOffsetFactor = factor;
              currentPolygonOffsetUnits = units;
            }
          } else {
            disable(gl2.POLYGON_OFFSET_FILL);
          }
        }
        function setScissorTest(scissorTest) {
          if (scissorTest) {
            enable(gl2.SCISSOR_TEST);
          } else {
            disable(gl2.SCISSOR_TEST);
          }
        }
        function activeTexture(webglSlot) {
          if (webglSlot === void 0)
            webglSlot = gl2.TEXTURE0 + maxTextures - 1;
          if (currentTextureSlot !== webglSlot) {
            gl2.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
          }
        }
        function bindTexture(webglType, webglTexture) {
          if (currentTextureSlot === null) {
            activeTexture();
          }
          let boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture === void 0) {
            boundTexture = {
              type: void 0,
              texture: void 0
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
          }
          if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl2.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
          }
        }
        function unbindTexture() {
          const boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture !== void 0 && boundTexture.type !== void 0) {
            gl2.bindTexture(boundTexture.type, null);
            boundTexture.type = void 0;
            boundTexture.texture = void 0;
          }
        }
        function compressedTexImage2D() {
          try {
            gl2.compressedTexImage2D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texSubImage2D() {
          try {
            gl2.texSubImage2D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texSubImage3D() {
          try {
            gl2.texSubImage3D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function compressedTexSubImage2D() {
          try {
            gl2.compressedTexSubImage2D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texStorage2D() {
          try {
            gl2.texStorage2D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texStorage3D() {
          try {
            gl2.texStorage3D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texImage2D() {
          try {
            gl2.texImage2D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texImage3D() {
          try {
            gl2.texImage3D.apply(gl2, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function scissor(scissor2) {
          if (currentScissor.equals(scissor2) === false) {
            gl2.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
            currentScissor.copy(scissor2);
          }
        }
        function viewport(viewport2) {
          if (currentViewport.equals(viewport2) === false) {
            gl2.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
            currentViewport.copy(viewport2);
          }
        }
        function reset() {
          gl2.disable(gl2.BLEND);
          gl2.disable(gl2.CULL_FACE);
          gl2.disable(gl2.DEPTH_TEST);
          gl2.disable(gl2.POLYGON_OFFSET_FILL);
          gl2.disable(gl2.SCISSOR_TEST);
          gl2.disable(gl2.STENCIL_TEST);
          gl2.disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
          gl2.blendEquation(gl2.FUNC_ADD);
          gl2.blendFunc(gl2.ONE, gl2.ZERO);
          gl2.blendFuncSeparate(gl2.ONE, gl2.ZERO, gl2.ONE, gl2.ZERO);
          gl2.colorMask(true, true, true, true);
          gl2.clearColor(0, 0, 0, 0);
          gl2.depthMask(true);
          gl2.depthFunc(gl2.LESS);
          gl2.clearDepth(1);
          gl2.stencilMask(4294967295);
          gl2.stencilFunc(gl2.ALWAYS, 0, 4294967295);
          gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.KEEP);
          gl2.clearStencil(0);
          gl2.cullFace(gl2.BACK);
          gl2.frontFace(gl2.CCW);
          gl2.polygonOffset(0, 0);
          gl2.activeTexture(gl2.TEXTURE0);
          gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
          if (isWebGL2 === true) {
            gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);
            gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, null);
          }
          gl2.useProgram(null);
          gl2.lineWidth(1);
          gl2.scissor(0, 0, gl2.canvas.width, gl2.canvas.height);
          gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
          enabledCapabilities = {};
          currentTextureSlot = null;
          currentBoundTextures = {};
          currentBoundFramebuffers = {};
          currentDrawbuffers = /* @__PURE__ */ new WeakMap();
          defaultDrawbuffers = [];
          currentProgram = null;
          currentBlendingEnabled = false;
          currentBlending = null;
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentPremultipledAlpha = false;
          currentFlipSided = null;
          currentCullFace = null;
          currentLineWidth = null;
          currentPolygonOffsetFactor = null;
          currentPolygonOffsetUnits = null;
          currentScissor.set(0, 0, gl2.canvas.width, gl2.canvas.height);
          currentViewport.set(0, 0, gl2.canvas.width, gl2.canvas.height);
          colorBuffer.reset();
          depthBuffer.reset();
          stencilBuffer.reset();
        }
        return {
          buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
          },
          enable,
          disable,
          bindFramebuffer,
          drawBuffers,
          useProgram,
          setBlending,
          setMaterial,
          setFlipSided,
          setCullFace,
          setLineWidth,
          setPolygonOffset,
          setScissorTest,
          activeTexture,
          bindTexture,
          unbindTexture,
          compressedTexImage2D,
          texImage2D,
          texImage3D,
          texStorage2D,
          texStorage3D,
          texSubImage2D,
          texSubImage3D,
          compressedTexSubImage2D,
          scissor,
          viewport,
          reset
        };
      }
      function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
        const isWebGL2 = capabilities.isWebGL2;
        const maxTextures = capabilities.maxTextures;
        const maxCubemapSize = capabilities.maxCubemapSize;
        const maxTextureSize = capabilities.maxTextureSize;
        const maxSamples = capabilities.maxSamples;
        const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
        const _videoTextures = /* @__PURE__ */ new WeakMap();
        let _canvas2;
        const _sources = /* @__PURE__ */ new WeakMap();
        let useOffscreenCanvas = false;
        try {
          useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch (err) {
        }
        function createCanvas(width, height) {
          return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
        }
        function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
          let scale = 1;
          if (image.width > maxSize || image.height > maxSize) {
            scale = maxSize / Math.max(image.width, image.height);
          }
          if (scale < 1 || needsPowerOfTwo === true) {
            if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
              const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
              const width = floor(scale * image.width);
              const height = floor(scale * image.height);
              if (_canvas2 === void 0)
                _canvas2 = createCanvas(width, height);
              const canvas2 = needsNewCanvas ? createCanvas(width, height) : _canvas2;
              canvas2.width = width;
              canvas2.height = height;
              const context = canvas2.getContext("2d");
              context.drawImage(image, 0, 0, width, height);
              console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
              return canvas2;
            } else {
              if ("data" in image) {
                console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
              }
              return image;
            }
          }
          return image;
        }
        function isPowerOfTwo$1(image) {
          return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
        }
        function textureNeedsPowerOfTwo(texture) {
          if (isWebGL2)
            return false;
          return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function textureNeedsGenerateMipmaps(texture, supportsMips) {
          return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function generateMipmap(target) {
          _gl.generateMipmap(target);
        }
        function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
          if (isWebGL2 === false)
            return glFormat;
          if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== void 0)
              return _gl[internalFormatName];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
          }
          let internalFormat = glFormat;
          if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.R8;
          }
          if (glFormat === _gl.RG) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RG32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RG16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.RG8;
          }
          if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
            if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
              internalFormat = _gl.RGBA4;
            if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
              internalFormat = _gl.RGB5_A1;
          }
          if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
            extensions.get("EXT_color_buffer_float");
          }
          return internalFormat;
        }
        function getMipLevels(texture, image, supportsMips) {
          if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
            return Math.log2(Math.max(image.width, image.height)) + 1;
          } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
            return texture.mipmaps.length;
          } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
            return image.mipmaps.length;
          } else {
            return 1;
          }
        }
        function filterFallback(f) {
          if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
            return _gl.NEAREST;
          }
          return _gl.LINEAR;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          deallocateTexture(texture);
          if (texture.isVideoTexture) {
            _videoTextures.delete(texture);
          }
        }
        function onRenderTargetDispose(event) {
          const renderTarget = event.target;
          renderTarget.removeEventListener("dispose", onRenderTargetDispose);
          deallocateRenderTarget(renderTarget);
        }
        function deallocateTexture(texture) {
          const textureProperties = properties.get(texture);
          if (textureProperties.__webglInit === void 0)
            return;
          const source = texture.source;
          const webglTextures = _sources.get(source);
          if (webglTextures) {
            const webglTexture = webglTextures[textureProperties.__cacheKey];
            webglTexture.usedTimes--;
            if (webglTexture.usedTimes === 0) {
              deleteTexture(texture);
            }
            if (Object.keys(webglTextures).length === 0) {
              _sources.delete(source);
            }
          }
          properties.remove(texture);
        }
        function deleteTexture(texture) {
          const textureProperties = properties.get(texture);
          _gl.deleteTexture(textureProperties.__webglTexture);
          const source = texture.source;
          const webglTextures = _sources.get(source);
          delete webglTextures[textureProperties.__cacheKey];
          info.memory.textures--;
        }
        function deallocateRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          if (textureProperties.__webglTexture !== void 0) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
          }
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
          }
          if (renderTarget.isWebGLCubeRenderTarget) {
            for (let i2 = 0; i2 < 6; i2++) {
              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
              if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
            }
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer)
              _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
          }
          if (renderTarget.isWebGLMultipleRenderTargets) {
            for (let i2 = 0, il2 = texture.length; i2 < il2; i2++) {
              const attachmentProperties = properties.get(texture[i2]);
              if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
              }
              properties.remove(texture[i2]);
            }
          }
          properties.remove(texture);
          properties.remove(renderTarget);
        }
        let textureUnits = 0;
        function resetTextureUnits() {
          textureUnits = 0;
        }
        function allocateTextureUnit() {
          const textureUnit = textureUnits;
          if (textureUnit >= maxTextures) {
            console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
          }
          textureUnits += 1;
          return textureUnit;
        }
        function getTextureCacheKey(texture) {
          const array = [];
          array.push(texture.wrapS);
          array.push(texture.wrapT);
          array.push(texture.magFilter);
          array.push(texture.minFilter);
          array.push(texture.anisotropy);
          array.push(texture.internalFormat);
          array.push(texture.format);
          array.push(texture.type);
          array.push(texture.generateMipmaps);
          array.push(texture.premultiplyAlpha);
          array.push(texture.flipY);
          array.push(texture.unpackAlignment);
          array.push(texture.encoding);
          return array.join();
        }
        function setTexture2D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.isVideoTexture)
            updateVideoTexture(texture);
          if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === null) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            } else if (image.complete === false) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            } else {
              uploadTexture(textureProperties, texture, slot);
              return;
            }
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTexture2DArray(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
        }
        function setTexture3D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        }
        const wrappingToGL = {
          [RepeatWrapping]: _gl.REPEAT,
          [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
          [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
        };
        const filterToGL = {
          [NearestFilter]: _gl.NEAREST,
          [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
          [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
          [LinearFilter]: _gl.LINEAR,
          [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
          [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
        };
        function setTextureParameters(textureType, texture, supportsMips) {
          if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
          } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            }
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
            }
          }
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
              return;
            if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false)
              return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
              _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
              properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
          }
        }
        function initTexture(textureProperties, texture) {
          let forceUpload = false;
          if (textureProperties.__webglInit === void 0) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
          }
          const source = texture.source;
          let webglTextures = _sources.get(source);
          if (webglTextures === void 0) {
            webglTextures = {};
            _sources.set(source, webglTextures);
          }
          const textureCacheKey = getTextureCacheKey(texture);
          if (textureCacheKey !== textureProperties.__cacheKey) {
            if (webglTextures[textureCacheKey] === void 0) {
              webglTextures[textureCacheKey] = {
                texture: _gl.createTexture(),
                usedTimes: 0
              };
              info.memory.textures++;
              forceUpload = true;
            }
            webglTextures[textureCacheKey].usedTimes++;
            const webglTexture = webglTextures[textureProperties.__cacheKey];
            if (webglTexture !== void 0) {
              webglTextures[textureProperties.__cacheKey].usedTimes--;
              if (webglTexture.usedTimes === 0) {
                deleteTexture(texture);
              }
            }
            textureProperties.__cacheKey = textureCacheKey;
            textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
          }
          return forceUpload;
        }
        function uploadTexture(textureProperties, texture, slot) {
          let textureType = _gl.TEXTURE_2D;
          if (texture.isDataArrayTexture)
            textureType = _gl.TEXTURE_2D_ARRAY;
          if (texture.isData3DTexture)
            textureType = _gl.TEXTURE_3D;
          const forceUpload = initTexture(textureProperties, texture);
          const source = texture.source;
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(textureType, textureProperties.__webglTexture);
          if (source.version !== source.__currentVersion || forceUpload === true) {
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
            const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
            let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
            image = verifyColorSpace(texture, image);
            const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
            let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
            setTextureParameters(textureType, texture, supportsMips);
            let mipmap;
            const mipmaps = texture.mipmaps;
            const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
            const allocateMemory = textureProperties.__version === void 0;
            const levels = getMipLevels(texture, image, supportsMips);
            if (texture.isDepthTexture) {
              glInternalFormat = _gl.DEPTH_COMPONENT;
              if (isWebGL2) {
                if (texture.type === FloatType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (texture.type === UnsignedIntType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT24;
                } else if (texture.type === UnsignedInt248Type) {
                  glInternalFormat = _gl.DEPTH24_STENCIL8;
                } else {
                  glInternalFormat = _gl.DEPTH_COMPONENT16;
                }
              } else {
                if (texture.type === FloatType) {
                  console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
                }
              }
              if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                  console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                  texture.type = UnsignedShortType;
                  glType = utils.convert(texture.type);
                }
              }
              if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
                glInternalFormat = _gl.DEPTH_STENCIL;
                if (texture.type !== UnsignedInt248Type) {
                  console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                  texture.type = UnsignedInt248Type;
                  glType = utils.convert(texture.type);
                }
              }
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
              }
            } else if (texture.isDataTexture) {
              if (mipmaps.length > 0 && supportsMips) {
                if (useTexStorage && allocateMemory) {
                  state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                }
                for (let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++) {
                  mipmap = mipmaps[i2];
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
                texture.generateMipmaps = false;
              } else {
                if (useTexStorage) {
                  if (allocateMemory) {
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                  }
                  state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                }
              }
            } else if (texture.isCompressedTexture) {
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
              }
              for (let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++) {
                mipmap = mipmaps[i2];
                if (texture.format !== RGBAFormat) {
                  if (glFormat !== null) {
                    if (useTexStorage) {
                      state.compressedTexSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                    } else {
                      state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    }
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                  }
                } else {
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              }
            } else if (texture.isDataArrayTexture) {
              if (useTexStorage) {
                if (allocateMemory) {
                  state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
                }
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
              }
            } else if (texture.isData3DTexture) {
              if (useTexStorage) {
                if (allocateMemory) {
                  state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
                }
                state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
              } else {
                state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
              }
            } else if (texture.isFramebufferTexture) {
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
              }
            } else {
              if (mipmaps.length > 0 && supportsMips) {
                if (useTexStorage && allocateMemory) {
                  state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                }
                for (let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++) {
                  mipmap = mipmaps[i2];
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, glFormat, glType, mipmap);
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
                  }
                }
                texture.generateMipmaps = false;
              } else {
                if (useTexStorage) {
                  if (allocateMemory) {
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                  }
                  state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
                }
              }
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(textureType);
            }
            source.__currentVersion = source.version;
            if (texture.onUpdate)
              texture.onUpdate(texture);
          }
          textureProperties.__version = texture.version;
        }
        function uploadCubeTexture(textureProperties, texture, slot) {
          if (texture.image.length !== 6)
            return;
          const forceUpload = initTexture(textureProperties, texture);
          const source = texture.source;
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
          if (source.version !== source.__currentVersion || forceUpload === true) {
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
            const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
            const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            const cubeImage = [];
            for (let i2 = 0; i2 < 6; i2++) {
              if (!isCompressed && !isDataTexture) {
                cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
              } else {
                cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
              }
              cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
            }
            const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
            const allocateMemory = textureProperties.__version === void 0;
            let levels = getMipLevels(texture, image, supportsMips);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            let mipmaps;
            if (isCompressed) {
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
              }
              for (let i2 = 0; i2 < 6; i2++) {
                mipmaps = cubeImage[i2].mipmaps;
                for (let j2 = 0; j2 < mipmaps.length; j2++) {
                  const mipmap = mipmaps[j2];
                  if (texture.format !== RGBAFormat) {
                    if (glFormat !== null) {
                      if (useTexStorage) {
                        state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                      } else {
                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                      }
                    } else {
                      console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                    }
                  } else {
                    if (useTexStorage) {
                      state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                    } else {
                      state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                  }
                }
              }
            } else {
              mipmaps = texture.mipmaps;
              if (useTexStorage && allocateMemory) {
                if (mipmaps.length > 0)
                  levels++;
                state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
              }
              for (let i2 = 0; i2 < 6; i2++) {
                if (isDataTexture) {
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
                  }
                  for (let j2 = 0; j2 < mipmaps.length; j2++) {
                    const mipmap = mipmaps[j2];
                    const mipmapImage = mipmap.image[i2].image;
                    if (useTexStorage) {
                      state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                    } else {
                      state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                  }
                } else {
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
                  }
                  for (let j2 = 0; j2 < mipmaps.length; j2++) {
                    const mipmap = mipmaps[j2];
                    if (useTexStorage) {
                      state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
                    } else {
                      state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
                    }
                  }
                }
              }
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            source.__currentVersion = source.version;
            if (texture.onUpdate)
              texture.onUpdate(texture);
          }
          textureProperties.__version = texture.version;
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
          const glFormat = utils.convert(texture.format, texture.encoding);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const renderTargetProperties = properties.get(renderTarget);
          if (!renderTargetProperties.__hasExternalTextures) {
            if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
              state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
            } else {
              state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            }
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
          } else {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample || useMultisampledRTT(renderTarget)) {
              const depthTexture = renderTarget.depthTexture;
              if (depthTexture && depthTexture.isDepthTexture) {
                if (depthTexture.type === FloatType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (depthTexture.type === UnsignedIntType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT24;
                }
              }
              const samples = getRenderTargetSamples(renderTarget);
              if (useMultisampledRTT(renderTarget)) {
                multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              } else {
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              }
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && useMultisampledRTT(renderTarget) === false) {
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else if (useMultisampledRTT(renderTarget)) {
              multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else {
            const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
            const glFormat = utils.convert(texture.format, texture.encoding);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && useMultisampledRTT(renderTarget) === false) {
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else if (useMultisampledRTT(renderTarget)) {
              multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
          const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
          if (isCube)
            throw new Error("Depth Texture with cube render targets is not supported");
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
          }
          setTexture2D(renderTarget.depthTexture, 0);
          const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
          const samples = getRenderTargetSamples(renderTarget);
          if (renderTarget.depthTexture.format === DepthFormat) {
            if (useMultisampledRTT(renderTarget)) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
            } else {
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
          } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
            if (useMultisampledRTT(renderTarget)) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
            } else {
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
          } else {
            throw new Error("Unknown depthTexture format");
          }
        }
        function setupDepthRenderbuffer(renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
            if (isCube)
              throw new Error("target.depthTexture not supported in Cube render targets");
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
          } else {
            if (isCube) {
              renderTargetProperties.__webglDepthbuffer = [];
              for (let i2 = 0; i2 < 6; i2++) {
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
                renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
              }
            } else {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
            }
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function rebindTextures(renderTarget, colorTexture, depthTexture) {
          const renderTargetProperties = properties.get(renderTarget);
          if (colorTexture !== void 0) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
          }
          if (depthTexture !== void 0) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function setupRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          renderTarget.addEventListener("dispose", onRenderTargetDispose);
          if (renderTarget.isWebGLMultipleRenderTargets !== true) {
            if (textureProperties.__webglTexture === void 0) {
              textureProperties.__webglTexture = _gl.createTexture();
            }
            textureProperties.__version = texture.version;
            info.memory.textures++;
          }
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for (let i2 = 0; i2 < 6; i2++) {
              renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
              if (capabilities.drawBuffers) {
                const textures = renderTarget.texture;
                for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
                  const attachmentProperties = properties.get(textures[i2]);
                  if (attachmentProperties.__webglTexture === void 0) {
                    attachmentProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                  }
                }
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
              }
            } else if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
              renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
              renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
              const glFormat = utils.convert(texture.format, texture.encoding);
              const glType = utils.convert(texture.type);
              const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
              const samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
              if (renderTarget.depthBuffer) {
                renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
              }
              state.bindFramebuffer(_gl.FRAMEBUFFER, null);
            }
          }
          if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            for (let i2 = 0; i2 < 6; i2++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2);
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            state.unbindTexture();
          } else if (isMultipleRenderTargets) {
            const textures = renderTarget.texture;
            for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
              const attachment = textures[i2];
              const attachmentProperties = properties.get(attachment);
              state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
              setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D);
              if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
                generateMipmap(_gl.TEXTURE_2D);
              }
            }
            state.unbindTexture();
          } else {
            let glTextureType = _gl.TEXTURE_2D;
            if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
              if (isWebGL2) {
                glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
              } else {
                console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
              }
            }
            state.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(glTextureType);
            }
            state.unbindTexture();
          }
          if (renderTarget.depthBuffer) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function updateRenderTargetMipmap(renderTarget) {
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
          for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
            const texture = textures[i2];
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
              const webglTexture = properties.get(texture).__webglTexture;
              state.bindTexture(target, webglTexture);
              generateMipmap(target);
              state.unbindTexture();
            }
          }
        }
        function updateMultisampleRenderTarget(renderTarget) {
          if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
            const width = renderTarget.width;
            const height = renderTarget.height;
            let mask = _gl.COLOR_BUFFER_BIT;
            const invalidationArray = [_gl.COLOR_ATTACHMENT0];
            const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            if (renderTarget.depthBuffer) {
              invalidationArray.push(depthStyle);
            }
            const renderTargetProperties = properties.get(renderTarget);
            const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
            if (ignoreDepthValues === false) {
              if (renderTarget.depthBuffer)
                mask |= _gl.DEPTH_BUFFER_BIT;
              if (renderTarget.stencilBuffer)
                mask |= _gl.STENCIL_BUFFER_BIT;
            }
            state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            if (ignoreDepthValues === true) {
              _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
            }
            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
            state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
            state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          }
        }
        function getRenderTargetSamples(renderTarget) {
          return Math.min(maxSamples, renderTarget.samples);
        }
        function useMultisampledRTT(renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
        }
        function updateVideoTexture(texture) {
          const frame = info.render.frame;
          if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
          }
        }
        function verifyColorSpace(texture, image) {
          const encoding = texture.encoding;
          const format = texture.format;
          const type = texture.type;
          if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
            return image;
          if (encoding !== LinearEncoding) {
            if (encoding === sRGBEncoding) {
              if (isWebGL2 === false) {
                if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
                  texture.format = _SRGBAFormat;
                  texture.minFilter = LinearFilter;
                  texture.generateMipmaps = false;
                } else {
                  image = ImageUtils.sRGBToLinear(image);
                }
              } else {
                if (format !== RGBAFormat || type !== UnsignedByteType) {
                  console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
                }
              }
            } else {
              console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
            }
          }
          return image;
        }
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.rebindTextures = rebindTextures;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.setupDepthRenderbuffer = setupDepthRenderbuffer;
        this.setupFrameBufferTexture = setupFrameBufferTexture;
        this.useMultisampledRTT = useMultisampledRTT;
      }
      function WebGLUtils(gl2, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function convert(p, encoding = null) {
          let extension;
          if (p === UnsignedByteType)
            return gl2.UNSIGNED_BYTE;
          if (p === UnsignedShort4444Type)
            return gl2.UNSIGNED_SHORT_4_4_4_4;
          if (p === UnsignedShort5551Type)
            return gl2.UNSIGNED_SHORT_5_5_5_1;
          if (p === ByteType)
            return gl2.BYTE;
          if (p === ShortType)
            return gl2.SHORT;
          if (p === UnsignedShortType)
            return gl2.UNSIGNED_SHORT;
          if (p === IntType)
            return gl2.INT;
          if (p === UnsignedIntType)
            return gl2.UNSIGNED_INT;
          if (p === FloatType)
            return gl2.FLOAT;
          if (p === HalfFloatType) {
            if (isWebGL2)
              return gl2.HALF_FLOAT;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) {
              return extension.HALF_FLOAT_OES;
            } else {
              return null;
            }
          }
          if (p === AlphaFormat)
            return gl2.ALPHA;
          if (p === RGBAFormat)
            return gl2.RGBA;
          if (p === LuminanceFormat)
            return gl2.LUMINANCE;
          if (p === LuminanceAlphaFormat)
            return gl2.LUMINANCE_ALPHA;
          if (p === DepthFormat)
            return gl2.DEPTH_COMPONENT;
          if (p === DepthStencilFormat)
            return gl2.DEPTH_STENCIL;
          if (p === RedFormat)
            return gl2.RED;
          if (p === RGBFormat) {
            console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
            return gl2.RGBA;
          }
          if (p === _SRGBAFormat) {
            extension = extensions.get("EXT_sRGB");
            if (extension !== null) {
              return extension.SRGB_ALPHA_EXT;
            } else {
              return null;
            }
          }
          if (p === RedIntegerFormat)
            return gl2.RED_INTEGER;
          if (p === RGFormat)
            return gl2.RG;
          if (p === RGIntegerFormat)
            return gl2.RG_INTEGER;
          if (p === RGBAIntegerFormat)
            return gl2.RGBA_INTEGER;
          if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            if (encoding === sRGBEncoding) {
              extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
              if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format)
                  return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format)
                  return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format)
                  return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format)
                  return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                return null;
              }
            } else {
              extension = extensions.get("WEBGL_compressed_texture_s3tc");
              if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format)
                  return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format)
                  return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format)
                  return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format)
                  return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              } else {
                return null;
              }
            }
          }
          if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
              if (p === RGB_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (p === RGB_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (p === RGBA_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (p === RGBA_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else {
              return null;
            }
          }
          if (p === RGB_ETC1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) {
              return extension.COMPRESSED_RGB_ETC1_WEBGL;
            } else {
              return null;
            }
          }
          if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc");
            if (extension !== null) {
              if (p === RGB_ETC2_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
              if (p === RGBA_ETC2_EAC_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
            } else {
              return null;
            }
          }
          if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) {
              if (p === RGBA_ASTC_4x4_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (p === RGBA_ASTC_5x4_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (p === RGBA_ASTC_5x5_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (p === RGBA_ASTC_6x5_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (p === RGBA_ASTC_6x6_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (p === RGBA_ASTC_8x5_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (p === RGBA_ASTC_8x6_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (p === RGBA_ASTC_8x8_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (p === RGBA_ASTC_10x5_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (p === RGBA_ASTC_10x6_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (p === RGBA_ASTC_10x8_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (p === RGBA_ASTC_10x10_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (p === RGBA_ASTC_12x10_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (p === RGBA_ASTC_12x12_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else {
              return null;
            }
          }
          if (p === RGBA_BPTC_Format) {
            extension = extensions.get("EXT_texture_compression_bptc");
            if (extension !== null) {
              if (p === RGBA_BPTC_Format)
                return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else {
              return null;
            }
          }
          if (p === UnsignedInt248Type) {
            if (isWebGL2)
              return gl2.UNSIGNED_INT_24_8;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) {
              return extension.UNSIGNED_INT_24_8_WEBGL;
            } else {
              return null;
            }
          }
        }
        return {
          convert
        };
      }
      var ArrayCamera = class extends PerspectiveCamera {
        constructor(array = []) {
          super();
          this.cameras = array;
        }
      };
      ArrayCamera.prototype.isArrayCamera = true;
      var Group = class extends Object3D {
        constructor() {
          super();
          this.type = "Group";
        }
      };
      Group.prototype.isGroup = true;
      var _moveEvent = {
        type: "move"
      };
      var WebXRController = class {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
              pinching: false
            };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector3();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector3();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector3();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector3();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({
            type: "disconnected",
            data: inputSource
          });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent);
              }
            }
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                if (hand.joints[inputjoint.jointName] === void 0) {
                  const joint2 = new Group();
                  joint2.matrixAutoUpdate = false;
                  joint2.visible = false;
                  hand.joints[inputjoint.jointName] = joint2;
                  hand.add(joint2);
                }
                const joint = hand.joints[inputjoint.jointName];
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
      };
      var DepthTexture = class extends Texture {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
          format = format !== void 0 ? format : DepthFormat;
          if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type === void 0 && format === DepthFormat)
            type = UnsignedShortType;
          if (type === void 0 && format === DepthStencilFormat)
            type = UnsignedInt248Type;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.image = {
            width,
            height
          };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      DepthTexture.prototype.isDepthTexture = true;
      var WebXRManager = class extends EventDispatcher {
        constructor(renderer, gl2) {
          super();
          const scope = this;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          let pose = null;
          let glBinding = null;
          let glProjLayer = null;
          let glBaseLayer = null;
          let xrFrame = null;
          const attributes = gl2.getContextAttributes();
          let initialRenderTarget = null;
          let newRenderTarget = null;
          const controllers = [];
          const inputSourcesMap = /* @__PURE__ */ new Map();
          const cameraL = new PerspectiveCamera();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector4();
          const cameraR = new PerspectiveCamera();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector4();
          const cameras = [cameraL, cameraR];
          const cameraVR = new ArrayCamera();
          cameraVR.layers.enable(1);
          cameraVR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) {
              controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
              });
            }
          }
          function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
              controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return referenceSpace;
          };
          this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
          };
          this.getBinding = function() {
            return glBinding;
          };
          this.getFrame = function() {
            return xrFrame;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                await gl2.makeXRCompatible();
              }
              if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
                const layerInit = {
                  antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
                session.updateRenderState({
                  baseLayer: glBaseLayer
                });
                newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  encoding: renderer.outputEncoding
                });
              } else {
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? gl2.DEPTH24_STENCIL8 : gl2.DEPTH_COMPONENT24;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
                }
                const projectionlayerInit = {
                  colorFormat: renderer.outputEncoding === sRGBEncoding ? gl2.SRGB8_ALPHA8 : gl2.RGBA8,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl2);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({
                  layers: [glProjLayer]
                });
                newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                  stencilBuffer: attributes.stencil,
                  encoding: renderer.outputEncoding,
                  samples: attributes.antialias ? 4 : 0
                });
                const renderTargetProperties = renderer.properties.get(newRenderTarget);
                renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
              }
              newRenderTarget.isXRRenderTarget = true;
              this.setFoveation(1);
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({
                type: "sessionstart"
              });
            }
          };
          function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              inputSourcesMap.set(inputSources[i2], controllers[i2]);
            }
            for (let i2 = 0; i2 < event.removed.length; i2++) {
              const inputSource = event.removed[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "disconnected",
                  data: inputSource
                });
                inputSourcesMap.delete(inputSource);
              }
            }
            for (let i2 = 0; i2 < event.added.length; i2++) {
              const inputSource = event.added[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "connected",
                  data: inputSource
                });
              }
            }
          }
          const cameraLPos = new Vector3();
          const cameraRPos = new Vector3();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
              session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
              });
              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (let i2 = 0; i2 < cameras2.length; i2++) {
              updateCamera(cameras2[i2], parent);
            }
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
              children[i2].updateMatrixWorld(true);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraVR, cameraL, cameraR);
            } else {
              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
          };
          this.getCamera = function() {
            return cameraVR;
          };
          this.getFoveation = function() {
            if (glProjLayer !== null) {
              return glProjLayer.fixedFoveation;
            }
            if (glBaseLayer !== null) {
              return glBaseLayer.fixedFoveation;
            }
            return void 0;
          };
          this.setFoveation = function(foveation) {
            if (glProjLayer !== null) {
              glProjLayer.fixedFoveation = foveation;
            }
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
              glBaseLayer.fixedFoveation = foveation;
            }
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
              const views = pose.views;
              if (glBaseLayer !== null) {
                renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                renderer.setRenderTarget(newRenderTarget);
              }
              let cameraVRNeedsUpdate = false;
              if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
              }
              for (let i2 = 0; i2 < views.length; i2++) {
                const view = views[i2];
                let viewport = null;
                if (glBaseLayer !== null) {
                  viewport = glBaseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  viewport = glSubImage.viewport;
                  if (i2 === 0) {
                    renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
                    renderer.setRenderTarget(newRenderTarget);
                  }
                }
                const camera = cameras[i2];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i2 === 0) {
                  cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                  cameraVR.cameras.push(camera);
                }
              }
            }
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              const controller = controllers[i2];
              const inputSource = inputSources[i2];
              controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time, frame);
            xrFrame = null;
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      };
      function WebGLMaterials(properties) {
        function refreshFogUniforms(uniforms, fog) {
          uniforms.fogColor.value.copy(fog.color);
          if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
          } else if (fog.isFogExp2) {
            uniforms.fogDensity.value = fog.density;
          }
        }
        function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
          if (material.isMeshBasicMaterial) {
            refreshUniformsCommon(uniforms, material);
          } else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
          } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
          } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
          } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) {
              refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
            } else {
              refreshUniformsStandard(uniforms, material);
            }
          } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
          } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
          } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
          } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
          } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) {
              refreshUniformsDash(uniforms, material);
            }
          } else if (material.isPointsMaterial) {
            refreshUniformsPoints(uniforms, material, pixelRatio, height);
          } else if (material.isSpriteMaterial) {
            refreshUniformsSprites(uniforms, material);
          } else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
          } else if (material.isShaderMaterial) {
            material.uniformsNeedUpdate = false;
          }
        }
        function refreshUniformsCommon(uniforms, material) {
          uniforms.opacity.value = material.opacity;
          if (material.color) {
            uniforms.diffuse.value.copy(material.color);
          }
          if (material.emissive) {
            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
          }
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.specularMap) {
            uniforms.specularMap.value = material.specularMap;
          }
          if (material.alphaTest > 0) {
            uniforms.alphaTest.value = material.alphaTest;
          }
          const envMap = properties.get(material).envMap;
          if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.ior.value = material.ior;
            uniforms.refractionRatio.value = material.refractionRatio;
          }
          if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
          }
          if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.specularMap) {
            uvScaleMap = material.specularMap;
          } else if (material.displacementMap) {
            uvScaleMap = material.displacementMap;
          } else if (material.normalMap) {
            uvScaleMap = material.normalMap;
          } else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
          } else if (material.roughnessMap) {
            uvScaleMap = material.roughnessMap;
          } else if (material.metalnessMap) {
            uvScaleMap = material.metalnessMap;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          } else if (material.emissiveMap) {
            uvScaleMap = material.emissiveMap;
          } else if (material.clearcoatMap) {
            uvScaleMap = material.clearcoatMap;
          } else if (material.clearcoatNormalMap) {
            uvScaleMap = material.clearcoatNormalMap;
          } else if (material.clearcoatRoughnessMap) {
            uvScaleMap = material.clearcoatRoughnessMap;
          } else if (material.specularIntensityMap) {
            uvScaleMap = material.specularIntensityMap;
          } else if (material.specularColorMap) {
            uvScaleMap = material.specularColorMap;
          } else if (material.transmissionMap) {
            uvScaleMap = material.transmissionMap;
          } else if (material.thicknessMap) {
            uvScaleMap = material.thicknessMap;
          } else if (material.sheenColorMap) {
            uvScaleMap = material.sheenColorMap;
          } else if (material.sheenRoughnessMap) {
            uvScaleMap = material.sheenRoughnessMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.isWebGLRenderTarget) {
              uvScaleMap = uvScaleMap.texture;
            }
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
          let uv2ScaleMap;
          if (material.aoMap) {
            uv2ScaleMap = material.aoMap;
          } else if (material.lightMap) {
            uv2ScaleMap = material.lightMap;
          }
          if (uv2ScaleMap !== void 0) {
            if (uv2ScaleMap.isWebGLRenderTarget) {
              uv2ScaleMap = uv2ScaleMap.texture;
            }
            if (uv2ScaleMap.matrixAutoUpdate === true) {
              uv2ScaleMap.updateMatrix();
            }
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
          }
        }
        function refreshUniformsLine(uniforms, material) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
          uniforms.dashSize.value = material.dashSize;
          uniforms.totalSize.value = material.dashSize + material.gapSize;
          uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.size.value = material.size * pixelRatio;
          uniforms.scale.value = height * 0.5;
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.alphaTest > 0) {
            uniforms.alphaTest.value = material.alphaTest;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsSprites(uniforms, material) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.rotation.value = material.rotation;
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.alphaTest > 0) {
            uniforms.alphaTest.value = material.alphaTest;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsLambert(uniforms, material) {
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
        }
        function refreshUniformsPhong(uniforms, material) {
          uniforms.specular.value.copy(material.specular);
          uniforms.shininess.value = Math.max(material.shininess, 1e-4);
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsToon(uniforms, material) {
          if (material.gradientMap) {
            uniforms.gradientMap.value = material.gradientMap;
          }
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsStandard(uniforms, material) {
          uniforms.roughness.value = material.roughness;
          uniforms.metalness.value = material.metalness;
          if (material.roughnessMap) {
            uniforms.roughnessMap.value = material.roughnessMap;
          }
          if (material.metalnessMap) {
            uniforms.metalnessMap.value = material.metalnessMap;
          }
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
          const envMap = properties.get(material).envMap;
          if (envMap) {
            uniforms.envMapIntensity.value = material.envMapIntensity;
          }
        }
        function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
          refreshUniformsStandard(uniforms, material);
          uniforms.ior.value = material.ior;
          if (material.sheen > 0) {
            uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
            uniforms.sheenRoughness.value = material.sheenRoughness;
            if (material.sheenColorMap) {
              uniforms.sheenColorMap.value = material.sheenColorMap;
            }
            if (material.sheenRoughnessMap) {
              uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
            }
          }
          if (material.clearcoat > 0) {
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if (material.clearcoatMap) {
              uniforms.clearcoatMap.value = material.clearcoatMap;
            }
            if (material.clearcoatRoughnessMap) {
              uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
            }
            if (material.clearcoatNormalMap) {
              uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
              uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
              if (material.side === BackSide) {
                uniforms.clearcoatNormalScale.value.negate();
              }
            }
          }
          if (material.transmission > 0) {
            uniforms.transmission.value = material.transmission;
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
            if (material.transmissionMap) {
              uniforms.transmissionMap.value = material.transmissionMap;
            }
            uniforms.thickness.value = material.thickness;
            if (material.thicknessMap) {
              uniforms.thicknessMap.value = material.thicknessMap;
            }
            uniforms.attenuationDistance.value = material.attenuationDistance;
            uniforms.attenuationColor.value.copy(material.attenuationColor);
          }
          uniforms.specularIntensity.value = material.specularIntensity;
          uniforms.specularColor.value.copy(material.specularColor);
          if (material.specularIntensityMap) {
            uniforms.specularIntensityMap.value = material.specularIntensityMap;
          }
          if (material.specularColorMap) {
            uniforms.specularColorMap.value = material.specularColorMap;
          }
        }
        function refreshUniformsMatcap(uniforms, material) {
          if (material.matcap) {
            uniforms.matcap.value = material.matcap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsDepth(uniforms, material) {
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsDistance(uniforms, material) {
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
          uniforms.referencePosition.value.copy(material.referencePosition);
          uniforms.nearDistance.value = material.nearDistance;
          uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        return {
          refreshFogUniforms,
          refreshMaterialUniforms
        };
      }
      function createCanvasElement() {
        const canvas2 = createElementNS("canvas");
        canvas2.style.display = "block";
        return canvas2;
      }
      function WebGLRenderer(parameters = {}) {
        const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
        let _alpha;
        if (parameters.context !== void 0) {
          _alpha = _context2.getContextAttributes().alpha;
        } else {
          _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
        }
        let currentRenderList = null;
        let currentRenderState = null;
        const renderListStack = [];
        const renderStateStack = [];
        this.domElement = _canvas2;
        this.debug = {
          checkShaderErrors: true
        };
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.outputEncoding = LinearEncoding;
        this.physicallyCorrectLights = false;
        this.toneMapping = NoToneMapping;
        this.toneMappingExposure = 1;
        const _this = this;
        let _isContextLost = false;
        let _currentActiveCubeFace = 0;
        let _currentActiveMipmapLevel = 0;
        let _currentRenderTarget = null;
        let _currentMaterialId = -1;
        let _currentCamera = null;
        const _currentViewport = new Vector4();
        const _currentScissor = new Vector4();
        let _currentScissorTest = null;
        let _width = _canvas2.width;
        let _height = _canvas2.height;
        let _pixelRatio = 1;
        let _opaqueSort = null;
        let _transparentSort = null;
        const _viewport = new Vector4(0, 0, _width, _height);
        const _scissor = new Vector4(0, 0, _width, _height);
        let _scissorTest = false;
        const _frustum = new Frustum();
        let _clippingEnabled = false;
        let _localClippingEnabled = false;
        let _transmissionRenderTarget = null;
        const _projScreenMatrix2 = new Matrix4();
        const _vector22 = new Vector2();
        const _vector3 = new Vector3();
        const _emptyScene = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: true
        };
        function getTargetPixelRatio() {
          return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        let _gl = _context2;
        function getContext(contextNames, contextAttributes) {
          for (let i2 = 0; i2 < contextNames.length; i2++) {
            const contextName = contextNames[i2];
            const context = _canvas2.getContext(contextName, contextAttributes);
            if (context !== null)
              return context;
          }
          return null;
        }
        try {
          const contextAttributes = {
            alpha: true,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
          };
          if ("setAttribute" in _canvas2)
            _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
          _canvas2.addEventListener("webglcontextlost", onContextLost, false);
          _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
          if (_gl === null) {
            const contextNames = ["webgl2", "webgl", "experimental-webgl"];
            if (_this.isWebGL1Renderer === true) {
              contextNames.shift();
            }
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
              if (getContext(contextNames)) {
                throw new Error("Error creating WebGL context with your selected attributes.");
              } else {
                throw new Error("Error creating WebGL context.");
              }
            }
          }
          if (_gl.getShaderPrecisionFormat === void 0) {
            _gl.getShaderPrecisionFormat = function() {
              return {
                "rangeMin": 1,
                "rangeMax": 1,
                "precision": 1
              };
            };
          }
        } catch (error) {
          console.error("THREE.WebGLRenderer: " + error.message);
          throw error;
        }
        let extensions, capabilities, state, info;
        let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
        let programCache, materials, renderLists, renderStates, clipping, shadowMap;
        let background, morphtargets, bufferRenderer, indexedBufferRenderer;
        let utils, bindingStates;
        function initGLContext() {
          extensions = new WebGLExtensions(_gl);
          capabilities = new WebGLCapabilities(_gl, extensions, parameters);
          extensions.init(capabilities);
          utils = new WebGLUtils(_gl, extensions, capabilities);
          state = new WebGLState(_gl, extensions, capabilities);
          info = new WebGLInfo(_gl);
          properties = new WebGLProperties();
          textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
          cubemaps = new WebGLCubeMaps(_this);
          cubeuvmaps = new WebGLCubeUVMaps(_this);
          attributes = new WebGLAttributes(_gl, capabilities);
          bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
          geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
          objects = new WebGLObjects(_gl, geometries, attributes, info);
          morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
          clipping = new WebGLClipping(properties);
          programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
          materials = new WebGLMaterials(properties);
          renderLists = new WebGLRenderLists();
          renderStates = new WebGLRenderStates(extensions, capabilities);
          background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
          shadowMap = new WebGLShadowMap(_this, objects, capabilities);
          bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
          indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
          info.programs = programCache.programs;
          _this.capabilities = capabilities;
          _this.extensions = extensions;
          _this.properties = properties;
          _this.renderLists = renderLists;
          _this.shadowMap = shadowMap;
          _this.state = state;
          _this.info = info;
        }
        initGLContext();
        const xr2 = new WebXRManager(_this, _gl);
        this.xr = xr2;
        this.getContext = function() {
          return _gl;
        };
        this.getContextAttributes = function() {
          return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.loseContext();
        };
        this.forceContextRestore = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.restoreContext();
        };
        this.getPixelRatio = function() {
          return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
          if (value === void 0)
            return;
          _pixelRatio = value;
          this.setSize(_width, _height, false);
        };
        this.getSize = function(target) {
          return target.set(_width, _height);
        };
        this.setSize = function(width, height, updateStyle) {
          if (xr2.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
          }
          _width = width;
          _height = height;
          _canvas2.width = Math.floor(width * _pixelRatio);
          _canvas2.height = Math.floor(height * _pixelRatio);
          if (updateStyle !== false) {
            _canvas2.style.width = width + "px";
            _canvas2.style.height = height + "px";
          }
          this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function(target) {
          return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
          _width = width;
          _height = height;
          _pixelRatio = pixelRatio;
          _canvas2.width = Math.floor(width * pixelRatio);
          _canvas2.height = Math.floor(height * pixelRatio);
          this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function(target) {
          return target.copy(_currentViewport);
        };
        this.getViewport = function(target) {
          return target.copy(_viewport);
        };
        this.setViewport = function(x2, y2, width, height) {
          if (x2.isVector4) {
            _viewport.set(x2.x, x2.y, x2.z, x2.w);
          } else {
            _viewport.set(x2, y2, width, height);
          }
          state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissor = function(target) {
          return target.copy(_scissor);
        };
        this.setScissor = function(x2, y2, width, height) {
          if (x2.isVector4) {
            _scissor.set(x2.x, x2.y, x2.z, x2.w);
          } else {
            _scissor.set(x2, y2, width, height);
          }
          state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissorTest = function() {
          return _scissorTest;
        };
        this.setScissorTest = function(boolean) {
          state.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function(method) {
          _opaqueSort = method;
        };
        this.setTransparentSort = function(method) {
          _transparentSort = method;
        };
        this.getClearColor = function(target) {
          return target.copy(background.getClearColor());
        };
        this.setClearColor = function() {
          background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
          return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
          background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color = true, depth = true, stencil = true) {
          let bits = 0;
          if (color)
            bits |= _gl.COLOR_BUFFER_BIT;
          if (depth)
            bits |= _gl.DEPTH_BUFFER_BIT;
          if (stencil)
            bits |= _gl.STENCIL_BUFFER_BIT;
          _gl.clear(bits);
        };
        this.clearColor = function() {
          this.clear(true, false, false);
        };
        this.clearDepth = function() {
          this.clear(false, true, false);
        };
        this.clearStencil = function() {
          this.clear(false, false, true);
        };
        this.dispose = function() {
          _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
          _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
          renderLists.dispose();
          renderStates.dispose();
          properties.dispose();
          cubemaps.dispose();
          cubeuvmaps.dispose();
          objects.dispose();
          bindingStates.dispose();
          programCache.dispose();
          xr2.dispose();
          xr2.removeEventListener("sessionstart", onXRSessionStart);
          xr2.removeEventListener("sessionend", onXRSessionEnd);
          if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
          }
          animation.stop();
        };
        function onContextLost(event) {
          event.preventDefault();
          console.log("THREE.WebGLRenderer: Context Lost.");
          _isContextLost = true;
        }
        function onContextRestore() {
          console.log("THREE.WebGLRenderer: Context Restored.");
          _isContextLost = false;
          const infoAutoReset = info.autoReset;
          const shadowMapEnabled = shadowMap.enabled;
          const shadowMapAutoUpdate = shadowMap.autoUpdate;
          const shadowMapNeedsUpdate = shadowMap.needsUpdate;
          const shadowMapType = shadowMap.type;
          initGLContext();
          info.autoReset = infoAutoReset;
          shadowMap.enabled = shadowMapEnabled;
          shadowMap.autoUpdate = shadowMapAutoUpdate;
          shadowMap.needsUpdate = shadowMapNeedsUpdate;
          shadowMap.type = shadowMapType;
        }
        function onMaterialDispose(event) {
          const material = event.target;
          material.removeEventListener("dispose", onMaterialDispose);
          deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
          releaseMaterialProgramReferences(material);
          properties.remove(material);
        }
        function releaseMaterialProgramReferences(material) {
          const programs = properties.get(material).programs;
          if (programs !== void 0) {
            programs.forEach(function(program) {
              programCache.releaseProgram(program);
            });
            if (material.isShaderMaterial) {
              programCache.releaseShaderCache(material);
            }
          }
        }
        this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
          if (scene === null)
            scene = _emptyScene;
          const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
          const program = setProgram(camera, scene, geometry, material, object);
          state.setMaterial(material, frontFaceCW);
          let index = geometry.index;
          const position = geometry.attributes.position;
          if (index === null) {
            if (position === void 0 || position.count === 0)
              return;
          } else if (index.count === 0) {
            return;
          }
          let rangeFactor = 1;
          if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
          }
          bindingStates.setup(object, material, program, geometry, index);
          let attribute;
          let renderer = bufferRenderer;
          if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
          }
          const dataCount = index !== null ? index.count : position.count;
          const rangeStart = geometry.drawRange.start * rangeFactor;
          const rangeCount = geometry.drawRange.count * rangeFactor;
          const groupStart = group !== null ? group.start * rangeFactor : 0;
          const groupCount = group !== null ? group.count * rangeFactor : Infinity;
          const drawStart = Math.max(rangeStart, groupStart);
          const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
          const drawCount = Math.max(0, drawEnd - drawStart + 1);
          if (drawCount === 0)
            return;
          if (object.isMesh) {
            if (material.wireframe === true) {
              state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
              renderer.setMode(_gl.LINES);
            } else {
              renderer.setMode(_gl.TRIANGLES);
            }
          } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === void 0)
              lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
              renderer.setMode(_gl.LINES);
            } else if (object.isLineLoop) {
              renderer.setMode(_gl.LINE_LOOP);
            } else {
              renderer.setMode(_gl.LINE_STRIP);
            }
          } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
          } else if (object.isSprite) {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (object.isInstancedMesh) {
            renderer.renderInstances(drawStart, drawCount, object.count);
          } else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
          } else {
            renderer.render(drawStart, drawCount);
          }
        };
        this.compile = function(scene, camera) {
          currentRenderState = renderStates.get(scene);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
          currentRenderState.setupLights(_this.physicallyCorrectLights);
          scene.traverse(function(object) {
            const material = object.material;
            if (material) {
              if (Array.isArray(material)) {
                for (let i2 = 0; i2 < material.length; i2++) {
                  const material2 = material[i2];
                  getProgram(material2, scene, object);
                }
              } else {
                getProgram(material, scene, object);
              }
            }
          });
          renderStateStack.pop();
          currentRenderState = null;
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
          if (onAnimationFrameCallback)
            onAnimationFrameCallback(time);
        }
        function onXRSessionStart() {
          animation.stop();
        }
        function onXRSessionEnd() {
          animation.start();
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof window !== "undefined")
          animation.setContext(window);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
          xr2.setAnimationLoop(callback);
          callback === null ? animation.stop() : animation.start();
        };
        xr2.addEventListener("sessionstart", onXRSessionStart);
        xr2.addEventListener("sessionend", onXRSessionEnd);
        this.render = function(scene, camera) {
          if (camera !== void 0 && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (_isContextLost === true)
            return;
          if (scene.autoUpdate === true)
            scene.updateMatrixWorld();
          if (camera.parent === null)
            camera.updateMatrixWorld();
          if (xr2.enabled === true && xr2.isPresenting === true) {
            if (xr2.cameraAutoUpdate === true)
              xr2.updateCamera(camera);
            camera = xr2.getCamera();
          }
          if (scene.isScene === true)
            scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
          currentRenderState = renderStates.get(scene, renderStateStack.length);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          _frustum.setFromProjectionMatrix(_projScreenMatrix2);
          _localClippingEnabled = this.localClippingEnabled;
          _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
          currentRenderList = renderLists.get(scene, renderListStack.length);
          currentRenderList.init();
          renderListStack.push(currentRenderList);
          projectObject(scene, camera, 0, _this.sortObjects);
          currentRenderList.finish();
          if (_this.sortObjects === true) {
            currentRenderList.sort(_opaqueSort, _transparentSort);
          }
          if (_clippingEnabled === true)
            clipping.beginShadows();
          const shadowsArray = currentRenderState.state.shadowsArray;
          shadowMap.render(shadowsArray, scene, camera);
          if (_clippingEnabled === true)
            clipping.endShadows();
          if (this.info.autoReset === true)
            this.info.reset();
          background.render(currentRenderList, scene);
          currentRenderState.setupLights(_this.physicallyCorrectLights);
          if (camera.isArrayCamera) {
            const cameras = camera.cameras;
            for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
              const camera2 = cameras[i2];
              renderScene(currentRenderList, scene, camera2, camera2.viewport);
            }
          } else {
            renderScene(currentRenderList, scene, camera);
          }
          if (_currentRenderTarget !== null) {
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            textures.updateRenderTargetMipmap(_currentRenderTarget);
          }
          if (scene.isScene === true)
            scene.onAfterRender(_this, scene, camera);
          bindingStates.resetDefaultState();
          _currentMaterialId = -1;
          _currentCamera = null;
          renderStateStack.pop();
          if (renderStateStack.length > 0) {
            currentRenderState = renderStateStack[renderStateStack.length - 1];
          } else {
            currentRenderState = null;
          }
          renderListStack.pop();
          if (renderListStack.length > 0) {
            currentRenderList = renderListStack[renderListStack.length - 1];
          } else {
            currentRenderList = null;
          }
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible) {
            if (object.isGroup) {
              groupOrder = object.renderOrder;
            } else if (object.isLOD) {
              if (object.autoUpdate === true)
                object.update(camera);
            } else if (object.isLight) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            } else if (object.isSprite) {
              if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
              }
            } else if (object.isMesh || object.isLine || object.isPoints) {
              if (object.isSkinnedMesh) {
                if (object.skeleton.frame !== info.render.frame) {
                  object.skeleton.update();
                  object.skeleton.frame = info.render.frame;
                }
              }
              if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                  const groups = geometry.groups;
                  for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
                    const group = groups[i2];
                    const groupMaterial = material[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                    }
                  }
                } else if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            projectObject(children[i2], camera, groupOrder, sortObjects);
          }
        }
        function renderScene(currentRenderList2, scene, camera, viewport) {
          const opaqueObjects = currentRenderList2.opaque;
          const transmissiveObjects = currentRenderList2.transmissive;
          const transparentObjects = currentRenderList2.transparent;
          currentRenderState.setupLightsView(camera);
          if (transmissiveObjects.length > 0)
            renderTransmissionPass(opaqueObjects, scene, camera);
          if (viewport)
            state.viewport(_currentViewport.copy(viewport));
          if (opaqueObjects.length > 0)
            renderObjects(opaqueObjects, scene, camera);
          if (transmissiveObjects.length > 0)
            renderObjects(transmissiveObjects, scene, camera);
          if (transparentObjects.length > 0)
            renderObjects(transparentObjects, scene, camera);
          state.buffers.depth.setTest(true);
          state.buffers.depth.setMask(true);
          state.buffers.color.setMask(true);
          state.setPolygonOffset(false);
        }
        function renderTransmissionPass(opaqueObjects, scene, camera) {
          const isWebGL2 = capabilities.isWebGL2;
          if (_transmissionRenderTarget === null) {
            _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
              generateMipmaps: true,
              type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
              minFilter: LinearMipmapLinearFilter,
              samples: isWebGL2 && _antialias === true ? 4 : 0
            });
          }
          _this.getDrawingBufferSize(_vector22);
          if (isWebGL2) {
            _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
          } else {
            _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
          }
          const currentRenderTarget = _this.getRenderTarget();
          _this.setRenderTarget(_transmissionRenderTarget);
          _this.clear();
          const currentToneMapping = _this.toneMapping;
          _this.toneMapping = NoToneMapping;
          renderObjects(opaqueObjects, scene, camera);
          _this.toneMapping = currentToneMapping;
          textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
          textures.updateRenderTargetMipmap(_transmissionRenderTarget);
          _this.setRenderTarget(currentRenderTarget);
        }
        function renderObjects(renderList, scene, camera) {
          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
          for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
            const renderItem = renderList[i2];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (object.layers.test(camera.layers)) {
              renderObject(object, scene, camera, geometry, material, group);
            }
          }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
          object.onBeforeRender(_this, scene, camera, geometry, material, group);
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          material.onBeforeRender(_this, scene, camera, geometry, object, group);
          if (material.transparent === true && material.side === DoubleSide) {
            material.side = BackSide;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = FrontSide;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = DoubleSide;
          } else {
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          }
          object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function getProgram(material, scene, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          const shadowsArray = currentRenderState.state.shadowsArray;
          const lightsStateVersion = lights.state.version;
          const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
          const programCacheKey = programCache.getProgramCacheKey(parameters2);
          let programs = materialProperties.programs;
          materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.fog = scene.fog;
          materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
          if (programs === void 0) {
            material.addEventListener("dispose", onMaterialDispose);
            programs = /* @__PURE__ */ new Map();
            materialProperties.programs = programs;
          }
          let program = programs.get(programCacheKey);
          if (program !== void 0) {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
              updateCommonMaterialProperties(material, parameters2);
              return program;
            }
          } else {
            parameters2.uniforms = programCache.getUniforms(material);
            material.onBuild(object, parameters2, _this);
            material.onBeforeCompile(parameters2, _this);
            program = programCache.acquireProgram(parameters2, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters2.uniforms;
          }
          const uniforms = materialProperties.uniforms;
          if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            uniforms.clippingPlanes = clipping.uniform;
          }
          updateCommonMaterialProperties(material, parameters2);
          materialProperties.needsLights = materialNeedsLights(material);
          materialProperties.lightsStateVersion = lightsStateVersion;
          if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
          }
          const progUniforms = program.getUniforms();
          const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
          materialProperties.currentProgram = program;
          materialProperties.uniformsList = uniformsList;
          return program;
        }
        function updateCommonMaterialProperties(material, parameters2) {
          const materialProperties = properties.get(material);
          materialProperties.outputEncoding = parameters2.outputEncoding;
          materialProperties.instancing = parameters2.instancing;
          materialProperties.skinning = parameters2.skinning;
          materialProperties.morphTargets = parameters2.morphTargets;
          materialProperties.morphNormals = parameters2.morphNormals;
          materialProperties.morphColors = parameters2.morphColors;
          materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
          materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
          materialProperties.numIntersection = parameters2.numClipIntersection;
          materialProperties.vertexAlphas = parameters2.vertexAlphas;
          materialProperties.vertexTangents = parameters2.vertexTangents;
          materialProperties.toneMapping = parameters2.toneMapping;
        }
        function setProgram(camera, scene, geometry, material, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          textures.resetTextureUnits();
          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
          const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
          const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
          const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
          const morphTargets = !!geometry.morphAttributes.position;
          const morphNormals = !!geometry.morphAttributes.normal;
          const morphColors = !!geometry.morphAttributes.color;
          const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
          const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
          const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
              const useCache = camera === _currentCamera && material.id === _currentMaterialId;
              clipping.setState(material, camera, useCache);
            }
          }
          let needsProgramChange = false;
          if (material.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
              needsProgramChange = true;
            } else if (materialProperties.outputEncoding !== encoding) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancing === false) {
              needsProgramChange = true;
            } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
              needsProgramChange = true;
            } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
              needsProgramChange = true;
            } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
              needsProgramChange = true;
            } else if (materialProperties.envMap !== envMap) {
              needsProgramChange = true;
            } else if (material.fog && materialProperties.fog !== fog) {
              needsProgramChange = true;
            } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
              needsProgramChange = true;
            } else if (materialProperties.vertexAlphas !== vertexAlphas) {
              needsProgramChange = true;
            } else if (materialProperties.vertexTangents !== vertexTangents) {
              needsProgramChange = true;
            } else if (materialProperties.morphTargets !== morphTargets) {
              needsProgramChange = true;
            } else if (materialProperties.morphNormals !== morphNormals) {
              needsProgramChange = true;
            } else if (materialProperties.morphColors !== morphColors) {
              needsProgramChange = true;
            } else if (materialProperties.toneMapping !== toneMapping) {
              needsProgramChange = true;
            } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
              needsProgramChange = true;
            }
          } else {
            needsProgramChange = true;
            materialProperties.__version = material.version;
          }
          let program = materialProperties.currentProgram;
          if (needsProgramChange === true) {
            program = getProgram(material, scene, object);
          }
          let refreshProgram = false;
          let refreshMaterial = false;
          let refreshLights = false;
          const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
          if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
          }
          if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) {
              p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
            }
            if (_currentCamera !== camera) {
              _currentCamera = camera;
              refreshMaterial = true;
              refreshLights = true;
            }
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
              const uCamPos = p_uniforms.map.cameraPosition;
              if (uCamPos !== void 0) {
                uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
              }
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
              p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
              p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
          }
          if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
              if (capabilities.floatVertexTextures) {
                if (skeleton.boneTexture === null)
                  skeleton.computeBoneTexture();
                p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
              } else {
                p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
              }
            }
          }
          const morphAttributes = geometry.morphAttributes;
          if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
            morphtargets.update(object, geometry, material, program);
          }
          if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
          }
          if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) {
              markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material.fog) {
              materials.refreshFogUniforms(m_uniforms, fog);
            }
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          }
          if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
          }
          if (material.isSpriteMaterial) {
            p_uniforms.setValue(_gl, "center", object.center);
          }
          p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
          p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
          p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
          return program;
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
          uniforms.ambientLightColor.needsUpdate = value;
          uniforms.lightProbe.needsUpdate = value;
          uniforms.directionalLights.needsUpdate = value;
          uniforms.directionalLightShadows.needsUpdate = value;
          uniforms.pointLights.needsUpdate = value;
          uniforms.pointLightShadows.needsUpdate = value;
          uniforms.spotLights.needsUpdate = value;
          uniforms.spotLightShadows.needsUpdate = value;
          uniforms.rectAreaLights.needsUpdate = value;
          uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material) {
          return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
        }
        this.getActiveCubeFace = function() {
          return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function() {
          return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function() {
          return _currentRenderTarget;
        };
        this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
          properties.get(renderTarget.texture).__webglTexture = colorTexture;
          properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__hasExternalTextures = true;
          if (renderTargetProperties.__hasExternalTextures) {
            renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
            if (!renderTargetProperties.__autoAllocateDepthBuffer) {
              if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
                console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
                renderTargetProperties.__useRenderToTexture = false;
              }
            }
          }
        };
        this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
          renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
        };
        this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
          _currentRenderTarget = renderTarget;
          _currentActiveCubeFace = activeCubeFace;
          _currentActiveMipmapLevel = activeMipmapLevel;
          let useDefaultFramebuffer = true;
          if (renderTarget) {
            const renderTargetProperties = properties.get(renderTarget);
            if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              useDefaultFramebuffer = false;
            } else if (renderTargetProperties.__webglFramebuffer === void 0) {
              textures.setupRenderTarget(renderTarget);
            } else if (renderTargetProperties.__hasExternalTextures) {
              textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
            }
          }
          let framebuffer = null;
          let isCube = false;
          let isRenderTarget3D = false;
          if (renderTarget) {
            const texture = renderTarget.texture;
            if (texture.isData3DTexture || texture.isDataArrayTexture) {
              isRenderTarget3D = true;
            }
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
              framebuffer = __webglFramebuffer[activeCubeFace];
              isCube = true;
            } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
              framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            } else {
              framebuffer = __webglFramebuffer;
            }
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
          } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
          }
          const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
            state.drawBuffers(renderTarget, framebuffer);
          }
          state.viewport(_currentViewport);
          state.scissor(_currentScissor);
          state.setScissorTest(_currentScissorTest);
          if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
          } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
          }
          _currentMaterialId = -1;
        };
        this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let framebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
            framebuffer = framebuffer[activeCubeFaceIndex];
          }
          if (framebuffer) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            try {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
              if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                if (x2 >= 0 && x2 <= renderTarget.width - width && y2 >= 0 && y2 <= renderTarget.height - height) {
                  _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                }
              } else {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
              }
            } finally {
              const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
            }
          }
        };
        this.copyFramebufferToTexture = function(position, texture, level = 0) {
          if (texture.isFramebufferTexture !== true) {
            console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
            return;
          }
          const levelScale = Math.pow(2, -level);
          const width = Math.floor(texture.image.width * levelScale);
          const height = Math.floor(texture.image.height * levelScale);
          textures.setTexture2D(texture, 0);
          _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
          state.unbindTexture();
        };
        this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
          const width = srcTexture.image.width;
          const height = srcTexture.image.height;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          textures.setTexture2D(dstTexture, 0);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
            } else {
              _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
            }
          }
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(_gl.TEXTURE_2D);
          state.unbindTexture();
        };
        this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
          if (_this.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
          }
          const width = sourceBox.max.x - sourceBox.min.x + 1;
          const height = sourceBox.max.y - sourceBox.min.y + 1;
          const depth = sourceBox.max.z - sourceBox.min.z + 1;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          let glTarget;
          if (dstTexture.isData3DTexture) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = _gl.TEXTURE_3D;
          } else if (dstTexture.isDataArrayTexture) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = _gl.TEXTURE_2D_ARRAY;
          } else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
          }
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
          const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
          const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
          const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
          const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
          const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
            _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
              _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
            } else {
              _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
            }
          }
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(glTarget);
          state.unbindTexture();
        };
        this.initTexture = function(texture) {
          textures.setTexture2D(texture, 0);
          state.unbindTexture();
        };
        this.resetState = function() {
          _currentActiveCubeFace = 0;
          _currentActiveMipmapLevel = 0;
          _currentRenderTarget = null;
          state.reset();
          bindingStates.reset();
        };
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
      }
      WebGLRenderer.prototype.isWebGLRenderer = true;
      var WebGL1Renderer = class extends WebGLRenderer {
      };
      WebGL1Renderer.prototype.isWebGL1Renderer = true;
      var FogExp2 = class {
        constructor(color, density = 25e-5) {
          this.name = "";
          this.color = new Color(color);
          this.density = density;
        }
        clone() {
          return new FogExp2(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      };
      FogExp2.prototype.isFogExp2 = true;
      var Fog = class {
        constructor(color, near = 1, far = 1e3) {
          this.name = "";
          this.color = new Color(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      };
      Fog.prototype.isFog = true;
      var Scene = class extends Object3D {
        constructor() {
          super();
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.overrideMaterial = null;
          this.autoUpdate = true;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
              detail: this
            }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.autoUpdate = source.autoUpdate;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          return data;
        }
      };
      Scene.prototype.isScene = true;
      var InterleavedBuffer = class {
        constructor(array, stride) {
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
          this.uuid = generateUUID();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib = new this.constructor(array, this.stride);
          ib.setUsage(this.usage);
          return ib;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      };
      InterleavedBuffer.prototype.isInterleavedBuffer = true;
      var _vector$6 = /* @__PURE__ */ new Vector3();
      var InterleavedBufferAttribute = class {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized === true;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m2) {
          for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.applyMatrix4(m2);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        applyNormalMatrix(m2) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.applyNormalMatrix(m2);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        transformDirection(m2) {
          for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.transformDirection(m2);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        setX(index, x2) {
          this.data.array[index * this.data.stride + this.offset] = x2;
          return this;
        }
        setY(index, y2) {
          this.data.array[index * this.data.stride + this.offset + 1] = y2;
          return this;
        }
        setZ(index, z2) {
          this.data.array[index * this.data.stride + this.offset + 2] = z2;
          return this;
        }
        setW(index, w2) {
          this.data.array[index * this.data.stride + this.offset + 3] = w2;
          return this;
        }
        getX(index) {
          return this.data.array[index * this.data.stride + this.offset];
        }
        getY(index) {
          return this.data.array[index * this.data.stride + this.offset + 1];
        }
        getZ(index) {
          return this.data.array[index * this.data.stride + this.offset + 2];
        }
        getW(index) {
          return this.data.array[index * this.data.stride + this.offset + 3];
        }
        setXY(index, x2, y2) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x2;
          this.data.array[index + 1] = y2;
          return this;
        }
        setXYZ(index, x2, y2, z2) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x2;
          this.data.array[index + 1] = y2;
          this.data.array[index + 2] = z2;
          return this;
        }
        setXYZW(index, x2, y2, z2, w2) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x2;
          this.data.array[index + 1] = y2;
          this.data.array[index + 2] = z2;
          this.data.array[index + 3] = w2;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j2 = 0; j2 < this.itemSize; j2++) {
                array.push(this.data.array[index + j2]);
              }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j2 = 0; j2 < this.itemSize; j2++) {
                array.push(this.data.array[index + j2]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      };
      InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
      var SpriteMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "SpriteMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.rotation = 0;
          this.sizeAttenuation = true;
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.rotation = source.rotation;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      };
      SpriteMaterial.prototype.isSpriteMaterial = true;
      var _geometry;
      var _intersectPoint = /* @__PURE__ */ new Vector3();
      var _worldScale = /* @__PURE__ */ new Vector3();
      var _mvPosition = /* @__PURE__ */ new Vector3();
      var _alignedPosition = /* @__PURE__ */ new Vector2();
      var _rotatedPosition = /* @__PURE__ */ new Vector2();
      var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
      var _vA = /* @__PURE__ */ new Vector3();
      var _vB = /* @__PURE__ */ new Vector3();
      var _vC = /* @__PURE__ */ new Vector3();
      var _uvA = /* @__PURE__ */ new Vector2();
      var _uvB = /* @__PURE__ */ new Vector2();
      var _uvC = /* @__PURE__ */ new Vector2();
      var Sprite = class extends Object3D {
        constructor(material) {
          super();
          this.type = "Sprite";
          if (_geometry === void 0) {
            _geometry = new BufferGeometry();
            const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
          }
          this.geometry = _geometry;
          this.material = material !== void 0 ? material : new SpriteMaterial();
          this.center = new Vector2(0.5, 0.5);
        }
        raycast(raycaster, intersects2) {
          if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
          }
          _worldScale.setFromMatrixScale(this.matrixWorld);
          _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
          _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale.multiplyScalar(-_mvPosition.z);
          }
          const rotation = this.material.rotation;
          let sin, cos;
          if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
          }
          const center = this.center;
          transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvA.set(0, 0);
          _uvB.set(1, 0);
          _uvC.set(1, 1);
          let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
          if (intersect === null) {
            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
            if (intersect === null) {
              return;
            }
          }
          const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
            face: null,
            object: this
          });
        }
        copy(source) {
          super.copy(source);
          if (source.center !== void 0)
            this.center.copy(source.center);
          this.material = source.material;
          return this;
        }
      };
      Sprite.prototype.isSprite = true;
      function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
        _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
        if (sin !== void 0) {
          _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
          _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
        } else {
          _rotatedPosition.copy(_alignedPosition);
        }
        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y;
        vertexPosition.applyMatrix4(_viewWorldMatrix);
      }
      var _v1$2 = /* @__PURE__ */ new Vector3();
      var _v2$1 = /* @__PURE__ */ new Vector3();
      var LOD = class extends Object3D {
        constructor() {
          super();
          this._currentLevel = 0;
          this.type = "LOD";
          Object.defineProperties(this, {
            levels: {
              enumerable: true,
              value: []
            },
            isLOD: {
              value: true
            }
          });
          this.autoUpdate = true;
        }
        copy(source) {
          super.copy(source, false);
          const levels = source.levels;
          for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
            const level = levels[i2];
            this.addLevel(level.object.clone(), level.distance);
          }
          this.autoUpdate = source.autoUpdate;
          return this;
        }
        addLevel(object, distance = 0) {
          distance = Math.abs(distance);
          const levels = this.levels;
          let l2;
          for (l2 = 0; l2 < levels.length; l2++) {
            if (distance < levels[l2].distance) {
              break;
            }
          }
          levels.splice(l2, 0, {
            distance,
            object
          });
          this.add(object);
          return this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(distance) {
          const levels = this.levels;
          if (levels.length > 0) {
            let i2, l2;
            for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
              if (distance < levels[i2].distance) {
                break;
              }
            }
            return levels[i2 - 1].object;
          }
          return null;
        }
        raycast(raycaster, intersects2) {
          const levels = this.levels;
          if (levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects2);
          }
        }
        update(camera) {
          const levels = this.levels;
          if (levels.length > 1) {
            _v1$2.setFromMatrixPosition(camera.matrixWorld);
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i2, l2;
            for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
              if (distance >= levels[i2].distance) {
                levels[i2 - 1].object.visible = false;
                levels[i2].object.visible = true;
              } else {
                break;
              }
            }
            this._currentLevel = i2 - 1;
            for (; i2 < l2; i2++) {
              levels[i2].object.visible = false;
            }
          }
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.autoUpdate === false)
            data.object.autoUpdate = false;
          data.object.levels = [];
          const levels = this.levels;
          for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
            const level = levels[i2];
            data.object.levels.push({
              object: level.object.uuid,
              distance: level.distance
            });
          }
          return data;
        }
      };
      var _basePosition = /* @__PURE__ */ new Vector3();
      var _skinIndex = /* @__PURE__ */ new Vector4();
      var _skinWeight = /* @__PURE__ */ new Vector4();
      var _vector$5 = /* @__PURE__ */ new Vector3();
      var _matrix = /* @__PURE__ */ new Matrix4();
      var SkinnedMesh = class extends Mesh {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new Matrix4();
          this.bindMatrixInverse = new Matrix4();
        }
        copy(source) {
          super.copy(source);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          return this;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector4();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
            vector.x = skinWeight.getX(i2);
            vector.y = skinWeight.getY(i2);
            vector.z = skinWeight.getZ(i2);
            vector.w = skinWeight.getW(i2);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) {
              vector.multiplyScalar(scale);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === "attached") {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        boneTransform(index, target) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
          _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
          _basePosition.copy(target).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i2 = 0; i2 < 4; i2++) {
            const weight = _skinWeight.getComponent(i2);
            if (weight !== 0) {
              const boneIndex = _skinIndex.getComponent(i2);
              _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        }
      };
      SkinnedMesh.prototype.isSkinnedMesh = true;
      var Bone = class extends Object3D {
        constructor() {
          super();
          this.type = "Bone";
        }
      };
      Bone.prototype.isBone = true;
      var DataTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.image = {
            data,
            width,
            height
          };
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture.prototype.isDataTexture = true;
      var _offsetMatrix = /* @__PURE__ */ new Matrix4();
      var _identityMatrix = /* @__PURE__ */ new Matrix4();
      var Skeleton = class {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.frame = -1;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i2 = 0, il2 = this.bones.length; i2 < il2; i2++) {
                this.boneInverses.push(new Matrix4());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i2 = 0, il2 = this.bones.length; i2 < il2; i2++) {
            const inverse = new Matrix4();
            if (this.bones[i2]) {
              inverse.copy(this.bones[i2].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i2 = 0, il2 = this.bones.length; i2 < il2; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i2]).invert();
            }
          }
          for (let i2 = 0, il2 = this.bones.length; i2 < il2; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i2 = 0, il2 = bones.length; i2 < il2; i2++) {
            const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
            _offsetMatrix.toArray(boneMatrices, i2 * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
          boneTexture.needsUpdate = true;
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name) {
          for (let i2 = 0, il2 = this.bones.length; i2 < il2; i2++) {
            const bone = this.bones[i2];
            if (bone.name === name) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
            const uuid = json.bones[i2];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
            const bone = bones[i2];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i2];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      };
      var InstancedBufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          if (typeof normalized === "number") {
            meshPerAttribute = normalized;
            normalized = false;
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
          }
          super(array, itemSize, normalized);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      };
      InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
      var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
      var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
      var _instanceIntersects = [];
      var _mesh = /* @__PURE__ */ new Mesh();
      var InstancedMesh = class extends Mesh {
        constructor(geometry, material, count) {
          super(geometry, material);
          this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.frustumCulled = false;
        }
        copy(source) {
          super.copy(source);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          return this;
        }
        getColorAt(index, color) {
          color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        raycast(raycaster, intersects2) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh.geometry = this.geometry;
          _mesh.material = this.material;
          if (_mesh.material === void 0)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
              const intersect = _instanceIntersects[i2];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects2.push(intersect);
            }
            _instanceIntersects.length = 0;
          }
        }
        setColorAt(index, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
          matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      };
      InstancedMesh.prototype.isInstancedMesh = true;
      var LineBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "LineBasicMaterial";
          this.color = new Color(16777215);
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          return this;
        }
      };
      LineBasicMaterial.prototype.isLineBasicMaterial = true;
      var _start$1 = /* @__PURE__ */ new Vector3();
      var _end$1 = /* @__PURE__ */ new Vector3();
      var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
      var _ray$1 = /* @__PURE__ */ new Ray();
      var _sphere$1 = /* @__PURE__ */ new Sphere();
      var Line = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
          super();
          this.type = "Line";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [0];
              for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
                _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
                _end$1.fromBufferAttribute(positionAttribute, i2);
                lineDistances[i2] = lineDistances[i2 - 1];
                lineDistances[i2] += _start$1.distanceTo(_end$1);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$1.copy(geometry.boundingSphere);
          _sphere$1.applyMatrix4(matrixWorld);
          _sphere$1.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$1) === false)
            return;
          _inverseMatrix$1.copy(matrixWorld).invert();
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector3();
          const vEnd = new Vector3();
          const interSegment = new Vector3();
          const interRay = new Vector3();
          const step = this.isLineSegments ? 2 : 1;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
                const a2 = index.getX(i2);
                const b2 = index.getX(i2 + 1);
                vStart.fromBufferAttribute(positionAttribute, a2);
                vEnd.fromBufferAttribute(positionAttribute, b2);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
                vStart.fromBufferAttribute(positionAttribute, i2);
                vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
                  const name = morphAttribute[m2].name || String(m2);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m2;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      };
      Line.prototype.isLine = true;
      var _start = /* @__PURE__ */ new Vector3();
      var _end = /* @__PURE__ */ new Vector3();
      var LineSegments = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [];
              for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
                _start.fromBufferAttribute(positionAttribute, i2);
                _end.fromBufferAttribute(positionAttribute, i2 + 1);
                lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
                lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
      };
      LineSegments.prototype.isLineSegments = true;
      var LineLoop = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineLoop";
        }
      };
      LineLoop.prototype.isLineLoop = true;
      var PointsMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "PointsMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      };
      PointsMaterial.prototype.isPointsMaterial = true;
      var _inverseMatrix = /* @__PURE__ */ new Matrix4();
      var _ray = /* @__PURE__ */ new Ray();
      var _sphere = /* @__PURE__ */ new Sphere();
      var _position$2 = /* @__PURE__ */ new Vector3();
      var Points = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
          super();
          this.type = "Points";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere.copy(geometry.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);
          _sphere.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere) === false)
            return;
          _inverseMatrix.copy(matrixWorld).invert();
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, il2 = end; i2 < il2; i2++) {
                const a2 = index.getX(i2);
                _position$2.fromBufferAttribute(positionAttribute, a2);
                testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l2 = end; i2 < l2; i2++) {
                _position$2.fromBufferAttribute(positionAttribute, i2);
                testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            }
          } else {
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
                  const name = morphAttribute[m2].name || String(m2);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m2;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      };
      Points.prototype.isPoints = true;
      function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
        const rayPointDistanceSq = _ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          const intersectPoint = new Vector3();
          _ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index,
            face: null,
            object
          });
        }
      }
      var VideoTexture = class extends Texture {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
          super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
          this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
          this.generateMipmaps = false;
          const scope = this;
          function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
          }
          if ("requestVideoFrameCallback" in video) {
            video.requestVideoFrameCallback(updateVideo);
          }
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const video = this.image;
          const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
          if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
          }
        }
      };
      VideoTexture.prototype.isVideoTexture = true;
      var FramebufferTexture = class extends Texture {
        constructor(width, height, format) {
          super({
            width,
            height
          });
          this.format = format;
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.generateMipmaps = false;
          this.needsUpdate = true;
        }
      };
      FramebufferTexture.prototype.isFramebufferTexture = true;
      var CompressedTexture = class extends Texture {
        constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.image = {
            width,
            height
          };
          this.mipmaps = mipmaps;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      CompressedTexture.prototype.isCompressedTexture = true;
      var CanvasTexture = class extends Texture {
        constructor(canvas2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
          super(canvas2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.needsUpdate = true;
        }
      };
      CanvasTexture.prototype.isCanvasTexture = true;
      var CircleGeometry = class extends BufferGeometry {
        constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CircleGeometry";
          this.parameters = {
            radius,
            segments,
            thetaStart,
            thetaLength
          };
          segments = Math.max(3, segments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex2 = new Vector3();
          const uv = new Vector2();
          vertices.push(0, 0, 0);
          normals.push(0, 0, 1);
          uvs.push(0.5, 0.5);
          for (let s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
            const segment = thetaStart + s2 / segments * thetaLength;
            vertex2.x = radius * Math.cos(segment);
            vertex2.y = radius * Math.sin(segment);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i2] / radius + 1) / 2;
            uv.y = (vertices[i2 + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            indices.push(i2, i2 + 1, 0);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
        }
      };
      var CylinderGeometry = class extends BufferGeometry {
        constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CylinderGeometry";
          this.parameters = {
            radiusTop,
            radiusBottom,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
          const scope = this;
          radialSegments = Math.floor(radialSegments);
          heightSegments = Math.floor(heightSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let index = 0;
          const indexArray = [];
          const halfHeight = height / 2;
          let groupStart = 0;
          generateTorso();
          if (openEnded === false) {
            if (radiusTop > 0)
              generateCap(true);
            if (radiusBottom > 0)
              generateCap(false);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function generateTorso() {
            const normal = new Vector3();
            const vertex2 = new Vector3();
            let groupCount = 0;
            const slope = (radiusBottom - radiusTop) / height;
            for (let y2 = 0; y2 <= heightSegments; y2++) {
              const indexRow = [];
              const v2 = y2 / heightSegments;
              const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
              for (let x2 = 0; x2 <= radialSegments; x2++) {
                const u2 = x2 / radialSegments;
                const theta = u2 * thetaLength + thetaStart;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                vertex2.x = radius * sinTheta;
                vertex2.y = -v2 * height + halfHeight;
                vertex2.z = radius * cosTheta;
                vertices.push(vertex2.x, vertex2.y, vertex2.z);
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u2, 1 - v2);
                indexRow.push(index++);
              }
              indexArray.push(indexRow);
            }
            for (let x2 = 0; x2 < radialSegments; x2++) {
              for (let y2 = 0; y2 < heightSegments; y2++) {
                const a2 = indexArray[y2][x2];
                const b2 = indexArray[y2 + 1][x2];
                const c2 = indexArray[y2 + 1][x2 + 1];
                const d = indexArray[y2][x2 + 1];
                indices.push(a2, b2, d);
                indices.push(b2, c2, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
          }
          function generateCap(top) {
            const centerIndexStart = index;
            const uv = new Vector2();
            const vertex2 = new Vector3();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign2 = top === true ? 1 : -1;
            for (let x2 = 1; x2 <= radialSegments; x2++) {
              vertices.push(0, halfHeight * sign2, 0);
              normals.push(0, sign2, 0);
              uvs.push(0.5, 0.5);
              index++;
            }
            const centerIndexEnd = index;
            for (let x2 = 0; x2 <= radialSegments; x2++) {
              const u2 = x2 / radialSegments;
              const theta = u2 * thetaLength + thetaStart;
              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);
              vertex2.x = radius * sinTheta;
              vertex2.y = halfHeight * sign2;
              vertex2.z = radius * cosTheta;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, sign2, 0);
              uv.x = cosTheta * 0.5 + 0.5;
              uv.y = sinTheta * 0.5 * sign2 + 0.5;
              uvs.push(uv.x, uv.y);
              index++;
            }
            for (let x2 = 0; x2 < radialSegments; x2++) {
              const c2 = centerIndexStart + x2;
              const i2 = centerIndexEnd + x2;
              if (top === true) {
                indices.push(i2, i2 + 1, c2);
              } else {
                indices.push(i2 + 1, i2, c2);
              }
              groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
          }
        }
        static fromJSON(data) {
          return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      };
      var ConeGeometry = class extends CylinderGeometry {
        constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
          this.type = "ConeGeometry";
          this.parameters = {
            radius,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
        }
        static fromJSON(data) {
          return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      };
      var PolyhedronGeometry = class extends BufferGeometry {
        constructor(vertices = [], indices = [], radius = 1, detail = 0) {
          super();
          this.type = "PolyhedronGeometry";
          this.parameters = {
            vertices,
            indices,
            radius,
            detail
          };
          const vertexBuffer = [];
          const uvBuffer = [];
          subdivide(detail);
          applyRadius(radius);
          generateUVs();
          this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
          this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
          if (detail === 0) {
            this.computeVertexNormals();
          } else {
            this.normalizeNormals();
          }
          function subdivide(detail2) {
            const a2 = new Vector3();
            const b2 = new Vector3();
            const c2 = new Vector3();
            for (let i2 = 0; i2 < indices.length; i2 += 3) {
              getVertexByIndex(indices[i2 + 0], a2);
              getVertexByIndex(indices[i2 + 1], b2);
              getVertexByIndex(indices[i2 + 2], c2);
              subdivideFace(a2, b2, c2, detail2);
            }
          }
          function subdivideFace(a2, b2, c2, detail2) {
            const cols = detail2 + 1;
            const v2 = [];
            for (let i2 = 0; i2 <= cols; i2++) {
              v2[i2] = [];
              const aj = a2.clone().lerp(c2, i2 / cols);
              const bj = b2.clone().lerp(c2, i2 / cols);
              const rows = cols - i2;
              for (let j2 = 0; j2 <= rows; j2++) {
                if (j2 === 0 && i2 === cols) {
                  v2[i2][j2] = aj;
                } else {
                  v2[i2][j2] = aj.clone().lerp(bj, j2 / rows);
                }
              }
            }
            for (let i2 = 0; i2 < cols; i2++) {
              for (let j2 = 0; j2 < 2 * (cols - i2) - 1; j2++) {
                const k2 = Math.floor(j2 / 2);
                if (j2 % 2 === 0) {
                  pushVertex(v2[i2][k2 + 1]);
                  pushVertex(v2[i2 + 1][k2]);
                  pushVertex(v2[i2][k2]);
                } else {
                  pushVertex(v2[i2][k2 + 1]);
                  pushVertex(v2[i2 + 1][k2 + 1]);
                  pushVertex(v2[i2 + 1][k2]);
                }
              }
            }
          }
          function applyRadius(radius2) {
            const vertex2 = new Vector3();
            for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
              vertex2.x = vertexBuffer[i2 + 0];
              vertex2.y = vertexBuffer[i2 + 1];
              vertex2.z = vertexBuffer[i2 + 2];
              vertex2.normalize().multiplyScalar(radius2);
              vertexBuffer[i2 + 0] = vertex2.x;
              vertexBuffer[i2 + 1] = vertex2.y;
              vertexBuffer[i2 + 2] = vertex2.z;
            }
          }
          function generateUVs() {
            const vertex2 = new Vector3();
            for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
              vertex2.x = vertexBuffer[i2 + 0];
              vertex2.y = vertexBuffer[i2 + 1];
              vertex2.z = vertexBuffer[i2 + 2];
              const u2 = azimuth(vertex2) / 2 / Math.PI + 0.5;
              const v2 = inclination(vertex2) / Math.PI + 0.5;
              uvBuffer.push(u2, 1 - v2);
            }
            correctUVs();
            correctSeam();
          }
          function correctSeam() {
            for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
              const x0 = uvBuffer[i2 + 0];
              const x1 = uvBuffer[i2 + 2];
              const x2 = uvBuffer[i2 + 4];
              const max = Math.max(x0, x1, x2);
              const min = Math.min(x0, x1, x2);
              if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2)
                  uvBuffer[i2 + 0] += 1;
                if (x1 < 0.2)
                  uvBuffer[i2 + 2] += 1;
                if (x2 < 0.2)
                  uvBuffer[i2 + 4] += 1;
              }
            }
          }
          function pushVertex(vertex2) {
            vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
          }
          function getVertexByIndex(index, vertex2) {
            const stride = index * 3;
            vertex2.x = vertices[stride + 0];
            vertex2.y = vertices[stride + 1];
            vertex2.z = vertices[stride + 2];
          }
          function correctUVs() {
            const a2 = new Vector3();
            const b2 = new Vector3();
            const c2 = new Vector3();
            const centroid = new Vector3();
            const uvA = new Vector2();
            const uvB = new Vector2();
            const uvC = new Vector2();
            for (let i2 = 0, j2 = 0; i2 < vertexBuffer.length; i2 += 9, j2 += 6) {
              a2.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
              b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
              c2.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
              uvA.set(uvBuffer[j2 + 0], uvBuffer[j2 + 1]);
              uvB.set(uvBuffer[j2 + 2], uvBuffer[j2 + 3]);
              uvC.set(uvBuffer[j2 + 4], uvBuffer[j2 + 5]);
              centroid.copy(a2).add(b2).add(c2).divideScalar(3);
              const azi = azimuth(centroid);
              correctUV(uvA, j2 + 0, a2, azi);
              correctUV(uvB, j2 + 2, b2, azi);
              correctUV(uvC, j2 + 4, c2, azi);
            }
          }
          function correctUV(uv, stride, vector, azimuth2) {
            if (azimuth2 < 0 && uv.x === 1) {
              uvBuffer[stride] = uv.x - 1;
            }
            if (vector.x === 0 && vector.z === 0) {
              uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
            }
          }
          function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
          }
          function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
          }
        }
        static fromJSON(data) {
          return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
        }
      };
      var DodecahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t2 = (1 + Math.sqrt(5)) / 2;
          const r2 = 1 / t2;
          const vertices = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r2,
            -t2,
            0,
            -r2,
            t2,
            0,
            r2,
            -t2,
            0,
            r2,
            t2,
            -r2,
            -t2,
            0,
            -r2,
            t2,
            0,
            r2,
            -t2,
            0,
            r2,
            t2,
            0,
            -t2,
            0,
            -r2,
            t2,
            0,
            -r2,
            -t2,
            0,
            r2,
            t2,
            0,
            r2
          ];
          const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
          super(vertices, indices, radius, detail);
          this.type = "DodecahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new DodecahedronGeometry(data.radius, data.detail);
        }
      };
      var _v0 = new Vector3();
      var _v1$1 = new Vector3();
      var _normal = new Vector3();
      var _triangle = new Triangle();
      var EdgesGeometry = class extends BufferGeometry {
        constructor(geometry = null, thresholdAngle = 1) {
          super();
          this.type = "EdgesGeometry";
          this.parameters = {
            geometry,
            thresholdAngle
          };
          if (geometry !== null) {
            const precisionPoints = 4;
            const precision = Math.pow(10, precisionPoints);
            const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
            const indexAttr = geometry.getIndex();
            const positionAttr = geometry.getAttribute("position");
            const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
            const indexArr = [0, 0, 0];
            const vertKeys = ["a", "b", "c"];
            const hashes = new Array(3);
            const edgeData = {};
            const vertices = [];
            for (let i2 = 0; i2 < indexCount; i2 += 3) {
              if (indexAttr) {
                indexArr[0] = indexAttr.getX(i2);
                indexArr[1] = indexAttr.getX(i2 + 1);
                indexArr[2] = indexAttr.getX(i2 + 2);
              } else {
                indexArr[0] = i2;
                indexArr[1] = i2 + 1;
                indexArr[2] = i2 + 2;
              }
              const {
                a: a2,
                b: b2,
                c: c2
              } = _triangle;
              a2.fromBufferAttribute(positionAttr, indexArr[0]);
              b2.fromBufferAttribute(positionAttr, indexArr[1]);
              c2.fromBufferAttribute(positionAttr, indexArr[2]);
              _triangle.getNormal(_normal);
              hashes[0] = `${Math.round(a2.x * precision)},${Math.round(a2.y * precision)},${Math.round(a2.z * precision)}`;
              hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
              hashes[2] = `${Math.round(c2.x * precision)},${Math.round(c2.y * precision)},${Math.round(c2.z * precision)}`;
              if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                continue;
              }
              for (let j2 = 0; j2 < 3; j2++) {
                const jNext = (j2 + 1) % 3;
                const vecHash0 = hashes[j2];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle[vertKeys[j2]];
                const v1 = _triangle[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                  if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                    vertices.push(v0.x, v0.y, v0.z);
                    vertices.push(v1.x, v1.y, v1.z);
                  }
                  edgeData[reverseHash] = null;
                } else if (!(hash in edgeData)) {
                  edgeData[hash] = {
                    index0: indexArr[j2],
                    index1: indexArr[jNext],
                    normal: _normal.clone()
                  };
                }
              }
            }
            for (const key in edgeData) {
              if (edgeData[key]) {
                const {
                  index0,
                  index1
                } = edgeData[key];
                _v0.fromBufferAttribute(positionAttr, index0);
                _v1$1.fromBufferAttribute(positionAttr, index1);
                vertices.push(_v0.x, _v0.y, _v0.z);
                vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
              }
            }
            this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          }
        }
      };
      var Curve = class {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        getPointAt(u2, optionalTarget) {
          const t2 = this.getUtoTmapping(u2);
          return this.getPoint(t2, optionalTarget);
        }
        getPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
          }
          return points;
        }
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
          }
          return points;
        }
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;
          cache.push(0);
          for (let p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        getUtoTmapping(u2, distance) {
          const arcLengths = this.getLengths();
          let i2 = 0;
          const il2 = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u2 * arcLengths[il2 - 1];
          }
          let low = 0, high = il2 - 1, comparison;
          while (low <= high) {
            i2 = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i2] - targetArcLength;
            if (comparison < 0) {
              low = i2 + 1;
            } else if (comparison > 0) {
              high = i2 - 1;
            } else {
              high = i2;
              break;
            }
          }
          i2 = high;
          if (arcLengths[i2] === targetArcLength) {
            return i2 / (il2 - 1);
          }
          const lengthBefore = arcLengths[i2];
          const lengthAfter = arcLengths[i2 + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t2 = (i2 + segmentFraction) / (il2 - 1);
          return t2;
        }
        getTangent(t2, optionalTarget) {
          const delta = 1e-4;
          let t1 = t2 - delta;
          let t22 = t2 + delta;
          if (t1 < 0)
            t1 = 0;
          if (t22 > 1)
            t22 = 1;
          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t22);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
          tangent.copy(pt2).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u2, optionalTarget) {
          const t2 = this.getUtoTmapping(u2);
          return this.getTangent(t2, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector3();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector3();
          const mat = new Matrix4();
          for (let i2 = 0; i2 <= segments; i2++) {
            const u2 = i2 / segments;
            tangents[i2] = this.getTangentAt(u2, new Vector3());
          }
          normals[0] = new Vector3();
          binormals[0] = new Vector3();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2] = normals[i2 - 1].clone();
            binormals[i2] = binormals[i2 - 1].clone();
            vec.crossVectors(tangents[i2 - 1], tangents[i2]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
              normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i2 = 1; i2 <= segments; i2++) {
              normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
              binormals[i2].crossVectors(tangents[i2], normals[i2]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      };
      var EllipseCurve = class extends Curve {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
          super();
          this.type = "EllipseCurve";
          this.aX = aX;
          this.aY = aY;
          this.xRadius = xRadius;
          this.yRadius = yRadius;
          this.aStartAngle = aStartAngle;
          this.aEndAngle = aEndAngle;
          this.aClockwise = aClockwise;
          this.aRotation = aRotation;
        }
        getPoint(t2, optionalTarget) {
          const point = optionalTarget || new Vector2();
          const twoPi = Math.PI * 2;
          let deltaAngle = this.aEndAngle - this.aStartAngle;
          const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0)
            deltaAngle += twoPi;
          while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          const angle = this.aStartAngle + t2 * deltaAngle;
          let x2 = this.aX + this.xRadius * Math.cos(angle);
          let y2 = this.aY + this.yRadius * Math.sin(angle);
          if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x2 - this.aX;
            const ty = y2 - this.aY;
            x2 = tx * cos - ty * sin + this.aX;
            y2 = tx * sin + ty * cos + this.aY;
          }
          return point.set(x2, y2);
        }
        copy(source) {
          super.copy(source);
          this.aX = source.aX;
          this.aY = source.aY;
          this.xRadius = source.xRadius;
          this.yRadius = source.yRadius;
          this.aStartAngle = source.aStartAngle;
          this.aEndAngle = source.aEndAngle;
          this.aClockwise = source.aClockwise;
          this.aRotation = source.aRotation;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.aX = this.aX;
          data.aY = this.aY;
          data.xRadius = this.xRadius;
          data.yRadius = this.yRadius;
          data.aStartAngle = this.aStartAngle;
          data.aEndAngle = this.aEndAngle;
          data.aClockwise = this.aClockwise;
          data.aRotation = this.aRotation;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.aX = json.aX;
          this.aY = json.aY;
          this.xRadius = json.xRadius;
          this.yRadius = json.yRadius;
          this.aStartAngle = json.aStartAngle;
          this.aEndAngle = json.aEndAngle;
          this.aClockwise = json.aClockwise;
          this.aRotation = json.aRotation;
          return this;
        }
      };
      EllipseCurve.prototype.isEllipseCurve = true;
      var ArcCurve = class extends EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          this.type = "ArcCurve";
        }
      };
      ArcCurve.prototype.isArcCurve = true;
      function CubicPoly() {
        let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        function init(x0, x1, t0, t1) {
          c0 = x0;
          c1 = t0;
          c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
          c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
          initCatmullRom: function(x0, x1, x2, x3, tension) {
            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
          },
          initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1;
            t2 *= dt1;
            init(x1, x2, t1, t2);
          },
          calc: function(t2) {
            const t22 = t2 * t2;
            const t3 = t22 * t2;
            return c0 + c1 * t2 + c2 * t22 + c3 * t3;
          }
        };
      }
      var tmp = new Vector3();
      var px = new CubicPoly();
      var py = new CubicPoly();
      var pz = new CubicPoly();
      var CatmullRomCurve3 = class extends Curve {
        constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
          super();
          this.type = "CatmullRomCurve3";
          this.points = points;
          this.closed = closed;
          this.curveType = curveType;
          this.tension = tension;
        }
        getPoint(t2, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const points = this.points;
          const l2 = points.length;
          const p = (l2 - (this.closed ? 0 : 1)) * t2;
          let intPoint = Math.floor(p);
          let weight = p - intPoint;
          if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
          } else if (weight === 0 && intPoint === l2 - 1) {
            intPoint = l2 - 2;
            weight = 1;
          }
          let p0, p3;
          if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l2];
          } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
          }
          const p1 = points[intPoint % l2];
          const p2 = points[(intPoint + 1) % l2];
          if (this.closed || intPoint + 2 < l2) {
            p3 = points[(intPoint + 2) % l2];
          } else {
            tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
            p3 = tmp;
          }
          if (this.curveType === "centripetal" || this.curveType === "chordal") {
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
              dt1 = 1;
            if (dt0 < 1e-4)
              dt0 = dt1;
            if (dt2 < 1e-4)
              dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
          } else if (this.curveType === "catmullrom") {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
          }
          point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          this.closed = source.closed;
          this.curveType = source.curveType;
          this.tension = source.tension;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          data.closed = this.closed;
          data.curveType = this.curveType;
          data.tension = this.tension;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector3().fromArray(point));
          }
          this.closed = json.closed;
          this.curveType = json.curveType;
          this.tension = json.tension;
          return this;
        }
      };
      CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
      function CatmullRom(t2, p0, p1, p2, p3) {
        const v0 = (p2 - p0) * 0.5;
        const v1 = (p3 - p1) * 0.5;
        const t22 = t2 * t2;
        const t3 = t2 * t22;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
      }
      function QuadraticBezierP0(t2, p) {
        const k2 = 1 - t2;
        return k2 * k2 * p;
      }
      function QuadraticBezierP1(t2, p) {
        return 2 * (1 - t2) * t2 * p;
      }
      function QuadraticBezierP2(t2, p) {
        return t2 * t2 * p;
      }
      function QuadraticBezier(t2, p0, p1, p2) {
        return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
      }
      function CubicBezierP0(t2, p) {
        const k2 = 1 - t2;
        return k2 * k2 * k2 * p;
      }
      function CubicBezierP1(t2, p) {
        const k2 = 1 - t2;
        return 3 * k2 * k2 * t2 * p;
      }
      function CubicBezierP2(t2, p) {
        return 3 * (1 - t2) * t2 * t2 * p;
      }
      function CubicBezierP3(t2, p) {
        return t2 * t2 * t2 * p;
      }
      function CubicBezier(t2, p0, p1, p2, p3) {
        return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
      }
      var CubicBezierCurve = class extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
          super();
          this.type = "CubicBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve.prototype.isCubicBezierCurve = true;
      var CubicBezierCurve3 = class extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
          super();
          this.type = "CubicBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t2, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
      var LineCurve = class extends Curve {
        constructor(v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.type = "LineCurve";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          if (t2 === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t2).add(this.v1);
          }
          return point;
        }
        getPointAt(u2, optionalTarget) {
          return this.getPoint(u2, optionalTarget);
        }
        getTangent(t2, optionalTarget) {
          const tangent = optionalTarget || new Vector2();
          tangent.copy(this.v2).sub(this.v1).normalize();
          return tangent;
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      LineCurve.prototype.isLineCurve = true;
      var LineCurve3 = class extends Curve {
        constructor(v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.type = "LineCurve3";
          this.isLineCurve3 = true;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          if (t2 === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t2).add(this.v1);
          }
          return point;
        }
        getPointAt(u2, optionalTarget) {
          return this.getPoint(u2, optionalTarget);
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      var QuadraticBezierCurve = class extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.type = "QuadraticBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
      var QuadraticBezierCurve3 = class extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.type = "QuadraticBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
      var SplineCurve = class extends Curve {
        constructor(points = []) {
          super();
          this.type = "SplineCurve";
          this.points = points;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const points = this.points;
          const p = (points.length - 1) * t2;
          const intPoint = Math.floor(p);
          const weight = p - intPoint;
          const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          const p1 = points[intPoint];
          const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector2().fromArray(point));
          }
          return this;
        }
      };
      SplineCurve.prototype.isSplineCurve = true;
      var Curves = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcCurve,
        CatmullRomCurve3,
        CubicBezierCurve,
        CubicBezierCurve3,
        EllipseCurve,
        LineCurve,
        LineCurve3,
        QuadraticBezierCurve,
        QuadraticBezierCurve3,
        SplineCurve
      });
      var CurvePath = class extends Curve {
        constructor() {
          super();
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = false;
        }
        add(curve) {
          this.curves.push(curve);
        }
        closePath() {
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);
          if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
          }
        }
        getPoint(t2, optionalTarget) {
          const d = t2 * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i2 = 0;
          while (i2 < curveLengths.length) {
            if (curveLengths[i2] >= d) {
              const diff = curveLengths[i2] - d;
              const curve = this.curves[i2];
              const segmentLength = curve.getLength();
              const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
              return curve.getPointAt(u2, optionalTarget);
            }
            i2++;
          }
          return null;
        }
        getLength() {
          const lens = this.getCurveLengths();
          return lens[lens.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
          }
          const lengths = [];
          let sums = 0;
          for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
            sums += this.curves[i2].getLength();
            lengths.push(sums);
          }
          this.cacheLengths = lengths;
          return lengths;
        }
        getSpacedPoints(divisions = 40) {
          const points = [];
          for (let i2 = 0; i2 <= divisions; i2++) {
            points.push(this.getPoint(i2 / divisions));
          }
          if (this.autoClose) {
            points.push(points[0]);
          }
          return points;
        }
        getPoints(divisions = 12) {
          const points = [];
          let last;
          for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
            const curve = curves[i2];
            const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for (let j2 = 0; j2 < pts.length; j2++) {
              const point = pts[j2];
              if (last && last.equals(point))
                continue;
              points.push(point);
              last = point;
            }
          }
          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
          }
          return points;
        }
        copy(source) {
          super.copy(source);
          this.curves = [];
          for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
            const curve = source.curves[i2];
            this.curves.push(curve.clone());
          }
          this.autoClose = source.autoClose;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.autoClose = this.autoClose;
          data.curves = [];
          for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
            const curve = this.curves[i2];
            data.curves.push(curve.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.autoClose = json.autoClose;
          this.curves = [];
          for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
            const curve = json.curves[i2];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
          }
          return this;
        }
      };
      var Path = class extends CurvePath {
        constructor(points) {
          super();
          this.type = "Path";
          this.currentPoint = new Vector2();
          if (points) {
            this.setFromPoints(points);
          }
        }
        setFromPoints(points) {
          this.moveTo(points[0].x, points[0].y);
          for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
            this.lineTo(points[i2].x, points[i2].y);
          }
          return this;
        }
        moveTo(x2, y2) {
          this.currentPoint.set(x2, y2);
          return this;
        }
        lineTo(x2, y2) {
          const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
          this.curves.push(curve);
          this.currentPoint.set(x2, y2);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        splineThru(pts) {
          const npts = [this.currentPoint.clone()].concat(pts);
          const curve = new SplineCurve(npts);
          this.curves.push(curve);
          this.currentPoint.copy(pts[pts.length - 1]);
          return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
              this.lineTo(firstPoint.x, firstPoint.y);
            }
          }
          this.curves.push(curve);
          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);
          return this;
        }
        copy(source) {
          super.copy(source);
          this.currentPoint.copy(source.currentPoint);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.currentPoint = this.currentPoint.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.currentPoint.fromArray(json.currentPoint);
          return this;
        }
      };
      var Shape = class extends Path {
        constructor(points) {
          super(points);
          this.uuid = generateUUID();
          this.type = "Shape";
          this.holes = [];
        }
        getPointsHoles(divisions) {
          const holesPts = [];
          for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
            holesPts[i2] = this.holes[i2].getPoints(divisions);
          }
          return holesPts;
        }
        extractPoints(divisions) {
          return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
          };
        }
        copy(source) {
          super.copy(source);
          this.holes = [];
          for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
            const hole = source.holes[i2];
            this.holes.push(hole.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.uuid = this.uuid;
          data.holes = [];
          for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
            const hole = this.holes[i2];
            data.holes.push(hole.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.uuid = json.uuid;
          this.holes = [];
          for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
            const hole = json.holes[i2];
            this.holes.push(new Path().fromJSON(hole));
          }
          return this;
        }
      };
      var Earcut = {
        triangulate: function(data, holeIndices, dim = 2) {
          const hasHoles = holeIndices && holeIndices.length;
          const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          let outerNode = linkedList(data, 0, outerLen, dim, true);
          const triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          let minX, minY, maxX, maxY, x2, y2, invSize;
          if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i2 = dim; i2 < outerLen; i2 += dim) {
              x2 = data[i2];
              y2 = data[i2 + 1];
              if (x2 < minX)
                minX = x2;
              if (y2 < minY)
                minY = y2;
              if (x2 > maxX)
                maxX = x2;
              if (y2 > maxY)
                maxY = y2;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
          }
          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
          return triangles;
        }
      };
      function linkedList(data, start, end, dim, clockwise) {
        let i2, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i2 = start; i2 < end; i2 += dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        } else {
          for (i2 = end - dim; i2 >= start; i2 -= dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        let p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        let stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        const a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        let p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        const a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
        const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        let p = ear.prevZ, n2 = ear.nextZ;
        while (p && p.z >= minZ && n2 && n2.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
          const a2 = p.prev, b2 = p.next.next;
          if (!equals(a2, b2) && intersects(a2, p, p.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b2.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b2;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        let a2 = start;
        do {
          let b2 = a2.next.next;
          while (b2 !== a2.prev) {
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
              let c2 = splitPolygon(a2, b2);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize);
              earcutLinked(c2, triangles, dim, minX, minY, invSize);
              return;
            }
            b2 = b2.next;
          }
          a2 = a2.next;
        } while (a2 !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        const queue = [];
        let i2, len, start, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i2 = 0; i2 < queue.length; i2++) {
          eliminateHole(queue[i2], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a2, b2) {
        return a2.x - b2.x;
      }
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          const b2 = splitPolygon(outerNode, hole);
          filterPoints(outerNode, outerNode.next);
          filterPoints(b2, b2.next);
        }
      }
      function findHoleBridge(hole, outerNode) {
        let p = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity, m2;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              if (x2 === hx) {
                if (hy === p.y)
                  return p;
                if (hy === p.next.y)
                  return p.next;
              }
              m2 = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m2)
          return null;
        if (hx === qx)
          return m2;
        const stop = m2, mx = m2.x, my = m2.y;
        let tanMin = Infinity, tan;
        p = m2;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
              m2 = p;
              tanMin = tan;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p) {
        return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        let p = start;
        do {
          if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        let i2, p, q2, e4, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q2 = p;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q2 = q2.nextZ;
              if (!q2)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q2) {
              if (pSize !== 0 && (qSize === 0 || !q2 || p.z <= q2.z)) {
                e4 = p;
                p = p.nextZ;
                pSize--;
              } else {
                e4 = q2;
                q2 = q2.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e4;
              else
                list = e4;
              e4.prevZ = tail;
              tail = e4;
            }
            p = q2;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = 32767 * (x2 - minX) * invSize;
        y2 = 32767 * (y2 - minY) * invSize;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        let p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
        return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
      }
      function isValidDiagonal(a2, b2) {
        return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
      }
      function area(p, q2, r2) {
        return (q2.y - p.y) * (r2.x - q2.x) - (q2.x - p.x) * (r2.y - q2.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        const o1 = sign(area(p1, q1, p2));
        const o2 = sign(area(p1, q1, q2));
        const o3 = sign(area(p2, q2, p1));
        const o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q2, r2) {
        return q2.x <= Math.max(p.x, r2.x) && q2.x >= Math.min(p.x, r2.x) && q2.y <= Math.max(p.y, r2.y) && q2.y >= Math.min(p.y, r2.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b2) {
        let p = a2;
        do {
          if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a2, b2))
            return true;
          p = p.next;
        } while (p !== a2);
        return false;
      }
      function locallyInside(a2, b2) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
      }
      function middleInside(a2, b2) {
        let p = a2, inside = false;
        const px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
        do {
          if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a2);
        return inside;
      }
      function splitPolygon(a2, b2) {
        const a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an2 = a2.next, bp2 = b2.prev;
        a2.next = b2;
        b2.prev = a2;
        a22.next = an2;
        an2.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp2.next = b22;
        b22.prev = bp2;
        return b22;
      }
      function insertNode(i2, x2, y2, last) {
        const p = new Node(i2, x2, y2);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i2, x2, y2) {
        this.i = i2;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      function signedArea(data, start, end, dim) {
        let sum = 0;
        for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
          sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
          j2 = i2;
        }
        return sum;
      }
      var ShapeUtils = class {
        static area(contour) {
          const n2 = contour.length;
          let a2 = 0;
          for (let p = n2 - 1, q2 = 0; q2 < n2; p = q2++) {
            a2 += contour[p].x * contour[q2].y - contour[q2].x * contour[p].y;
          }
          return a2 * 0.5;
        }
        static isClockWise(pts) {
          return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
          const vertices = [];
          const holeIndices = [];
          const faces = [];
          removeDupEndPts(contour);
          addContour(vertices, contour);
          let holeIndex = contour.length;
          holes.forEach(removeDupEndPts);
          for (let i2 = 0; i2 < holes.length; i2++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i2].length;
            addContour(vertices, holes[i2]);
          }
          const triangles = Earcut.triangulate(vertices, holeIndices);
          for (let i2 = 0; i2 < triangles.length; i2 += 3) {
            faces.push(triangles.slice(i2, i2 + 3));
          }
          return faces;
        }
      };
      function removeDupEndPts(points) {
        const l2 = points.length;
        if (l2 > 2 && points[l2 - 1].equals(points[0])) {
          points.pop();
        }
      }
      function addContour(vertices, contour) {
        for (let i2 = 0; i2 < contour.length; i2++) {
          vertices.push(contour[i2].x);
          vertices.push(contour[i2].y);
        }
      }
      var ExtrudeGeometry = class extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
          super();
          this.type = "ExtrudeGeometry";
          this.parameters = {
            shapes,
            options
          };
          shapes = Array.isArray(shapes) ? shapes : [shapes];
          const scope = this;
          const verticesArray = [];
          const uvArray = [];
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            addShape(shape);
          }
          this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
          this.computeVertexNormals();
          function addShape(shape) {
            const placeholder = [];
            const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
            const steps = options.steps !== void 0 ? options.steps : 1;
            let depth = options.depth !== void 0 ? options.depth : 1;
            let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
            let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
            let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
            if (options.amount !== void 0) {
              console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
              depth = options.amount;
            }
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector3();
              normal = new Vector3();
              position2 = new Vector3();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
                const ahole = holes[h2];
                if (ShapeUtils.isClockWise(ahole)) {
                  holes[h2] = ahole.reverse();
                }
              }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            const contour = vertices;
            for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
              const ahole = holes[h2];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt2, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt2);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              let v_trans_x, v_trans_y, shrink_by;
              const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                const sf2 = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf2 - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf2 - inPt.y;
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector2(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                let direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i2 = 0, il2 = contour.length, j2 = il2 - 1, k2 = i2 + 1; i2 < il2; i2++, j2++, k2++) {
              if (j2 === il2)
                j2 = 0;
              if (k2 === il2)
                k2 = 0;
              contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
              const ahole = holes[h2];
              oneHoleMovements = [];
              for (let i2 = 0, il2 = ahole.length, j2 = il2 - 1, k2 = i2 + 1; i2 < il2; i2++, j2++, k2++) {
                if (j2 === il2)
                  j2 = 0;
                if (k2 === il2)
                  k2 = 0;
                oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (let b2 = 0; b2 < bevelSegments; b2++) {
              const t2 = b2 / bevelSegments;
              const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
              const bs3 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il2 = contour.length; i2 < il2; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs3);
                v2(vert.x, vert.y, -z2);
              }
              for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
                const ahole = holes[h2];
                oneHoleMovements = holesMovements[h2];
                for (let i2 = 0, il2 = ahole.length; i2 < il2; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs3);
                  v2(vert.x, vert.y, -z2);
                }
              }
            }
            const bs2 = bevelSize + bevelOffset;
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs2) : vertices[i2];
              if (!extrudeByPath) {
                v2(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v2(position2.x, position2.y, position2.z);
              }
            }
            for (let s2 = 1; s2 <= steps; s2++) {
              for (let i2 = 0; i2 < vlen; i2++) {
                const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs2) : vertices[i2];
                if (!extrudeByPath) {
                  v2(vert.x, vert.y, depth / steps * s2);
                } else {
                  normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s2]).add(normal).add(binormal);
                  v2(position2.x, position2.y, position2.z);
                }
              }
            }
            for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
              const t2 = b2 / bevelSegments;
              const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
              const bs3 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il2 = contour.length; i2 < il2; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs3);
                v2(vert.x, vert.y, depth + z2);
              }
              for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
                const ahole = holes[h2];
                oneHoleMovements = holesMovements[h2];
                for (let i2 = 0, il2 = ahole.length; i2 < il2; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs3);
                  if (!extrudeByPath) {
                    v2(vert.x, vert.y, depth + z2);
                  } else {
                    v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              const start = verticesArray.length / 3;
              if (bevelEnabled) {
                let layer = 0;
                let offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2], face[1], face[0]);
                }
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
              const start = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
                const ahole = holes[h2];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour2, layeroffset) {
              let i2 = contour2.length;
              while (--i2 >= 0) {
                const j2 = i2;
                let k2 = i2 - 1;
                if (k2 < 0)
                  k2 = contour2.length - 1;
                for (let s2 = 0, sl2 = steps + bevelSegments * 2; s2 < sl2; s2++) {
                  const slen1 = vlen * s2;
                  const slen2 = vlen * (s2 + 1);
                  const a2 = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d = layeroffset + j2 + slen2;
                  f4(a2, b2, c2, d);
                }
              }
            }
            function v2(x2, y2, z2) {
              placeholder.push(x2);
              placeholder.push(y2);
              placeholder.push(z2);
            }
            function f3(a2, b2, c2) {
              addVertex(a2);
              addVertex(b2);
              addVertex(c2);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);
            }
            function f4(a2, b2, c2, d) {
              addVertex(a2);
              addVertex(b2);
              addVertex(d);
              addVertex(b2);
              addVertex(c2);
              addVertex(d);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);
              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);
            }
            function addVertex(index) {
              verticesArray.push(placeholder[index * 3 + 0]);
              verticesArray.push(placeholder[index * 3 + 1]);
              verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
              uvArray.push(vector2.x);
              uvArray.push(vector2.y);
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          const options = this.parameters.options;
          return toJSON$1(shapes, options, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j2 = 0, jl2 = data.shapes.length; j2 < jl2; j2++) {
            const shape = shapes[data.shapes[j2]];
            geometryShapes.push(shape);
          }
          const extrudePath = data.options.extrudePath;
          if (extrudePath !== void 0) {
            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
          }
          return new ExtrudeGeometry(geometryShapes, data.options);
        }
      };
      var WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];
          if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
          } else {
            return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
          }
        }
      };
      function toJSON$1(shapes, options, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        if (options.extrudePath !== void 0)
          data.options.extrudePath = options.extrudePath.toJSON();
        return data;
      }
      var IcosahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t2 = (1 + Math.sqrt(5)) / 2;
          const vertices = [-1, t2, 0, 1, t2, 0, -1, -t2, 0, 1, -t2, 0, 0, -1, t2, 0, 1, t2, 0, -1, -t2, 0, 1, -t2, t2, 0, -1, t2, 0, 1, -t2, 0, -1, -t2, 0, 1];
          const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
          super(vertices, indices, radius, detail);
          this.type = "IcosahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new IcosahedronGeometry(data.radius, data.detail);
        }
      };
      var LatheGeometry = class extends BufferGeometry {
        constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
          super();
          this.type = "LatheGeometry";
          this.parameters = {
            points,
            segments,
            phiStart,
            phiLength
          };
          segments = Math.floor(segments);
          phiLength = clamp(phiLength, 0, Math.PI * 2);
          const indices = [];
          const vertices = [];
          const uvs = [];
          const initNormals = [];
          const normals = [];
          const inverseSegments = 1 / segments;
          const vertex2 = new Vector3();
          const uv = new Vector2();
          const normal = new Vector3();
          const curNormal = new Vector3();
          const prevNormal = new Vector3();
          let dx = 0;
          let dy = 0;
          for (let j2 = 0; j2 <= points.length - 1; j2++) {
            switch (j2) {
              case 0:
                dx = points[j2 + 1].x - points[j2].x;
                dy = points[j2 + 1].y - points[j2].y;
                normal.x = dy * 1;
                normal.y = -dx;
                normal.z = dy * 0;
                prevNormal.copy(normal);
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                break;
              case points.length - 1:
                initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                break;
              default:
                dx = points[j2 + 1].x - points[j2].x;
                dy = points[j2 + 1].y - points[j2].y;
                normal.x = dy * 1;
                normal.y = -dx;
                normal.z = dy * 0;
                curNormal.copy(normal);
                normal.x += prevNormal.x;
                normal.y += prevNormal.y;
                normal.z += prevNormal.z;
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                prevNormal.copy(curNormal);
            }
          }
          for (let i2 = 0; i2 <= segments; i2++) {
            const phi = phiStart + i2 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for (let j2 = 0; j2 <= points.length - 1; j2++) {
              vertex2.x = points[j2].x * sin;
              vertex2.y = points[j2].y;
              vertex2.z = points[j2].x * cos;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              uv.x = i2 / segments;
              uv.y = j2 / (points.length - 1);
              uvs.push(uv.x, uv.y);
              const x2 = initNormals[3 * j2 + 0] * sin;
              const y2 = initNormals[3 * j2 + 1];
              const z2 = initNormals[3 * j2 + 0] * cos;
              normals.push(x2, y2, z2);
            }
          }
          for (let i2 = 0; i2 < segments; i2++) {
            for (let j2 = 0; j2 < points.length - 1; j2++) {
              const base = j2 + i2 * points.length;
              const a2 = base;
              const b2 = base + points.length;
              const c2 = base + points.length + 1;
              const d = base + 1;
              indices.push(a2, b2, d);
              indices.push(c2, d, b2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        }
        static fromJSON(data) {
          return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
        }
      };
      var OctahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
          const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
          super(vertices, indices, radius, detail);
          this.type = "OctahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new OctahedronGeometry(data.radius, data.detail);
        }
      };
      var RingGeometry = class extends BufferGeometry {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius,
            outerRadius,
            thetaSegments,
            phiSegments,
            thetaStart,
            thetaLength
          };
          thetaSegments = Math.max(3, thetaSegments);
          phiSegments = Math.max(1, phiSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let radius = innerRadius;
          const radiusStep = (outerRadius - innerRadius) / phiSegments;
          const vertex2 = new Vector3();
          const uv = new Vector2();
          for (let j2 = 0; j2 <= phiSegments; j2++) {
            for (let i2 = 0; i2 <= thetaSegments; i2++) {
              const segment = thetaStart + i2 / thetaSegments * thetaLength;
              vertex2.x = radius * Math.cos(segment);
              vertex2.y = radius * Math.sin(segment);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, 0, 1);
              uv.x = (vertex2.x / outerRadius + 1) / 2;
              uv.y = (vertex2.y / outerRadius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
          }
          for (let j2 = 0; j2 < phiSegments; j2++) {
            const thetaSegmentLevel = j2 * (thetaSegments + 1);
            for (let i2 = 0; i2 < thetaSegments; i2++) {
              const segment = i2 + thetaSegmentLevel;
              const a2 = segment;
              const b2 = segment + thetaSegments + 1;
              const c2 = segment + thetaSegments + 2;
              const d = segment + 1;
              indices.push(a2, b2, d);
              indices.push(b2, c2, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
      };
      var ShapeGeometry = class extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
          super();
          this.type = "ShapeGeometry";
          this.parameters = {
            shapes,
            curveSegments
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let groupStart = 0;
          let groupCount = 0;
          if (Array.isArray(shapes) === false) {
            addShape(shapes);
          } else {
            for (let i2 = 0; i2 < shapes.length; i2++) {
              addShape(shapes[i2]);
              this.addGroup(groupStart, groupCount, i2);
              groupStart += groupCount;
              groupCount = 0;
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
              shapeVertices = shapeVertices.reverse();
            }
            for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
              const shapeHole = shapeHoles[i2];
              if (ShapeUtils.isClockWise(shapeHole) === true) {
                shapeHoles[i2] = shapeHole.reverse();
              }
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
              const shapeHole = shapeHoles[i2];
              shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
              const vertex2 = shapeVertices[i2];
              vertices.push(vertex2.x, vertex2.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex2.x, vertex2.y);
            }
            for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
              const face = faces[i2];
              const a2 = face[0] + indexOffset;
              const b2 = face[1] + indexOffset;
              const c2 = face[2] + indexOffset;
              indices.push(a2, b2, c2);
              groupCount += 3;
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          return toJSON(shapes, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j2 = 0, jl2 = data.shapes.length; j2 < jl2; j2++) {
            const shape = shapes[data.shapes[j2]];
            geometryShapes.push(shape);
          }
          return new ShapeGeometry(geometryShapes, data.curveSegments);
        }
      };
      function toJSON(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        return data;
      }
      var SphereGeometry = class extends BufferGeometry {
        constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
          super();
          this.type = "SphereGeometry";
          this.parameters = {
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
          };
          widthSegments = Math.max(3, Math.floor(widthSegments));
          heightSegments = Math.max(2, Math.floor(heightSegments));
          const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
          let index = 0;
          const grid = [];
          const vertex2 = new Vector3();
          const normal = new Vector3();
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy <= heightSegments; iy++) {
            const verticesRow = [];
            const v2 = iy / heightSegments;
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
              uOffset = 0.5 / widthSegments;
            } else if (iy == heightSegments && thetaEnd == Math.PI) {
              uOffset = -0.5 / widthSegments;
            }
            for (let ix = 0; ix <= widthSegments; ix++) {
              const u2 = ix / widthSegments;
              vertex2.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
              vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
              vertex2.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.copy(vertex2).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u2 + uOffset, 1 - v2);
              verticesRow.push(index++);
            }
            grid.push(verticesRow);
          }
          for (let iy = 0; iy < heightSegments; iy++) {
            for (let ix = 0; ix < widthSegments; ix++) {
              const a2 = grid[iy][ix + 1];
              const b2 = grid[iy][ix];
              const c2 = grid[iy + 1][ix];
              const d = grid[iy + 1][ix + 1];
              if (iy !== 0 || thetaStart > 0)
                indices.push(a2, b2, d);
              if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                indices.push(b2, c2, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
        }
      };
      var TetrahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
          const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(vertices, indices, radius, detail);
          this.type = "TetrahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new TetrahedronGeometry(data.radius, data.detail);
        }
      };
      var TorusGeometry = class extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
          super();
          this.type = "TorusGeometry";
          this.parameters = {
            radius,
            tube,
            radialSegments,
            tubularSegments,
            arc
          };
          radialSegments = Math.floor(radialSegments);
          tubularSegments = Math.floor(tubularSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const center = new Vector3();
          const vertex2 = new Vector3();
          const normal = new Vector3();
          for (let j2 = 0; j2 <= radialSegments; j2++) {
            for (let i2 = 0; i2 <= tubularSegments; i2++) {
              const u2 = i2 / tubularSegments * arc;
              const v2 = j2 / radialSegments * Math.PI * 2;
              vertex2.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
              vertex2.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
              vertex2.z = tube * Math.sin(v2);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              center.x = radius * Math.cos(u2);
              center.y = radius * Math.sin(u2);
              normal.subVectors(vertex2, center).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i2 / tubularSegments);
              uvs.push(j2 / radialSegments);
            }
          }
          for (let j2 = 1; j2 <= radialSegments; j2++) {
            for (let i2 = 1; i2 <= tubularSegments; i2++) {
              const a2 = (tubularSegments + 1) * j2 + i2 - 1;
              const b2 = (tubularSegments + 1) * (j2 - 1) + i2 - 1;
              const c2 = (tubularSegments + 1) * (j2 - 1) + i2;
              const d = (tubularSegments + 1) * j2 + i2;
              indices.push(a2, b2, d);
              indices.push(b2, c2, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
        }
      };
      var TorusKnotGeometry = class extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q2 = 3) {
          super();
          this.type = "TorusKnotGeometry";
          this.parameters = {
            radius,
            tube,
            tubularSegments,
            radialSegments,
            p,
            q: q2
          };
          tubularSegments = Math.floor(tubularSegments);
          radialSegments = Math.floor(radialSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex2 = new Vector3();
          const normal = new Vector3();
          const P1 = new Vector3();
          const P2 = new Vector3();
          const B2 = new Vector3();
          const T2 = new Vector3();
          const N2 = new Vector3();
          for (let i2 = 0; i2 <= tubularSegments; ++i2) {
            const u2 = i2 / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u2, p, q2, radius, P1);
            calculatePositionOnCurve(u2 + 0.01, p, q2, radius, P2);
            T2.subVectors(P2, P1);
            N2.addVectors(P2, P1);
            B2.crossVectors(T2, N2);
            N2.crossVectors(B2, T2);
            B2.normalize();
            N2.normalize();
            for (let j2 = 0; j2 <= radialSegments; ++j2) {
              const v2 = j2 / radialSegments * Math.PI * 2;
              const cx = -tube * Math.cos(v2);
              const cy = tube * Math.sin(v2);
              vertex2.x = P1.x + (cx * N2.x + cy * B2.x);
              vertex2.y = P1.y + (cx * N2.y + cy * B2.y);
              vertex2.z = P1.z + (cx * N2.z + cy * B2.z);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.subVectors(vertex2, P1).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i2 / tubularSegments);
              uvs.push(j2 / radialSegments);
            }
          }
          for (let j2 = 1; j2 <= tubularSegments; j2++) {
            for (let i2 = 1; i2 <= radialSegments; i2++) {
              const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
              const b2 = (radialSegments + 1) * j2 + (i2 - 1);
              const c2 = (radialSegments + 1) * j2 + i2;
              const d = (radialSegments + 1) * (j2 - 1) + i2;
              indices.push(a2, b2, d);
              indices.push(b2, c2, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function calculatePositionOnCurve(u2, p2, q3, radius2, position) {
            const cu2 = Math.cos(u2);
            const su2 = Math.sin(u2);
            const quOverP = q3 / p2 * u2;
            const cs2 = Math.cos(quOverP);
            position.x = radius2 * (2 + cs2) * 0.5 * cu2;
            position.y = radius2 * (2 + cs2) * su2 * 0.5;
            position.z = radius2 * Math.sin(quOverP) * 0.5;
          }
        }
        static fromJSON(data) {
          return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
        }
      };
      var TubeGeometry = class extends BufferGeometry {
        constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
          super();
          this.type = "TubeGeometry";
          this.parameters = {
            path,
            tubularSegments,
            radius,
            radialSegments,
            closed
          };
          const frames = path.computeFrenetFrames(tubularSegments, closed);
          this.tangents = frames.tangents;
          this.normals = frames.normals;
          this.binormals = frames.binormals;
          const vertex2 = new Vector3();
          const normal = new Vector3();
          const uv = new Vector2();
          let P2 = new Vector3();
          const vertices = [];
          const normals = [];
          const uvs = [];
          const indices = [];
          generateBufferData();
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function generateBufferData() {
            for (let i2 = 0; i2 < tubularSegments; i2++) {
              generateSegment(i2);
            }
            generateSegment(closed === false ? tubularSegments : 0);
            generateUVs();
            generateIndices();
          }
          function generateSegment(i2) {
            P2 = path.getPointAt(i2 / tubularSegments, P2);
            const N2 = frames.normals[i2];
            const B2 = frames.binormals[i2];
            for (let j2 = 0; j2 <= radialSegments; j2++) {
              const v2 = j2 / radialSegments * Math.PI * 2;
              const sin = Math.sin(v2);
              const cos = -Math.cos(v2);
              normal.x = cos * N2.x + sin * B2.x;
              normal.y = cos * N2.y + sin * B2.y;
              normal.z = cos * N2.z + sin * B2.z;
              normal.normalize();
              normals.push(normal.x, normal.y, normal.z);
              vertex2.x = P2.x + radius * normal.x;
              vertex2.y = P2.y + radius * normal.y;
              vertex2.z = P2.z + radius * normal.z;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
            }
          }
          function generateIndices() {
            for (let j2 = 1; j2 <= tubularSegments; j2++) {
              for (let i2 = 1; i2 <= radialSegments; i2++) {
                const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
                const b2 = (radialSegments + 1) * j2 + (i2 - 1);
                const c2 = (radialSegments + 1) * j2 + i2;
                const d = (radialSegments + 1) * (j2 - 1) + i2;
                indices.push(a2, b2, d);
                indices.push(b2, c2, d);
              }
            }
          }
          function generateUVs() {
            for (let i2 = 0; i2 <= tubularSegments; i2++) {
              for (let j2 = 0; j2 <= radialSegments; j2++) {
                uv.x = i2 / tubularSegments;
                uv.y = j2 / radialSegments;
                uvs.push(uv.x, uv.y);
              }
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          data.path = this.parameters.path.toJSON();
          return data;
        }
        static fromJSON(data) {
          return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
        }
      };
      var WireframeGeometry = class extends BufferGeometry {
        constructor(geometry = null) {
          super();
          this.type = "WireframeGeometry";
          this.parameters = {
            geometry
          };
          if (geometry !== null) {
            const vertices = [];
            const edges = /* @__PURE__ */ new Set();
            const start = new Vector3();
            const end = new Vector3();
            if (geometry.index !== null) {
              const position = geometry.attributes.position;
              const indices = geometry.index;
              let groups = geometry.groups;
              if (groups.length === 0) {
                groups = [{
                  start: 0,
                  count: indices.count,
                  materialIndex: 0
                }];
              }
              for (let o2 = 0, ol2 = groups.length; o2 < ol2; ++o2) {
                const group = groups[o2];
                const groupStart = group.start;
                const groupCount = group.count;
                for (let i2 = groupStart, l2 = groupStart + groupCount; i2 < l2; i2 += 3) {
                  for (let j2 = 0; j2 < 3; j2++) {
                    const index1 = indices.getX(i2 + j2);
                    const index2 = indices.getX(i2 + (j2 + 1) % 3);
                    start.fromBufferAttribute(position, index1);
                    end.fromBufferAttribute(position, index2);
                    if (isUniqueEdge(start, end, edges) === true) {
                      vertices.push(start.x, start.y, start.z);
                      vertices.push(end.x, end.y, end.z);
                    }
                  }
                }
              }
            } else {
              const position = geometry.attributes.position;
              for (let i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
                for (let j2 = 0; j2 < 3; j2++) {
                  const index1 = 3 * i2 + j2;
                  const index2 = 3 * i2 + (j2 + 1) % 3;
                  start.fromBufferAttribute(position, index1);
                  end.fromBufferAttribute(position, index2);
                  if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
            this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          }
        }
      };
      function isUniqueEdge(start, end, edges) {
        const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
        const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
        if (edges.has(hash1) === true || edges.has(hash2) === true) {
          return false;
        } else {
          edges.add(hash1);
          edges.add(hash2);
          return true;
        }
      }
      var Geometries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BoxGeometry,
        BoxBufferGeometry: BoxGeometry,
        CircleGeometry,
        CircleBufferGeometry: CircleGeometry,
        ConeGeometry,
        ConeBufferGeometry: ConeGeometry,
        CylinderGeometry,
        CylinderBufferGeometry: CylinderGeometry,
        DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronGeometry,
        EdgesGeometry,
        ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeGeometry,
        IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronGeometry,
        LatheGeometry,
        LatheBufferGeometry: LatheGeometry,
        OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronGeometry,
        PlaneGeometry,
        PlaneBufferGeometry: PlaneGeometry,
        PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronGeometry,
        RingGeometry,
        RingBufferGeometry: RingGeometry,
        ShapeGeometry,
        ShapeBufferGeometry: ShapeGeometry,
        SphereGeometry,
        SphereBufferGeometry: SphereGeometry,
        TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronGeometry,
        TorusGeometry,
        TorusBufferGeometry: TorusGeometry,
        TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotGeometry,
        TubeGeometry,
        TubeBufferGeometry: TubeGeometry,
        WireframeGeometry
      });
      var ShadowMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "ShadowMaterial";
          this.color = new Color(0);
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          return this;
        }
      };
      ShadowMaterial.prototype.isShadowMaterial = true;
      var RawShaderMaterial = class extends ShaderMaterial {
        constructor(parameters) {
          super(parameters);
          this.type = "RawShaderMaterial";
        }
      };
      RawShaderMaterial.prototype.isRawShaderMaterial = true;
      var MeshStandardMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": ""
          };
          this.type = "MeshStandardMaterial";
          this.color = new Color(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": ""
          };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
      var MeshPhysicalMaterial = class extends MeshStandardMaterial {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector2(1, 1);
          this.clearcoatNormalMap = null;
          this.ior = 1.5;
          Object.defineProperty(this, "reflectivity", {
            get: function() {
              return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
              this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
          });
          this.sheenColor = new Color(0);
          this.sheenColorMap = null;
          this.sheenRoughness = 1;
          this.sheenRoughnessMap = null;
          this.transmissionMap = null;
          this.thickness = 0;
          this.thicknessMap = null;
          this.attenuationDistance = 0;
          this.attenuationColor = new Color(1, 1, 1);
          this.specularIntensity = 1;
          this.specularIntensityMap = null;
          this.specularColor = new Color(1, 1, 1);
          this.specularColorMap = null;
          this._sheen = 0;
          this._clearcoat = 0;
          this._transmission = 0;
          this.setValues(parameters);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(value) {
          if (this._sheen > 0 !== value > 0) {
            this.version++;
          }
          this._sheen = value;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(value) {
          if (this._clearcoat > 0 !== value > 0) {
            this.version++;
          }
          this._clearcoat = value;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(value) {
          if (this._transmission > 0 !== value > 0) {
            this.version++;
          }
          this._transmission = value;
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.ior = source.ior;
          this.sheen = source.sheen;
          this.sheenColor.copy(source.sheenColor);
          this.sheenColorMap = source.sheenColorMap;
          this.sheenRoughness = source.sheenRoughness;
          this.sheenRoughnessMap = source.sheenRoughnessMap;
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          this.specularIntensity = source.specularIntensity;
          this.specularIntensityMap = source.specularIntensityMap;
          this.specularColor.copy(source.specularColor);
          this.specularColorMap = source.specularColorMap;
          return this;
        }
      };
      MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
      var MeshPhongMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshPhongMaterial";
          this.color = new Color(16777215);
          this.specular = new Color(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
      var MeshToonMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "TOON": ""
          };
          this.type = "MeshToonMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.gradientMap = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.gradientMap = source.gradientMap;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshToonMaterial.prototype.isMeshToonMaterial = true;
      var MeshNormalMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
      var MeshLambertMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshLambertMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
      var MeshMatcapMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "MATCAP": ""
          };
          this.type = "MeshMatcapMaterial";
          this.color = new Color(16777215);
          this.matcap = null;
          this.map = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "MATCAP": ""
          };
          this.color.copy(source.color);
          this.matcap = source.matcap;
          this.map = source.map;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
      var LineDashedMaterial = class extends LineBasicMaterial {
        constructor(parameters) {
          super();
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.scale = source.scale;
          this.dashSize = source.dashSize;
          this.gapSize = source.gapSize;
          return this;
        }
      };
      LineDashedMaterial.prototype.isLineDashedMaterial = true;
      var materialLib = {
        ShadowMaterial,
        SpriteMaterial,
        RawShaderMaterial,
        ShaderMaterial,
        PointsMaterial,
        MeshPhysicalMaterial,
        MeshStandardMaterial,
        MeshPhongMaterial,
        MeshToonMaterial,
        MeshNormalMaterial,
        MeshLambertMaterial,
        MeshDepthMaterial,
        MeshDistanceMaterial,
        MeshBasicMaterial,
        MeshMatcapMaterial,
        LineDashedMaterial,
        LineBasicMaterial,
        Material
      };
      Material.fromType = function(type) {
        return new materialLib[type]();
      };
      var AnimationUtils = {
        arraySlice: function(array, from, to2) {
          if (AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to2 !== void 0 ? to2 : array.length));
          }
          return array.slice(from, to2);
        },
        convertArray: function(array, type, forceClone) {
          if (!array || !forceClone && array.constructor === type)
            return array;
          if (typeof type.BYTES_PER_ELEMENT === "number") {
            return new type(array);
          }
          return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
          return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
          function compareTime(i2, j2) {
            return times[i2] - times[j2];
          }
          const n2 = times.length;
          const result = new Array(n2);
          for (let i2 = 0; i2 !== n2; ++i2)
            result[i2] = i2;
          result.sort(compareTime);
          return result;
        },
        sortedArray: function(values, stride, order) {
          const nValues = values.length;
          const result = new values.constructor(nValues);
          for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
            const srcOffset = order[i2] * stride;
            for (let j2 = 0; j2 !== stride; ++j2) {
              result[dstOffset++] = values[srcOffset + j2];
            }
          }
          return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
          let i2 = 1, key = jsonKeys[0];
          while (key !== void 0 && key[valuePropertyName] === void 0) {
            key = jsonKeys[i2++];
          }
          if (key === void 0)
            return;
          let value = key[valuePropertyName];
          if (value === void 0)
            return;
          if (Array.isArray(value)) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push.apply(values, value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else if (value.toArray !== void 0) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                value.toArray(values, values.length);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push(value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          }
        },
        subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
          const clip = sourceClip.clone();
          clip.name = name;
          const tracks = [];
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            const track = clip.tracks[i2];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for (let j2 = 0; j2 < track.times.length; ++j2) {
              const frame = track.times[j2] * fps;
              if (frame < startFrame || frame >= endFrame)
                continue;
              times.push(track.times[j2]);
              for (let k2 = 0; k2 < valueSize; ++k2) {
                values.push(track.values[j2 * valueSize + k2]);
              }
            }
            if (times.length === 0)
              continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
          }
          clip.tracks = tracks;
          let minStartTime = Infinity;
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            if (minStartTime > clip.tracks[i2].times[0]) {
              minStartTime = clip.tracks[i2].times[0];
            }
          }
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            clip.tracks[i2].shift(-1 * minStartTime);
          }
          clip.resetDuration();
          return clip;
        },
        makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
          if (fps <= 0)
            fps = 30;
          const numTracks = referenceClip.tracks.length;
          const referenceTime = referenceFrame / fps;
          for (let i2 = 0; i2 < numTracks; ++i2) {
            const referenceTrack = referenceClip.tracks[i2];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === "bool" || referenceTrackType === "string")
              continue;
            const targetTrack = targetClip.tracks.find(function(track) {
              return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === void 0)
              continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
              const startIndex = lastIndex * referenceValueSize + referenceOffset;
              const endIndex = startIndex + referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
              const interpolant = referenceTrack.createInterpolant();
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              interpolant.evaluate(referenceTime);
              referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            if (referenceTrackType === "quaternion") {
              const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
              referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for (let j2 = 0; j2 < numTimes; ++j2) {
              const valueStart = j2 * targetValueSize + targetOffset;
              if (referenceTrackType === "quaternion") {
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
              } else {
                const valueEnd = targetValueSize - targetOffset * 2;
                for (let k2 = 0; k2 < valueEnd; ++k2) {
                  targetTrack.values[valueStart + k2] -= referenceValue[k2];
                }
              }
            }
          }
          targetClip.blendMode = AdditiveAnimationBlendMode;
          return targetClip;
        }
      };
      var Interpolant = class {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t2) {
          const pp2 = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp2[i1], t0 = pp2[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t2 < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t2 < t0)
                          break forward_scan;
                        i1 = pp2.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t2, t0);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp2[++i1];
                      if (t2 < t1) {
                        break seek;
                      }
                    }
                    right = pp2.length;
                    break linear_scan;
                  }
                if (!(t2 >= t0)) {
                  const t1global = pp2[1];
                  if (t2 < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.beforeStart_(0, t2, t1);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp2[--i1 - 1];
                    if (t2 >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t2 < pp2[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp2[i1];
              t0 = pp2[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (t1 === void 0) {
                i1 = pp2.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t0, t2);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t2, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset + i2];
          }
          return result;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      };
      Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
      Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
      var CubicInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp2 = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp2[iPrev], tNext = pp2[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding:
                iPrev = pp2.length - 2;
                tPrev = t0 + pp2[iPrev] - pp2[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp2[1] - pp2[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t2, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t2 - t0) / (t1 - t0), pp2 = p * p, ppp = pp2 * p;
          const sP = -wP * ppp + 2 * wP * pp2 - wP * p;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp2 + (-0.5 + wP) * p + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp2 + 0.5 * p;
          const sN = wN * ppp - wN * pp2;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
          }
          return result;
        }
      };
      var LinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t2, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
          }
          return result;
        }
      };
      var DiscreteInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      };
      var KeyframeTrack = class {
        constructor(name, times, values, interpolation) {
          if (name === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
          this.name = name;
          this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
          this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": AnimationUtils.convertArray(track.times, Array),
              "values": AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
              times[i2] += timeOffset;
            }
          }
          return this;
        }
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
              times[i2] *= timeScale;
            }
          }
          return this;
        }
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to2 = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to2 !== -1 && times[to2] > endTime) {
            --to2;
          }
          ++to2;
          if (from !== 0 || to2 !== nKeys) {
            if (from >= to2) {
              to2 = Math.max(to2, 1);
              from = to2 - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to2);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to2 * stride);
          }
          return this;
        }
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i2 = 0; i2 !== nKeys; i2++) {
            const currTime = times[i2];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values !== void 0) {
            if (AnimationUtils.isTypedArray(values)) {
              for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
                const value = values[i2];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        optimize() {
          const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i2 = 1; i2 < lastIndex; ++i2) {
            let keep = false;
            const time = times[i2];
            const timeNext = times[i2 + 1];
            if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j2 = 0; j2 !== stride; ++j2) {
                  const value = values[offset + j2];
                  if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i2 !== writeIndex) {
                times[writeIndex] = times[i2];
                const readOffset = i2 * stride, writeOffset = writeIndex * stride;
                for (let j2 = 0; j2 !== stride; ++j2) {
                  values[writeOffset + j2] = values[readOffset + j2];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
              values[writeOffset + j2] = values[readOffset + j2];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values;
          }
          return this;
        }
        clone() {
          const times = AnimationUtils.arraySlice(this.times, 0);
          const values = AnimationUtils.arraySlice(this.values, 0);
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      };
      KeyframeTrack.prototype.TimeBufferType = Float32Array;
      KeyframeTrack.prototype.ValueBufferType = Float32Array;
      KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      var BooleanKeyframeTrack = class extends KeyframeTrack {
      };
      BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      var ColorKeyframeTrack = class extends KeyframeTrack {
      };
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      var NumberKeyframeTrack = class extends KeyframeTrack {
      };
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      var QuaternionLinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t2, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
          }
          return result;
        }
      };
      var QuaternionKeyframeTrack = class extends KeyframeTrack {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
      };
      QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      var StringKeyframeTrack = class extends KeyframeTrack {
      };
      StringKeyframeTrack.prototype.ValueTypeName = "string";
      StringKeyframeTrack.prototype.ValueBufferType = Array;
      StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      var VectorKeyframeTrack = class extends KeyframeTrack {
      };
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      var AnimationClip = class {
        constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
          this.name = name;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
            tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i2 = 0; i2 < numMorphTargets; i2++) {
            let times = [];
            let values = [];
            times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
          }
          return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o2 = objectOrClipArray;
            clipArray = o2.geometry && o2.geometry.animations || o2.animations;
          }
          for (let i2 = 0; i2 < clipArray.length; i2++) {
            if (clipArray[i2].name === name) {
              return clipArray[i2];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i2 = 0, il2 = morphTargets.length; i2 < il2; i2++) {
            const morphTarget = morphTargets[i2];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name = parts[1];
              let animationMorphTargets = animationToMorphTargets[name];
              if (!animationMorphTargets) {
                animationToMorphTargets[name] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
          }
          return clips;
        }
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values = [];
              AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
            const animationKeys = hierarchyTracks[h2].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k2;
              for (k2 = 0; k2 < animationKeys.length; k2++) {
                if (animationKeys[k2].morphTargets) {
                  for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
                    morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values = [];
                for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
                  const animationKey = animationKeys[k2];
                  times.push(animationKey.time);
                  values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
              }
              duration = morphTargetNames.length * fps;
            } else {
              const boneName = ".bones[" + bones[h2].name + "]";
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
              addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
            const track = this.tracks[i2];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            valid = valid && this.tracks[i2].validate();
          }
          return valid;
        }
        optimize() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            tracks.push(this.tracks[i2].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      };
      function getTrackTypeForValueTypeName(typeName) {
        switch (typeName.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return NumberKeyframeTrack;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return VectorKeyframeTrack;
          case "color":
            return ColorKeyframeTrack;
          case "quaternion":
            return QuaternionKeyframeTrack;
          case "bool":
          case "boolean":
            return BooleanKeyframeTrack;
          case "string":
            return StringKeyframeTrack;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
      }
      function parseKeyframeTrack(json) {
        if (json.type === void 0) {
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        }
        const trackType = getTrackTypeForValueTypeName(json.type);
        if (json.times === void 0) {
          const times = [], values = [];
          AnimationUtils.flattenJSON(json.keys, times, values, "value");
          json.times = times;
          json.values = values;
        }
        if (trackType.parse !== void 0) {
          return trackType.parse(json);
        } else {
          return new trackType(json.name, json.times, json.values, json.interpolation);
        }
      }
      var Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      var LoadingManager = class {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
          };
          this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
              const regex = handlers[i2];
              const loader = handlers[i2 + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader;
              }
            }
            return null;
          };
        }
      };
      var DefaultLoadingManager = new LoadingManager();
      var Loader = class {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      };
      var loading = {};
      var FileLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const cached = Cache.get(url);
          if (cached !== void 0) {
            this.manager.itemStart(url);
            setTimeout(() => {
              if (onLoad)
                onLoad(cached);
              this.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading[url] !== void 0) {
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          loading[url] = [];
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          });
          const mimeType = this.mimeType;
          const responseType = this.responseType;
          fetch(req).then((response) => {
            if (response.status === 200 || response.status === 0) {
              if (response.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
                return response;
              }
              const callbacks = loading[url];
              const reader = response.body.getReader();
              const contentLength = response.headers.get("Content-Length");
              const total = contentLength ? parseInt(contentLength) : 0;
              const lengthComputable = total !== 0;
              let loaded = 0;
              const stream = new ReadableStream({
                start(controller) {
                  readData();
                  function readData() {
                    reader.read().then(({
                      done,
                      value
                    }) => {
                      if (done) {
                        controller.close();
                      } else {
                        loaded += value.byteLength;
                        const event = new ProgressEvent("progress", {
                          lengthComputable,
                          loaded,
                          total
                        });
                        for (let i2 = 0, il2 = callbacks.length; i2 < il2; i2++) {
                          const callback = callbacks[i2];
                          if (callback.onProgress)
                            callback.onProgress(event);
                        }
                        controller.enqueue(value);
                        readData();
                      }
                    });
                  }
                }
              });
              return new Response(stream);
            } else {
              throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
            }
          }).then((response) => {
            switch (responseType) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "document":
                return response.text().then((text) => {
                  const parser = new DOMParser();
                  return parser.parseFromString(text, mimeType);
                });
              case "json":
                return response.json();
              default:
                if (mimeType === void 0) {
                  return response.text();
                } else {
                  const re2 = /charset="?([^;"\s]*)"?/i;
                  const exec = re2.exec(mimeType);
                  const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                  const decoder = new TextDecoder(label);
                  return response.arrayBuffer().then((ab) => decoder.decode(ab));
                }
            }
          }).then((data) => {
            Cache.add(url, data);
            const callbacks = loading[url];
            delete loading[url];
            for (let i2 = 0, il2 = callbacks.length; i2 < il2; i2++) {
              const callback = callbacks[i2];
              if (callback.onLoad)
                callback.onLoad(data);
            }
          }).catch((err) => {
            const callbacks = loading[url];
            if (callbacks === void 0) {
              this.manager.itemError(url);
              throw err;
            }
            delete loading[url];
            for (let i2 = 0, il2 = callbacks.length; i2 < il2; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(err);
            }
            this.manager.itemError(url);
          }).finally(() => {
            this.manager.itemEnd(url);
          });
          this.manager.itemStart(url);
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      };
      var AnimationLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e4) {
              if (onError) {
                onError(e4);
              } else {
                console.error(e4);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const animations = [];
          for (let i2 = 0; i2 < json.length; i2++) {
            const clip = AnimationClip.parse(json[i2]);
            animations.push(clip);
          }
          return animations;
        }
      };
      var CompressedTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const images = [];
          const texture = new CompressedTexture();
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          let loaded = 0;
          function loadTexture(i2) {
            loader.load(url[i2], function(buffer) {
              const texDatas = scope.parse(buffer, true);
              images[i2] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = LinearFilter;
                texture.image = images;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          }
          if (Array.isArray(url)) {
            for (let i2 = 0, il2 = url.length; i2 < il2; ++i2) {
              loadTexture(i2);
            }
          } else {
            loader.load(url, function(buffer) {
              const texDatas = scope.parse(buffer, true);
              if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for (let f = 0; f < faces; f++) {
                  images[f] = {
                    mipmaps: []
                  };
                  for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
                    images[f].format = texDatas.format;
                    images[f].width = texDatas.width;
                    images[f].height = texDatas.height;
                  }
                }
                texture.image = images;
              } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
              }
              if (texDatas.mipmapCount === 1) {
                texture.minFilter = LinearFilter;
              }
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }, onProgress, onError);
          }
          return texture;
        }
      };
      var ImageLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = createElementNS("img");
          function onImageLoad() {
            removeEventListeners();
            Cache.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            removeEventListeners();
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.slice(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      };
      var CubeTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
          const texture = new CubeTexture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          let loaded = 0;
          function loadTexture(i2) {
            loader.load(urls[i2], function(image) {
              texture.images[i2] = image;
              loaded++;
              if (loaded === 6) {
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, void 0, onError);
          }
          for (let i2 = 0; i2 < urls.length; ++i2) {
            loadTexture(i2);
          }
          return texture;
        }
      };
      var DataTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const texture = new DataTexture();
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setPath(this.path);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData)
              return;
            if (texData.image !== void 0) {
              texture.image = texData.image;
            } else if (texData.data !== void 0) {
              texture.image.width = texData.width;
              texture.image.height = texData.height;
              texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
            if (texData.encoding !== void 0) {
              texture.encoding = texData.encoding;
            }
            if (texData.flipY !== void 0) {
              texture.flipY = texData.flipY;
            }
            if (texData.format !== void 0) {
              texture.format = texData.format;
            }
            if (texData.type !== void 0) {
              texture.type = texData.type;
            }
            if (texData.mipmaps !== void 0) {
              texture.mipmaps = texData.mipmaps;
              texture.minFilter = LinearMipmapLinearFilter;
            }
            if (texData.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            if (texData.generateMipmaps !== void 0) {
              texture.generateMipmaps = texData.generateMipmaps;
            }
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture, texData);
          }, onProgress, onError);
          return texture;
        }
      };
      var TextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          loader.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      };
      var Light = class extends Object3D {
        constructor(color, intensity = 1) {
          super();
          this.type = "Light";
          this.color = new Color(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      };
      Light.prototype.isLight = true;
      var HemisphereLight = class extends Light {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.type = "HemisphereLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.groundColor = new Color(groundColor);
        }
        copy(source) {
          Light.prototype.copy.call(this, source);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      };
      HemisphereLight.prototype.isHemisphereLight = true;
      var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
      var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
      var _lookTarget$1 = /* @__PURE__ */ new Vector3();
      var LightShadow = class {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.blurSamples = 8;
          this.mapSize = new Vector2(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix4();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum();
          this._frameExtents = new Vector2(1, 1);
          this._viewportCount = 1;
          this._viewports = [new Vector4(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$1);
          _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$1);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
          shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      };
      var SpotLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(50, 1, 0.5, 500));
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov2 = RAD2DEG * 2 * light.angle * this.focus;
          const aspect2 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      };
      SpotLightShadow.prototype.isSpotLightShadow = true;
      var SpotLight = class extends Light {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
          super(color, intensity);
          this.type = "SpotLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D();
          this.distance = distance;
          this.angle = angle;
          this.penumbra = penumbra;
          this.decay = decay;
          this.shadow = new SpotLightShadow();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      SpotLight.prototype.isSpotLight = true;
      var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
      var _lightPositionWorld = /* @__PURE__ */ new Vector3();
      var _lookTarget = /* @__PURE__ */ new Vector3();
      var PointLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(90, 1, 0.5, 500));
          this._frameExtents = new Vector2(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new Vector4(2, 1, 1, 1),
            new Vector4(0, 1, 1, 1),
            new Vector4(3, 1, 1, 1),
            new Vector4(1, 1, 1, 1),
            new Vector4(3, 0, 1, 1),
            new Vector4(1, 0, 1, 1)
          ];
          this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
          this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld);
          _lookTarget.copy(camera.position);
          _lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix);
        }
      };
      PointLightShadow.prototype.isPointLightShadow = true;
      var PointLight = class extends Light {
        constructor(color, intensity, distance = 0, decay = 1) {
          super(color, intensity);
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      PointLight.prototype.isPointLight = true;
      var DirectionalLightShadow = class extends LightShadow {
        constructor() {
          super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
        }
      };
      DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
      var DirectionalLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "DirectionalLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D();
          this.shadow = new DirectionalLightShadow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      DirectionalLight.prototype.isDirectionalLight = true;
      var AmbientLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "AmbientLight";
        }
      };
      AmbientLight.prototype.isAmbientLight = true;
      var RectAreaLight = class extends Light {
        constructor(color, intensity, width = 10, height = 10) {
          super(color, intensity);
          this.type = "RectAreaLight";
          this.width = width;
          this.height = height;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(power) {
          this.intensity = power / (this.width * this.height * Math.PI);
        }
        copy(source) {
          super.copy(source);
          this.width = source.width;
          this.height = source.height;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.width = this.width;
          data.object.height = this.height;
          return data;
        }
      };
      RectAreaLight.prototype.isRectAreaLight = true;
      var SphericalHarmonics3 = class {
        constructor() {
          this.coefficients = [];
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients.push(new Vector3());
          }
        }
        set(coefficients) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].copy(coefficients[i2]);
          }
          return this;
        }
        zero() {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].set(0, 0, 0);
          }
          return this;
        }
        getAt(normal, target) {
          const x2 = normal.x, y2 = normal.y, z2 = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.282095);
          target.addScaledVector(coeff[1], 0.488603 * y2);
          target.addScaledVector(coeff[2], 0.488603 * z2);
          target.addScaledVector(coeff[3], 0.488603 * x2);
          target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
          target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
          target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
          target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
          target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
          return target;
        }
        getIrradianceAt(normal, target) {
          const x2 = normal.x, y2 = normal.y, z2 = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.886227);
          target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
          target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
          target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
          target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
          target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
          target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
          target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
          target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
          return target;
        }
        add(sh2) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].add(sh2.coefficients[i2]);
          }
          return this;
        }
        addScaledSH(sh2, s2) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].addScaledVector(sh2.coefficients[i2], s2);
          }
          return this;
        }
        scale(s2) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].multiplyScalar(s2);
          }
          return this;
        }
        lerp(sh2, alpha) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].lerp(sh2.coefficients[i2], alpha);
          }
          return this;
        }
        equals(sh2) {
          for (let i2 = 0; i2 < 9; i2++) {
            if (!this.coefficients[i2].equals(sh2.coefficients[i2])) {
              return false;
            }
          }
          return true;
        }
        copy(sh2) {
          return this.set(sh2.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].fromArray(array, offset + i2 * 3);
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].toArray(array, offset + i2 * 3);
          }
          return array;
        }
        static getBasisAt(normal, shBasis) {
          const x2 = normal.x, y2 = normal.y, z2 = normal.z;
          shBasis[0] = 0.282095;
          shBasis[1] = 0.488603 * y2;
          shBasis[2] = 0.488603 * z2;
          shBasis[3] = 0.488603 * x2;
          shBasis[4] = 1.092548 * x2 * y2;
          shBasis[5] = 1.092548 * y2 * z2;
          shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
          shBasis[7] = 1.092548 * x2 * z2;
          shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
        }
      };
      SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
      var LightProbe = class extends Light {
        constructor(sh2 = new SphericalHarmonics3(), intensity = 1) {
          super(void 0, intensity);
          this.sh = sh2;
        }
        copy(source) {
          super.copy(source);
          this.sh.copy(source.sh);
          return this;
        }
        fromJSON(json) {
          this.intensity = json.intensity;
          this.sh.fromArray(json.sh);
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.sh = this.sh.toArray();
          return data;
        }
      };
      LightProbe.prototype.isLightProbe = true;
      var MaterialLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.textures = {};
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e4) {
              if (onError) {
                onError(e4);
              } else {
                console.error(e4);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const textures = this.textures;
          function getTexture(name) {
            if (textures[name] === void 0) {
              console.warn("THREE.MaterialLoader: Undefined texture", name);
            }
            return textures[name];
          }
          const material = Material.fromType(json.type);
          if (json.uuid !== void 0)
            material.uuid = json.uuid;
          if (json.name !== void 0)
            material.name = json.name;
          if (json.color !== void 0 && material.color !== void 0)
            material.color.setHex(json.color);
          if (json.roughness !== void 0)
            material.roughness = json.roughness;
          if (json.metalness !== void 0)
            material.metalness = json.metalness;
          if (json.sheen !== void 0)
            material.sheen = json.sheen;
          if (json.sheenColor !== void 0)
            material.sheenColor = new Color().setHex(json.sheenColor);
          if (json.sheenRoughness !== void 0)
            material.sheenRoughness = json.sheenRoughness;
          if (json.emissive !== void 0 && material.emissive !== void 0)
            material.emissive.setHex(json.emissive);
          if (json.specular !== void 0 && material.specular !== void 0)
            material.specular.setHex(json.specular);
          if (json.specularIntensity !== void 0)
            material.specularIntensity = json.specularIntensity;
          if (json.specularColor !== void 0 && material.specularColor !== void 0)
            material.specularColor.setHex(json.specularColor);
          if (json.shininess !== void 0)
            material.shininess = json.shininess;
          if (json.clearcoat !== void 0)
            material.clearcoat = json.clearcoat;
          if (json.clearcoatRoughness !== void 0)
            material.clearcoatRoughness = json.clearcoatRoughness;
          if (json.transmission !== void 0)
            material.transmission = json.transmission;
          if (json.thickness !== void 0)
            material.thickness = json.thickness;
          if (json.attenuationDistance !== void 0)
            material.attenuationDistance = json.attenuationDistance;
          if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
            material.attenuationColor.setHex(json.attenuationColor);
          if (json.fog !== void 0)
            material.fog = json.fog;
          if (json.flatShading !== void 0)
            material.flatShading = json.flatShading;
          if (json.blending !== void 0)
            material.blending = json.blending;
          if (json.combine !== void 0)
            material.combine = json.combine;
          if (json.side !== void 0)
            material.side = json.side;
          if (json.shadowSide !== void 0)
            material.shadowSide = json.shadowSide;
          if (json.opacity !== void 0)
            material.opacity = json.opacity;
          if (json.transparent !== void 0)
            material.transparent = json.transparent;
          if (json.alphaTest !== void 0)
            material.alphaTest = json.alphaTest;
          if (json.depthTest !== void 0)
            material.depthTest = json.depthTest;
          if (json.depthWrite !== void 0)
            material.depthWrite = json.depthWrite;
          if (json.colorWrite !== void 0)
            material.colorWrite = json.colorWrite;
          if (json.stencilWrite !== void 0)
            material.stencilWrite = json.stencilWrite;
          if (json.stencilWriteMask !== void 0)
            material.stencilWriteMask = json.stencilWriteMask;
          if (json.stencilFunc !== void 0)
            material.stencilFunc = json.stencilFunc;
          if (json.stencilRef !== void 0)
            material.stencilRef = json.stencilRef;
          if (json.stencilFuncMask !== void 0)
            material.stencilFuncMask = json.stencilFuncMask;
          if (json.stencilFail !== void 0)
            material.stencilFail = json.stencilFail;
          if (json.stencilZFail !== void 0)
            material.stencilZFail = json.stencilZFail;
          if (json.stencilZPass !== void 0)
            material.stencilZPass = json.stencilZPass;
          if (json.wireframe !== void 0)
            material.wireframe = json.wireframe;
          if (json.wireframeLinewidth !== void 0)
            material.wireframeLinewidth = json.wireframeLinewidth;
          if (json.wireframeLinecap !== void 0)
            material.wireframeLinecap = json.wireframeLinecap;
          if (json.wireframeLinejoin !== void 0)
            material.wireframeLinejoin = json.wireframeLinejoin;
          if (json.rotation !== void 0)
            material.rotation = json.rotation;
          if (json.linewidth !== 1)
            material.linewidth = json.linewidth;
          if (json.dashSize !== void 0)
            material.dashSize = json.dashSize;
          if (json.gapSize !== void 0)
            material.gapSize = json.gapSize;
          if (json.scale !== void 0)
            material.scale = json.scale;
          if (json.polygonOffset !== void 0)
            material.polygonOffset = json.polygonOffset;
          if (json.polygonOffsetFactor !== void 0)
            material.polygonOffsetFactor = json.polygonOffsetFactor;
          if (json.polygonOffsetUnits !== void 0)
            material.polygonOffsetUnits = json.polygonOffsetUnits;
          if (json.dithering !== void 0)
            material.dithering = json.dithering;
          if (json.alphaToCoverage !== void 0)
            material.alphaToCoverage = json.alphaToCoverage;
          if (json.premultipliedAlpha !== void 0)
            material.premultipliedAlpha = json.premultipliedAlpha;
          if (json.visible !== void 0)
            material.visible = json.visible;
          if (json.toneMapped !== void 0)
            material.toneMapped = json.toneMapped;
          if (json.userData !== void 0)
            material.userData = json.userData;
          if (json.vertexColors !== void 0) {
            if (typeof json.vertexColors === "number") {
              material.vertexColors = json.vertexColors > 0 ? true : false;
            } else {
              material.vertexColors = json.vertexColors;
            }
          }
          if (json.uniforms !== void 0) {
            for (const name in json.uniforms) {
              const uniform = json.uniforms[name];
              material.uniforms[name] = {};
              switch (uniform.type) {
                case "t":
                  material.uniforms[name].value = getTexture(uniform.value);
                  break;
                case "c":
                  material.uniforms[name].value = new Color().setHex(uniform.value);
                  break;
                case "v2":
                  material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                  break;
                case "v3":
                  material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                  break;
                case "v4":
                  material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                  break;
                case "m3":
                  material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                  break;
                case "m4":
                  material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                  break;
                default:
                  material.uniforms[name].value = uniform.value;
              }
            }
          }
          if (json.defines !== void 0)
            material.defines = json.defines;
          if (json.vertexShader !== void 0)
            material.vertexShader = json.vertexShader;
          if (json.fragmentShader !== void 0)
            material.fragmentShader = json.fragmentShader;
          if (json.extensions !== void 0) {
            for (const key in json.extensions) {
              material.extensions[key] = json.extensions[key];
            }
          }
          if (json.shading !== void 0)
            material.flatShading = json.shading === 1;
          if (json.size !== void 0)
            material.size = json.size;
          if (json.sizeAttenuation !== void 0)
            material.sizeAttenuation = json.sizeAttenuation;
          if (json.map !== void 0)
            material.map = getTexture(json.map);
          if (json.matcap !== void 0)
            material.matcap = getTexture(json.matcap);
          if (json.alphaMap !== void 0)
            material.alphaMap = getTexture(json.alphaMap);
          if (json.bumpMap !== void 0)
            material.bumpMap = getTexture(json.bumpMap);
          if (json.bumpScale !== void 0)
            material.bumpScale = json.bumpScale;
          if (json.normalMap !== void 0)
            material.normalMap = getTexture(json.normalMap);
          if (json.normalMapType !== void 0)
            material.normalMapType = json.normalMapType;
          if (json.normalScale !== void 0) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
              normalScale = [normalScale, normalScale];
            }
            material.normalScale = new Vector2().fromArray(normalScale);
          }
          if (json.displacementMap !== void 0)
            material.displacementMap = getTexture(json.displacementMap);
          if (json.displacementScale !== void 0)
            material.displacementScale = json.displacementScale;
          if (json.displacementBias !== void 0)
            material.displacementBias = json.displacementBias;
          if (json.roughnessMap !== void 0)
            material.roughnessMap = getTexture(json.roughnessMap);
          if (json.metalnessMap !== void 0)
            material.metalnessMap = getTexture(json.metalnessMap);
          if (json.emissiveMap !== void 0)
            material.emissiveMap = getTexture(json.emissiveMap);
          if (json.emissiveIntensity !== void 0)
            material.emissiveIntensity = json.emissiveIntensity;
          if (json.specularMap !== void 0)
            material.specularMap = getTexture(json.specularMap);
          if (json.specularIntensityMap !== void 0)
            material.specularIntensityMap = getTexture(json.specularIntensityMap);
          if (json.specularColorMap !== void 0)
            material.specularColorMap = getTexture(json.specularColorMap);
          if (json.envMap !== void 0)
            material.envMap = getTexture(json.envMap);
          if (json.envMapIntensity !== void 0)
            material.envMapIntensity = json.envMapIntensity;
          if (json.reflectivity !== void 0)
            material.reflectivity = json.reflectivity;
          if (json.refractionRatio !== void 0)
            material.refractionRatio = json.refractionRatio;
          if (json.lightMap !== void 0)
            material.lightMap = getTexture(json.lightMap);
          if (json.lightMapIntensity !== void 0)
            material.lightMapIntensity = json.lightMapIntensity;
          if (json.aoMap !== void 0)
            material.aoMap = getTexture(json.aoMap);
          if (json.aoMapIntensity !== void 0)
            material.aoMapIntensity = json.aoMapIntensity;
          if (json.gradientMap !== void 0)
            material.gradientMap = getTexture(json.gradientMap);
          if (json.clearcoatMap !== void 0)
            material.clearcoatMap = getTexture(json.clearcoatMap);
          if (json.clearcoatRoughnessMap !== void 0)
            material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
          if (json.clearcoatNormalMap !== void 0)
            material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
          if (json.clearcoatNormalScale !== void 0)
            material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
          if (json.transmissionMap !== void 0)
            material.transmissionMap = getTexture(json.transmissionMap);
          if (json.thicknessMap !== void 0)
            material.thicknessMap = getTexture(json.thicknessMap);
          if (json.sheenColorMap !== void 0)
            material.sheenColorMap = getTexture(json.sheenColorMap);
          if (json.sheenRoughnessMap !== void 0)
            material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
          return material;
        }
        setTextures(value) {
          this.textures = value;
          return this;
        }
      };
      var LoaderUtils = class {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s2 = "";
          for (let i2 = 0, il2 = array.length; i2 < il2; i2++) {
            s2 += String.fromCharCode(array[i2]);
          }
          try {
            return decodeURIComponent(escape(s2));
          } catch (e4) {
            return s2;
          }
        }
        static extractUrlBase(url) {
          const index = url.lastIndexOf("/");
          if (index === -1)
            return "./";
          return url.slice(0, index + 1);
        }
        static resolveURL(url, path) {
          if (typeof url !== "string" || url === "")
            return "";
          if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
            path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
          }
          if (/^(https?:)?\/\//i.test(url))
            return url;
          if (/^data:.*,.*$/i.test(url))
            return url;
          if (/^blob:.*$/i.test(url))
            return url;
          return path + url;
        }
      };
      var InstancedBufferGeometry = class extends BufferGeometry {
        constructor() {
          super();
          this.type = "InstancedBufferGeometry";
          this.instanceCount = Infinity;
        }
        copy(source) {
          super.copy(source);
          this.instanceCount = source.instanceCount;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const data = super.toJSON(this);
          data.instanceCount = this.instanceCount;
          data.isInstancedBufferGeometry = true;
          return data;
        }
      };
      InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
      var BufferGeometryLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e4) {
              if (onError) {
                onError(e4);
              } else {
                console.error(e4);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const interleavedBufferMap = {};
          const arrayBufferMap = {};
          function getInterleavedBuffer(json2, uuid) {
            if (interleavedBufferMap[uuid] !== void 0)
              return interleavedBufferMap[uuid];
            const interleavedBuffers = json2.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
          }
          function getArrayBuffer(json2, uuid) {
            if (arrayBufferMap[uuid] !== void 0)
              return arrayBufferMap[uuid];
            const arrayBuffers = json2.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
          }
          const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
          const index = json.data.index;
          if (index !== void 0) {
            const typedArray = getTypedArray(index.type, index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
          }
          const attributes = json.data.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
              bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            if (attribute.usage !== void 0)
              bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== void 0) {
              bufferAttribute.updateRange.offset = attribute.updateRange.offset;
              bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry.setAttribute(key, bufferAttribute);
          }
          const morphAttributes = json.data.morphAttributes;
          if (morphAttributes) {
            for (const key in morphAttributes) {
              const attributeArray = morphAttributes[key];
              const array = [];
              for (let i2 = 0, il2 = attributeArray.length; i2 < il2; i2++) {
                const attribute = attributeArray[i2];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                  const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  const typedArray = getTypedArray(attribute.type, attribute.array);
                  bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== void 0)
                  bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
              }
              geometry.morphAttributes[key] = array;
            }
          }
          const morphTargetsRelative = json.data.morphTargetsRelative;
          if (morphTargetsRelative) {
            geometry.morphTargetsRelative = true;
          }
          const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
          if (groups !== void 0) {
            for (let i2 = 0, n2 = groups.length; i2 !== n2; ++i2) {
              const group = groups[i2];
              geometry.addGroup(group.start, group.count, group.materialIndex);
            }
          }
          const boundingSphere = json.data.boundingSphere;
          if (boundingSphere !== void 0) {
            const center = new Vector3();
            if (boundingSphere.center !== void 0) {
              center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
          }
          if (json.name)
            geometry.name = json.name;
          if (json.userData)
            geometry.userData = json.userData;
          return geometry;
        }
      };
      var ObjectLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            let json = null;
            try {
              json = JSON.parse(text);
            } catch (error) {
              if (onError !== void 0)
                onError(error);
              console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
              return;
            }
            const metadata = json.metadata;
            if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
              console.error("THREE.ObjectLoader: Can't load " + url);
              return;
            }
            scope.parse(json, onLoad);
          }, onProgress, onError);
        }
        async loadAsync(url, onProgress) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          const text = await loader.loadAsync(url, onProgress);
          const json = JSON.parse(text);
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            throw new Error("THREE.ObjectLoader: Can't load " + url);
          }
          return await scope.parseAsync(json);
        }
        parse(json, onLoad) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = this.parseImages(json.images, function() {
            if (onLoad !== void 0)
              onLoad(object);
          });
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          if (onLoad !== void 0) {
            let hasImages = false;
            for (const uuid in images) {
              if (images[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
              }
            }
            if (hasImages === false)
              onLoad(object);
          }
          return object;
        }
        async parseAsync(json) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = await this.parseImagesAsync(json.images);
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          return object;
        }
        parseShapes(json) {
          const shapes = {};
          if (json !== void 0) {
            for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
              const shape = new Shape().fromJSON(json[i2]);
              shapes[shape.uuid] = shape;
            }
          }
          return shapes;
        }
        parseSkeletons(json, object) {
          const skeletons = {};
          const bones = {};
          object.traverse(function(child) {
            if (child.isBone)
              bones[child.uuid] = child;
          });
          if (json !== void 0) {
            for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
              const skeleton = new Skeleton().fromJSON(json[i2], bones);
              skeletons[skeleton.uuid] = skeleton;
            }
          }
          return skeletons;
        }
        parseGeometries(json, shapes) {
          const geometries = {};
          if (json !== void 0) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
              let geometry;
              const data = json[i2];
              switch (data.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  geometry = bufferGeometryLoader.parse(data);
                  break;
                case "Geometry":
                  console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                  break;
                default:
                  if (data.type in Geometries) {
                    geometry = Geometries[data.type].fromJSON(data, shapes);
                  } else {
                    console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                  }
              }
              geometry.uuid = data.uuid;
              if (data.name !== void 0)
                geometry.name = data.name;
              if (geometry.isBufferGeometry === true && data.userData !== void 0)
                geometry.userData = data.userData;
              geometries[data.uuid] = geometry;
            }
          }
          return geometries;
        }
        parseMaterials(json, textures) {
          const cache = {};
          const materials = {};
          if (json !== void 0) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
              const data = json[i2];
              if (data.type === "MultiMaterial") {
                const array = [];
                for (let j2 = 0; j2 < data.materials.length; j2++) {
                  const material = data.materials[j2];
                  if (cache[material.uuid] === void 0) {
                    cache[material.uuid] = loader.parse(material);
                  }
                  array.push(cache[material.uuid]);
                }
                materials[data.uuid] = array;
              } else {
                if (cache[data.uuid] === void 0) {
                  cache[data.uuid] = loader.parse(data);
                }
                materials[data.uuid] = cache[data.uuid];
              }
            }
          }
          return materials;
        }
        parseAnimations(json) {
          const animations = {};
          if (json !== void 0) {
            for (let i2 = 0; i2 < json.length; i2++) {
              const data = json[i2];
              const clip = AnimationClip.parse(data);
              animations[clip.uuid] = clip;
            }
          }
          return animations;
        }
        parseImages(json, onLoad) {
          const scope = this;
          const images = {};
          let loader;
          function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
              scope.manager.itemEnd(url);
            }, void 0, function() {
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            });
          }
          function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return loadImage(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            const manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il2 = json.length; i2 < il2; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                const imageArray = [];
                for (let j2 = 0, jl2 = url.length; j2 < jl2; j2++) {
                  const currentUrl = url[j2];
                  const deserializedImage = deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      imageArray.push(deserializedImage);
                    } else {
                      imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
                images[image.uuid] = new Source(imageArray);
              } else {
                const deserializedImage = deserializeImage(image.url);
                images[image.uuid] = new Source(deserializedImage);
              }
            }
          }
          return images;
        }
        async parseImagesAsync(json) {
          const scope = this;
          const images = {};
          let loader;
          async function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return await loader.loadAsync(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il2 = json.length; i2 < il2; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                const imageArray = [];
                for (let j2 = 0, jl2 = url.length; j2 < jl2; j2++) {
                  const currentUrl = url[j2];
                  const deserializedImage = await deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      imageArray.push(deserializedImage);
                    } else {
                      imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
                images[image.uuid] = new Source(imageArray);
              } else {
                const deserializedImage = await deserializeImage(image.url);
                images[image.uuid] = new Source(deserializedImage);
              }
            }
          }
          return images;
        }
        parseTextures(json, images) {
          function parseConstant(value, type) {
            if (typeof value === "number")
              return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type[value];
          }
          const textures = {};
          if (json !== void 0) {
            for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
              const data = json[i2];
              if (data.image === void 0) {
                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
              }
              if (images[data.image] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined image", data.image);
              }
              const source = images[data.image];
              const image = source.data;
              let texture;
              if (Array.isArray(image)) {
                texture = new CubeTexture();
                if (image.length === 6)
                  texture.needsUpdate = true;
              } else {
                if (image && image.data) {
                  texture = new DataTexture();
                } else {
                  texture = new Texture();
                }
                if (image)
                  texture.needsUpdate = true;
              }
              texture.source = source;
              texture.uuid = data.uuid;
              if (data.name !== void 0)
                texture.name = data.name;
              if (data.mapping !== void 0)
                texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
              if (data.offset !== void 0)
                texture.offset.fromArray(data.offset);
              if (data.repeat !== void 0)
                texture.repeat.fromArray(data.repeat);
              if (data.center !== void 0)
                texture.center.fromArray(data.center);
              if (data.rotation !== void 0)
                texture.rotation = data.rotation;
              if (data.wrap !== void 0) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
              }
              if (data.format !== void 0)
                texture.format = data.format;
              if (data.type !== void 0)
                texture.type = data.type;
              if (data.encoding !== void 0)
                texture.encoding = data.encoding;
              if (data.minFilter !== void 0)
                texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
              if (data.magFilter !== void 0)
                texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
              if (data.anisotropy !== void 0)
                texture.anisotropy = data.anisotropy;
              if (data.flipY !== void 0)
                texture.flipY = data.flipY;
              if (data.premultiplyAlpha !== void 0)
                texture.premultiplyAlpha = data.premultiplyAlpha;
              if (data.unpackAlignment !== void 0)
                texture.unpackAlignment = data.unpackAlignment;
              if (data.userData !== void 0)
                texture.userData = data.userData;
              textures[data.uuid] = texture;
            }
          }
          return textures;
        }
        parseObject(data, geometries, materials, textures, animations) {
          let object;
          function getGeometry(name) {
            if (geometries[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined geometry", name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === void 0)
              return void 0;
            if (Array.isArray(name)) {
              const array = [];
              for (let i2 = 0, l2 = name.length; i2 < l2; i2++) {
                const uuid = name[i2];
                if (materials[uuid] === void 0) {
                  console.warn("THREE.ObjectLoader: Undefined material", uuid);
                }
                array.push(materials[uuid]);
              }
              return array;
            }
            if (materials[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", name);
            }
            return materials[name];
          }
          function getTexture(uuid) {
            if (textures[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined texture", uuid);
            }
            return textures[uuid];
          }
          let geometry, material;
          switch (data.type) {
            case "Scene":
              object = new Scene();
              if (data.background !== void 0) {
                if (Number.isInteger(data.background)) {
                  object.background = new Color(data.background);
                } else {
                  object.background = getTexture(data.background);
                }
              }
              if (data.environment !== void 0) {
                object.environment = getTexture(data.environment);
              }
              if (data.fog !== void 0) {
                if (data.fog.type === "Fog") {
                  object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                } else if (data.fog.type === "FogExp2") {
                  object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
              }
              break;
            case "PerspectiveCamera":
              object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
              if (data.focus !== void 0)
                object.focus = data.focus;
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.filmGauge !== void 0)
                object.filmGauge = data.filmGauge;
              if (data.filmOffset !== void 0)
                object.filmOffset = data.filmOffset;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "OrthographicCamera":
              object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "AmbientLight":
              object = new AmbientLight(data.color, data.intensity);
              break;
            case "DirectionalLight":
              object = new DirectionalLight(data.color, data.intensity);
              break;
            case "PointLight":
              object = new PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case "RectAreaLight":
              object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
              break;
            case "SpotLight":
              object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
              break;
            case "HemisphereLight":
              object = new HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case "LightProbe":
              object = new LightProbe().fromJSON(data);
              break;
            case "SkinnedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new SkinnedMesh(geometry, material);
              if (data.bindMode !== void 0)
                object.bindMode = data.bindMode;
              if (data.bindMatrix !== void 0)
                object.bindMatrix.fromArray(data.bindMatrix);
              if (data.skeleton !== void 0)
                object.skeleton = data.skeleton;
              break;
            case "Mesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new Mesh(geometry, material);
              break;
            case "InstancedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              const count = data.count;
              const instanceMatrix = data.instanceMatrix;
              const instanceColor = data.instanceColor;
              object = new InstancedMesh(geometry, material, count);
              object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
              if (instanceColor !== void 0)
                object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
              break;
            case "LOD":
              object = new LOD();
              break;
            case "Line":
              object = new Line(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineLoop":
              object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineSegments":
              object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "PointCloud":
            case "Points":
              object = new Points(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "Sprite":
              object = new Sprite(getMaterial(data.material));
              break;
            case "Group":
              object = new Group();
              break;
            case "Bone":
              object = new Bone();
              break;
            default:
              object = new Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== void 0)
            object.name = data.name;
          if (data.matrix !== void 0) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== void 0)
              object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate)
              object.matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== void 0)
              object.position.fromArray(data.position);
            if (data.rotation !== void 0)
              object.rotation.fromArray(data.rotation);
            if (data.quaternion !== void 0)
              object.quaternion.fromArray(data.quaternion);
            if (data.scale !== void 0)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== void 0)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== void 0)
            object.receiveShadow = data.receiveShadow;
          if (data.shadow) {
            if (data.shadow.bias !== void 0)
              object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== void 0)
              object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== void 0)
              object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== void 0)
              object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== void 0)
              object.shadow.camera = this.parseObject(data.shadow.camera);
          }
          if (data.visible !== void 0)
            object.visible = data.visible;
          if (data.frustumCulled !== void 0)
            object.frustumCulled = data.frustumCulled;
          if (data.renderOrder !== void 0)
            object.renderOrder = data.renderOrder;
          if (data.userData !== void 0)
            object.userData = data.userData;
          if (data.layers !== void 0)
            object.layers.mask = data.layers;
          if (data.children !== void 0) {
            const children = data.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              object.add(this.parseObject(children[i2], geometries, materials, textures, animations));
            }
          }
          if (data.animations !== void 0) {
            const objectAnimations = data.animations;
            for (let i2 = 0; i2 < objectAnimations.length; i2++) {
              const uuid = objectAnimations[i2];
              object.animations.push(animations[uuid]);
            }
          }
          if (data.type === "LOD") {
            if (data.autoUpdate !== void 0)
              object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for (let l2 = 0; l2 < levels.length; l2++) {
              const level = levels[l2];
              const child = object.getObjectByProperty("uuid", level.object);
              if (child !== void 0) {
                object.addLevel(child, level.distance);
              }
            }
          }
          return object;
        }
        bindSkeletons(object, skeletons) {
          if (Object.keys(skeletons).length === 0)
            return;
          object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
              const skeleton = skeletons[child.skeleton];
              if (skeleton === void 0) {
                console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
              } else {
                child.bind(skeleton, child.bindMatrix);
              }
            }
          });
        }
        setTexturePath(value) {
          console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
          return this.setResourcePath(value);
        }
      };
      var TEXTURE_MAPPING = {
        UVMapping,
        CubeReflectionMapping,
        CubeRefractionMapping,
        EquirectangularReflectionMapping,
        EquirectangularRefractionMapping,
        CubeUVReflectionMapping,
        CubeUVRefractionMapping
      };
      var TEXTURE_WRAPPING = {
        RepeatWrapping,
        ClampToEdgeWrapping,
        MirroredRepeatWrapping
      };
      var TEXTURE_FILTER = {
        NearestFilter,
        NearestMipmapNearestFilter,
        NearestMipmapLinearFilter,
        LinearFilter,
        LinearMipmapNearestFilter,
        LinearMipmapLinearFilter
      };
      var ImageBitmapLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(options) {
          this.options = options;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e4) {
            if (onError)
              onError(e4);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      };
      ImageBitmapLoader.prototype.isImageBitmapLoader = true;
      var _context;
      var AudioContext2 = {
        getContext: function() {
          if (_context === void 0) {
            _context = new (window.AudioContext || window.webkitAudioContext)();
          }
          return _context;
        },
        setContext: function(value) {
          _context = value;
        }
      };
      var AudioLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(buffer) {
            try {
              const bufferCopy = buffer.slice(0);
              const context = AudioContext2.getContext();
              context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
              });
            } catch (e4) {
              if (onError) {
                onError(e4);
              } else {
                console.error(e4);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
      };
      var HemisphereLightProbe = class extends LightProbe {
        constructor(skyColor, groundColor, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(skyColor);
          const color2 = new Color().set(groundColor);
          const sky = new Vector3(color1.r, color1.g, color1.b);
          const ground = new Vector3(color2.r, color2.g, color2.b);
          const c0 = Math.sqrt(Math.PI);
          const c1 = c0 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
          this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        }
      };
      HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
      var AmbientLightProbe = class extends LightProbe {
        constructor(color, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(color);
          this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      };
      AmbientLightProbe.prototype.isAmbientLightProbe = true;
      var _eyeRight = /* @__PURE__ */ new Matrix4();
      var _eyeLeft = /* @__PURE__ */ new Matrix4();
      var _projectionMatrix = /* @__PURE__ */ new Matrix4();
      var StereoCamera = class {
        constructor() {
          this.type = "StereoCamera";
          this.aspect = 1;
          this.eyeSep = 0.064;
          this.cameraL = new PerspectiveCamera();
          this.cameraL.layers.enable(1);
          this.cameraL.matrixAutoUpdate = false;
          this.cameraR = new PerspectiveCamera();
          this.cameraR.layers.enable(2);
          this.cameraR.matrixAutoUpdate = false;
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        update(camera) {
          const cache = this._cache;
          const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
          if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            _projectionMatrix.copy(camera.projectionMatrix);
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(_projectionMatrix);
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(_projectionMatrix);
          }
          this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
          this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
      };
      var Clock = class {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      };
      function now() {
        return (typeof performance === "undefined" ? Date : performance).now();
      }
      var _position$1 = /* @__PURE__ */ new Vector3();
      var _quaternion$1 = /* @__PURE__ */ new Quaternion();
      var _scale$1 = /* @__PURE__ */ new Vector3();
      var _orientation$1 = /* @__PURE__ */ new Vector3();
      var AudioListener = class extends Object3D {
        constructor() {
          super();
          this.type = "AudioListener";
          this.context = AudioContext2.getContext();
          this.gain = this.context.createGain();
          this.gain.connect(this.context.destination);
          this.filter = null;
          this.timeDelta = 0;
          this._clock = new Clock();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
          }
          return this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(value) {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
          } else {
            this.gain.disconnect(this.context.destination);
          }
          this.filter = value;
          this.gain.connect(this.filter);
          this.filter.connect(this.context.destination);
          return this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          const listener = this.context.listener;
          const up2 = this.up;
          this.timeDelta = this._clock.getDelta();
          this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
          _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
          if (listener.positionX) {
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up2.x, endTime);
            listener.upY.linearRampToValueAtTime(up2.y, endTime);
            listener.upZ.linearRampToValueAtTime(up2.z, endTime);
          } else {
            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up2.x, up2.y, up2.z);
          }
        }
      };
      var Audio = class extends Object3D {
        constructor(listener) {
          super();
          this.type = "Audio";
          this.listener = listener;
          this.context = listener.context;
          this.gain = this.context.createGain();
          this.gain.connect(listener.getInput());
          this.autoplay = false;
          this.buffer = null;
          this.detune = 0;
          this.loop = false;
          this.loopStart = 0;
          this.loopEnd = 0;
          this.offset = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = false;
          this.hasPlaybackControl = true;
          this.source = null;
          this.sourceType = "empty";
          this._startedAt = 0;
          this._progress = 0;
          this._connected = false;
          this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(audioNode) {
          this.hasPlaybackControl = false;
          this.sourceType = "audioNode";
          this.source = audioNode;
          this.connect();
          return this;
        }
        setMediaElementSource(mediaElement) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaNode";
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();
          return this;
        }
        setMediaStreamSource(mediaStream) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaStreamNode";
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();
          return this;
        }
        setBuffer(audioBuffer) {
          this.buffer = audioBuffer;
          this.sourceType = "buffer";
          if (this.autoplay)
            this.play();
          return this;
        }
        play(delay = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + delay;
          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);
          this.isPlaying = true;
          this.source = source;
          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);
          return this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
              this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
          }
          return this;
        }
        stop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._progress = 0;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
          return this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
              this.filters[i2 - 1].connect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else {
            this.source.connect(this.getOutput());
          }
          this._connected = true;
          return this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
              this.filters[i2 - 1].disconnect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else {
            this.source.disconnect(this.getOutput());
          }
          this._connected = false;
          return this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(value) {
          if (!value)
            value = [];
          if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
          } else {
            this.filters = value.slice();
          }
          return this;
        }
        setDetune(value) {
          this.detune = value;
          if (this.source.detune === void 0)
            return;
          if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
          }
          return this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(filter) {
          return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.playbackRate = value;
          if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
          }
          return this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
          }
          return this.loop;
        }
        setLoop(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.loop = value;
          if (this.isPlaying === true) {
            this.source.loop = this.loop;
          }
          return this;
        }
        setLoopStart(value) {
          this.loopStart = value;
          return this;
        }
        setLoopEnd(value) {
          this.loopEnd = value;
          return this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
      };
      var _position = /* @__PURE__ */ new Vector3();
      var _quaternion = /* @__PURE__ */ new Quaternion();
      var _scale = /* @__PURE__ */ new Vector3();
      var _orientation = /* @__PURE__ */ new Vector3();
      var PositionalAudio = class extends Audio {
        constructor(listener) {
          super(listener);
          this.panner = this.context.createPanner();
          this.panner.panningModel = "HRTF";
          this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(value) {
          this.panner.refDistance = value;
          return this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
          this.panner.rolloffFactor = value;
          return this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(value) {
          this.panner.distanceModel = value;
          return this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(value) {
          this.panner.maxDistance = value;
          return this;
        }
        setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
          this.panner.coneInnerAngle = coneInnerAngle;
          this.panner.coneOuterAngle = coneOuterAngle;
          this.panner.coneOuterGain = coneOuterGain;
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.hasPlaybackControl === true && this.isPlaying === false)
            return;
          this.matrixWorld.decompose(_position, _quaternion, _scale);
          _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
          const panner = this.panner;
          if (panner.positionX) {
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
          } else {
            panner.setPosition(_position.x, _position.y, _position.z);
            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
          }
        }
      };
      var AudioAnalyser = class {
        constructor(audio, fftSize = 2048) {
          this.analyser = audio.context.createAnalyser();
          this.analyser.fftSize = fftSize;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        }
        getAverageFrequency() {
          let value = 0;
          const data = this.getFrequencyData();
          for (let i2 = 0; i2 < data.length; i2++) {
            value += data[i2];
          }
          return value / data.length;
        }
      };
      var PropertyMixer = class {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[offset + i2] = buffer[i2];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i2 = stride, e4 = stride + stride; i2 !== e4; ++i2) {
            if (buffer[i2] !== buffer[i2 + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i2 = stride, e4 = originalValueOffset; i2 !== e4; ++i2) {
            buffer[i2] = buffer[originalValueOffset + i2 % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i2 = startIndex; i2 < endIndex; i2++) {
            this.buffer[i2] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i2 = 0; i2 < this.valueSize; i2++) {
            this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
          }
        }
        _select(buffer, dstOffset, srcOffset, t2, stride) {
          if (t2 >= 0.5) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[dstOffset + i2] = buffer[srcOffset + i2];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t2) {
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
        }
        _lerp(buffer, dstOffset, srcOffset, t2, stride) {
          const s2 = 1 - t2;
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j2 = dstOffset + i2;
            buffer[j2] = buffer[j2] * s2 + buffer[srcOffset + i2] * t2;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j2 = dstOffset + i2;
            buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
          }
        }
      };
      var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
      var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
      var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
      var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
      var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
      var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
      var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
      var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
      var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
      var _supportedObjectNames = ["material", "materials", "bones"];
      var Composite = class {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
            bindings[i2].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
            bindings[i2].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
            bindings[i2].unbind();
          }
        }
      };
      var PropertyBinding = class {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
          this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root, path, parsedPath) {
          if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
          } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
          }
        }
        static sanitizeNodeName(name) {
          return name.replace(/\s/g, "_").replace(_reservedRe, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe.exec(trackName);
          if (matches === null) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root, nodeName) {
          if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
          }
          if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root.children) {
            const searchNodeSubtree = function(children) {
              for (let i2 = 0; i2 < children.length; i2++) {
                const childNode = children[i2];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
            buffer[offset++] = source[i2];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
            dest[i2] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i2 = 0; i2 < targetObject.length; i2++) {
                  if (targetObject[i2].name === objectIndex) {
                    objectIndex = i2;
                    break;
                  }
                }
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (targetObject.geometry.isBufferGeometry) {
                if (!targetObject.geometry.morphAttributes) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  return;
                }
                if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                  propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                }
              } else {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                return;
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      };
      PropertyBinding.Composite = Composite;
      PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
      PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]];
      var AnimationObjectGroup = class {
        constructor() {
          this.uuid = generateUUID();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          const indices = {};
          this._indicesByUUID = indices;
          for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
            indices[arguments[i2].uuid] = i2;
          }
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          const scope = this;
          this.stats = {
            objects: {
              get total() {
                return scope._objects.length;
              },
              get inUse() {
                return this.total - scope.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return scope._bindings.length;
            }
          };
        }
        add() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
          let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
            const object = arguments[i2], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === void 0) {
              index = nObjects++;
              indicesByUUID[uuid] = index;
              objects.push(object);
              for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
                bindings[j2].push(new PropertyBinding(object, paths[j2], parsedPaths[j2]));
              }
            } else if (index < nCachedObjects) {
              knownObject = objects[index];
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[uuid] = firstActiveIndex;
              objects[firstActiveIndex] = object;
              for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
                const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex];
                let binding = bindingsForPath[index];
                bindingsForPath[index] = lastCached;
                if (binding === void 0) {
                  binding = new PropertyBinding(object, paths[j2], parsedPaths[j2]);
                }
                bindingsForPath[firstActiveIndex] = binding;
              }
            } else if (objects[index] !== knownObject) {
              console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0 && index >= nCachedObjects) {
              const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
              indicesByUUID[firstActiveObject.uuid] = index;
              objects[index] = firstActiveObject;
              indicesByUUID[uuid] = lastCachedIndex;
              objects[lastCachedIndex] = object;
              for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
                const bindingsForPath = bindings[j2], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                bindingsForPath[index] = firstActive;
                bindingsForPath[lastCachedIndex] = binding;
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
          for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0) {
              delete indicesByUUID[uuid];
              if (index < nCachedObjects) {
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                objects[firstActiveIndex] = lastObject;
                objects.pop();
                for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
                  const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                  bindingsForPath[index] = lastCached;
                  bindingsForPath[firstActiveIndex] = last;
                  bindingsForPath.pop();
                }
              } else {
                const lastIndex = --nObjects, lastObject = objects[lastIndex];
                if (lastIndex > 0) {
                  indicesByUUID[lastObject.uuid] = index;
                }
                objects[index] = lastObject;
                objects.pop();
                for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
                  const bindingsForPath = bindings[j2];
                  bindingsForPath[index] = bindingsForPath[lastIndex];
                  bindingsForPath.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        subscribe_(path, parsedPath) {
          const indicesByPath = this._bindingsIndicesByPath;
          let index = indicesByPath[path];
          const bindings = this._bindings;
          if (index !== void 0)
            return bindings[index];
          const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
          index = bindings.length;
          indicesByPath[path] = index;
          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);
          for (let i2 = nCachedObjects, n2 = objects.length; i2 !== n2; ++i2) {
            const object = objects[i2];
            bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
          }
          return bindingsForPath;
        }
        unsubscribe_(path) {
          const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
          if (index !== void 0) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
          }
        }
      };
      AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
      var AnimationAction = class {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const interpolant = tracks[i2].createInterpolant(null);
            interpolants[i2] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time) {
          this._startTime = time;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now2;
          times[1] = now2 + duration;
          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(time, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
          }
          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode:
                for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
                  interpolants[j2].evaluate(clipTime);
                  propertyMixers[j2].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode:
              default:
                for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
                  interpolants[j2].evaluate(clipTime);
                  propertyMixers[j2].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              weight *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              timeScale *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop = this.loop;
          let time = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop === LoopPingPong;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
          }
          if (loop === LoopOnce) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time >= duration) {
                time = duration;
              } else if (time < 0) {
                time = 0;
              } else {
                this.time = time;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time >= duration || time < 0) {
              const loopDelta = Math.floor(time / duration);
              time -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time = deltaTime > 0 ? duration : 0;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time;
            }
          }
          return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingEnd = WrapAroundEnding;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now2 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now2;
          values[0] = weightNow;
          times[1] = now2 + duration;
          values[1] = weightThen;
          return this;
        }
      };
      var AnimationMixer = class extends EventDispatcher {
        constructor(root) {
          super();
          this._root = root;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const track = tracks[i2], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              ++binding.referenceCount;
              bindings[i2] = binding;
            } else {
              binding = bindings[i2];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
              binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i2] = binding;
            }
            interpolants[i2].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
              const binding = bindings[i2];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
              const binding = bindings[i2];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(action) {
          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
            const binding = bindings[i2];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
          const root = optionalRoot || this._root, rootUuid = root.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        existingAction(clip, optionalRoot) {
          const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i2 = nActions - 1; i2 >= 0; --i2) {
            actions[i2].stop();
          }
          return this;
        }
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i2 = 0; i2 !== nActions; ++i2) {
            const action = actions[i2];
            action._update(time, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i2 = 0; i2 !== nBindings; ++i2) {
            bindings[i2].apply(accuIndex);
          }
          return this;
        }
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i2 = 0; i2 < this._actions.length; i2++) {
            this._actions[i2].time = 0;
          }
          return this.update(timeInSeconds);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
              const action = actionsToRemove[i2];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        uncacheRoot(root) {
          const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      };
      AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      var Uniform = class {
        constructor(value) {
          if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
          }
          this.value = value;
        }
        clone() {
          return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
        }
      };
      var InstancedInterleavedBuffer = class extends InterleavedBuffer {
        constructor(array, stride, meshPerAttribute = 1) {
          super(array, stride);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        clone(data) {
          const ib = super.clone(data);
          ib.meshPerAttribute = this.meshPerAttribute;
          return ib;
        }
        toJSON(data) {
          const json = super.toJSON(data);
          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;
          return json;
        }
      };
      InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
      var GLBufferAttribute = class {
        constructor(buffer, type, itemSize, elementSize, count) {
          this.buffer = buffer;
          this.type = type;
          this.itemSize = itemSize;
          this.elementSize = elementSize;
          this.count = count;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setBuffer(buffer) {
          this.buffer = buffer;
          return this;
        }
        setType(type, elementSize) {
          this.type = type;
          this.elementSize = elementSize;
          return this;
        }
        setItemSize(itemSize) {
          this.itemSize = itemSize;
          return this;
        }
        setCount(count) {
          this.count = count;
          return this;
        }
      };
      GLBufferAttribute.prototype.isGLBufferAttribute = true;
      var Raycaster = class {
        constructor(origin, direction, near = 0, far = Infinity) {
          this.ray = new Ray(origin, direction);
          this.near = near;
          this.far = far;
          this.camera = null;
          this.layers = new Layers();
          this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(origin, direction) {
          this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
          if (camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
          } else if (camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
          } else {
            console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
          }
        }
        intersectObject(object, recursive = true, intersects2 = []) {
          intersectObject(object, this, intersects2, recursive);
          intersects2.sort(ascSort);
          return intersects2;
        }
        intersectObjects(objects, recursive = true, intersects2 = []) {
          for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
            intersectObject(objects[i2], this, intersects2, recursive);
          }
          intersects2.sort(ascSort);
          return intersects2;
        }
      };
      function ascSort(a2, b2) {
        return a2.distance - b2.distance;
      }
      function intersectObject(object, raycaster, intersects2, recursive) {
        if (object.layers.test(raycaster.layers)) {
          object.raycast(raycaster, intersects2);
        }
        if (recursive === true) {
          const children = object.children;
          for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
            intersectObject(children[i2], raycaster, intersects2, true);
          }
        }
      }
      var Spherical = class {
        constructor(radius = 1, phi = 0, theta = 0) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        set(radius, phi, theta) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;
          return this;
        }
        makeSafe() {
          const EPS = 1e-6;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
          return this;
        }
        setFromVector3(v2) {
          return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
        }
        setFromCartesianCoords(x2, y2, z2) {
          this.radius = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
          if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
          } else {
            this.theta = Math.atan2(x2, z2);
            this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var Cylindrical = class {
        constructor(radius = 1, theta = 0, y2 = 0) {
          this.radius = radius;
          this.theta = theta;
          this.y = y2;
          return this;
        }
        set(radius, theta, y2) {
          this.radius = radius;
          this.theta = theta;
          this.y = y2;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.theta = other.theta;
          this.y = other.y;
          return this;
        }
        setFromVector3(v2) {
          return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
        }
        setFromCartesianCoords(x2, y2, z2) {
          this.radius = Math.sqrt(x2 * x2 + z2 * z2);
          this.theta = Math.atan2(x2, z2);
          this.y = y2;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var _vector$4 = /* @__PURE__ */ new Vector2();
      var Box2 = class {
        constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il2 = points.length; i2 < il2; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      Box2.prototype.isBox2 = true;
      var _startP = /* @__PURE__ */ new Vector3();
      var _startEnd = /* @__PURE__ */ new Vector3();
      var Line3 = class {
        constructor(start = new Vector3(), end = new Vector3()) {
          this.start = start;
          this.end = end;
        }
        set(start, end) {
          this.start.copy(start);
          this.end.copy(end);
          return this;
        }
        copy(line) {
          this.start.copy(line.start);
          this.end.copy(line.end);
          return this;
        }
        getCenter(target) {
          return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
          return target.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t2, target) {
          return this.delta(target).multiplyScalar(t2).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
          _startP.subVectors(point, this.start);
          _startEnd.subVectors(this.end, this.start);
          const startEnd2 = _startEnd.dot(_startEnd);
          const startEnd_startP = _startEnd.dot(_startP);
          let t2 = startEnd_startP / startEnd2;
          if (clampToLine) {
            t2 = clamp(t2, 0, 1);
          }
          return t2;
        }
        closestPointToPoint(point, clampToLine, target) {
          const t2 = this.closestPointToPointParameter(point, clampToLine);
          return this.delta(target).multiplyScalar(t2).add(this.start);
        }
        applyMatrix4(matrix) {
          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);
          return this;
        }
        equals(line) {
          return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var _vector$3 = /* @__PURE__ */ new Vector3();
      var SpotLightHelper = class extends Object3D {
        constructor(light, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry = new BufferGeometry();
          const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let i2 = 0, j2 = 1, l2 = 32; i2 < l2; i2++, j2++) {
            const p1 = i2 / l2 * Math.PI * 2;
            const p2 = j2 / l2 * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          const material = new LineBasicMaterial({
            fog: false,
            toneMapped: false
          });
          this.cone = new LineSegments(geometry, material);
          this.add(this.cone);
          this.update();
        }
        dispose() {
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const coneLength = this.light.distance ? this.light.distance : 1e3;
          const coneWidth = coneLength * Math.tan(this.light.angle);
          this.cone.scale.set(coneWidth, coneWidth, coneLength);
          _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(_vector$3);
          if (this.color !== void 0) {
            this.cone.material.color.set(this.color);
          } else {
            this.cone.material.color.copy(this.light.color);
          }
        }
      };
      var _vector$2 = /* @__PURE__ */ new Vector3();
      var _boneMatrix = /* @__PURE__ */ new Matrix4();
      var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
      var SkeletonHelper = class extends LineSegments {
        constructor(object) {
          const bones = getBoneList(object);
          const geometry = new BufferGeometry();
          const vertices = [];
          const colors = [];
          const color1 = new Color(0, 0, 1);
          const color2 = new Color(0, 1, 0);
          for (let i2 = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
          });
          super(geometry, material);
          this.type = "SkeletonHelper";
          this.isSkeletonHelper = true;
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry = this.geometry;
          const position = geometry.getAttribute("position");
          _matrixWorldInv.copy(this.root.matrixWorld).invert();
          for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
              j2 += 2;
            }
          }
          geometry.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
      };
      function getBoneList(object) {
        const boneList = [];
        if (object.isBone === true) {
          boneList.push(object);
        }
        for (let i2 = 0; i2 < object.children.length; i2++) {
          boneList.push.apply(boneList, getBoneList(object.children[i2]));
        }
        return boneList;
      }
      var PointLightHelper = class extends Mesh {
        constructor(light, sphereSize, color) {
          const geometry = new SphereGeometry(sphereSize, 4, 2);
          const material = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          super(geometry, material);
          this.light = light;
          this.light.updateMatrixWorld();
          this.color = color;
          this.type = "PointLightHelper";
          this.matrix = this.light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.update();
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
        update() {
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            this.material.color.copy(this.light.color);
          }
        }
      };
      var _vector$1 = /* @__PURE__ */ new Vector3();
      var _color1 = /* @__PURE__ */ new Color();
      var _color2 = /* @__PURE__ */ new Color();
      var HemisphereLightHelper = class extends Object3D {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry = new OctahedronGeometry(size);
          geometry.rotateY(Math.PI * 0.5);
          this.material = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          if (this.color === void 0)
            this.material.vertexColors = true;
          const position = geometry.getAttribute("position");
          const colors = new Float32Array(position.count * 3);
          geometry.setAttribute("color", new BufferAttribute(colors, 3));
          this.add(new Mesh(geometry, this.material));
          this.update();
        }
        dispose() {
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        }
        update() {
          const mesh = this.children[0];
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            const colors = mesh.geometry.getAttribute("color");
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for (let i2 = 0, l2 = colors.count; i2 < l2; i2++) {
              const color = i2 < l2 / 2 ? _color1 : _color2;
              colors.setXYZ(i2, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
          }
          mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      };
      var GridHelper = class extends LineSegments {
        constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const center = divisions / 2;
          const step = size / divisions;
          const halfSize = size / 2;
          const vertices = [], colors = [];
          for (let i2 = 0, j2 = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
            vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
            vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
            const color = i2 === center ? color1 : color2;
            color.toArray(colors, j2);
            j2 += 3;
            color.toArray(colors, j2);
            j2 += 3;
            color.toArray(colors, j2);
            j2 += 3;
            color.toArray(colors, j2);
            j2 += 3;
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "GridHelper";
        }
      };
      var PolarGridHelper = class extends LineSegments {
        constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const vertices = [];
          const colors = [];
          for (let i2 = 0; i2 <= radials; i2++) {
            const v2 = i2 / radials * (Math.PI * 2);
            const x2 = Math.sin(v2) * radius;
            const z2 = Math.cos(v2) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x2, 0, z2);
            const color = i2 & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
          }
          for (let i2 = 0; i2 <= circles; i2++) {
            const color = i2 & 1 ? color1 : color2;
            const r2 = radius - radius / circles * i2;
            for (let j2 = 0; j2 < divisions; j2++) {
              let v2 = j2 / divisions * (Math.PI * 2);
              let x2 = Math.sin(v2) * r2;
              let z2 = Math.cos(v2) * r2;
              vertices.push(x2, 0, z2);
              colors.push(color.r, color.g, color.b);
              v2 = (j2 + 1) / divisions * (Math.PI * 2);
              x2 = Math.sin(v2) * r2;
              z2 = Math.cos(v2) * r2;
              vertices.push(x2, 0, z2);
              colors.push(color.r, color.g, color.b);
            }
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "PolarGridHelper";
        }
      };
      var _v1 = /* @__PURE__ */ new Vector3();
      var _v2 = /* @__PURE__ */ new Vector3();
      var _v3 = /* @__PURE__ */ new Vector3();
      var DirectionalLightHelper = class extends Object3D {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          if (size === void 0)
            size = 1;
          let geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
          const material = new LineBasicMaterial({
            fog: false,
            toneMapped: false
          });
          this.lightPlane = new Line(geometry, material);
          this.add(this.lightPlane);
          geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
          this.targetLine = new Line(geometry, material);
          this.add(this.targetLine);
          this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose();
          this.lightPlane.material.dispose();
          this.targetLine.geometry.dispose();
          this.targetLine.material.dispose();
        }
        update() {
          _v1.setFromMatrixPosition(this.light.matrixWorld);
          _v2.setFromMatrixPosition(this.light.target.matrixWorld);
          _v3.subVectors(_v2, _v1);
          this.lightPlane.lookAt(_v2);
          if (this.color !== void 0) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
          } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
          }
          this.targetLine.lookAt(_v2);
          this.targetLine.scale.z = _v3.length();
        }
      };
      var _vector = /* @__PURE__ */ new Vector3();
      var _camera = /* @__PURE__ */ new Camera();
      var CameraHelper = class extends LineSegments {
        constructor(camera) {
          const geometry = new BufferGeometry();
          const material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
          });
          const vertices = [];
          const colors = [];
          const pointMap = {};
          const colorFrustum = new Color(16755200);
          const colorCone = new Color(16711680);
          const colorUp = new Color(43775);
          const colorTarget = new Color(16777215);
          const colorCross = new Color(3355443);
          addLine("n1", "n2", colorFrustum);
          addLine("n2", "n4", colorFrustum);
          addLine("n4", "n3", colorFrustum);
          addLine("n3", "n1", colorFrustum);
          addLine("f1", "f2", colorFrustum);
          addLine("f2", "f4", colorFrustum);
          addLine("f4", "f3", colorFrustum);
          addLine("f3", "f1", colorFrustum);
          addLine("n1", "f1", colorFrustum);
          addLine("n2", "f2", colorFrustum);
          addLine("n3", "f3", colorFrustum);
          addLine("n4", "f4", colorFrustum);
          addLine("p", "n1", colorCone);
          addLine("p", "n2", colorCone);
          addLine("p", "n3", colorCone);
          addLine("p", "n4", colorCone);
          addLine("u1", "u2", colorUp);
          addLine("u2", "u3", colorUp);
          addLine("u3", "u1", colorUp);
          addLine("c", "t", colorTarget);
          addLine("p", "c", colorCross);
          addLine("cn1", "cn2", colorCross);
          addLine("cn3", "cn4", colorCross);
          addLine("cf1", "cf2", colorCross);
          addLine("cf3", "cf4", colorCross);
          function addLine(a2, b2, color) {
            addPoint(a2, color);
            addPoint(b2, color);
          }
          function addPoint(id2, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id2] === void 0) {
              pointMap[id2] = [];
            }
            pointMap[id2].push(vertices.length / 3 - 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          super(geometry, material);
          this.type = "CameraHelper";
          this.camera = camera;
          if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
          this.matrix = camera.matrixWorld;
          this.matrixAutoUpdate = false;
          this.pointMap = pointMap;
          this.update();
        }
        update() {
          const geometry = this.geometry;
          const pointMap = this.pointMap;
          const w2 = 1, h2 = 1;
          _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
          setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
          setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
          setPoint("n1", pointMap, geometry, _camera, -w2, -h2, -1);
          setPoint("n2", pointMap, geometry, _camera, w2, -h2, -1);
          setPoint("n3", pointMap, geometry, _camera, -w2, h2, -1);
          setPoint("n4", pointMap, geometry, _camera, w2, h2, -1);
          setPoint("f1", pointMap, geometry, _camera, -w2, -h2, 1);
          setPoint("f2", pointMap, geometry, _camera, w2, -h2, 1);
          setPoint("f3", pointMap, geometry, _camera, -w2, h2, 1);
          setPoint("f4", pointMap, geometry, _camera, w2, h2, 1);
          setPoint("u1", pointMap, geometry, _camera, w2 * 0.7, h2 * 1.1, -1);
          setPoint("u2", pointMap, geometry, _camera, -w2 * 0.7, h2 * 1.1, -1);
          setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
          setPoint("cf1", pointMap, geometry, _camera, -w2, 0, 1);
          setPoint("cf2", pointMap, geometry, _camera, w2, 0, 1);
          setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
          setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
          setPoint("cn1", pointMap, geometry, _camera, -w2, 0, -1);
          setPoint("cn2", pointMap, geometry, _camera, w2, 0, -1);
          setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
          setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
          geometry.getAttribute("position").needsUpdate = true;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      function setPoint(point, pointMap, geometry, camera, x2, y2, z2) {
        _vector.set(x2, y2, z2).unproject(camera);
        const points = pointMap[point];
        if (points !== void 0) {
          const position = geometry.getAttribute("position");
          for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
            position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
          }
        }
      }
      var _box = /* @__PURE__ */ new Box3();
      var BoxHelper = class extends LineSegments {
        constructor(object, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = new Float32Array(8 * 3);
          const geometry = new BufferGeometry();
          geometry.setIndex(new BufferAttribute(indices, 1));
          geometry.setAttribute("position", new BufferAttribute(positions, 3));
          super(geometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.object = object;
          this.type = "BoxHelper";
          this.matrixAutoUpdate = false;
          this.update();
        }
        update(object) {
          if (object !== void 0) {
            console.warn("THREE.BoxHelper: .update() has no longer arguments.");
          }
          if (this.object !== void 0) {
            _box.setFromObject(this.object);
          }
          if (_box.isEmpty())
            return;
          const min = _box.min;
          const max = _box.max;
          const position = this.geometry.attributes.position;
          const array = position.array;
          array[0] = max.x;
          array[1] = max.y;
          array[2] = max.z;
          array[3] = min.x;
          array[4] = max.y;
          array[5] = max.z;
          array[6] = min.x;
          array[7] = min.y;
          array[8] = max.z;
          array[9] = max.x;
          array[10] = min.y;
          array[11] = max.z;
          array[12] = max.x;
          array[13] = max.y;
          array[14] = min.z;
          array[15] = min.x;
          array[16] = max.y;
          array[17] = min.z;
          array[18] = min.x;
          array[19] = min.y;
          array[20] = min.z;
          array[21] = max.x;
          array[22] = min.y;
          array[23] = min.z;
          position.needsUpdate = true;
          this.geometry.computeBoundingSphere();
        }
        setFromObject(object) {
          this.object = object;
          this.update();
          return this;
        }
        copy(source) {
          LineSegments.prototype.copy.call(this, source);
          this.object = source.object;
          return this;
        }
      };
      var Box3Helper = class extends LineSegments {
        constructor(box, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
          const geometry = new BufferGeometry();
          geometry.setIndex(new BufferAttribute(indices, 1));
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          super(geometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.box = box;
          this.type = "Box3Helper";
          this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
          const box = this.box;
          if (box.isEmpty())
            return;
          box.getCenter(this.position);
          box.getSize(this.scale);
          this.scale.multiplyScalar(0.5);
          super.updateMatrixWorld(force);
        }
      };
      var PlaneHelper = class extends Line {
        constructor(plane, size = 1, hex = 16776960) {
          const color = hex;
          const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          geometry.computeBoundingSphere();
          super(geometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.type = "PlaneHelper";
          this.plane = plane;
          this.size = size;
          const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
          const geometry2 = new BufferGeometry();
          geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
          geometry2.computeBoundingSphere();
          this.add(new Mesh(geometry2, new MeshBasicMaterial({
            color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
          })));
        }
        updateMatrixWorld(force) {
          let scale = -this.plane.constant;
          if (Math.abs(scale) < 1e-8)
            scale = 1e-8;
          this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
          this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
          this.lookAt(this.plane.normal);
          super.updateMatrixWorld(force);
        }
      };
      var _axis = /* @__PURE__ */ new Vector3();
      var _lineGeometry;
      var _coneGeometry;
      var ArrowHelper = class extends Object3D {
        constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
          super();
          this.type = "ArrowHelper";
          if (_lineGeometry === void 0) {
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
          }
          this.position.copy(origin);
          this.line = new Line(_lineGeometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
          this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
            color,
            toneMapped: false
          }));
          this.cone.matrixAutoUpdate = false;
          this.add(this.cone);
          this.setDirection(dir);
          this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
          if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
          } else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
          } else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
          }
        }
        setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
          this.line.updateMatrix();
          this.cone.scale.set(headWidth, headLength, headWidth);
          this.cone.position.y = length;
          this.cone.updateMatrix();
        }
        setColor(color) {
          this.line.material.color.set(color);
          this.cone.material.color.set(color);
        }
        copy(source) {
          super.copy(source, false);
          this.line.copy(source.line);
          this.cone.copy(source.cone);
          return this;
        }
      };
      var AxesHelper = class extends LineSegments {
        constructor(size = 1) {
          const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
          const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "AxesHelper";
        }
        setColors(xAxisColor, yAxisColor, zAxisColor) {
          const color = new Color();
          const array = this.geometry.attributes.color.array;
          color.set(xAxisColor);
          color.toArray(array, 0);
          color.toArray(array, 3);
          color.set(yAxisColor);
          color.toArray(array, 6);
          color.toArray(array, 9);
          color.set(zAxisColor);
          color.toArray(array, 12);
          color.toArray(array, 15);
          this.geometry.attributes.color.needsUpdate = true;
          return this;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      var ShapePath = class {
        constructor() {
          this.type = "ShapePath";
          this.color = new Color();
          this.subPaths = [];
          this.currentPath = null;
        }
        moveTo(x2, y2) {
          this.currentPath = new Path();
          this.subPaths.push(this.currentPath);
          this.currentPath.moveTo(x2, y2);
          return this;
        }
        lineTo(x2, y2) {
          this.currentPath.lineTo(x2, y2);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
          return this;
        }
        splineThru(pts) {
          this.currentPath.splineThru(pts);
          return this;
        }
        toShapes(isCCW, noHoles) {
          function toShapesNoHoles(inSubpaths) {
            const shapes2 = [];
            for (let i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
              const tmpPath2 = inSubpaths[i2];
              const tmpShape2 = new Shape();
              tmpShape2.curves = tmpPath2.curves;
              shapes2.push(tmpShape2);
            }
            return shapes2;
          }
          function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for (let p = polyLen - 1, q2 = 0; q2 < polyLen; p = q2++) {
              let edgeLowPt = inPolygon[p];
              let edgeHighPt = inPolygon[q2];
              let edgeDx = edgeHighPt.x - edgeLowPt.x;
              let edgeDy = edgeHighPt.y - edgeLowPt.y;
              if (Math.abs(edgeDy) > Number.EPSILON) {
                if (edgeDy < 0) {
                  edgeLowPt = inPolygon[q2];
                  edgeDx = -edgeDx;
                  edgeHighPt = inPolygon[p];
                  edgeDy = -edgeDy;
                }
                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                  continue;
                if (inPt.y === edgeLowPt.y) {
                  if (inPt.x === edgeLowPt.x)
                    return true;
                } else {
                  const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                  if (perpEdge === 0)
                    return true;
                  if (perpEdge < 0)
                    continue;
                  inside = !inside;
                }
              } else {
                if (inPt.y !== edgeLowPt.y)
                  continue;
                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                  return true;
              }
            }
            return inside;
          }
          const isClockWise = ShapeUtils.isClockWise;
          const subPaths = this.subPaths;
          if (subPaths.length === 0)
            return [];
          if (noHoles === true)
            return toShapesNoHoles(subPaths);
          let solid, tmpPath, tmpShape;
          const shapes = [];
          if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
          }
          let holesFirst = !isClockWise(subPaths[0].getPoints());
          holesFirst = isCCW ? !holesFirst : holesFirst;
          const betterShapeHoles = [];
          const newShapes = [];
          let newShapeHoles = [];
          let mainIdx = 0;
          let tmpPoints;
          newShapes[mainIdx] = void 0;
          newShapeHoles[mainIdx] = [];
          for (let i2 = 0, l2 = subPaths.length; i2 < l2; i2++) {
            tmpPath = subPaths[i2];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
              if (!holesFirst && newShapes[mainIdx])
                mainIdx++;
              newShapes[mainIdx] = {
                s: new Shape(),
                p: tmpPoints
              };
              newShapes[mainIdx].s.curves = tmpPath.curves;
              if (holesFirst)
                mainIdx++;
              newShapeHoles[mainIdx] = [];
            } else {
              newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
              });
            }
          }
          if (!newShapes[0])
            return toShapesNoHoles(subPaths);
          if (newShapes.length > 1) {
            let ambiguous = false;
            let toChange = 0;
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              const sho = newShapeHoles[sIdx];
              for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                const ho2 = sho[hIdx];
                let hole_unassigned = true;
                for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                  if (isPointInsidePolygon(ho2.p, newShapes[s2Idx].p)) {
                    if (sIdx !== s2Idx)
                      toChange++;
                    if (hole_unassigned) {
                      hole_unassigned = false;
                      betterShapeHoles[s2Idx].push(ho2);
                    } else {
                      ambiguous = true;
                    }
                  }
                }
                if (hole_unassigned) {
                  betterShapeHoles[sIdx].push(ho2);
                }
              }
            }
            if (toChange > 0 && ambiguous === false) {
              newShapeHoles = betterShapeHoles;
            }
          }
          let tmpHoles;
          for (let i2 = 0, il2 = newShapes.length; i2 < il2; i2++) {
            tmpShape = newShapes[i2].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i2];
            for (let j2 = 0, jl2 = tmpHoles.length; j2 < jl2; j2++) {
              tmpShape.holes.push(tmpHoles[j2].h);
            }
          }
          return shapes;
        }
      };
      var _floatView = new Float32Array(1);
      var _int32View = new Int32Array(_floatView.buffer);
      var DataUtils = class {
        static toHalfFloat(val) {
          if (val > 65504) {
            console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504.");
            val = 65504;
          }
          _floatView[0] = val;
          const x2 = _int32View[0];
          let bits = x2 >> 16 & 32768;
          let m2 = x2 >> 12 & 2047;
          const e4 = x2 >> 23 & 255;
          if (e4 < 103)
            return bits;
          if (e4 > 142) {
            bits |= 31744;
            bits |= (e4 == 255 ? 0 : 1) && x2 & 8388607;
            return bits;
          }
          if (e4 < 113) {
            m2 |= 2048;
            bits |= (m2 >> 114 - e4) + (m2 >> 113 - e4 & 1);
            return bits;
          }
          bits |= e4 - 112 << 10 | m2 >> 1;
          bits += m2 & 1;
          return bits;
        }
      };
      var LineStrip = 0;
      var LinePieces = 1;
      var NoColors = 0;
      var FaceColors = 1;
      var VertexColors = 2;
      function MeshFaceMaterial(materials) {
        console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
        return materials;
      }
      function MultiMaterial(materials = []) {
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function() {
          return materials.slice();
        };
        return materials;
      }
      function PointCloud(geometry, material) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        return new Points(geometry, material);
      }
      function Particle(material) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        return new Sprite(material);
      }
      function ParticleSystem(geometry, material) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        return new Points(geometry, material);
      }
      function PointCloudMaterial(parameters) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function ParticleBasicMaterial(parameters) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function ParticleSystemMaterial(parameters) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function Vertex(x2, y2, z2) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        return new Vector3(x2, y2, z2);
      }
      function DynamicBufferAttribute(array, itemSize) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
        return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
      }
      function Int8Attribute(array, itemSize) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        return new Int8BufferAttribute(array, itemSize);
      }
      function Uint8Attribute(array, itemSize) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        return new Uint8BufferAttribute(array, itemSize);
      }
      function Uint8ClampedAttribute(array, itemSize) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        return new Uint8ClampedBufferAttribute(array, itemSize);
      }
      function Int16Attribute(array, itemSize) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        return new Int16BufferAttribute(array, itemSize);
      }
      function Uint16Attribute(array, itemSize) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        return new Uint16BufferAttribute(array, itemSize);
      }
      function Int32Attribute(array, itemSize) {
        console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
        return new Int32BufferAttribute(array, itemSize);
      }
      function Uint32Attribute(array, itemSize) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        return new Uint32BufferAttribute(array, itemSize);
      }
      function Float32Attribute(array, itemSize) {
        console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
        return new Float32BufferAttribute(array, itemSize);
      }
      function Float64Attribute(array, itemSize) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        return new Float64BufferAttribute(array, itemSize);
      }
      Curve.create = function(construct, getPoint) {
        console.log("THREE.Curve.create() has been deprecated");
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
      };
      Path.prototype.fromPoints = function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      };
      function AxisHelper(size) {
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
        return new AxesHelper(size);
      }
      function BoundingBoxHelper(object, color) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new BoxHelper(object, color);
      }
      function EdgesHelper(object, hex) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      GridHelper.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      };
      SkeletonHelper.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      };
      function WireframeHelper(object, hex) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      Loader.prototype.extractUrlBase = function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
      };
      Loader.Handlers = {
        add: function() {
          console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
        },
        get: function() {
          console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
        }
      };
      function XHRLoader(manager) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        return new FileLoader(manager);
      }
      function BinaryTextureLoader(manager) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        return new DataTextureLoader(manager);
      }
      Box2.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box2.prototype.empty = function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box2.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box2.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Box3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box3.prototype.empty = function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box3.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box3.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Box3.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Euler.prototype.toVector3 = function() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
      };
      Sphere.prototype.empty = function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Frustum.prototype.setFromMatrix = function(m2) {
        console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
        return this.setFromProjectionMatrix(m2);
      };
      Line3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix3.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      };
      Matrix3.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      };
      Matrix3.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
      };
      Matrix3.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      };
      Matrix3.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Matrix4.prototype.extractPosition = function(m2) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m2);
      };
      Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix4.prototype.getPosition = function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector3().setFromMatrixColumn(this, 3);
      };
      Matrix4.prototype.setRotationFromQuaternion = function(q2) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q2);
      };
      Matrix4.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      Matrix4.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector4 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      };
      Matrix4.prototype.rotateAxis = function(v2) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v2.transformDirection(this);
      };
      Matrix4.prototype.crossVector = function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      Matrix4.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      Matrix4.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      Matrix4.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      Matrix4.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      Matrix4.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
      };
      Matrix4.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      };
      Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      };
      Matrix4.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Plane.prototype.isIntersectionLine = function(line) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(line);
      };
      Quaternion.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return vector.applyQuaternion(this);
      };
      Quaternion.prototype.inverse = function() {
        console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
        return this.invert();
      };
      Ray.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Ray.prototype.isIntersectionPlane = function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      };
      Ray.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Triangle.prototype.area = function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      };
      Triangle.prototype.barycoordFromPoint = function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      };
      Triangle.prototype.midpoint = function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      };
      Triangle.prototypenormal = function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      };
      Triangle.prototype.plane = function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      };
      Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a2, b2, c2, target);
      };
      Triangle.normal = function(a2, b2, c2, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a2, b2, c2, target);
      };
      Shape.prototype.extractAllPoints = function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      };
      Shape.prototype.extrude = function(options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options);
      };
      Shape.prototype.makeGeometry = function(options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options);
      };
      Vector2.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector2.prototype.distanceToManhattan = function(v2) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v2);
      };
      Vector2.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector3.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      };
      Vector3.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      };
      Vector3.prototype.getPositionFromMatrix = function(m2) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m2);
      };
      Vector3.prototype.getScaleFromMatrix = function(m2) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m2);
      };
      Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
      };
      Vector3.prototype.applyProjection = function(m2) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m2);
      };
      Vector3.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector3.prototype.distanceToManhattan = function(v2) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v2);
      };
      Vector3.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector4.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector4.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Object3D.prototype.getChildByName = function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      };
      Object3D.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      };
      Object3D.prototype.translate = function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      };
      Object3D.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      };
      Object3D.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
          get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
          },
          set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
          }
        },
        useQuaternion: {
          get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          },
          set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          }
        }
      });
      Mesh.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      };
      Object.defineProperties(Mesh.prototype, {
        drawMode: {
          get: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
            return TrianglesDrawMode;
          },
          set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
          }
        }
      });
      SkinnedMesh.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== void 0)
          this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
      };
      Object.defineProperties(Light.prototype, {
        onlyShadow: {
          set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          }
        },
        shadowCameraFov: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
          }
        },
        shadowCameraLeft: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
          }
        },
        shadowCameraRight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
          }
        },
        shadowCameraTop: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
          }
        },
        shadowCameraBottom: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
          }
        },
        shadowCameraNear: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
          }
        },
        shadowCameraFar: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
          }
        },
        shadowCameraVisible: {
          set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
          }
        },
        shadowBias: {
          set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
          }
        },
        shadowDarkness: {
          set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          }
        },
        shadowMapWidth: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
          }
        },
        shadowMapHeight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
          }
        }
      });
      Object.defineProperties(BufferAttribute.prototype, {
        length: {
          get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
          }
        },
        dynamic: {
          get: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            return this.usage === DynamicDrawUsage;
          },
          set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            this.setUsage(DynamicDrawUsage);
          }
        }
      });
      BufferAttribute.prototype.setDynamic = function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      BufferAttribute.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, BufferAttribute.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      BufferGeometry.prototype.addIndex = function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
      };
      BufferGeometry.prototype.addAttribute = function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      };
      BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      };
      BufferGeometry.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      };
      BufferGeometry.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      };
      BufferGeometry.prototype.removeAttribute = function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      };
      BufferGeometry.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
          get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
          }
        },
        offsets: {
          get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
          }
        }
      });
      InterleavedBuffer.prototype.setDynamic = function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      InterleavedBuffer.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      ExtrudeGeometry.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      ExtrudeGeometry.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      };
      ExtrudeGeometry.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Scene.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Uniform.prototype.onUpdate = function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      };
      Object.defineProperties(Material.prototype, {
        wrapAround: {
          get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          }
        },
        overdraw: {
          get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          }
        },
        wrapRGB: {
          get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color();
          }
        },
        shading: {
          get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading;
          }
        },
        stencilMask: {
          get: function() {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            return this.stencilFuncMask;
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            this.stencilFuncMask = value;
          }
        },
        vertexTangents: {
          get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          },
          set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          }
        }
      });
      Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
          get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
          },
          set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
          }
        }
      });
      WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      WebGLRenderer.prototype.animate = function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      };
      WebGLRenderer.prototype.getCurrentRenderTarget = function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      };
      WebGLRenderer.prototype.getMaxAnisotropy = function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      };
      WebGLRenderer.prototype.getPrecision = function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      };
      WebGLRenderer.prototype.resetGLState = function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      };
      WebGLRenderer.prototype.supportsFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      };
      WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      };
      WebGLRenderer.prototype.supportsStandardDerivatives = function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      };
      WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      };
      WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      };
      WebGLRenderer.prototype.supportsBlendMinMax = function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      };
      WebGLRenderer.prototype.supportsVertexTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      };
      WebGLRenderer.prototype.supportsInstancedArrays = function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      };
      WebGLRenderer.prototype.enableScissorTest = function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      };
      WebGLRenderer.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      WebGLRenderer.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      WebGLRenderer.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      WebGLRenderer.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      };
      WebGLRenderer.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      };
      WebGLRenderer.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      };
      WebGLRenderer.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      WebGLRenderer.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      WebGLRenderer.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      };
      WebGLRenderer.prototype.getActiveMipMapLevel = function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      };
      Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
          get: function() {
            return this.shadowMap.enabled;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return this.shadowMap.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        context: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
            return this.getContext();
          }
        },
        vr: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
            return this.xr;
          }
        },
        gammaInput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
            return false;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          }
        },
        gammaOutput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            return false;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
          }
        },
        toneMappingWhitePoint: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
            return 1;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          }
        },
        gammaFactor: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
            return 2;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          }
        }
      });
      Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        renderReverseSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          }
        },
        renderSingleSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          }
        }
      });
      function WebGLRenderTargetCube(width, height, options) {
        console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
        return new WebGLCubeRenderTarget(width, options);
      }
      Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
          }
        },
        wrapT: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
          }
        },
        magFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
          }
        },
        minFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
          }
        },
        anisotropy: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
          }
        },
        offset: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
          }
        },
        repeat: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
          }
        },
        format: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
          }
        },
        type: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
          }
        },
        generateMipmaps: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
          }
        }
      });
      Audio.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const scope = this;
        const audioLoader = new AudioLoader();
        audioLoader.load(file, function(buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      };
      AudioAnalyser.prototype.getData = function() {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData();
      };
      CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
        return this.update(renderer, scene);
      };
      CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
        console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
        return this.renderTarget.clear(renderer, color, depth, stencil);
      };
      ImageUtils.crossOrigin = void 0;
      ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const loader = new TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(url, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const loader = new CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(urls, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      };
      ImageUtils.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function JSONLoader() {
        console.error("THREE.JSONLoader has been removed.");
      }
      var SceneUtils = {
        createMultiMaterialObject: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        detach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        attach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        }
      };
      function LensFlare() {
        console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
      }
      function ParametricGeometry() {
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");
        return new BufferGeometry();
      }
      function TextGeometry() {
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");
        return new BufferGeometry();
      }
      function FontLoader() {
        console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
      }
      function Font() {
        console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
      }
      function ImmediateRenderObject() {
        console.error("THREE.ImmediateRenderObject has been removed.");
      }
      function WebGLMultisampleRenderTarget(width, height, options) {
        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
        const renderTarget = new WebGLRenderTarget(width, height, options);
        renderTarget.samples = 4;
        return renderTarget;
      }
      function DataTexture2DArray(data, width, height, depth) {
        console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture.");
        return new DataArrayTexture(data, width, height, depth);
      }
      function DataTexture3D(data, width, height, depth) {
        console.warn("THREE.DataTexture3D has been renamed to Data3DTexture.");
        return new Data3DTexture(data, width, height, depth);
      }
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
          detail: {
            revision: REVISION
          }
        }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION;
        }
      }
      exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
      exports.AddEquation = AddEquation;
      exports.AddOperation = AddOperation;
      exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
      exports.AdditiveBlending = AdditiveBlending;
      exports.AlphaFormat = AlphaFormat;
      exports.AlwaysDepth = AlwaysDepth;
      exports.AlwaysStencilFunc = AlwaysStencilFunc;
      exports.AmbientLight = AmbientLight;
      exports.AmbientLightProbe = AmbientLightProbe;
      exports.AnimationClip = AnimationClip;
      exports.AnimationLoader = AnimationLoader;
      exports.AnimationMixer = AnimationMixer;
      exports.AnimationObjectGroup = AnimationObjectGroup;
      exports.AnimationUtils = AnimationUtils;
      exports.ArcCurve = ArcCurve;
      exports.ArrayCamera = ArrayCamera;
      exports.ArrowHelper = ArrowHelper;
      exports.Audio = Audio;
      exports.AudioAnalyser = AudioAnalyser;
      exports.AudioContext = AudioContext2;
      exports.AudioListener = AudioListener;
      exports.AudioLoader = AudioLoader;
      exports.AxesHelper = AxesHelper;
      exports.AxisHelper = AxisHelper;
      exports.BackSide = BackSide;
      exports.BasicDepthPacking = BasicDepthPacking;
      exports.BasicShadowMap = BasicShadowMap;
      exports.BinaryTextureLoader = BinaryTextureLoader;
      exports.Bone = Bone;
      exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
      exports.BoundingBoxHelper = BoundingBoxHelper;
      exports.Box2 = Box2;
      exports.Box3 = Box3;
      exports.Box3Helper = Box3Helper;
      exports.BoxBufferGeometry = BoxGeometry;
      exports.BoxGeometry = BoxGeometry;
      exports.BoxHelper = BoxHelper;
      exports.BufferAttribute = BufferAttribute;
      exports.BufferGeometry = BufferGeometry;
      exports.BufferGeometryLoader = BufferGeometryLoader;
      exports.ByteType = ByteType;
      exports.Cache = Cache;
      exports.Camera = Camera;
      exports.CameraHelper = CameraHelper;
      exports.CanvasRenderer = CanvasRenderer;
      exports.CanvasTexture = CanvasTexture;
      exports.CatmullRomCurve3 = CatmullRomCurve3;
      exports.CineonToneMapping = CineonToneMapping;
      exports.CircleBufferGeometry = CircleGeometry;
      exports.CircleGeometry = CircleGeometry;
      exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
      exports.Clock = Clock;
      exports.Color = Color;
      exports.ColorKeyframeTrack = ColorKeyframeTrack;
      exports.CompressedTexture = CompressedTexture;
      exports.CompressedTextureLoader = CompressedTextureLoader;
      exports.ConeBufferGeometry = ConeGeometry;
      exports.ConeGeometry = ConeGeometry;
      exports.CubeCamera = CubeCamera;
      exports.CubeReflectionMapping = CubeReflectionMapping;
      exports.CubeRefractionMapping = CubeRefractionMapping;
      exports.CubeTexture = CubeTexture;
      exports.CubeTextureLoader = CubeTextureLoader;
      exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
      exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
      exports.CubicBezierCurve = CubicBezierCurve;
      exports.CubicBezierCurve3 = CubicBezierCurve3;
      exports.CubicInterpolant = CubicInterpolant;
      exports.CullFaceBack = CullFaceBack;
      exports.CullFaceFront = CullFaceFront;
      exports.CullFaceFrontBack = CullFaceFrontBack;
      exports.CullFaceNone = CullFaceNone;
      exports.Curve = Curve;
      exports.CurvePath = CurvePath;
      exports.CustomBlending = CustomBlending;
      exports.CustomToneMapping = CustomToneMapping;
      exports.CylinderBufferGeometry = CylinderGeometry;
      exports.CylinderGeometry = CylinderGeometry;
      exports.Cylindrical = Cylindrical;
      exports.Data3DTexture = Data3DTexture;
      exports.DataArrayTexture = DataArrayTexture;
      exports.DataTexture = DataTexture;
      exports.DataTexture2DArray = DataTexture2DArray;
      exports.DataTexture3D = DataTexture3D;
      exports.DataTextureLoader = DataTextureLoader;
      exports.DataUtils = DataUtils;
      exports.DecrementStencilOp = DecrementStencilOp;
      exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
      exports.DefaultLoadingManager = DefaultLoadingManager;
      exports.DepthFormat = DepthFormat;
      exports.DepthStencilFormat = DepthStencilFormat;
      exports.DepthTexture = DepthTexture;
      exports.DirectionalLight = DirectionalLight;
      exports.DirectionalLightHelper = DirectionalLightHelper;
      exports.DiscreteInterpolant = DiscreteInterpolant;
      exports.DodecahedronBufferGeometry = DodecahedronGeometry;
      exports.DodecahedronGeometry = DodecahedronGeometry;
      exports.DoubleSide = DoubleSide;
      exports.DstAlphaFactor = DstAlphaFactor;
      exports.DstColorFactor = DstColorFactor;
      exports.DynamicBufferAttribute = DynamicBufferAttribute;
      exports.DynamicCopyUsage = DynamicCopyUsage;
      exports.DynamicDrawUsage = DynamicDrawUsage;
      exports.DynamicReadUsage = DynamicReadUsage;
      exports.EdgesGeometry = EdgesGeometry;
      exports.EdgesHelper = EdgesHelper;
      exports.EllipseCurve = EllipseCurve;
      exports.EqualDepth = EqualDepth;
      exports.EqualStencilFunc = EqualStencilFunc;
      exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
      exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
      exports.Euler = Euler;
      exports.EventDispatcher = EventDispatcher;
      exports.ExtrudeBufferGeometry = ExtrudeGeometry;
      exports.ExtrudeGeometry = ExtrudeGeometry;
      exports.FaceColors = FaceColors;
      exports.FileLoader = FileLoader;
      exports.FlatShading = FlatShading;
      exports.Float16BufferAttribute = Float16BufferAttribute;
      exports.Float32Attribute = Float32Attribute;
      exports.Float32BufferAttribute = Float32BufferAttribute;
      exports.Float64Attribute = Float64Attribute;
      exports.Float64BufferAttribute = Float64BufferAttribute;
      exports.FloatType = FloatType;
      exports.Fog = Fog;
      exports.FogExp2 = FogExp2;
      exports.Font = Font;
      exports.FontLoader = FontLoader;
      exports.FramebufferTexture = FramebufferTexture;
      exports.FrontSide = FrontSide;
      exports.Frustum = Frustum;
      exports.GLBufferAttribute = GLBufferAttribute;
      exports.GLSL1 = GLSL1;
      exports.GLSL3 = GLSL3;
      exports.GreaterDepth = GreaterDepth;
      exports.GreaterEqualDepth = GreaterEqualDepth;
      exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
      exports.GreaterStencilFunc = GreaterStencilFunc;
      exports.GridHelper = GridHelper;
      exports.Group = Group;
      exports.HalfFloatType = HalfFloatType;
      exports.HemisphereLight = HemisphereLight;
      exports.HemisphereLightHelper = HemisphereLightHelper;
      exports.HemisphereLightProbe = HemisphereLightProbe;
      exports.IcosahedronBufferGeometry = IcosahedronGeometry;
      exports.IcosahedronGeometry = IcosahedronGeometry;
      exports.ImageBitmapLoader = ImageBitmapLoader;
      exports.ImageLoader = ImageLoader;
      exports.ImageUtils = ImageUtils;
      exports.ImmediateRenderObject = ImmediateRenderObject;
      exports.IncrementStencilOp = IncrementStencilOp;
      exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
      exports.InstancedBufferAttribute = InstancedBufferAttribute;
      exports.InstancedBufferGeometry = InstancedBufferGeometry;
      exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
      exports.InstancedMesh = InstancedMesh;
      exports.Int16Attribute = Int16Attribute;
      exports.Int16BufferAttribute = Int16BufferAttribute;
      exports.Int32Attribute = Int32Attribute;
      exports.Int32BufferAttribute = Int32BufferAttribute;
      exports.Int8Attribute = Int8Attribute;
      exports.Int8BufferAttribute = Int8BufferAttribute;
      exports.IntType = IntType;
      exports.InterleavedBuffer = InterleavedBuffer;
      exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
      exports.Interpolant = Interpolant;
      exports.InterpolateDiscrete = InterpolateDiscrete;
      exports.InterpolateLinear = InterpolateLinear;
      exports.InterpolateSmooth = InterpolateSmooth;
      exports.InvertStencilOp = InvertStencilOp;
      exports.JSONLoader = JSONLoader;
      exports.KeepStencilOp = KeepStencilOp;
      exports.KeyframeTrack = KeyframeTrack;
      exports.LOD = LOD;
      exports.LatheBufferGeometry = LatheGeometry;
      exports.LatheGeometry = LatheGeometry;
      exports.Layers = Layers;
      exports.LensFlare = LensFlare;
      exports.LessDepth = LessDepth;
      exports.LessEqualDepth = LessEqualDepth;
      exports.LessEqualStencilFunc = LessEqualStencilFunc;
      exports.LessStencilFunc = LessStencilFunc;
      exports.Light = Light;
      exports.LightProbe = LightProbe;
      exports.Line = Line;
      exports.Line3 = Line3;
      exports.LineBasicMaterial = LineBasicMaterial;
      exports.LineCurve = LineCurve;
      exports.LineCurve3 = LineCurve3;
      exports.LineDashedMaterial = LineDashedMaterial;
      exports.LineLoop = LineLoop;
      exports.LinePieces = LinePieces;
      exports.LineSegments = LineSegments;
      exports.LineStrip = LineStrip;
      exports.LinearEncoding = LinearEncoding;
      exports.LinearFilter = LinearFilter;
      exports.LinearInterpolant = LinearInterpolant;
      exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
      exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
      exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
      exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
      exports.LinearToneMapping = LinearToneMapping;
      exports.Loader = Loader;
      exports.LoaderUtils = LoaderUtils;
      exports.LoadingManager = LoadingManager;
      exports.LoopOnce = LoopOnce;
      exports.LoopPingPong = LoopPingPong;
      exports.LoopRepeat = LoopRepeat;
      exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
      exports.LuminanceFormat = LuminanceFormat;
      exports.MOUSE = MOUSE;
      exports.Material = Material;
      exports.MaterialLoader = MaterialLoader;
      exports.Math = MathUtils;
      exports.MathUtils = MathUtils;
      exports.Matrix3 = Matrix3;
      exports.Matrix4 = Matrix4;
      exports.MaxEquation = MaxEquation;
      exports.Mesh = Mesh;
      exports.MeshBasicMaterial = MeshBasicMaterial;
      exports.MeshDepthMaterial = MeshDepthMaterial;
      exports.MeshDistanceMaterial = MeshDistanceMaterial;
      exports.MeshFaceMaterial = MeshFaceMaterial;
      exports.MeshLambertMaterial = MeshLambertMaterial;
      exports.MeshMatcapMaterial = MeshMatcapMaterial;
      exports.MeshNormalMaterial = MeshNormalMaterial;
      exports.MeshPhongMaterial = MeshPhongMaterial;
      exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
      exports.MeshStandardMaterial = MeshStandardMaterial;
      exports.MeshToonMaterial = MeshToonMaterial;
      exports.MinEquation = MinEquation;
      exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
      exports.MixOperation = MixOperation;
      exports.MultiMaterial = MultiMaterial;
      exports.MultiplyBlending = MultiplyBlending;
      exports.MultiplyOperation = MultiplyOperation;
      exports.NearestFilter = NearestFilter;
      exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
      exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
      exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
      exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
      exports.NeverDepth = NeverDepth;
      exports.NeverStencilFunc = NeverStencilFunc;
      exports.NoBlending = NoBlending;
      exports.NoColors = NoColors;
      exports.NoToneMapping = NoToneMapping;
      exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
      exports.NormalBlending = NormalBlending;
      exports.NotEqualDepth = NotEqualDepth;
      exports.NotEqualStencilFunc = NotEqualStencilFunc;
      exports.NumberKeyframeTrack = NumberKeyframeTrack;
      exports.Object3D = Object3D;
      exports.ObjectLoader = ObjectLoader;
      exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
      exports.OctahedronBufferGeometry = OctahedronGeometry;
      exports.OctahedronGeometry = OctahedronGeometry;
      exports.OneFactor = OneFactor;
      exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
      exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
      exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
      exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
      exports.OrthographicCamera = OrthographicCamera;
      exports.PCFShadowMap = PCFShadowMap;
      exports.PCFSoftShadowMap = PCFSoftShadowMap;
      exports.PMREMGenerator = PMREMGenerator;
      exports.ParametricGeometry = ParametricGeometry;
      exports.Particle = Particle;
      exports.ParticleBasicMaterial = ParticleBasicMaterial;
      exports.ParticleSystem = ParticleSystem;
      exports.ParticleSystemMaterial = ParticleSystemMaterial;
      exports.Path = Path;
      exports.PerspectiveCamera = PerspectiveCamera;
      exports.Plane = Plane;
      exports.PlaneBufferGeometry = PlaneGeometry;
      exports.PlaneGeometry = PlaneGeometry;
      exports.PlaneHelper = PlaneHelper;
      exports.PointCloud = PointCloud;
      exports.PointCloudMaterial = PointCloudMaterial;
      exports.PointLight = PointLight;
      exports.PointLightHelper = PointLightHelper;
      exports.Points = Points;
      exports.PointsMaterial = PointsMaterial;
      exports.PolarGridHelper = PolarGridHelper;
      exports.PolyhedronBufferGeometry = PolyhedronGeometry;
      exports.PolyhedronGeometry = PolyhedronGeometry;
      exports.PositionalAudio = PositionalAudio;
      exports.PropertyBinding = PropertyBinding;
      exports.PropertyMixer = PropertyMixer;
      exports.QuadraticBezierCurve = QuadraticBezierCurve;
      exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
      exports.Quaternion = Quaternion;
      exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
      exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
      exports.REVISION = REVISION;
      exports.RGBADepthPacking = RGBADepthPacking;
      exports.RGBAFormat = RGBAFormat;
      exports.RGBAIntegerFormat = RGBAIntegerFormat;
      exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
      exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
      exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
      exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
      exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
      exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
      exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
      exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
      exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
      exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
      exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
      exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
      exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
      exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
      exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
      exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
      exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
      exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
      exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
      exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
      exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
      exports.RGBFormat = RGBFormat;
      exports.RGB_ETC1_Format = RGB_ETC1_Format;
      exports.RGB_ETC2_Format = RGB_ETC2_Format;
      exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
      exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
      exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
      exports.RGFormat = RGFormat;
      exports.RGIntegerFormat = RGIntegerFormat;
      exports.RawShaderMaterial = RawShaderMaterial;
      exports.Ray = Ray;
      exports.Raycaster = Raycaster;
      exports.RectAreaLight = RectAreaLight;
      exports.RedFormat = RedFormat;
      exports.RedIntegerFormat = RedIntegerFormat;
      exports.ReinhardToneMapping = ReinhardToneMapping;
      exports.RepeatWrapping = RepeatWrapping;
      exports.ReplaceStencilOp = ReplaceStencilOp;
      exports.ReverseSubtractEquation = ReverseSubtractEquation;
      exports.RingBufferGeometry = RingGeometry;
      exports.RingGeometry = RingGeometry;
      exports.Scene = Scene;
      exports.SceneUtils = SceneUtils;
      exports.ShaderChunk = ShaderChunk;
      exports.ShaderLib = ShaderLib;
      exports.ShaderMaterial = ShaderMaterial;
      exports.ShadowMaterial = ShadowMaterial;
      exports.Shape = Shape;
      exports.ShapeBufferGeometry = ShapeGeometry;
      exports.ShapeGeometry = ShapeGeometry;
      exports.ShapePath = ShapePath;
      exports.ShapeUtils = ShapeUtils;
      exports.ShortType = ShortType;
      exports.Skeleton = Skeleton;
      exports.SkeletonHelper = SkeletonHelper;
      exports.SkinnedMesh = SkinnedMesh;
      exports.SmoothShading = SmoothShading;
      exports.Sphere = Sphere;
      exports.SphereBufferGeometry = SphereGeometry;
      exports.SphereGeometry = SphereGeometry;
      exports.Spherical = Spherical;
      exports.SphericalHarmonics3 = SphericalHarmonics3;
      exports.SplineCurve = SplineCurve;
      exports.SpotLight = SpotLight;
      exports.SpotLightHelper = SpotLightHelper;
      exports.Sprite = Sprite;
      exports.SpriteMaterial = SpriteMaterial;
      exports.SrcAlphaFactor = SrcAlphaFactor;
      exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
      exports.SrcColorFactor = SrcColorFactor;
      exports.StaticCopyUsage = StaticCopyUsage;
      exports.StaticDrawUsage = StaticDrawUsage;
      exports.StaticReadUsage = StaticReadUsage;
      exports.StereoCamera = StereoCamera;
      exports.StreamCopyUsage = StreamCopyUsage;
      exports.StreamDrawUsage = StreamDrawUsage;
      exports.StreamReadUsage = StreamReadUsage;
      exports.StringKeyframeTrack = StringKeyframeTrack;
      exports.SubtractEquation = SubtractEquation;
      exports.SubtractiveBlending = SubtractiveBlending;
      exports.TOUCH = TOUCH;
      exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
      exports.TetrahedronBufferGeometry = TetrahedronGeometry;
      exports.TetrahedronGeometry = TetrahedronGeometry;
      exports.TextGeometry = TextGeometry;
      exports.Texture = Texture;
      exports.TextureLoader = TextureLoader;
      exports.TorusBufferGeometry = TorusGeometry;
      exports.TorusGeometry = TorusGeometry;
      exports.TorusKnotBufferGeometry = TorusKnotGeometry;
      exports.TorusKnotGeometry = TorusKnotGeometry;
      exports.Triangle = Triangle;
      exports.TriangleFanDrawMode = TriangleFanDrawMode;
      exports.TriangleStripDrawMode = TriangleStripDrawMode;
      exports.TrianglesDrawMode = TrianglesDrawMode;
      exports.TubeBufferGeometry = TubeGeometry;
      exports.TubeGeometry = TubeGeometry;
      exports.UVMapping = UVMapping;
      exports.Uint16Attribute = Uint16Attribute;
      exports.Uint16BufferAttribute = Uint16BufferAttribute;
      exports.Uint32Attribute = Uint32Attribute;
      exports.Uint32BufferAttribute = Uint32BufferAttribute;
      exports.Uint8Attribute = Uint8Attribute;
      exports.Uint8BufferAttribute = Uint8BufferAttribute;
      exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
      exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
      exports.Uniform = Uniform;
      exports.UniformsLib = UniformsLib;
      exports.UniformsUtils = UniformsUtils;
      exports.UnsignedByteType = UnsignedByteType;
      exports.UnsignedInt248Type = UnsignedInt248Type;
      exports.UnsignedIntType = UnsignedIntType;
      exports.UnsignedShort4444Type = UnsignedShort4444Type;
      exports.UnsignedShort5551Type = UnsignedShort5551Type;
      exports.UnsignedShortType = UnsignedShortType;
      exports.VSMShadowMap = VSMShadowMap;
      exports.Vector2 = Vector2;
      exports.Vector3 = Vector3;
      exports.Vector4 = Vector4;
      exports.VectorKeyframeTrack = VectorKeyframeTrack;
      exports.Vertex = Vertex;
      exports.VertexColors = VertexColors;
      exports.VideoTexture = VideoTexture;
      exports.WebGL1Renderer = WebGL1Renderer;
      exports.WebGL3DRenderTarget = WebGL3DRenderTarget;
      exports.WebGLArrayRenderTarget = WebGLArrayRenderTarget;
      exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
      exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
      exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
      exports.WebGLRenderTarget = WebGLRenderTarget;
      exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
      exports.WebGLRenderer = WebGLRenderer;
      exports.WebGLUtils = WebGLUtils;
      exports.WireframeGeometry = WireframeGeometry;
      exports.WireframeHelper = WireframeHelper;
      exports.WrapAroundEnding = WrapAroundEnding;
      exports.XHRLoader = XHRLoader;
      exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
      exports.ZeroFactor = ZeroFactor;
      exports.ZeroSlopeEnding = ZeroSlopeEnding;
      exports.ZeroStencilOp = ZeroStencilOp;
      exports._SRGBAFormat = _SRGBAFormat;
      exports.sRGBEncoding = sRGBEncoding;
    }
  });

  // (disabled):../../node_modules/paper/dist/node/self.js
  var require_self = __commonJS({
    "(disabled):../../node_modules/paper/dist/node/self.js"() {
    }
  });

  // ../../node_modules/acorn/dist/acorn.js
  var require_acorn = __commonJS({
    "../../node_modules/acorn/dist/acorn.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
      })(exports, function(exports2) {
        "use strict";
        var reservedWords = {
          3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
          5: "class enum extends super const export import",
          6: "enum",
          strict: "implements interface let package private protected public static yield",
          strictBind: "eval arguments"
        };
        var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
        var keywords$1 = {
          5: ecma5AndLessKeywords,
          "5module": ecma5AndLessKeywords + " export import",
          6: ecma5AndLessKeywords + " const class extends export import super"
        };
        var keywordRelationalOperator = /^in(stanceof)?$/;
        var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
        var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
        var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
        var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(code, set) {
          var pos = 65536;
          for (var i3 = 0; i3 < set.length; i3 += 2) {
            pos += set[i3];
            if (pos > code) {
              return false;
            }
            pos += set[i3 + 1];
            if (pos >= code) {
              return true;
            }
          }
        }
        function isIdentifierStart(code, astral) {
          if (code < 65) {
            return code === 36;
          }
          if (code < 91) {
            return true;
          }
          if (code < 97) {
            return code === 95;
          }
          if (code < 123) {
            return true;
          }
          if (code <= 65535) {
            return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
          }
          if (astral === false) {
            return false;
          }
          return isInAstralSet(code, astralIdentifierStartCodes);
        }
        function isIdentifierChar(code, astral) {
          if (code < 48) {
            return code === 36;
          }
          if (code < 58) {
            return true;
          }
          if (code < 65) {
            return false;
          }
          if (code < 91) {
            return true;
          }
          if (code < 97) {
            return code === 95;
          }
          if (code < 123) {
            return true;
          }
          if (code <= 65535) {
            return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
          }
          if (astral === false) {
            return false;
          }
          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
        }
        var TokenType = function TokenType2(label, conf) {
          if (conf === void 0)
            conf = {};
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop || null;
          this.updateContext = null;
        };
        function binop(name, prec) {
          return new TokenType(name, { beforeExpr: true, binop: prec });
        }
        var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
        var keywords = {};
        function kw(name, options) {
          if (options === void 0)
            options = {};
          options.keyword = name;
          return keywords[name] = new TokenType(name, options);
        }
        var types$1 = {
          num: new TokenType("num", startsExpr),
          regexp: new TokenType("regexp", startsExpr),
          string: new TokenType("string", startsExpr),
          name: new TokenType("name", startsExpr),
          privateId: new TokenType("privateId", startsExpr),
          eof: new TokenType("eof"),
          bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
          bracketR: new TokenType("]"),
          braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
          braceR: new TokenType("}"),
          parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
          parenR: new TokenType(")"),
          comma: new TokenType(",", beforeExpr),
          semi: new TokenType(";", beforeExpr),
          colon: new TokenType(":", beforeExpr),
          dot: new TokenType("."),
          question: new TokenType("?", beforeExpr),
          questionDot: new TokenType("?."),
          arrow: new TokenType("=>", beforeExpr),
          template: new TokenType("template"),
          invalidTemplate: new TokenType("invalidTemplate"),
          ellipsis: new TokenType("...", beforeExpr),
          backQuote: new TokenType("`", startsExpr),
          dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
          eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
          assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
          incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
          prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
          logicalOR: binop("||", 1),
          logicalAND: binop("&&", 2),
          bitwiseOR: binop("|", 3),
          bitwiseXOR: binop("^", 4),
          bitwiseAND: binop("&", 5),
          equality: binop("==/!=/===/!==", 6),
          relational: binop("</>/<=/>=", 7),
          bitShift: binop("<</>>/>>>", 8),
          plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
          modulo: binop("%", 10),
          star: binop("*", 10),
          slash: binop("/", 10),
          starstar: new TokenType("**", { beforeExpr: true }),
          coalesce: binop("??", 1),
          _break: kw("break"),
          _case: kw("case", beforeExpr),
          _catch: kw("catch"),
          _continue: kw("continue"),
          _debugger: kw("debugger"),
          _default: kw("default", beforeExpr),
          _do: kw("do", { isLoop: true, beforeExpr: true }),
          _else: kw("else", beforeExpr),
          _finally: kw("finally"),
          _for: kw("for", { isLoop: true }),
          _function: kw("function", startsExpr),
          _if: kw("if"),
          _return: kw("return", beforeExpr),
          _switch: kw("switch"),
          _throw: kw("throw", beforeExpr),
          _try: kw("try"),
          _var: kw("var"),
          _const: kw("const"),
          _while: kw("while", { isLoop: true }),
          _with: kw("with"),
          _new: kw("new", { beforeExpr: true, startsExpr: true }),
          _this: kw("this", startsExpr),
          _super: kw("super", startsExpr),
          _class: kw("class", startsExpr),
          _extends: kw("extends", beforeExpr),
          _export: kw("export"),
          _import: kw("import", startsExpr),
          _null: kw("null", startsExpr),
          _true: kw("true", startsExpr),
          _false: kw("false", startsExpr),
          _in: kw("in", { beforeExpr: true, binop: 7 }),
          _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
          _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
          _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
          _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
        };
        var lineBreak = /\r\n?|\n|\u2028|\u2029/;
        var lineBreakG = new RegExp(lineBreak.source, "g");
        function isNewLine(code) {
          return code === 10 || code === 13 || code === 8232 || code === 8233;
        }
        function nextLineBreak(code, from, end) {
          if (end === void 0)
            end = code.length;
          for (var i3 = from; i3 < end; i3++) {
            var next = code.charCodeAt(i3);
            if (isNewLine(next)) {
              return i3 < end - 1 && next === 13 && code.charCodeAt(i3 + 1) === 10 ? i3 + 2 : i3 + 1;
            }
          }
          return -1;
        }
        var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        var ref = Object.prototype;
        var hasOwnProperty = ref.hasOwnProperty;
        var toString = ref.toString;
        var hasOwn = Object.hasOwn || function(obj, propName) {
          return hasOwnProperty.call(obj, propName);
        };
        var isArray = Array.isArray || function(obj) {
          return toString.call(obj) === "[object Array]";
        };
        function wordsRegexp(words) {
          return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
        }
        var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
        var Position = function Position2(line, col) {
          this.line = line;
          this.column = col;
        };
        Position.prototype.offset = function offset(n2) {
          return new Position(this.line, this.column + n2);
        };
        var SourceLocation = function SourceLocation2(p, start, end) {
          this.start = start;
          this.end = end;
          if (p.sourceFile !== null) {
            this.source = p.sourceFile;
          }
        };
        function getLineInfo(input, offset) {
          for (var line = 1, cur = 0; ; ) {
            var nextBreak = nextLineBreak(input, cur, offset);
            if (nextBreak < 0) {
              return new Position(line, offset - cur);
            }
            ++line;
            cur = nextBreak;
          }
        }
        var defaultOptions = {
          ecmaVersion: null,
          sourceType: "script",
          onInsertedSemicolon: null,
          onTrailingComma: null,
          allowReserved: null,
          allowReturnOutsideFunction: false,
          allowImportExportEverywhere: false,
          allowAwaitOutsideFunction: null,
          allowSuperOutsideMethod: null,
          allowHashBang: false,
          locations: false,
          onToken: null,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null,
          preserveParens: false
        };
        var warnedAboutEcmaVersion = false;
        function getOptions(opts) {
          var options = {};
          for (var opt in defaultOptions) {
            options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
          }
          if (options.ecmaVersion === "latest") {
            options.ecmaVersion = 1e8;
          } else if (options.ecmaVersion == null) {
            if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
              warnedAboutEcmaVersion = true;
              console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
            }
            options.ecmaVersion = 11;
          } else if (options.ecmaVersion >= 2015) {
            options.ecmaVersion -= 2009;
          }
          if (options.allowReserved == null) {
            options.allowReserved = options.ecmaVersion < 5;
          }
          if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function(token) {
              return tokens.push(token);
            };
          }
          if (isArray(options.onComment)) {
            options.onComment = pushComment(options, options.onComment);
          }
          return options;
        }
        function pushComment(options, array) {
          return function(block, text, start, end, startLoc, endLoc) {
            var comment = {
              type: block ? "Block" : "Line",
              value: text,
              start,
              end
            };
            if (options.locations) {
              comment.loc = new SourceLocation(this, startLoc, endLoc);
            }
            if (options.ranges) {
              comment.range = [start, end];
            }
            array.push(comment);
          };
        }
        var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
        function functionFlags(async, generator) {
          return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
        }
        var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
        var Parser = function Parser2(options, input, startPos) {
          this.options = options = getOptions(options);
          this.sourceFile = options.sourceFile;
          this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
          var reserved = "";
          if (options.allowReserved !== true) {
            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
            if (options.sourceType === "module") {
              reserved += " await";
            }
          }
          this.reservedWords = wordsRegexp(reserved);
          var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
          this.reservedWordsStrict = wordsRegexp(reservedStrict);
          this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
          this.input = String(input);
          this.containsEsc = false;
          if (startPos) {
            this.pos = startPos;
            this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
          } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
          }
          this.type = types$1.eof;
          this.value = null;
          this.start = this.end = this.pos;
          this.startLoc = this.endLoc = this.curPosition();
          this.lastTokEndLoc = this.lastTokStartLoc = null;
          this.lastTokStart = this.lastTokEnd = this.pos;
          this.context = this.initialContext();
          this.exprAllowed = true;
          this.inModule = options.sourceType === "module";
          this.strict = this.inModule || this.strictDirective(this.pos);
          this.potentialArrowAt = -1;
          this.potentialArrowInForAwait = false;
          this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
          this.labels = [];
          this.undefinedExports = /* @__PURE__ */ Object.create(null);
          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
            this.skipLineComment(2);
          }
          this.scopeStack = [];
          this.enterScope(SCOPE_TOP);
          this.regexpState = null;
          this.privateNameStack = [];
        };
        var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        Parser.prototype.parse = function parse2() {
          var node = this.options.program || this.startNode();
          this.nextToken();
          return this.parseTopLevel(node);
        };
        prototypeAccessors.inFunction.get = function() {
          return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
        };
        prototypeAccessors.inGenerator.get = function() {
          return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
        };
        prototypeAccessors.inAsync.get = function() {
          return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
        };
        prototypeAccessors.canAwait.get = function() {
          for (var i3 = this.scopeStack.length - 1; i3 >= 0; i3--) {
            var scope = this.scopeStack[i3];
            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
              return false;
            }
            if (scope.flags & SCOPE_FUNCTION) {
              return (scope.flags & SCOPE_ASYNC) > 0;
            }
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        };
        prototypeAccessors.allowSuper.get = function() {
          var ref2 = this.currentThisScope();
          var flags = ref2.flags;
          var inClassFieldInit = ref2.inClassFieldInit;
          return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
        };
        prototypeAccessors.allowDirectSuper.get = function() {
          return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
        };
        prototypeAccessors.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        };
        prototypeAccessors.allowNewDotTarget.get = function() {
          var ref2 = this.currentThisScope();
          var flags = ref2.flags;
          var inClassFieldInit = ref2.inClassFieldInit;
          return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
        };
        prototypeAccessors.inClassStaticBlock.get = function() {
          return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
        };
        Parser.extend = function extend() {
          var plugins = [], len = arguments.length;
          while (len--)
            plugins[len] = arguments[len];
          var cls = this;
          for (var i3 = 0; i3 < plugins.length; i3++) {
            cls = plugins[i3](cls);
          }
          return cls;
        };
        Parser.parse = function parse2(input, options) {
          return new this(options, input).parse();
        };
        Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
          var parser = new this(options, input, pos);
          parser.nextToken();
          return parser.parseExpression();
        };
        Parser.tokenizer = function tokenizer2(input, options) {
          return new this(options, input);
        };
        Object.defineProperties(Parser.prototype, prototypeAccessors);
        var pp$9 = Parser.prototype;
        var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
        pp$9.strictDirective = function(start) {
          for (; ; ) {
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            var match = literal.exec(this.input.slice(start));
            if (!match) {
              return false;
            }
            if ((match[1] || match[2]) === "use strict") {
              skipWhiteSpace.lastIndex = start + match[0].length;
              var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
              var next = this.input.charAt(end);
              return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
            }
            start += match[0].length;
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            if (this.input[start] === ";") {
              start++;
            }
          }
        };
        pp$9.eat = function(type) {
          if (this.type === type) {
            this.next();
            return true;
          } else {
            return false;
          }
        };
        pp$9.isContextual = function(name) {
          return this.type === types$1.name && this.value === name && !this.containsEsc;
        };
        pp$9.eatContextual = function(name) {
          if (!this.isContextual(name)) {
            return false;
          }
          this.next();
          return true;
        };
        pp$9.expectContextual = function(name) {
          if (!this.eatContextual(name)) {
            this.unexpected();
          }
        };
        pp$9.canInsertSemicolon = function() {
          return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        };
        pp$9.insertSemicolon = function() {
          if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon) {
              this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
            }
            return true;
          }
        };
        pp$9.semicolon = function() {
          if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
            this.unexpected();
          }
        };
        pp$9.afterTrailingComma = function(tokType, notNext) {
          if (this.type === tokType) {
            if (this.options.onTrailingComma) {
              this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
            }
            if (!notNext) {
              this.next();
            }
            return true;
          }
        };
        pp$9.expect = function(type) {
          this.eat(type) || this.unexpected();
        };
        pp$9.unexpected = function(pos) {
          this.raise(pos != null ? pos : this.start, "Unexpected token");
        };
        function DestructuringErrors() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        }
        pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
          if (!refDestructuringErrors) {
            return;
          }
          if (refDestructuringErrors.trailingComma > -1) {
            this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
          }
          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
          if (parens > -1) {
            this.raiseRecoverable(parens, "Parenthesized pattern");
          }
        };
        pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
          if (!refDestructuringErrors) {
            return false;
          }
          var shorthandAssign = refDestructuringErrors.shorthandAssign;
          var doubleProto = refDestructuringErrors.doubleProto;
          if (!andThrow) {
            return shorthandAssign >= 0 || doubleProto >= 0;
          }
          if (shorthandAssign >= 0) {
            this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
          }
          if (doubleProto >= 0) {
            this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
          }
        };
        pp$9.checkYieldAwaitInDefaultParams = function() {
          if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
            this.raise(this.yieldPos, "Yield expression cannot be a default value");
          }
          if (this.awaitPos) {
            this.raise(this.awaitPos, "Await expression cannot be a default value");
          }
        };
        pp$9.isSimpleAssignTarget = function(expr) {
          if (expr.type === "ParenthesizedExpression") {
            return this.isSimpleAssignTarget(expr.expression);
          }
          return expr.type === "Identifier" || expr.type === "MemberExpression";
        };
        var pp$8 = Parser.prototype;
        pp$8.parseTopLevel = function(node) {
          var exports3 = /* @__PURE__ */ Object.create(null);
          if (!node.body) {
            node.body = [];
          }
          while (this.type !== types$1.eof) {
            var stmt = this.parseStatement(null, true, exports3);
            node.body.push(stmt);
          }
          if (this.inModule) {
            for (var i3 = 0, list2 = Object.keys(this.undefinedExports); i3 < list2.length; i3 += 1) {
              var name = list2[i3];
              this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
            }
          }
          this.adaptDirectivePrologue(node.body);
          this.next();
          node.sourceType = this.options.sourceType;
          return this.finishNode(node, "Program");
        };
        var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
        pp$8.isLet = function(context) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
            return false;
          }
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          if (context) {
            return false;
          }
          if (nextCh === 123) {
            return true;
          }
          if (isIdentifierStart(nextCh, true)) {
            var pos = next + 1;
            while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
              ++pos;
            }
            if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
              return true;
            }
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator.test(ident)) {
              return true;
            }
          }
          return false;
        };
        pp$8.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
            return false;
          }
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, after;
          return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
        };
        pp$8.parseStatement = function(context, topLevel, exports3) {
          var starttype = this.type, node = this.startNode(), kind;
          if (this.isLet(context)) {
            starttype = types$1._var;
            kind = "let";
          }
          switch (starttype) {
            case types$1._break:
            case types$1._continue:
              return this.parseBreakContinueStatement(node, starttype.keyword);
            case types$1._debugger:
              return this.parseDebuggerStatement(node);
            case types$1._do:
              return this.parseDoStatement(node);
            case types$1._for:
              return this.parseForStatement(node);
            case types$1._function:
              if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
                this.unexpected();
              }
              return this.parseFunctionStatement(node, false, !context);
            case types$1._class:
              if (context) {
                this.unexpected();
              }
              return this.parseClass(node, true);
            case types$1._if:
              return this.parseIfStatement(node);
            case types$1._return:
              return this.parseReturnStatement(node);
            case types$1._switch:
              return this.parseSwitchStatement(node);
            case types$1._throw:
              return this.parseThrowStatement(node);
            case types$1._try:
              return this.parseTryStatement(node);
            case types$1._const:
            case types$1._var:
              kind = kind || this.value;
              if (context && kind !== "var") {
                this.unexpected();
              }
              return this.parseVarStatement(node, kind);
            case types$1._while:
              return this.parseWhileStatement(node);
            case types$1._with:
              return this.parseWithStatement(node);
            case types$1.braceL:
              return this.parseBlock(true, node);
            case types$1.semi:
              return this.parseEmptyStatement(node);
            case types$1._export:
            case types$1._import:
              if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
                skipWhiteSpace.lastIndex = this.pos;
                var skip = skipWhiteSpace.exec(this.input);
                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                if (nextCh === 40 || nextCh === 46) {
                  return this.parseExpressionStatement(node, this.parseExpression());
                }
              }
              if (!this.options.allowImportExportEverywhere) {
                if (!topLevel) {
                  this.raise(this.start, "'import' and 'export' may only appear at the top level");
                }
                if (!this.inModule) {
                  this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                }
              }
              return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports3);
            default:
              if (this.isAsyncFunction()) {
                if (context) {
                  this.unexpected();
                }
                this.next();
                return this.parseFunctionStatement(node, true, !context);
              }
              var maybeName = this.value, expr = this.parseExpression();
              if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
                return this.parseLabeledStatement(node, maybeName, expr, context);
              } else {
                return this.parseExpressionStatement(node, expr);
              }
          }
        };
        pp$8.parseBreakContinueStatement = function(node, keyword) {
          var isBreak = keyword === "break";
          this.next();
          if (this.eat(types$1.semi) || this.insertSemicolon()) {
            node.label = null;
          } else if (this.type !== types$1.name) {
            this.unexpected();
          } else {
            node.label = this.parseIdent();
            this.semicolon();
          }
          var i3 = 0;
          for (; i3 < this.labels.length; ++i3) {
            var lab = this.labels[i3];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) {
                break;
              }
              if (node.label && isBreak) {
                break;
              }
            }
          }
          if (i3 === this.labels.length) {
            this.raise(node.start, "Unsyntactic " + keyword);
          }
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        };
        pp$8.parseDebuggerStatement = function(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        };
        pp$8.parseDoStatement = function(node) {
          this.next();
          this.labels.push(loopLabel);
          node.body = this.parseStatement("do");
          this.labels.pop();
          this.expect(types$1._while);
          node.test = this.parseParenExpression();
          if (this.options.ecmaVersion >= 6) {
            this.eat(types$1.semi);
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "DoWhileStatement");
        };
        pp$8.parseForStatement = function(node) {
          this.next();
          var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          this.labels.push(loopLabel);
          this.enterScope(0);
          this.expect(types$1.parenL);
          if (this.type === types$1.semi) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          var isLet = this.isLet();
          if (this.type === types$1._var || this.type === types$1._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
              if (this.options.ecmaVersion >= 9) {
                if (this.type === types$1._in) {
                  if (awaitAt > -1) {
                    this.unexpected(awaitAt);
                  }
                } else {
                  node.await = awaitAt > -1;
                }
              }
              return this.parseForIn(node, init$1);
            }
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init$1);
          }
          var startsWithLet = this.isContextual("let"), isForOf = false;
          var refDestructuringErrors = new DestructuringErrors();
          var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
          if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            if (startsWithLet && isForOf) {
              this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
            }
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLValPattern(init);
            return this.parseForIn(node, init);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init);
        };
        pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
        };
        pp$8.parseIfStatement = function(node) {
          this.next();
          node.test = this.parseParenExpression();
          node.consequent = this.parseStatement("if");
          node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
          return this.finishNode(node, "IfStatement");
        };
        pp$8.parseReturnStatement = function(node) {
          if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
            this.raise(this.start, "'return' outside of function");
          }
          this.next();
          if (this.eat(types$1.semi) || this.insertSemicolon()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        };
        pp$8.parseSwitchStatement = function(node) {
          this.next();
          node.discriminant = this.parseParenExpression();
          node.cases = [];
          this.expect(types$1.braceL);
          this.labels.push(switchLabel);
          this.enterScope(0);
          var cur;
          for (var sawDefault = false; this.type !== types$1.braceR; ) {
            if (this.type === types$1._case || this.type === types$1._default) {
              var isCase = this.type === types$1._case;
              if (cur) {
                this.finishNode(cur, "SwitchCase");
              }
              node.cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(types$1.colon);
            } else {
              if (!cur) {
                this.unexpected();
              }
              cur.consequent.push(this.parseStatement(null));
            }
          }
          this.exitScope();
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          this.next();
          this.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        };
        pp$8.parseThrowStatement = function(node) {
          this.next();
          if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
            this.raise(this.lastTokEnd, "Illegal newline after throw");
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        };
        var empty$1 = [];
        pp$8.parseTryStatement = function(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.type === types$1._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$1.parenL)) {
              clause.param = this.parseBindingAtom();
              var simple = clause.param.type === "Identifier";
              this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
              this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
              this.expect(types$1.parenR);
            } else {
              if (this.options.ecmaVersion < 10) {
                this.unexpected();
              }
              clause.param = null;
              this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(node.start, "Missing catch or finally clause");
          }
          return this.finishNode(node, "TryStatement");
        };
        pp$8.parseVarStatement = function(node, kind) {
          this.next();
          this.parseVar(node, false, kind);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        };
        pp$8.parseWhileStatement = function(node) {
          this.next();
          node.test = this.parseParenExpression();
          this.labels.push(loopLabel);
          node.body = this.parseStatement("while");
          this.labels.pop();
          return this.finishNode(node, "WhileStatement");
        };
        pp$8.parseWithStatement = function(node) {
          if (this.strict) {
            this.raise(this.start, "'with' in strict mode");
          }
          this.next();
          node.object = this.parseParenExpression();
          node.body = this.parseStatement("with");
          return this.finishNode(node, "WithStatement");
        };
        pp$8.parseEmptyStatement = function(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        };
        pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
          for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
            var label = list2[i$1];
            if (label.name === maybeName) {
              this.raise(expr.start, "Label '" + maybeName + "' is already declared");
            }
          }
          var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
          for (var i3 = this.labels.length - 1; i3 >= 0; i3--) {
            var label$1 = this.labels[i3];
            if (label$1.statementStart === node.start) {
              label$1.statementStart = this.start;
              label$1.kind = kind;
            } else {
              break;
            }
          }
          this.labels.push({ name: maybeName, kind, statementStart: this.start });
          node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          this.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        };
        pp$8.parseExpressionStatement = function(node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        };
        pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
          if (createNewLexicalScope === void 0)
            createNewLexicalScope = true;
          if (node === void 0)
            node = this.startNode();
          node.body = [];
          this.expect(types$1.braceL);
          if (createNewLexicalScope) {
            this.enterScope(0);
          }
          while (this.type !== types$1.braceR) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          if (exitStrict) {
            this.strict = false;
          }
          this.next();
          if (createNewLexicalScope) {
            this.exitScope();
          }
          return this.finishNode(node, "BlockStatement");
        };
        pp$8.parseFor = function(node, init) {
          node.init = init;
          this.expect(types$1.semi);
          node.test = this.type === types$1.semi ? null : this.parseExpression();
          this.expect(types$1.semi);
          node.update = this.type === types$1.parenR ? null : this.parseExpression();
          this.expect(types$1.parenR);
          node.body = this.parseStatement("for");
          this.exitScope();
          this.labels.pop();
          return this.finishNode(node, "ForStatement");
        };
        pp$8.parseForIn = function(node, init) {
          var isForIn = this.type === types$1._in;
          this.next();
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
          this.expect(types$1.parenR);
          node.body = this.parseStatement("for");
          this.exitScope();
          this.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        };
        pp$8.parseVar = function(node, isFor, kind) {
          node.declarations = [];
          node.kind = kind;
          for (; ; ) {
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types$1.eq)) {
              decl.init = this.parseMaybeAssign(isFor);
            } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
              this.unexpected();
            } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
              this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
            } else {
              decl.init = null;
            }
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types$1.comma)) {
              break;
            }
          }
          return node;
        };
        pp$8.parseVarId = function(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
        };
        var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
        pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
          this.initFunction(node);
          if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
              this.unexpected();
            }
            node.generator = this.eat(types$1.star);
          }
          if (this.options.ecmaVersion >= 8) {
            node.async = !!isAsync;
          }
          if (statement & FUNC_STATEMENT) {
            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
              this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
            }
          }
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          this.enterScope(functionFlags(node.async, node.generator));
          if (!(statement & FUNC_STATEMENT)) {
            node.id = this.type === types$1.name ? this.parseIdent() : null;
          }
          this.parseFunctionParams(node);
          this.parseFunctionBody(node, allowExpressionBody, false, forInit);
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
        };
        pp$8.parseFunctionParams = function(node) {
          this.expect(types$1.parenL);
          node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
        };
        pp$8.parseClass = function(node, isStatement) {
          this.next();
          var oldStrict = this.strict;
          this.strict = true;
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          var privateNameMap = this.enterClassBody();
          var classBody = this.startNode();
          var hadConstructor = false;
          classBody.body = [];
          this.expect(types$1.braceL);
          while (this.type !== types$1.braceR) {
            var element = this.parseClassElement(node.superClass !== null);
            if (element) {
              classBody.body.push(element);
              if (element.type === "MethodDefinition" && element.kind === "constructor") {
                if (hadConstructor) {
                  this.raise(element.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
              } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
                this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
              }
            }
          }
          this.strict = oldStrict;
          this.next();
          node.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        };
        pp$8.parseClassElement = function(constructorAllowsSuper) {
          if (this.eat(types$1.semi)) {
            return null;
          }
          var ecmaVersion2 = this.options.ecmaVersion;
          var node = this.startNode();
          var keyName = "";
          var isGenerator = false;
          var isAsync = false;
          var kind = "method";
          var isStatic = false;
          if (this.eatContextual("static")) {
            if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
              this.parseClassStaticBlock(node);
              return node;
            }
            if (this.isClassElementNameStart() || this.type === types$1.star) {
              isStatic = true;
            } else {
              keyName = "static";
            }
          }
          node.static = isStatic;
          if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
              isAsync = true;
            } else {
              keyName = "async";
            }
          }
          if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
            isGenerator = true;
          }
          if (!keyName && !isAsync && !isGenerator) {
            var lastValue = this.value;
            if (this.eatContextual("get") || this.eatContextual("set")) {
              if (this.isClassElementNameStart()) {
                kind = lastValue;
              } else {
                keyName = lastValue;
              }
            }
          }
          if (keyName) {
            node.computed = false;
            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node.key.name = keyName;
            this.finishNode(node.key, "Identifier");
          } else {
            this.parseClassElementName(node);
          }
          if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
            var isConstructor = !node.static && checkKeyName(node, "constructor");
            var allowsDirectSuper = isConstructor && constructorAllowsSuper;
            if (isConstructor && kind !== "method") {
              this.raise(node.key.start, "Constructor can't have get/set modifier");
            }
            node.kind = isConstructor ? "constructor" : kind;
            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
          } else {
            this.parseClassField(node);
          }
          return node;
        };
        pp$8.isClassElementNameStart = function() {
          return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
        };
        pp$8.parseClassElementName = function(element) {
          if (this.type === types$1.privateId) {
            if (this.value === "constructor") {
              this.raise(this.start, "Classes can't have an element named '#constructor'");
            }
            element.computed = false;
            element.key = this.parsePrivateIdent();
          } else {
            this.parsePropertyName(element);
          }
        };
        pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
          var key = method.key;
          if (method.kind === "constructor") {
            if (isGenerator) {
              this.raise(key.start, "Constructor can't be a generator");
            }
            if (isAsync) {
              this.raise(key.start, "Constructor can't be an async method");
            }
          } else if (method.static && checkKeyName(method, "prototype")) {
            this.raise(key.start, "Classes may not have a static property named prototype");
          }
          var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
          if (method.kind === "get" && value.params.length !== 0) {
            this.raiseRecoverable(value.start, "getter should have no params");
          }
          if (method.kind === "set" && value.params.length !== 1) {
            this.raiseRecoverable(value.start, "setter should have exactly one param");
          }
          if (method.kind === "set" && value.params[0].type === "RestElement") {
            this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
          }
          return this.finishNode(method, "MethodDefinition");
        };
        pp$8.parseClassField = function(field) {
          if (checkKeyName(field, "constructor")) {
            this.raise(field.key.start, "Classes can't have a field named 'constructor'");
          } else if (field.static && checkKeyName(field, "prototype")) {
            this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
          }
          if (this.eat(types$1.eq)) {
            var scope = this.currentThisScope();
            var inClassFieldInit = scope.inClassFieldInit;
            scope.inClassFieldInit = true;
            field.value = this.parseMaybeAssign();
            scope.inClassFieldInit = inClassFieldInit;
          } else {
            field.value = null;
          }
          this.semicolon();
          return this.finishNode(field, "PropertyDefinition");
        };
        pp$8.parseClassStaticBlock = function(node) {
          node.body = [];
          var oldLabels = this.labels;
          this.labels = [];
          this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
          while (this.type !== types$1.braceR) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          this.next();
          this.exitScope();
          this.labels = oldLabels;
          return this.finishNode(node, "StaticBlock");
        };
        pp$8.parseClassId = function(node, isStatement) {
          if (this.type === types$1.name) {
            node.id = this.parseIdent();
            if (isStatement) {
              this.checkLValSimple(node.id, BIND_LEXICAL, false);
            }
          } else {
            if (isStatement === true) {
              this.unexpected();
            }
            node.id = null;
          }
        };
        pp$8.parseClassSuper = function(node) {
          node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
        };
        pp$8.enterClassBody = function() {
          var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          this.privateNameStack.push(element);
          return element.declared;
        };
        pp$8.exitClassBody = function() {
          var ref2 = this.privateNameStack.pop();
          var declared = ref2.declared;
          var used = ref2.used;
          var len = this.privateNameStack.length;
          var parent = len === 0 ? null : this.privateNameStack[len - 1];
          for (var i3 = 0; i3 < used.length; ++i3) {
            var id2 = used[i3];
            if (!hasOwn(declared, id2.name)) {
              if (parent) {
                parent.used.push(id2);
              } else {
                this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
              }
            }
          }
        };
        function isPrivateNameConflicted(privateNameMap, element) {
          var name = element.key.name;
          var curr = privateNameMap[name];
          var next = "true";
          if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
            next = (element.static ? "s" : "i") + element.kind;
          }
          if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
            privateNameMap[name] = "true";
            return false;
          } else if (!curr) {
            privateNameMap[name] = next;
            return false;
          } else {
            return true;
          }
        }
        function checkKeyName(node, name) {
          var computed = node.computed;
          var key = node.key;
          return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
        }
        pp$8.parseExport = function(node, exports3) {
          this.next();
          if (this.eat(types$1.star)) {
            if (this.options.ecmaVersion >= 11) {
              if (this.eatContextual("as")) {
                node.exported = this.parseModuleExportName();
                this.checkExport(exports3, node.exported.name, this.lastTokStart);
              } else {
                node.exported = null;
              }
            }
            this.expectContextual("from");
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            this.semicolon();
            return this.finishNode(node, "ExportAllDeclaration");
          }
          if (this.eat(types$1._default)) {
            this.checkExport(exports3, "default", this.lastTokStart);
            var isAsync;
            if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
              var fNode = this.startNode();
              this.next();
              if (isAsync) {
                this.next();
              }
              node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
            } else if (this.type === types$1._class) {
              var cNode = this.startNode();
              node.declaration = this.parseClass(cNode, "nullableID");
            } else {
              node.declaration = this.parseMaybeAssign();
              this.semicolon();
            }
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseStatement(null);
            if (node.declaration.type === "VariableDeclaration") {
              this.checkVariableExport(exports3, node.declaration.declarations);
            } else {
              this.checkExport(exports3, node.declaration.id.name, node.declaration.id.start);
            }
            node.specifiers = [];
            node.source = null;
          } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports3);
            if (this.eatContextual("from")) {
              if (this.type !== types$1.string) {
                this.unexpected();
              }
              node.source = this.parseExprAtom();
            } else {
              for (var i3 = 0, list2 = node.specifiers; i3 < list2.length; i3 += 1) {
                var spec = list2[i3];
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
                }
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        };
        pp$8.checkExport = function(exports3, name, pos) {
          if (!exports3) {
            return;
          }
          if (hasOwn(exports3, name)) {
            this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
          }
          exports3[name] = true;
        };
        pp$8.checkPatternExport = function(exports3, pat) {
          var type = pat.type;
          if (type === "Identifier") {
            this.checkExport(exports3, pat.name, pat.start);
          } else if (type === "ObjectPattern") {
            for (var i3 = 0, list2 = pat.properties; i3 < list2.length; i3 += 1) {
              var prop = list2[i3];
              this.checkPatternExport(exports3, prop);
            }
          } else if (type === "ArrayPattern") {
            for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
              var elt = list$1[i$1];
              if (elt) {
                this.checkPatternExport(exports3, elt);
              }
            }
          } else if (type === "Property") {
            this.checkPatternExport(exports3, pat.value);
          } else if (type === "AssignmentPattern") {
            this.checkPatternExport(exports3, pat.left);
          } else if (type === "RestElement") {
            this.checkPatternExport(exports3, pat.argument);
          } else if (type === "ParenthesizedExpression") {
            this.checkPatternExport(exports3, pat.expression);
          }
        };
        pp$8.checkVariableExport = function(exports3, decls) {
          if (!exports3) {
            return;
          }
          for (var i3 = 0, list2 = decls; i3 < list2.length; i3 += 1) {
            var decl = list2[i3];
            this.checkPatternExport(exports3, decl.id);
          }
        };
        pp$8.shouldParseExportStatement = function() {
          return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
        };
        pp$8.parseExportSpecifiers = function(exports3) {
          var nodes = [], first = true;
          this.expect(types$1.braceL);
          while (!this.eat(types$1.braceR)) {
            if (!first) {
              this.expect(types$1.comma);
              if (this.afterTrailingComma(types$1.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            var node = this.startNode();
            node.local = this.parseModuleExportName();
            node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
            this.checkExport(exports3, node.exported[node.exported.type === "Identifier" ? "name" : "value"], node.exported.start);
            nodes.push(this.finishNode(node, "ExportSpecifier"));
          }
          return nodes;
        };
        pp$8.parseImport = function(node) {
          this.next();
          if (this.type === types$1.string) {
            node.specifiers = empty$1;
            node.source = this.parseExprAtom();
          } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
          }
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        };
        pp$8.parseImportSpecifiers = function() {
          var nodes = [], first = true;
          if (this.type === types$1.name) {
            var node = this.startNode();
            node.local = this.parseIdent();
            this.checkLValSimple(node.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
            if (!this.eat(types$1.comma)) {
              return nodes;
            }
          }
          if (this.type === types$1.star) {
            var node$1 = this.startNode();
            this.next();
            this.expectContextual("as");
            node$1.local = this.parseIdent();
            this.checkLValSimple(node$1.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
            return nodes;
          }
          this.expect(types$1.braceL);
          while (!this.eat(types$1.braceR)) {
            if (!first) {
              this.expect(types$1.comma);
              if (this.afterTrailingComma(types$1.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            var node$2 = this.startNode();
            node$2.imported = this.parseModuleExportName();
            if (this.eatContextual("as")) {
              node$2.local = this.parseIdent();
            } else {
              this.checkUnreserved(node$2.imported);
              node$2.local = node$2.imported;
            }
            this.checkLValSimple(node$2.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node$2, "ImportSpecifier"));
          }
          return nodes;
        };
        pp$8.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
            var stringLiteral = this.parseLiteral(this.value);
            if (loneSurrogate.test(stringLiteral.value)) {
              this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
            }
            return stringLiteral;
          }
          return this.parseIdent(true);
        };
        pp$8.adaptDirectivePrologue = function(statements) {
          for (var i3 = 0; i3 < statements.length && this.isDirectiveCandidate(statements[i3]); ++i3) {
            statements[i3].directive = statements[i3].expression.raw.slice(1, -1);
          }
        };
        pp$8.isDirectiveCandidate = function(statement) {
          return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
        };
        var pp$7 = Parser.prototype;
        pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 6 && node) {
            switch (node.type) {
              case "Identifier":
                if (this.inAsync && node.name === "await") {
                  this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
                }
                break;
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                node.type = "ObjectPattern";
                if (refDestructuringErrors) {
                  this.checkPatternErrors(refDestructuringErrors, true);
                }
                for (var i3 = 0, list2 = node.properties; i3 < list2.length; i3 += 1) {
                  var prop = list2[i3];
                  this.toAssignable(prop, isBinding);
                  if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                    this.raise(prop.argument.start, "Unexpected token");
                  }
                }
                break;
              case "Property":
                if (node.kind !== "init") {
                  this.raise(node.key.start, "Object pattern can't contain getter or setter");
                }
                this.toAssignable(node.value, isBinding);
                break;
              case "ArrayExpression":
                node.type = "ArrayPattern";
                if (refDestructuringErrors) {
                  this.checkPatternErrors(refDestructuringErrors, true);
                }
                this.toAssignableList(node.elements, isBinding);
                break;
              case "SpreadElement":
                node.type = "RestElement";
                this.toAssignable(node.argument, isBinding);
                if (node.argument.type === "AssignmentPattern") {
                  this.raise(node.argument.start, "Rest elements cannot have a default value");
                }
                break;
              case "AssignmentExpression":
                if (node.operator !== "=") {
                  this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                }
                node.type = "AssignmentPattern";
                delete node.operator;
                this.toAssignable(node.left, isBinding);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(node.expression, isBinding, refDestructuringErrors);
                break;
              case "ChainExpression":
                this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
                break;
              case "MemberExpression":
                if (!isBinding) {
                  break;
                }
              default:
                this.raise(node.start, "Assigning to rvalue");
            }
          } else if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          return node;
        };
        pp$7.toAssignableList = function(exprList, isBinding) {
          var end = exprList.length;
          for (var i3 = 0; i3 < end; i3++) {
            var elt = exprList[i3];
            if (elt) {
              this.toAssignable(elt, isBinding);
            }
          }
          if (end) {
            var last = exprList[end - 1];
            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
              this.unexpected(last.argument.start);
            }
          }
          return exprList;
        };
        pp$7.parseSpread = function(refDestructuringErrors) {
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          return this.finishNode(node, "SpreadElement");
        };
        pp$7.parseRestBinding = function() {
          var node = this.startNode();
          this.next();
          if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
            this.unexpected();
          }
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        };
        pp$7.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) {
            switch (this.type) {
              case types$1.bracketL:
                var node = this.startNode();
                this.next();
                node.elements = this.parseBindingList(types$1.bracketR, true, true);
                return this.finishNode(node, "ArrayPattern");
              case types$1.braceL:
                return this.parseObj(true);
            }
          }
          return this.parseIdent();
        };
        pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(types$1.comma);
            }
            if (allowEmpty && this.type === types$1.comma) {
              elts.push(null);
            } else if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            } else if (this.type === types$1.ellipsis) {
              var rest = this.parseRestBinding();
              this.parseBindingListItem(rest);
              elts.push(rest);
              if (this.type === types$1.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              this.expect(close);
              break;
            } else {
              var elem = this.parseMaybeDefault(this.start, this.startLoc);
              this.parseBindingListItem(elem);
              elts.push(elem);
            }
          }
          return elts;
        };
        pp$7.parseBindingListItem = function(param) {
          return param;
        };
        pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
          left = left || this.parseBindingAtom();
          if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
            return left;
          }
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssign();
          return this.finishNode(node, "AssignmentPattern");
        };
        pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE;
          var isBind = bindingType !== BIND_NONE;
          switch (expr.type) {
            case "Identifier":
              if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
                this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
              }
              if (isBind) {
                if (bindingType === BIND_LEXICAL && expr.name === "let") {
                  this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
                }
                if (checkClashes) {
                  if (hasOwn(checkClashes, expr.name)) {
                    this.raiseRecoverable(expr.start, "Argument name clash");
                  }
                  checkClashes[expr.name] = true;
                }
                if (bindingType !== BIND_OUTSIDE) {
                  this.declareName(expr.name, bindingType, expr.start);
                }
              }
              break;
            case "ChainExpression":
              this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (isBind) {
                this.raiseRecoverable(expr.start, "Binding member expression");
              }
              break;
            case "ParenthesizedExpression":
              if (isBind) {
                this.raiseRecoverable(expr.start, "Binding parenthesized expression");
              }
              return this.checkLValSimple(expr.expression, bindingType, checkClashes);
            default:
              this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
          }
        };
        pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE;
          switch (expr.type) {
            case "ObjectPattern":
              for (var i3 = 0, list2 = expr.properties; i3 < list2.length; i3 += 1) {
                var prop = list2[i3];
                this.checkLValInnerPattern(prop, bindingType, checkClashes);
              }
              break;
            case "ArrayPattern":
              for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
                var elem = list$1[i$1];
                if (elem) {
                  this.checkLValInnerPattern(elem, bindingType, checkClashes);
                }
              }
              break;
            default:
              this.checkLValSimple(expr, bindingType, checkClashes);
          }
        };
        pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE;
          switch (expr.type) {
            case "Property":
              this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(expr.left, bindingType, checkClashes);
              break;
            case "RestElement":
              this.checkLValPattern(expr.argument, bindingType, checkClashes);
              break;
            default:
              this.checkLValPattern(expr, bindingType, checkClashes);
          }
        };
        var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
          this.token = token;
          this.isExpr = !!isExpr;
          this.preserveSpace = !!preserveSpace;
          this.override = override;
          this.generator = !!generator;
        };
        var types = {
          b_stat: new TokContext("{", false),
          b_expr: new TokContext("{", true),
          b_tmpl: new TokContext("${", false),
          p_stat: new TokContext("(", false),
          p_expr: new TokContext("(", true),
          q_tmpl: new TokContext("`", true, true, function(p) {
            return p.tryReadTemplateToken();
          }),
          f_stat: new TokContext("function", false),
          f_expr: new TokContext("function", true),
          f_expr_gen: new TokContext("function", true, false, null, true),
          f_gen: new TokContext("function", false, false, null, true)
        };
        var pp$6 = Parser.prototype;
        pp$6.initialContext = function() {
          return [types.b_stat];
        };
        pp$6.curContext = function() {
          return this.context[this.context.length - 1];
        };
        pp$6.braceIsBlock = function(prevType) {
          var parent = this.curContext();
          if (parent === types.f_expr || parent === types.f_stat) {
            return true;
          }
          if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
            return !parent.isExpr;
          }
          if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
            return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
          }
          if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
            return true;
          }
          if (prevType === types$1.braceL) {
            return parent === types.b_stat;
          }
          if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
            return false;
          }
          return !this.exprAllowed;
        };
        pp$6.inGeneratorContext = function() {
          for (var i3 = this.context.length - 1; i3 >= 1; i3--) {
            var context = this.context[i3];
            if (context.token === "function") {
              return context.generator;
            }
          }
          return false;
        };
        pp$6.updateContext = function(prevType) {
          var update, type = this.type;
          if (type.keyword && prevType === types$1.dot) {
            this.exprAllowed = false;
          } else if (update = type.updateContext) {
            update.call(this, prevType);
          } else {
            this.exprAllowed = type.beforeExpr;
          }
        };
        pp$6.overrideContext = function(tokenCtx) {
          if (this.curContext() !== tokenCtx) {
            this.context[this.context.length - 1] = tokenCtx;
          }
        };
        types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
          if (this.context.length === 1) {
            this.exprAllowed = true;
            return;
          }
          var out = this.context.pop();
          if (out === types.b_stat && this.curContext().token === "function") {
            out = this.context.pop();
          }
          this.exprAllowed = !out.isExpr;
        };
        types$1.braceL.updateContext = function(prevType) {
          this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
          this.exprAllowed = true;
        };
        types$1.dollarBraceL.updateContext = function() {
          this.context.push(types.b_tmpl);
          this.exprAllowed = true;
        };
        types$1.parenL.updateContext = function(prevType) {
          var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
          this.context.push(statementParens ? types.p_stat : types.p_expr);
          this.exprAllowed = true;
        };
        types$1.incDec.updateContext = function() {
        };
        types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
          if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
            this.context.push(types.f_expr);
          } else {
            this.context.push(types.f_stat);
          }
          this.exprAllowed = false;
        };
        types$1.backQuote.updateContext = function() {
          if (this.curContext() === types.q_tmpl) {
            this.context.pop();
          } else {
            this.context.push(types.q_tmpl);
          }
          this.exprAllowed = false;
        };
        types$1.star.updateContext = function(prevType) {
          if (prevType === types$1._function) {
            var index = this.context.length - 1;
            if (this.context[index] === types.f_expr) {
              this.context[index] = types.f_expr_gen;
            } else {
              this.context[index] = types.f_gen;
            }
          }
          this.exprAllowed = true;
        };
        types$1.name.updateContext = function(prevType) {
          var allowed = false;
          if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
            if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
              allowed = true;
            }
          }
          this.exprAllowed = allowed;
        };
        var pp$5 = Parser.prototype;
        pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
            return;
          }
          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
            return;
          }
          var key = prop.key;
          var name;
          switch (key.type) {
            case "Identifier":
              name = key.name;
              break;
            case "Literal":
              name = String(key.value);
              break;
            default:
              return;
          }
          var kind = prop.kind;
          if (this.options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
              if (propHash.proto) {
                if (refDestructuringErrors) {
                  if (refDestructuringErrors.doubleProto < 0) {
                    refDestructuringErrors.doubleProto = key.start;
                  }
                } else {
                  this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                }
              }
              propHash.proto = true;
            }
            return;
          }
          name = "$" + name;
          var other = propHash[name];
          if (other) {
            var redefinition;
            if (kind === "init") {
              redefinition = this.strict && other.init || other.get || other.set;
            } else {
              redefinition = other.init || other[kind];
            }
            if (redefinition) {
              this.raiseRecoverable(key.start, "Redefinition of property");
            }
          } else {
            other = propHash[name] = {
              init: false,
              get: false,
              set: false
            };
          }
          other[kind] = true;
        };
        pp$5.parseExpression = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
          if (this.type === types$1.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(types$1.comma)) {
              node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            }
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        };
        pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) {
              return this.parseYield(forInit);
            } else {
              this.exprAllowed = false;
            }
          }
          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
          if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            oldDoubleProto = refDestructuringErrors.doubleProto;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
          } else {
            refDestructuringErrors = new DestructuringErrors();
            ownDestructuringErrors = true;
          }
          var startPos = this.start, startLoc = this.startLoc;
          if (this.type === types$1.parenL || this.type === types$1.name) {
            this.potentialArrowAt = this.start;
            this.potentialArrowInForAwait = forInit === "await";
          }
          var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }
          if (this.type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = this.value;
            if (this.type === types$1.eq) {
              left = this.toAssignable(left, false, refDestructuringErrors);
            }
            if (!ownDestructuringErrors) {
              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            }
            if (refDestructuringErrors.shorthandAssign >= left.start) {
              refDestructuringErrors.shorthandAssign = -1;
            }
            if (this.type === types$1.eq) {
              this.checkLValPattern(left);
            } else {
              this.checkLValSimple(left);
            }
            node.left = left;
            this.next();
            node.right = this.parseMaybeAssign(forInit);
            if (oldDoubleProto > -1) {
              refDestructuringErrors.doubleProto = oldDoubleProto;
            }
            return this.finishNode(node, "AssignmentExpression");
          } else {
            if (ownDestructuringErrors) {
              this.checkExpressionErrors(refDestructuringErrors, true);
            }
          }
          if (oldParenAssign > -1) {
            refDestructuringErrors.parenthesizedAssign = oldParenAssign;
          }
          if (oldTrailingComma > -1) {
            refDestructuringErrors.trailingComma = oldTrailingComma;
          }
          return left;
        };
        pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseExprOps(forInit, refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          if (this.eat(types$1.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(types$1.colon);
            node.alternate = this.parseMaybeAssign(forInit);
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        };
        pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
        };
        pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
          var prec = this.type.binop;
          if (prec != null && (!forInit || this.type !== types$1._in)) {
            if (prec > minPrec) {
              var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
              var coalesce = this.type === types$1.coalesce;
              if (coalesce) {
                prec = types$1.logicalAND.binop;
              }
              var op2 = this.value;
              this.next();
              var startPos = this.start, startLoc = this.startLoc;
              var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op2, logical || coalesce);
              if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
                this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
              }
              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
            }
          }
          return left;
        };
        pp$5.buildBinary = function(startPos, startLoc, left, right, op2, logical) {
          if (right.type === "PrivateIdentifier") {
            this.raise(right.start, "Private identifier can only be left side of binary expression");
          }
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.operator = op2;
          node.right = right;
          return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
        };
        pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
          var startPos = this.start, startLoc = this.startLoc, expr;
          if (this.isContextual("await") && this.canAwait) {
            expr = this.parseAwait(forInit);
            sawUnary = true;
          } else if (this.type.prefix) {
            var node = this.startNode(), update = this.type === types$1.incDec;
            node.operator = this.value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true, update, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) {
              this.checkLValSimple(node.argument);
            } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
              this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
            } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
              this.raiseRecoverable(node.start, "Private fields can not be deleted");
            } else {
              sawUnary = true;
            }
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          } else if (!sawUnary && this.type === types$1.privateId) {
            if (forInit || this.privateNameStack.length === 0) {
              this.unexpected();
            }
            expr = this.parsePrivateIdent();
            if (this.type !== types$1._in) {
              this.unexpected();
            }
          } else {
            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
            if (this.checkExpressionErrors(refDestructuringErrors)) {
              return expr;
            }
            while (this.type.postfix && !this.canInsertSemicolon()) {
              var node$1 = this.startNodeAt(startPos, startLoc);
              node$1.operator = this.value;
              node$1.prefix = false;
              node$1.argument = expr;
              this.checkLValSimple(expr);
              this.next();
              expr = this.finishNode(node$1, "UpdateExpression");
            }
          }
          if (!incDec && this.eat(types$1.starstar)) {
            if (sawUnary) {
              this.unexpected(this.lastTokStart);
            } else {
              return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
            }
          } else {
            return expr;
          }
        };
        function isPrivateFieldAccess(node) {
          return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
        }
        pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseExprAtom(refDestructuringErrors, forInit);
          if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
            return expr;
          }
          var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
          if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) {
              refDestructuringErrors.parenthesizedAssign = -1;
            }
            if (refDestructuringErrors.parenthesizedBind >= result.start) {
              refDestructuringErrors.parenthesizedBind = -1;
            }
            if (refDestructuringErrors.trailingComma >= result.start) {
              refDestructuringErrors.trailingComma = -1;
            }
          }
          return result;
        };
        pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
          var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
          var optionalChained = false;
          while (true) {
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element.optional) {
              optionalChained = true;
            }
            if (element === base || element.type === "ArrowFunctionExpression") {
              if (optionalChained) {
                var chainNode = this.startNodeAt(startPos, startLoc);
                chainNode.expression = element;
                element = this.finishNode(chainNode, "ChainExpression");
              }
              return element;
            }
            base = element;
          }
        };
        pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
          var optionalSupported = this.options.ecmaVersion >= 11;
          var optional = optionalSupported && this.eat(types$1.questionDot);
          if (noCalls && optional) {
            this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          }
          var computed = this.eat(types$1.bracketL);
          if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            if (computed) {
              node.property = this.parseExpression();
              this.expect(types$1.bracketR);
            } else if (this.type === types$1.privateId && base.type !== "Super") {
              node.property = this.parsePrivateIdent();
            } else {
              node.property = this.parseIdent(this.options.allowReserved !== "never");
            }
            node.computed = !!computed;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "MemberExpression");
          } else if (!noCalls && this.eat(types$1.parenL)) {
            var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0;
            this.awaitPos = 0;
            this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              if (this.awaitIdentPos > 0) {
                this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
              }
              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              this.awaitIdentPos = oldAwaitIdentPos;
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            if (optionalSupported) {
              node$1.optional = optional;
            }
            base = this.finishNode(node$1, "CallExpression");
          } else if (this.type === types$1.backQuote) {
            if (optional || optionalChained) {
              this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            }
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({ isTagged: true });
            base = this.finishNode(node$2, "TaggedTemplateExpression");
          }
          return base;
        };
        pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
          if (this.type === types$1.slash) {
            this.readRegexp();
          }
          var node, canBeArrow = this.potentialArrowAt === this.start;
          switch (this.type) {
            case types$1._super:
              if (!this.allowSuper) {
                this.raise(this.start, "'super' keyword outside a method");
              }
              node = this.startNode();
              this.next();
              if (this.type === types$1.parenL && !this.allowDirectSuper) {
                this.raise(node.start, "super() call outside constructor of a subclass");
              }
              if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
                this.unexpected();
              }
              return this.finishNode(node, "Super");
            case types$1._this:
              node = this.startNode();
              this.next();
              return this.finishNode(node, "ThisExpression");
            case types$1.name:
              var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
              var id2 = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
                this.overrideContext(types.f_expr);
                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
              }
              if (canBeArrow && !this.canInsertSemicolon()) {
                if (this.eat(types$1.arrow)) {
                  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
                }
                if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                  id2 = this.parseIdent(false);
                  if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                    this.unexpected();
                  }
                  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
                }
              }
              return id2;
            case types$1.regexp:
              var value = this.value;
              node = this.parseLiteral(value.value);
              node.regex = { pattern: value.pattern, flags: value.flags };
              return node;
            case types$1.num:
            case types$1.string:
              return this.parseLiteral(this.value);
            case types$1._null:
            case types$1._true:
            case types$1._false:
              node = this.startNode();
              node.value = this.type === types$1._null ? null : this.type === types$1._true;
              node.raw = this.type.keyword;
              this.next();
              return this.finishNode(node, "Literal");
            case types$1.parenL:
              var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
              if (refDestructuringErrors) {
                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                  refDestructuringErrors.parenthesizedAssign = start;
                }
                if (refDestructuringErrors.parenthesizedBind < 0) {
                  refDestructuringErrors.parenthesizedBind = start;
                }
              }
              return expr;
            case types$1.bracketL:
              node = this.startNode();
              this.next();
              node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
              return this.finishNode(node, "ArrayExpression");
            case types$1.braceL:
              this.overrideContext(types.b_expr);
              return this.parseObj(false, refDestructuringErrors);
            case types$1._function:
              node = this.startNode();
              this.next();
              return this.parseFunction(node, 0);
            case types$1._class:
              return this.parseClass(this.startNode(), false);
            case types$1._new:
              return this.parseNew();
            case types$1.backQuote:
              return this.parseTemplate();
            case types$1._import:
              if (this.options.ecmaVersion >= 11) {
                return this.parseExprImport();
              } else {
                return this.unexpected();
              }
            default:
              this.unexpected();
          }
        };
        pp$5.parseExprImport = function() {
          var node = this.startNode();
          if (this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword import");
          }
          var meta = this.parseIdent(true);
          switch (this.type) {
            case types$1.parenL:
              return this.parseDynamicImport(node);
            case types$1.dot:
              node.meta = meta;
              return this.parseImportMeta(node);
            default:
              this.unexpected();
          }
        };
        pp$5.parseDynamicImport = function(node) {
          this.next();
          node.source = this.parseMaybeAssign();
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
          return this.finishNode(node, "ImportExpression");
        };
        pp$5.parseImportMeta = function(node) {
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "meta") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
          }
          if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
            this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
          }
          return this.finishNode(node, "MetaProperty");
        };
        pp$5.parseLiteral = function(value) {
          var node = this.startNode();
          node.value = value;
          node.raw = this.input.slice(this.start, this.end);
          if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
            node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
          }
          this.next();
          return this.finishNode(node, "Literal");
        };
        pp$5.parseParenExpression = function() {
          this.expect(types$1.parenL);
          var val = this.parseExpression();
          this.expect(types$1.parenR);
          return val;
        };
        pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
          var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            this.yieldPos = 0;
            this.awaitPos = 0;
            while (this.type !== types$1.parenR) {
              first ? first = false : this.expect(types$1.comma);
              if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
                lastIsComma = true;
                break;
              } else if (this.type === types$1.ellipsis) {
                spreadStart = this.start;
                exprList.push(this.parseParenItem(this.parseRestBinding()));
                if (this.type === types$1.comma) {
                  this.raise(this.start, "Comma is not permitted after the rest element");
                }
                break;
              } else {
                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
              }
            }
            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
            this.expect(types$1.parenR);
            if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            }
            if (!exprList.length || lastIsComma) {
              this.unexpected(this.lastTokStart);
            }
            if (spreadStart) {
              this.unexpected(spreadStart);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
          } else {
            val = this.parseParenExpression();
          }
          if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
          } else {
            return val;
          }
        };
        pp$5.parseParenItem = function(item) {
          return item;
        };
        pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
        };
        var empty = [];
        pp$5.parseNew = function() {
          if (this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          }
          var node = this.startNode();
          var meta = this.parseIdent(true);
          if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
            node.meta = meta;
            var containsEsc = this.containsEsc;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target") {
              this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
            }
            if (containsEsc) {
              this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
            }
            if (!this.allowNewDotTarget) {
              this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
            }
            return this.finishNode(node, "MetaProperty");
          }
          var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
          node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
          if (isImport && node.callee.type === "ImportExpression") {
            this.raise(startPos, "Cannot use new with import()");
          }
          if (this.eat(types$1.parenL)) {
            node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
          } else {
            node.arguments = empty;
          }
          return this.finishNode(node, "NewExpression");
        };
        pp$5.parseTemplateElement = function(ref2) {
          var isTagged = ref2.isTagged;
          var elem = this.startNode();
          if (this.type === types$1.invalidTemplate) {
            if (!isTagged) {
              this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
            }
            elem.value = {
              raw: this.value,
              cooked: null
            };
          } else {
            elem.value = {
              raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
              cooked: this.value
            };
          }
          this.next();
          elem.tail = this.type === types$1.backQuote;
          return this.finishNode(elem, "TemplateElement");
        };
        pp$5.parseTemplate = function(ref2) {
          if (ref2 === void 0)
            ref2 = {};
          var isTagged = ref2.isTagged;
          if (isTagged === void 0)
            isTagged = false;
          var node = this.startNode();
          this.next();
          node.expressions = [];
          var curElt = this.parseTemplateElement({ isTagged });
          node.quasis = [curElt];
          while (!curElt.tail) {
            if (this.type === types$1.eof) {
              this.raise(this.pos, "Unterminated template literal");
            }
            this.expect(types$1.dollarBraceL);
            node.expressions.push(this.parseExpression());
            this.expect(types$1.braceR);
            node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
          }
          this.next();
          return this.finishNode(node, "TemplateLiteral");
        };
        pp$5.isAsyncProp = function(prop) {
          return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        };
        pp$5.parseObj = function(isPattern, refDestructuringErrors) {
          var node = this.startNode(), first = true, propHash = {};
          node.properties = [];
          this.next();
          while (!this.eat(types$1.braceR)) {
            if (!first) {
              this.expect(types$1.comma);
              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) {
              this.checkPropClash(prop, propHash, refDestructuringErrors);
            }
            node.properties.push(prop);
          }
          return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
        };
        pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
          if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
            if (isPattern) {
              prop.argument = this.parseIdent(false);
              if (this.type === types$1.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              return this.finishNode(prop, "RestElement");
            }
            if (this.type === types$1.parenL && refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0) {
                refDestructuringErrors.parenthesizedAssign = this.start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = this.start;
              }
            }
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
            return this.finishNode(prop, "SpreadElement");
          }
          if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
              startPos = this.start;
              startLoc = this.startLoc;
            }
            if (!isPattern) {
              isGenerator = this.eat(types$1.star);
            }
          }
          var containsEsc = this.containsEsc;
          this.parsePropertyName(prop);
          if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
            this.parsePropertyName(prop, refDestructuringErrors);
          } else {
            isAsync = false;
          }
          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
          return this.finishNode(prop, "Property");
        };
        pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
          if ((isGenerator || isAsync) && this.type === types$1.colon) {
            this.unexpected();
          }
          if (this.eat(types$1.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
          } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
            if (isPattern) {
              this.unexpected();
            }
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
          } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
            if (isGenerator || isAsync) {
              this.unexpected();
            }
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
            var paramCount = prop.kind === "get" ? 0 : 1;
            if (prop.value.params.length !== paramCount) {
              var start = prop.value.start;
              if (prop.kind === "get") {
                this.raiseRecoverable(start, "getter should have no params");
              } else {
                this.raiseRecoverable(start, "setter should have exactly one param");
              }
            } else {
              if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
                this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
              }
            }
          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) {
              this.unexpected();
            }
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !this.awaitIdentPos) {
              this.awaitIdentPos = startPos;
            }
            prop.kind = "init";
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else if (this.type === types$1.eq && refDestructuringErrors) {
              if (refDestructuringErrors.shorthandAssign < 0) {
                refDestructuringErrors.shorthandAssign = this.start;
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else {
              prop.value = this.copyNode(prop.key);
            }
            prop.shorthand = true;
          } else {
            this.unexpected();
          }
        };
        pp$5.parsePropertyName = function(prop) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(types$1.bracketL)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssign();
              this.expect(types$1.bracketR);
              return prop.key;
            } else {
              prop.computed = false;
            }
          }
          return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        };
        pp$5.initFunction = function(node) {
          node.id = null;
          if (this.options.ecmaVersion >= 6) {
            node.generator = node.expression = false;
          }
          if (this.options.ecmaVersion >= 8) {
            node.async = false;
          }
        };
        pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
          var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.initFunction(node);
          if (this.options.ecmaVersion >= 6) {
            node.generator = isGenerator;
          }
          if (this.options.ecmaVersion >= 8) {
            node.async = !!isAsync;
          }
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.expect(types$1.parenL);
          node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
          this.parseFunctionBody(node, false, true, false);
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, "FunctionExpression");
        };
        pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
          this.initFunction(node);
          if (this.options.ecmaVersion >= 8) {
            node.async = !!isAsync;
          }
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          node.params = this.toAssignableList(params, true);
          this.parseFunctionBody(node, true, false, forInit);
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, "ArrowFunctionExpression");
        };
        pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
          var isExpression = isArrowFunction && this.type !== types$1.braceL;
          var oldStrict = this.strict, useStrict = false;
          if (isExpression) {
            node.body = this.parseMaybeAssign(forInit);
            node.expression = true;
            this.checkParams(node, false);
          } else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            if (!oldStrict || nonSimple) {
              useStrict = this.strictDirective(this.end);
              if (useStrict && nonSimple) {
                this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
              }
            }
            var oldLabels = this.labels;
            this.labels = [];
            if (useStrict) {
              this.strict = true;
            }
            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
            if (this.strict && node.id) {
              this.checkLValSimple(node.id, BIND_OUTSIDE);
            }
            node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
            node.expression = false;
            this.adaptDirectivePrologue(node.body.body);
            this.labels = oldLabels;
          }
          this.exitScope();
        };
        pp$5.isSimpleParamList = function(params) {
          for (var i3 = 0, list2 = params; i3 < list2.length; i3 += 1) {
            var param = list2[i3];
            if (param.type !== "Identifier") {
              return false;
            }
          }
          return true;
        };
        pp$5.checkParams = function(node, allowDuplicates) {
          var nameHash = /* @__PURE__ */ Object.create(null);
          for (var i3 = 0, list2 = node.params; i3 < list2.length; i3 += 1) {
            var param = list2[i3];
            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
          }
        };
        pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (!first) {
              this.expect(types$1.comma);
              if (allowTrailingComma && this.afterTrailingComma(close)) {
                break;
              }
            } else {
              first = false;
            }
            var elt = void 0;
            if (allowEmpty && this.type === types$1.comma) {
              elt = null;
            } else if (this.type === types$1.ellipsis) {
              elt = this.parseSpread(refDestructuringErrors);
              if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
                refDestructuringErrors.trailingComma = this.start;
              }
            } else {
              elt = this.parseMaybeAssign(false, refDestructuringErrors);
            }
            elts.push(elt);
          }
          return elts;
        };
        pp$5.checkUnreserved = function(ref2) {
          var start = ref2.start;
          var end = ref2.end;
          var name = ref2.name;
          if (this.inGenerator && name === "yield") {
            this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
          }
          if (this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
          }
          if (this.currentThisScope().inClassFieldInit && name === "arguments") {
            this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
          }
          if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
            this.raise(start, "Cannot use " + name + " in class static initialization block");
          }
          if (this.keywords.test(name)) {
            this.raise(start, "Unexpected keyword '" + name + "'");
          }
          if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
            return;
          }
          var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
          if (re2.test(name)) {
            if (!this.inAsync && name === "await") {
              this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
            }
            this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
          }
        };
        pp$5.parseIdent = function(liberal, isBinding) {
          var node = this.startNode();
          if (this.type === types$1.name) {
            node.name = this.value;
          } else if (this.type.keyword) {
            node.name = this.type.keyword;
            if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
              this.context.pop();
            }
          } else {
            this.unexpected();
          }
          this.next(!!liberal);
          this.finishNode(node, "Identifier");
          if (!liberal) {
            this.checkUnreserved(node);
            if (node.name === "await" && !this.awaitIdentPos) {
              this.awaitIdentPos = node.start;
            }
          }
          return node;
        };
        pp$5.parsePrivateIdent = function() {
          var node = this.startNode();
          if (this.type === types$1.privateId) {
            node.name = this.value;
          } else {
            this.unexpected();
          }
          this.next();
          this.finishNode(node, "PrivateIdentifier");
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
          return node;
        };
        pp$5.parseYield = function(forInit) {
          if (!this.yieldPos) {
            this.yieldPos = this.start;
          }
          var node = this.startNode();
          this.next();
          if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
            node.delegate = false;
            node.argument = null;
          } else {
            node.delegate = this.eat(types$1.star);
            node.argument = this.parseMaybeAssign(forInit);
          }
          return this.finishNode(node, "YieldExpression");
        };
        pp$5.parseAwait = function(forInit) {
          if (!this.awaitPos) {
            this.awaitPos = this.start;
          }
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeUnary(null, true, false, forInit);
          return this.finishNode(node, "AwaitExpression");
        };
        var pp$4 = Parser.prototype;
        pp$4.raise = function(pos, message) {
          var loc = getLineInfo(this.input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = this.pos;
          throw err;
        };
        pp$4.raiseRecoverable = pp$4.raise;
        pp$4.curPosition = function() {
          if (this.options.locations) {
            return new Position(this.curLine, this.pos - this.lineStart);
          }
        };
        var pp$3 = Parser.prototype;
        var Scope = function Scope2(flags) {
          this.flags = flags;
          this.var = [];
          this.lexical = [];
          this.functions = [];
          this.inClassFieldInit = false;
        };
        pp$3.enterScope = function(flags) {
          this.scopeStack.push(new Scope(flags));
        };
        pp$3.exitScope = function() {
          this.scopeStack.pop();
        };
        pp$3.treatFunctionsAsVarInScope = function(scope) {
          return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
        };
        pp$3.declareName = function(name, bindingType, pos) {
          var redeclared = false;
          if (bindingType === BIND_LEXICAL) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
            scope.lexical.push(name);
            if (this.inModule && scope.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
          } else if (bindingType === BIND_SIMPLE_CATCH) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name);
          } else if (bindingType === BIND_FUNCTION) {
            var scope$2 = this.currentScope();
            if (this.treatFunctionsAsVar) {
              redeclared = scope$2.lexical.indexOf(name) > -1;
            } else {
              redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
            }
            scope$2.functions.push(name);
          } else {
            for (var i3 = this.scopeStack.length - 1; i3 >= 0; --i3) {
              var scope$3 = this.scopeStack[i3];
              if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                redeclared = true;
                break;
              }
              scope$3.var.push(name);
              if (this.inModule && scope$3.flags & SCOPE_TOP) {
                delete this.undefinedExports[name];
              }
              if (scope$3.flags & SCOPE_VAR) {
                break;
              }
            }
          }
          if (redeclared) {
            this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
          }
        };
        pp$3.checkLocalExport = function(id2) {
          if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
            this.undefinedExports[id2.name] = id2;
          }
        };
        pp$3.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        };
        pp$3.currentVarScope = function() {
          for (var i3 = this.scopeStack.length - 1; ; i3--) {
            var scope = this.scopeStack[i3];
            if (scope.flags & SCOPE_VAR) {
              return scope;
            }
          }
        };
        pp$3.currentThisScope = function() {
          for (var i3 = this.scopeStack.length - 1; ; i3--) {
            var scope = this.scopeStack[i3];
            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
              return scope;
            }
          }
        };
        var Node = function Node2(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          if (parser.options.locations) {
            this.loc = new SourceLocation(parser, loc);
          }
          if (parser.options.directSourceFile) {
            this.sourceFile = parser.options.directSourceFile;
          }
          if (parser.options.ranges) {
            this.range = [pos, 0];
          }
        };
        var pp$2 = Parser.prototype;
        pp$2.startNode = function() {
          return new Node(this, this.start, this.startLoc);
        };
        pp$2.startNodeAt = function(pos, loc) {
          return new Node(this, pos, loc);
        };
        function finishNodeAt(node, type, pos, loc) {
          node.type = type;
          node.end = pos;
          if (this.options.locations) {
            node.loc.end = loc;
          }
          if (this.options.ranges) {
            node.range[1] = pos;
          }
          return node;
        }
        pp$2.finishNode = function(node, type) {
          return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
        };
        pp$2.finishNodeAt = function(node, type, pos, loc) {
          return finishNodeAt.call(this, node, type, pos, loc);
        };
        pp$2.copyNode = function(node) {
          var newNode = new Node(this, node.start, this.startLoc);
          for (var prop in node) {
            newNode[prop] = node[prop];
          }
          return newNode;
        };
        var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
        var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
        var ecma11BinaryProperties = ecma10BinaryProperties;
        var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
        var ecma13BinaryProperties = ecma12BinaryProperties;
        var unicodeBinaryProperties = {
          9: ecma9BinaryProperties,
          10: ecma10BinaryProperties,
          11: ecma11BinaryProperties,
          12: ecma12BinaryProperties,
          13: ecma13BinaryProperties
        };
        var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
        var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
        var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
        var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
        var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
        var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
        var unicodeScriptValues = {
          9: ecma9ScriptValues,
          10: ecma10ScriptValues,
          11: ecma11ScriptValues,
          12: ecma12ScriptValues,
          13: ecma13ScriptValues
        };
        var data = {};
        function buildUnicodeData(ecmaVersion2) {
          var d = data[ecmaVersion2] = {
            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
            nonBinary: {
              General_Category: wordsRegexp(unicodeGeneralCategoryValues),
              Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
            }
          };
          d.nonBinary.Script_Extensions = d.nonBinary.Script;
          d.nonBinary.gc = d.nonBinary.General_Category;
          d.nonBinary.sc = d.nonBinary.Script;
          d.nonBinary.scx = d.nonBinary.Script_Extensions;
        }
        for (var i2 = 0, list = [9, 10, 11, 12, 13]; i2 < list.length; i2 += 1) {
          var ecmaVersion = list[i2];
          buildUnicodeData(ecmaVersion);
        }
        var pp$1 = Parser.prototype;
        var RegExpValidationState = function RegExpValidationState2(parser) {
          this.parser = parser;
          this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
          this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
          this.source = "";
          this.flags = "";
          this.start = 0;
          this.switchU = false;
          this.switchN = false;
          this.pos = 0;
          this.lastIntValue = 0;
          this.lastStringValue = "";
          this.lastAssertionIsQuantifiable = false;
          this.numCapturingParens = 0;
          this.maxBackReference = 0;
          this.groupNames = [];
          this.backReferenceNames = [];
        };
        RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
          var unicode = flags.indexOf("u") !== -1;
          this.start = start | 0;
          this.source = pattern + "";
          this.flags = flags;
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        };
        RegExpValidationState.prototype.raise = function raise(message) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
        };
        RegExpValidationState.prototype.at = function at2(i3, forceU) {
          if (forceU === void 0)
            forceU = false;
          var s2 = this.source;
          var l2 = s2.length;
          if (i3 >= l2) {
            return -1;
          }
          var c2 = s2.charCodeAt(i3);
          if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i3 + 1 >= l2) {
            return c2;
          }
          var next = s2.charCodeAt(i3 + 1);
          return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
        };
        RegExpValidationState.prototype.nextIndex = function nextIndex(i3, forceU) {
          if (forceU === void 0)
            forceU = false;
          var s2 = this.source;
          var l2 = s2.length;
          if (i3 >= l2) {
            return l2;
          }
          var c2 = s2.charCodeAt(i3), next;
          if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i3 + 1 >= l2 || (next = s2.charCodeAt(i3 + 1)) < 56320 || next > 57343) {
            return i3 + 1;
          }
          return i3 + 2;
        };
        RegExpValidationState.prototype.current = function current(forceU) {
          if (forceU === void 0)
            forceU = false;
          return this.at(this.pos, forceU);
        };
        RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
          if (forceU === void 0)
            forceU = false;
          return this.at(this.nextIndex(this.pos, forceU), forceU);
        };
        RegExpValidationState.prototype.advance = function advance(forceU) {
          if (forceU === void 0)
            forceU = false;
          this.pos = this.nextIndex(this.pos, forceU);
        };
        RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
          if (forceU === void 0)
            forceU = false;
          if (this.current(forceU) === ch2) {
            this.advance(forceU);
            return true;
          }
          return false;
        };
        function codePointToString$1(ch2) {
          if (ch2 <= 65535) {
            return String.fromCharCode(ch2);
          }
          ch2 -= 65536;
          return String.fromCharCode((ch2 >> 10) + 55296, (ch2 & 1023) + 56320);
        }
        pp$1.validateRegExpFlags = function(state) {
          var validFlags = state.validFlags;
          var flags = state.flags;
          for (var i3 = 0; i3 < flags.length; i3++) {
            var flag = flags.charAt(i3);
            if (validFlags.indexOf(flag) === -1) {
              this.raise(state.start, "Invalid regular expression flag");
            }
            if (flags.indexOf(flag, i3 + 1) > -1) {
              this.raise(state.start, "Duplicate regular expression flag");
            }
          }
        };
        pp$1.validateRegExpPattern = function(state) {
          this.regexp_pattern(state);
          if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
            state.switchN = true;
            this.regexp_pattern(state);
          }
        };
        pp$1.regexp_pattern = function(state) {
          state.pos = 0;
          state.lastIntValue = 0;
          state.lastStringValue = "";
          state.lastAssertionIsQuantifiable = false;
          state.numCapturingParens = 0;
          state.maxBackReference = 0;
          state.groupNames.length = 0;
          state.backReferenceNames.length = 0;
          this.regexp_disjunction(state);
          if (state.pos !== state.source.length) {
            if (state.eat(41)) {
              state.raise("Unmatched ')'");
            }
            if (state.eat(93) || state.eat(125)) {
              state.raise("Lone quantifier brackets");
            }
          }
          if (state.maxBackReference > state.numCapturingParens) {
            state.raise("Invalid escape");
          }
          for (var i3 = 0, list2 = state.backReferenceNames; i3 < list2.length; i3 += 1) {
            var name = list2[i3];
            if (state.groupNames.indexOf(name) === -1) {
              state.raise("Invalid named capture referenced");
            }
          }
        };
        pp$1.regexp_disjunction = function(state) {
          this.regexp_alternative(state);
          while (state.eat(124)) {
            this.regexp_alternative(state);
          }
          if (this.regexp_eatQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          if (state.eat(123)) {
            state.raise("Lone quantifier brackets");
          }
        };
        pp$1.regexp_alternative = function(state) {
          while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
          }
        };
        pp$1.regexp_eatTerm = function(state) {
          if (this.regexp_eatAssertion(state)) {
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
              if (state.switchU) {
                state.raise("Invalid quantifier");
              }
            }
            return true;
          }
          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true;
          }
          return false;
        };
        pp$1.regexp_eatAssertion = function(state) {
          var start = state.pos;
          state.lastAssertionIsQuantifiable = false;
          if (state.eat(94) || state.eat(36)) {
            return true;
          }
          if (state.eat(92)) {
            if (state.eat(66) || state.eat(98)) {
              return true;
            }
            state.pos = start;
          }
          if (state.eat(40) && state.eat(63)) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9) {
              lookbehind = state.eat(60);
            }
            if (state.eat(61) || state.eat(33)) {
              this.regexp_disjunction(state);
              if (!state.eat(41)) {
                state.raise("Unterminated group");
              }
              state.lastAssertionIsQuantifiable = !lookbehind;
              return true;
            }
          }
          state.pos = start;
          return false;
        };
        pp$1.regexp_eatQuantifier = function(state, noError) {
          if (noError === void 0)
            noError = false;
          if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(63);
            return true;
          }
          return false;
        };
        pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
          return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
        };
        pp$1.regexp_eatBracedQuantifier = function(state, noError) {
          var start = state.pos;
          if (state.eat(123)) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
              min = state.lastIntValue;
              if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
                max = state.lastIntValue;
              }
              if (state.eat(125)) {
                if (max !== -1 && max < min && !noError) {
                  state.raise("numbers out of order in {} quantifier");
                }
                return true;
              }
            }
            if (state.switchU && !noError) {
              state.raise("Incomplete quantifier");
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatAtom = function(state) {
          return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
        };
        pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatAtomEscape(state)) {
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatUncapturingGroup = function(state) {
          var start = state.pos;
          if (state.eat(40)) {
            if (state.eat(63) && state.eat(58)) {
              this.regexp_disjunction(state);
              if (state.eat(41)) {
                return true;
              }
              state.raise("Unterminated group");
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatCapturingGroup = function(state) {
          if (state.eat(40)) {
            if (this.options.ecmaVersion >= 9) {
              this.regexp_groupSpecifier(state);
            } else if (state.current() === 63) {
              state.raise("Invalid group");
            }
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              state.numCapturingParens += 1;
              return true;
            }
            state.raise("Unterminated group");
          }
          return false;
        };
        pp$1.regexp_eatExtendedAtom = function(state) {
          return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
        };
        pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
          if (this.regexp_eatBracedQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          return false;
        };
        pp$1.regexp_eatSyntaxCharacter = function(state) {
          var ch2 = state.current();
          if (isSyntaxCharacter(ch2)) {
            state.lastIntValue = ch2;
            state.advance();
            return true;
          }
          return false;
        };
        function isSyntaxCharacter(ch2) {
          return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
        }
        pp$1.regexp_eatPatternCharacters = function(state) {
          var start = state.pos;
          var ch2 = 0;
          while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
            state.advance();
          }
          return state.pos !== start;
        };
        pp$1.regexp_eatExtendedPatternCharacter = function(state) {
          var ch2 = state.current();
          if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_groupSpecifier = function(state) {
          if (state.eat(63)) {
            if (this.regexp_eatGroupName(state)) {
              if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
                state.raise("Duplicate capture group name");
              }
              state.groupNames.push(state.lastStringValue);
              return;
            }
            state.raise("Invalid group");
          }
        };
        pp$1.regexp_eatGroupName = function(state) {
          state.lastStringValue = "";
          if (state.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
              return true;
            }
            state.raise("Invalid capture group name");
          }
          return false;
        };
        pp$1.regexp_eatRegExpIdentifierName = function(state) {
          state.lastStringValue = "";
          if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString$1(state.lastIntValue);
            while (this.regexp_eatRegExpIdentifierPart(state)) {
              state.lastStringValue += codePointToString$1(state.lastIntValue);
            }
            return true;
          }
          return false;
        };
        pp$1.regexp_eatRegExpIdentifierStart = function(state) {
          var start = state.pos;
          var forceU = this.options.ecmaVersion >= 11;
          var ch2 = state.current(forceU);
          state.advance(forceU);
          if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch2 = state.lastIntValue;
          }
          if (isRegExpIdentifierStart(ch2)) {
            state.lastIntValue = ch2;
            return true;
          }
          state.pos = start;
          return false;
        };
        function isRegExpIdentifierStart(ch2) {
          return isIdentifierStart(ch2, true) || ch2 === 36 || ch2 === 95;
        }
        pp$1.regexp_eatRegExpIdentifierPart = function(state) {
          var start = state.pos;
          var forceU = this.options.ecmaVersion >= 11;
          var ch2 = state.current(forceU);
          state.advance(forceU);
          if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch2 = state.lastIntValue;
          }
          if (isRegExpIdentifierPart(ch2)) {
            state.lastIntValue = ch2;
            return true;
          }
          state.pos = start;
          return false;
        };
        function isRegExpIdentifierPart(ch2) {
          return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
        }
        pp$1.regexp_eatAtomEscape = function(state) {
          if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
            return true;
          }
          if (state.switchU) {
            if (state.current() === 99) {
              state.raise("Invalid unicode escape");
            }
            state.raise("Invalid escape");
          }
          return false;
        };
        pp$1.regexp_eatBackReference = function(state) {
          var start = state.pos;
          if (this.regexp_eatDecimalEscape(state)) {
            var n2 = state.lastIntValue;
            if (state.switchU) {
              if (n2 > state.maxBackReference) {
                state.maxBackReference = n2;
              }
              return true;
            }
            if (n2 <= state.numCapturingParens) {
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatKGroupName = function(state) {
          if (state.eat(107)) {
            if (this.regexp_eatGroupName(state)) {
              state.backReferenceNames.push(state.lastStringValue);
              return true;
            }
            state.raise("Invalid named reference");
          }
          return false;
        };
        pp$1.regexp_eatCharacterEscape = function(state) {
          return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
        };
        pp$1.regexp_eatCControlLetter = function(state) {
          var start = state.pos;
          if (state.eat(99)) {
            if (this.regexp_eatControlLetter(state)) {
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatZero = function(state) {
          if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatControlEscape = function(state) {
          var ch2 = state.current();
          if (ch2 === 116) {
            state.lastIntValue = 9;
            state.advance();
            return true;
          }
          if (ch2 === 110) {
            state.lastIntValue = 10;
            state.advance();
            return true;
          }
          if (ch2 === 118) {
            state.lastIntValue = 11;
            state.advance();
            return true;
          }
          if (ch2 === 102) {
            state.lastIntValue = 12;
            state.advance();
            return true;
          }
          if (ch2 === 114) {
            state.lastIntValue = 13;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatControlLetter = function(state) {
          var ch2 = state.current();
          if (isControlLetter(ch2)) {
            state.lastIntValue = ch2 % 32;
            state.advance();
            return true;
          }
          return false;
        };
        function isControlLetter(ch2) {
          return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
        }
        pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
          if (forceU === void 0)
            forceU = false;
          var start = state.pos;
          var switchU = forceU || state.switchU;
          if (state.eat(117)) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
              var lead = state.lastIntValue;
              if (switchU && lead >= 55296 && lead <= 56319) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                  var trail = state.lastIntValue;
                  if (trail >= 56320 && trail <= 57343) {
                    state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                    return true;
                  }
                }
                state.pos = leadSurrogateEnd;
                state.lastIntValue = lead;
              }
              return true;
            }
            if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
              return true;
            }
            if (switchU) {
              state.raise("Invalid unicode escape");
            }
            state.pos = start;
          }
          return false;
        };
        function isValidUnicode(ch2) {
          return ch2 >= 0 && ch2 <= 1114111;
        }
        pp$1.regexp_eatIdentityEscape = function(state) {
          if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) {
              return true;
            }
            if (state.eat(47)) {
              state.lastIntValue = 47;
              return true;
            }
            return false;
          }
          var ch2 = state.current();
          if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
            state.lastIntValue = ch2;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatDecimalEscape = function(state) {
          state.lastIntValue = 0;
          var ch2 = state.current();
          if (ch2 >= 49 && ch2 <= 57) {
            do {
              state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
              state.advance();
            } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
            return true;
          }
          return false;
        };
        pp$1.regexp_eatCharacterClassEscape = function(state) {
          var ch2 = state.current();
          if (isCharacterClassEscape(ch2)) {
            state.lastIntValue = -1;
            state.advance();
            return true;
          }
          if (state.switchU && this.options.ecmaVersion >= 9 && (ch2 === 80 || ch2 === 112)) {
            state.lastIntValue = -1;
            state.advance();
            if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
              return true;
            }
            state.raise("Invalid property name");
          }
          return false;
        };
        function isCharacterClassEscape(ch2) {
          return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
        }
        pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
          var start = state.pos;
          if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
              var value = state.lastStringValue;
              this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
              return true;
            }
          }
          state.pos = start;
          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
            return true;
          }
          return false;
        };
        pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
          if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
            state.raise("Invalid property name");
          }
          if (!state.unicodeProperties.nonBinary[name].test(value)) {
            state.raise("Invalid property value");
          }
        };
        pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
          if (!state.unicodeProperties.binary.test(nameOrValue)) {
            state.raise("Invalid property name");
          }
        };
        pp$1.regexp_eatUnicodePropertyName = function(state) {
          var ch2 = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
            state.lastStringValue += codePointToString$1(ch2);
            state.advance();
          }
          return state.lastStringValue !== "";
        };
        function isUnicodePropertyNameCharacter(ch2) {
          return isControlLetter(ch2) || ch2 === 95;
        }
        pp$1.regexp_eatUnicodePropertyValue = function(state) {
          var ch2 = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
            state.lastStringValue += codePointToString$1(ch2);
            state.advance();
          }
          return state.lastStringValue !== "";
        };
        function isUnicodePropertyValueCharacter(ch2) {
          return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
        }
        pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
          return this.regexp_eatUnicodePropertyValue(state);
        };
        pp$1.regexp_eatCharacterClass = function(state) {
          if (state.eat(91)) {
            state.eat(94);
            this.regexp_classRanges(state);
            if (state.eat(93)) {
              return true;
            }
            state.raise("Unterminated character class");
          }
          return false;
        };
        pp$1.regexp_classRanges = function(state) {
          while (this.regexp_eatClassAtom(state)) {
            var left = state.lastIntValue;
            if (state.eat(45) && this.regexp_eatClassAtom(state)) {
              var right = state.lastIntValue;
              if (state.switchU && (left === -1 || right === -1)) {
                state.raise("Invalid character class");
              }
              if (left !== -1 && right !== -1 && left > right) {
                state.raise("Range out of order in character class");
              }
            }
          }
        };
        pp$1.regexp_eatClassAtom = function(state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatClassEscape(state)) {
              return true;
            }
            if (state.switchU) {
              var ch$1 = state.current();
              if (ch$1 === 99 || isOctalDigit(ch$1)) {
                state.raise("Invalid class escape");
              }
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
          var ch2 = state.current();
          if (ch2 !== 93) {
            state.lastIntValue = ch2;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatClassEscape = function(state) {
          var start = state.pos;
          if (state.eat(98)) {
            state.lastIntValue = 8;
            return true;
          }
          if (state.switchU && state.eat(45)) {
            state.lastIntValue = 45;
            return true;
          }
          if (!state.switchU && state.eat(99)) {
            if (this.regexp_eatClassControlLetter(state)) {
              return true;
            }
            state.pos = start;
          }
          return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
        };
        pp$1.regexp_eatClassControlLetter = function(state) {
          var ch2 = state.current();
          if (isDecimalDigit(ch2) || ch2 === 95) {
            state.lastIntValue = ch2 % 32;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatHexEscapeSequence = function(state) {
          var start = state.pos;
          if (state.eat(120)) {
            if (this.regexp_eatFixedHexDigits(state, 2)) {
              return true;
            }
            if (state.switchU) {
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatDecimalDigits = function(state) {
          var start = state.pos;
          var ch2 = 0;
          state.lastIntValue = 0;
          while (isDecimalDigit(ch2 = state.current())) {
            state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
            state.advance();
          }
          return state.pos !== start;
        };
        function isDecimalDigit(ch2) {
          return ch2 >= 48 && ch2 <= 57;
        }
        pp$1.regexp_eatHexDigits = function(state) {
          var start = state.pos;
          var ch2 = 0;
          state.lastIntValue = 0;
          while (isHexDigit(ch2 = state.current())) {
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
            state.advance();
          }
          return state.pos !== start;
        };
        function isHexDigit(ch2) {
          return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
        }
        function hexToInt(ch2) {
          if (ch2 >= 65 && ch2 <= 70) {
            return 10 + (ch2 - 65);
          }
          if (ch2 >= 97 && ch2 <= 102) {
            return 10 + (ch2 - 97);
          }
          return ch2 - 48;
        }
        pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
          if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
              var n2 = state.lastIntValue;
              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
              } else {
                state.lastIntValue = n1 * 8 + n2;
              }
            } else {
              state.lastIntValue = n1;
            }
            return true;
          }
          return false;
        };
        pp$1.regexp_eatOctalDigit = function(state) {
          var ch2 = state.current();
          if (isOctalDigit(ch2)) {
            state.lastIntValue = ch2 - 48;
            state.advance();
            return true;
          }
          state.lastIntValue = 0;
          return false;
        };
        function isOctalDigit(ch2) {
          return ch2 >= 48 && ch2 <= 55;
        }
        pp$1.regexp_eatFixedHexDigits = function(state, length) {
          var start = state.pos;
          state.lastIntValue = 0;
          for (var i3 = 0; i3 < length; ++i3) {
            var ch2 = state.current();
            if (!isHexDigit(ch2)) {
              state.pos = start;
              return false;
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
            state.advance();
          }
          return true;
        };
        var Token = function Token2(p) {
          this.type = p.type;
          this.value = p.value;
          this.start = p.start;
          this.end = p.end;
          if (p.options.locations) {
            this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
          }
          if (p.options.ranges) {
            this.range = [p.start, p.end];
          }
        };
        var pp2 = Parser.prototype;
        pp2.next = function(ignoreEscapeSequenceInKeyword) {
          if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
          }
          if (this.options.onToken) {
            this.options.onToken(new Token(this));
          }
          this.lastTokEnd = this.end;
          this.lastTokStart = this.start;
          this.lastTokEndLoc = this.endLoc;
          this.lastTokStartLoc = this.startLoc;
          this.nextToken();
        };
        pp2.getToken = function() {
          this.next();
          return new Token(this);
        };
        if (typeof Symbol !== "undefined") {
          pp2[Symbol.iterator] = function() {
            var this$1$1 = this;
            return {
              next: function() {
                var token = this$1$1.getToken();
                return {
                  done: token.type === types$1.eof,
                  value: token
                };
              }
            };
          };
        }
        pp2.nextToken = function() {
          var curContext = this.curContext();
          if (!curContext || !curContext.preserveSpace) {
            this.skipSpace();
          }
          this.start = this.pos;
          if (this.options.locations) {
            this.startLoc = this.curPosition();
          }
          if (this.pos >= this.input.length) {
            return this.finishToken(types$1.eof);
          }
          if (curContext.override) {
            return curContext.override(this);
          } else {
            this.readToken(this.fullCharCodeAtPos());
          }
        };
        pp2.readToken = function(code) {
          if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
            return this.readWord();
          }
          return this.getTokenFromCode(code);
        };
        pp2.fullCharCodeAtPos = function() {
          var code = this.input.charCodeAt(this.pos);
          if (code <= 55295 || code >= 56320) {
            return code;
          }
          var next = this.input.charCodeAt(this.pos + 1);
          return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
        };
        pp2.skipBlockComment = function() {
          var startLoc = this.options.onComment && this.curPosition();
          var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
          if (end === -1) {
            this.raise(this.pos - 2, "Unterminated comment");
          }
          this.pos = end + 2;
          if (this.options.locations) {
            for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
              ++this.curLine;
              pos = this.lineStart = nextBreak;
            }
          }
          if (this.options.onComment) {
            this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
          }
        };
        pp2.skipLineComment = function(startSkip) {
          var start = this.pos;
          var startLoc = this.options.onComment && this.curPosition();
          var ch2 = this.input.charCodeAt(this.pos += startSkip);
          while (this.pos < this.input.length && !isNewLine(ch2)) {
            ch2 = this.input.charCodeAt(++this.pos);
          }
          if (this.options.onComment) {
            this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
          }
        };
        pp2.skipSpace = function() {
          loop:
            while (this.pos < this.input.length) {
              var ch2 = this.input.charCodeAt(this.pos);
              switch (ch2) {
                case 32:
                case 160:
                  ++this.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.pos + 1) === 10) {
                    ++this.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.pos;
                  if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                  }
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.pos + 1)) {
                    case 42:
                      this.skipBlockComment();
                      break;
                    case 47:
                      this.skipLineComment(2);
                      break;
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
                    ++this.pos;
                  } else {
                    break loop;
                  }
              }
            }
        };
        pp2.finishToken = function(type, val) {
          this.end = this.pos;
          if (this.options.locations) {
            this.endLoc = this.curPosition();
          }
          var prevType = this.type;
          this.type = type;
          this.value = val;
          this.updateContext(prevType);
        };
        pp2.readToken_dot = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next >= 48 && next <= 57) {
            return this.readNumber(true);
          }
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            this.pos += 3;
            return this.finishToken(types$1.ellipsis);
          } else {
            ++this.pos;
            return this.finishToken(types$1.dot);
          }
        };
        pp2.readToken_slash = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (this.exprAllowed) {
            ++this.pos;
            return this.readRegexp();
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(types$1.slash, 1);
        };
        pp2.readToken_mult_modulo_exp = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          var tokentype = code === 42 ? types$1.star : types$1.modulo;
          if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
            ++size;
            tokentype = types$1.starstar;
            next = this.input.charCodeAt(this.pos + 2);
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(tokentype, size);
        };
        pp2.readToken_pipe_amp = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) {
            if (this.options.ecmaVersion >= 12) {
              var next2 = this.input.charCodeAt(this.pos + 2);
              if (next2 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
        };
        pp2.readToken_caret = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(types$1.bitwiseXOR, 1);
        };
        pp2.readToken_plus_min = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) {
            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
              this.skipLineComment(3);
              this.skipSpace();
              return this.nextToken();
            }
            return this.finishOp(types$1.incDec, 2);
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(types$1.plusMin, 1);
        };
        pp2.readToken_lt_gt = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          if (next === code) {
            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) {
              return this.finishOp(types$1.assign, size + 1);
            }
            return this.finishOp(types$1.bitShift, size);
          }
          if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
          }
          if (next === 61) {
            size = 2;
          }
          return this.finishOp(types$1.relational, size);
        };
        pp2.readToken_eq_excl = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) {
            return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
          }
          if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
            this.pos += 2;
            return this.finishToken(types$1.arrow);
          }
          return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
        };
        pp2.readToken_question = function() {
          var ecmaVersion2 = this.options.ecmaVersion;
          if (ecmaVersion2 >= 11) {
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 46) {
              var next2 = this.input.charCodeAt(this.pos + 2);
              if (next2 < 48 || next2 > 57) {
                return this.finishOp(types$1.questionDot, 2);
              }
            }
            if (next === 63) {
              if (ecmaVersion2 >= 12) {
                var next2$1 = this.input.charCodeAt(this.pos + 2);
                if (next2$1 === 61) {
                  return this.finishOp(types$1.assign, 3);
                }
              }
              return this.finishOp(types$1.coalesce, 2);
            }
          }
          return this.finishOp(types$1.question, 1);
        };
        pp2.readToken_numberSign = function() {
          var ecmaVersion2 = this.options.ecmaVersion;
          var code = 35;
          if (ecmaVersion2 >= 13) {
            ++this.pos;
            code = this.fullCharCodeAtPos();
            if (isIdentifierStart(code, true) || code === 92) {
              return this.finishToken(types$1.privateId, this.readWord1());
            }
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
        };
        pp2.getTokenFromCode = function(code) {
          switch (code) {
            case 46:
              return this.readToken_dot();
            case 40:
              ++this.pos;
              return this.finishToken(types$1.parenL);
            case 41:
              ++this.pos;
              return this.finishToken(types$1.parenR);
            case 59:
              ++this.pos;
              return this.finishToken(types$1.semi);
            case 44:
              ++this.pos;
              return this.finishToken(types$1.comma);
            case 91:
              ++this.pos;
              return this.finishToken(types$1.bracketL);
            case 93:
              ++this.pos;
              return this.finishToken(types$1.bracketR);
            case 123:
              ++this.pos;
              return this.finishToken(types$1.braceL);
            case 125:
              ++this.pos;
              return this.finishToken(types$1.braceR);
            case 58:
              ++this.pos;
              return this.finishToken(types$1.colon);
            case 96:
              if (this.options.ecmaVersion < 6) {
                break;
              }
              ++this.pos;
              return this.finishToken(types$1.backQuote);
            case 48:
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === 120 || next === 88) {
                return this.readRadixNumber(16);
              }
              if (this.options.ecmaVersion >= 6) {
                if (next === 111 || next === 79) {
                  return this.readRadixNumber(8);
                }
                if (next === 98 || next === 66) {
                  return this.readRadixNumber(2);
                }
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(code);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(code);
            case 124:
            case 38:
              return this.readToken_pipe_amp(code);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(code);
            case 60:
            case 62:
              return this.readToken_lt_gt(code);
            case 61:
            case 33:
              return this.readToken_eq_excl(code);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(types$1.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
        };
        pp2.finishOp = function(type, size) {
          var str = this.input.slice(this.pos, this.pos + size);
          this.pos += size;
          return this.finishToken(type, str);
        };
        pp2.readRegexp = function() {
          var escaped, inClass, start = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length) {
              this.raise(start, "Unterminated regular expression");
            }
            var ch2 = this.input.charAt(this.pos);
            if (lineBreak.test(ch2)) {
              this.raise(start, "Unterminated regular expression");
            }
            if (!escaped) {
              if (ch2 === "[") {
                inClass = true;
              } else if (ch2 === "]" && inClass) {
                inClass = false;
              } else if (ch2 === "/" && !inClass) {
                break;
              }
              escaped = ch2 === "\\";
            } else {
              escaped = false;
            }
            ++this.pos;
          }
          var pattern = this.input.slice(start, this.pos);
          ++this.pos;
          var flagsStart = this.pos;
          var flags = this.readWord1();
          if (this.containsEsc) {
            this.unexpected(flagsStart);
          }
          var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
          state.reset(start, pattern, flags);
          this.validateRegExpFlags(state);
          this.validateRegExpPattern(state);
          var value = null;
          try {
            value = new RegExp(pattern, flags);
          } catch (e4) {
          }
          return this.finishToken(types$1.regexp, { pattern, flags, value });
        };
        pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
          var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
          var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
          var start = this.pos, total = 0, lastCode = 0;
          for (var i3 = 0, e4 = len == null ? Infinity : len; i3 < e4; ++i3, ++this.pos) {
            var code = this.input.charCodeAt(this.pos), val = void 0;
            if (allowSeparators && code === 95) {
              if (isLegacyOctalNumericLiteral) {
                this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
              }
              if (lastCode === 95) {
                this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
              }
              if (i3 === 0) {
                this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
              }
              lastCode = code;
              continue;
            }
            if (code >= 97) {
              val = code - 97 + 10;
            } else if (code >= 65) {
              val = code - 65 + 10;
            } else if (code >= 48 && code <= 57) {
              val = code - 48;
            } else {
              val = Infinity;
            }
            if (val >= radix) {
              break;
            }
            lastCode = code;
            total = total * radix + val;
          }
          if (allowSeparators && lastCode === 95) {
            this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
          }
          if (this.pos === start || len != null && this.pos - start !== len) {
            return null;
          }
          return total;
        };
        function stringToNumber(str, isLegacyOctalNumericLiteral) {
          if (isLegacyOctalNumericLiteral) {
            return parseInt(str, 8);
          }
          return parseFloat(str.replace(/_/g, ""));
        }
        function stringToBigInt(str) {
          if (typeof BigInt !== "function") {
            return null;
          }
          return BigInt(str.replace(/_/g, ""));
        }
        pp2.readRadixNumber = function(radix) {
          var start = this.pos;
          this.pos += 2;
          var val = this.readInt(radix);
          if (val == null) {
            this.raise(this.start + 2, "Expected number in radix " + radix);
          }
          if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
            val = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
          } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val);
        };
        pp2.readNumber = function(startsWithDot) {
          var start = this.pos;
          if (!startsWithDot && this.readInt(10, void 0, true) === null) {
            this.raise(start, "Invalid number");
          }
          var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (octal && this.strict) {
            this.raise(start, "Invalid number");
          }
          var next = this.input.charCodeAt(this.pos);
          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
            var val$1 = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
            if (isIdentifierStart(this.fullCharCodeAtPos())) {
              this.raise(this.pos, "Identifier directly after number");
            }
            return this.finishToken(types$1.num, val$1);
          }
          if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
            octal = false;
          }
          if (next === 46 && !octal) {
            ++this.pos;
            this.readInt(10);
            next = this.input.charCodeAt(this.pos);
          }
          if ((next === 69 || next === 101) && !octal) {
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) {
              ++this.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(start, "Invalid number");
            }
          }
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          var val = stringToNumber(this.input.slice(start, this.pos), octal);
          return this.finishToken(types$1.num, val);
        };
        pp2.readCodePoint = function() {
          var ch2 = this.input.charCodeAt(this.pos), code;
          if (ch2 === 123) {
            if (this.options.ecmaVersion < 6) {
              this.unexpected();
            }
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
            ++this.pos;
            if (code > 1114111) {
              this.invalidStringToken(codePos, "Code point out of bounds");
            }
          } else {
            code = this.readHexChar(4);
          }
          return code;
        };
        function codePointToString(code) {
          if (code <= 65535) {
            return String.fromCharCode(code);
          }
          code -= 65536;
          return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
        }
        pp2.readString = function(quote) {
          var out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length) {
              this.raise(this.start, "Unterminated string constant");
            }
            var ch2 = this.input.charCodeAt(this.pos);
            if (ch2 === quote) {
              break;
            }
            if (ch2 === 92) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.readEscapedChar(false);
              chunkStart = this.pos;
            } else if (ch2 === 8232 || ch2 === 8233) {
              if (this.options.ecmaVersion < 10) {
                this.raise(this.start, "Unterminated string constant");
              }
              ++this.pos;
              if (this.options.locations) {
                this.curLine++;
                this.lineStart = this.pos;
              }
            } else {
              if (isNewLine(ch2)) {
                this.raise(this.start, "Unterminated string constant");
              }
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(types$1.string, out);
        };
        var INVALID_TEMPLATE_ESCAPE_ERROR = {};
        pp2.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
              this.readInvalidTemplateToken();
            } else {
              throw err;
            }
          }
          this.inTemplateElement = false;
        };
        pp2.invalidStringToken = function(position, message) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
            throw INVALID_TEMPLATE_ESCAPE_ERROR;
          } else {
            this.raise(position, message);
          }
        };
        pp2.readTmplToken = function() {
          var out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length) {
              this.raise(this.start, "Unterminated template");
            }
            var ch2 = this.input.charCodeAt(this.pos);
            if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
              if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
                if (ch2 === 36) {
                  this.pos += 2;
                  return this.finishToken(types$1.dollarBraceL);
                } else {
                  ++this.pos;
                  return this.finishToken(types$1.backQuote);
                }
              }
              out += this.input.slice(chunkStart, this.pos);
              return this.finishToken(types$1.template, out);
            }
            if (ch2 === 92) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.readEscapedChar(true);
              chunkStart = this.pos;
            } else if (isNewLine(ch2)) {
              out += this.input.slice(chunkStart, this.pos);
              ++this.pos;
              switch (ch2) {
                case 13:
                  if (this.input.charCodeAt(this.pos) === 10) {
                    ++this.pos;
                  }
                case 10:
                  out += "\n";
                  break;
                default:
                  out += String.fromCharCode(ch2);
                  break;
              }
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
        };
        pp2.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) {
            switch (this.input[this.pos]) {
              case "\\":
                ++this.pos;
                break;
              case "$":
                if (this.input[this.pos + 1] !== "{") {
                  break;
                }
              case "`":
                return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            }
          }
          this.raise(this.start, "Unterminated template");
        };
        pp2.readEscapedChar = function(inTemplate) {
          var ch2 = this.input.charCodeAt(++this.pos);
          ++this.pos;
          switch (ch2) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return codePointToString(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            case 56:
            case 57:
              if (this.strict) {
                this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
              }
              if (inTemplate) {
                var codePos = this.pos - 1;
                this.invalidStringToken(codePos, "Invalid escape sequence in template string");
                return null;
              }
            default:
              if (ch2 >= 48 && ch2 <= 55) {
                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                var octal = parseInt(octalStr, 8);
                if (octal > 255) {
                  octalStr = octalStr.slice(0, -1);
                  octal = parseInt(octalStr, 8);
                }
                this.pos += octalStr.length - 1;
                ch2 = this.input.charCodeAt(this.pos);
                if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
                  this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
                }
                return String.fromCharCode(octal);
              }
              if (isNewLine(ch2)) {
                return "";
              }
              return String.fromCharCode(ch2);
          }
        };
        pp2.readHexChar = function(len) {
          var codePos = this.pos;
          var n2 = this.readInt(16, len);
          if (n2 === null) {
            this.invalidStringToken(codePos, "Bad character escape sequence");
          }
          return n2;
        };
        pp2.readWord1 = function() {
          this.containsEsc = false;
          var word = "", first = true, chunkStart = this.pos;
          var astral = this.options.ecmaVersion >= 6;
          while (this.pos < this.input.length) {
            var ch2 = this.fullCharCodeAtPos();
            if (isIdentifierChar(ch2, astral)) {
              this.pos += ch2 <= 65535 ? 1 : 2;
            } else if (ch2 === 92) {
              this.containsEsc = true;
              word += this.input.slice(chunkStart, this.pos);
              var escStart = this.pos;
              if (this.input.charCodeAt(++this.pos) !== 117) {
                this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
              }
              ++this.pos;
              var esc = this.readCodePoint();
              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
                this.invalidStringToken(escStart, "Invalid Unicode escape");
              }
              word += codePointToString(esc);
              chunkStart = this.pos;
            } else {
              break;
            }
            first = false;
          }
          return word + this.input.slice(chunkStart, this.pos);
        };
        pp2.readWord = function() {
          var word = this.readWord1();
          var type = types$1.name;
          if (this.keywords.test(word)) {
            type = keywords[word];
          }
          return this.finishToken(type, word);
        };
        var version = "8.7.0";
        Parser.acorn = {
          Parser,
          version,
          defaultOptions,
          Position,
          SourceLocation,
          getLineInfo,
          Node,
          TokenType,
          tokTypes: types$1,
          keywordTypes: keywords,
          TokContext,
          tokContexts: types,
          isIdentifierChar,
          isIdentifierStart,
          Token,
          isNewLine,
          lineBreak,
          lineBreakG,
          nonASCIIwhitespace
        };
        function parse(input, options) {
          return Parser.parse(input, options);
        }
        function parseExpressionAt(input, pos, options) {
          return Parser.parseExpressionAt(input, pos, options);
        }
        function tokenizer(input, options) {
          return Parser.tokenizer(input, options);
        }
        exports2.Node = Node;
        exports2.Parser = Parser;
        exports2.Position = Position;
        exports2.SourceLocation = SourceLocation;
        exports2.TokContext = TokContext;
        exports2.Token = Token;
        exports2.TokenType = TokenType;
        exports2.defaultOptions = defaultOptions;
        exports2.getLineInfo = getLineInfo;
        exports2.isIdentifierChar = isIdentifierChar;
        exports2.isIdentifierStart = isIdentifierStart;
        exports2.isNewLine = isNewLine;
        exports2.keywordTypes = keywords;
        exports2.lineBreak = lineBreak;
        exports2.lineBreakG = lineBreakG;
        exports2.nonASCIIwhitespace = nonASCIIwhitespace;
        exports2.parse = parse;
        exports2.parseExpressionAt = parseExpressionAt;
        exports2.tokContexts = types;
        exports2.tokTypes = types$1;
        exports2.tokenizer = tokenizer;
        exports2.version = version;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // (disabled):../../node_modules/paper/dist/node/extend.js
  var require_extend = __commonJS({
    "(disabled):../../node_modules/paper/dist/node/extend.js"() {
    }
  });

  // ../../node_modules/paper/dist/paper-full.js
  var require_paper_full = __commonJS({
    "../../node_modules/paper/dist/paper-full.js"(exports, module) {
      var paper = function(self2, undefined2) {
        self2 = self2 || require_self();
        var window2 = self2.window, document2 = self2.document;
        var Base = new function() {
          var hidden = /^(statics|enumerable|beans|preserve)$/, array = [], slice = array.slice, create = Object.create, describe = Object.getOwnPropertyDescriptor, define2 = Object.defineProperty, forEach = array.forEach || function(iter, bind) {
            for (var i2 = 0, l2 = this.length; i2 < l2; i2++) {
              iter.call(bind, this[i2], i2, this);
            }
          }, forIn = function(iter, bind) {
            for (var i2 in this) {
              if (this.hasOwnProperty(i2))
                iter.call(bind, this[i2], i2, this);
            }
          }, set = Object.assign || function(dst) {
            for (var i2 = 1, l2 = arguments.length; i2 < l2; i2++) {
              var src = arguments[i2];
              for (var key in src) {
                if (src.hasOwnProperty(key))
                  dst[key] = src[key];
              }
            }
            return dst;
          }, each = function(obj, iter, bind) {
            if (obj) {
              var desc = describe(obj, "length");
              (desc && typeof desc.value === "number" ? forEach : forIn).call(obj, iter, bind = bind || obj);
            }
            return bind;
          };
          function inject(dest, src, enumerable, beans, preserve) {
            var beansNames = {};
            function field(name2, val) {
              val = val || (val = describe(src, name2)) && (val.get ? val : val.value);
              if (typeof val === "string" && val[0] === "#")
                val = dest[val.substring(1)] || val;
              var isFunc = typeof val === "function", res = val, prev = preserve || isFunc && !val.base ? val && val.get ? name2 in dest : dest[name2] : null, bean;
              if (!preserve || !prev) {
                if (isFunc && prev)
                  val.base = prev;
                if (isFunc && beans !== false && (bean = name2.match(/^([gs]et|is)(([A-Z])(.*))$/)))
                  beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
                if (!res || isFunc || !res.get || typeof res.get !== "function" || !Base2.isPlainObject(res)) {
                  res = { value: res, writable: true };
                }
                if ((describe(dest, name2) || { configurable: true }).configurable) {
                  res.configurable = true;
                  res.enumerable = enumerable != null ? enumerable : !bean;
                }
                define2(dest, name2, res);
              }
            }
            if (src) {
              for (var name in src) {
                if (src.hasOwnProperty(name) && !hidden.test(name))
                  field(name);
              }
              for (var name in beansNames) {
                var part = beansNames[name], set2 = dest["set" + part], get = dest["get" + part] || set2 && dest["is" + part];
                if (get && (beans === true || get.length === 0))
                  field(name, { get, set: set2 });
              }
            }
            return dest;
          }
          function Base2() {
            for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
              var src = arguments[i2];
              if (src)
                set(this, src);
            }
            return this;
          }
          return inject(Base2, {
            inject: function(src) {
              if (src) {
                var statics = src.statics === true ? src : src.statics, beans = src.beans, preserve = src.preserve;
                if (statics !== src)
                  inject(this.prototype, src, src.enumerable, beans, preserve);
                inject(this, statics, null, beans, preserve);
              }
              for (var i2 = 1, l2 = arguments.length; i2 < l2; i2++)
                this.inject(arguments[i2]);
              return this;
            },
            extend: function() {
              var base = this, ctor, proto;
              for (var i2 = 0, obj, l2 = arguments.length; i2 < l2 && !(ctor && proto); i2++) {
                obj = arguments[i2];
                ctor = ctor || obj.initialize;
                proto = proto || obj.prototype;
              }
              ctor = ctor || function() {
                base.apply(this, arguments);
              };
              proto = ctor.prototype = proto || create(this.prototype);
              define2(proto, "constructor", { value: ctor, writable: true, configurable: true });
              inject(ctor, this);
              if (arguments.length)
                this.inject.apply(ctor, arguments);
              ctor.base = base;
              return ctor;
            }
          }).inject({
            enumerable: false,
            initialize: Base2,
            set: Base2,
            inject: function() {
              for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
                var src = arguments[i2];
                if (src) {
                  inject(this, src, src.enumerable, src.beans, src.preserve);
                }
              }
              return this;
            },
            extend: function() {
              var res = create(this);
              return res.inject.apply(res, arguments);
            },
            each: function(iter, bind) {
              return each(this, iter, bind);
            },
            clone: function() {
              return new this.constructor(this);
            },
            statics: {
              set,
              each,
              create,
              define: define2,
              describe,
              clone: function(obj) {
                return set(new obj.constructor(), obj);
              },
              isPlainObject: function(obj) {
                var ctor = obj != null && obj.constructor;
                return ctor && (ctor === Object || ctor === Base2 || ctor.name === "Object");
              },
              pick: function(a2, b2) {
                return a2 !== undefined2 ? a2 : b2;
              },
              slice: function(list, begin, end) {
                return slice.call(list, begin, end);
              }
            }
          });
        }();
        if (typeof module !== "undefined")
          module.exports = Base;
        Base.inject({
          enumerable: false,
          toString: function() {
            return this._id != null ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + Base.each(this, function(value, key) {
              if (!/^_/.test(key)) {
                var type = typeof value;
                this.push(key + ": " + (type === "number" ? Formatter.instance.number(value) : type === "string" ? "'" + value + "'" : value));
              }
            }, []).join(", ") + " }";
          },
          getClassName: function() {
            return this._class || "";
          },
          importJSON: function(json) {
            return Base.importJSON(json, this);
          },
          exportJSON: function(options) {
            return Base.exportJSON(this, options);
          },
          toJSON: function() {
            return Base.serialize(this);
          },
          set: function(props, exclude) {
            if (props)
              Base.filter(this, props, exclude, this._prioritize);
            return this;
          }
        }, {
          beans: false,
          statics: {
            exports: {},
            extend: function extend() {
              var res = extend.base.apply(this, arguments), name = res.prototype._class;
              if (name && !Base.exports[name])
                Base.exports[name] = res;
              return res;
            },
            equals: function(obj1, obj2) {
              if (obj1 === obj2)
                return true;
              if (obj1 && obj1.equals)
                return obj1.equals(obj2);
              if (obj2 && obj2.equals)
                return obj2.equals(obj1);
              if (obj1 && obj2 && typeof obj1 === "object" && typeof obj2 === "object") {
                if (Array.isArray(obj1) && Array.isArray(obj2)) {
                  var length = obj1.length;
                  if (length !== obj2.length)
                    return false;
                  while (length--) {
                    if (!Base.equals(obj1[length], obj2[length]))
                      return false;
                  }
                } else {
                  var keys = Object.keys(obj1), length = keys.length;
                  if (length !== Object.keys(obj2).length)
                    return false;
                  while (length--) {
                    var key = keys[length];
                    if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key])))
                      return false;
                  }
                }
                return true;
              }
              return false;
            },
            read: function(list, start, options, amount) {
              if (this === Base) {
                var value = this.peek(list, start);
                list.__index++;
                return value;
              }
              var proto = this.prototype, readIndex = proto._readIndex, begin = start || readIndex && list.__index || 0, length = list.length, obj = list[begin];
              amount = amount || length - begin;
              if (obj instanceof this || options && options.readNull && obj == null && amount <= 1) {
                if (readIndex)
                  list.__index = begin + 1;
                return obj && options && options.clone ? obj.clone() : obj;
              }
              obj = Base.create(proto);
              if (readIndex)
                obj.__read = true;
              obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length ? Base.slice(list, begin, begin + amount) : list) || obj;
              if (readIndex) {
                list.__index = begin + obj.__read;
                var filtered = obj.__filtered;
                if (filtered) {
                  list.__filtered = filtered;
                  obj.__filtered = undefined2;
                }
                obj.__read = undefined2;
              }
              return obj;
            },
            peek: function(list, start) {
              return list[list.__index = start || list.__index || 0];
            },
            remain: function(list) {
              return list.length - (list.__index || 0);
            },
            readList: function(list, start, options, amount) {
              var res = [], entry, begin = start || 0, end = amount ? begin + amount : list.length;
              for (var i2 = begin; i2 < end; i2++) {
                res.push(Array.isArray(entry = list[i2]) ? this.read(entry, 0, options) : this.read(list, i2, options, 1));
              }
              return res;
            },
            readNamed: function(list, name, start, options, amount) {
              var value = this.getNamed(list, name), hasValue = value !== undefined2;
              if (hasValue) {
                var filtered = list.__filtered;
                if (!filtered) {
                  var source = this.getSource(list);
                  filtered = list.__filtered = Base.create(source);
                  filtered.__unfiltered = source;
                }
                filtered[name] = undefined2;
              }
              return this.read(hasValue ? [value] : list, start, options, amount);
            },
            readSupported: function(list, dest) {
              var source = this.getSource(list), that = this, read = false;
              if (source) {
                Object.keys(source).forEach(function(key) {
                  if (key in dest) {
                    var value = that.readNamed(list, key);
                    if (value !== undefined2) {
                      dest[key] = value;
                    }
                    read = true;
                  }
                });
              }
              return read;
            },
            getSource: function(list) {
              var source = list.__source;
              if (source === undefined2) {
                var arg = list.length === 1 && list[0];
                source = list.__source = arg && Base.isPlainObject(arg) ? arg : null;
              }
              return source;
            },
            getNamed: function(list, name) {
              var source = this.getSource(list);
              if (source) {
                return name ? source[name] : list.__filtered || source;
              }
            },
            hasNamed: function(list, name) {
              return !!this.getNamed(list, name);
            },
            filter: function(dest, source, exclude, prioritize) {
              var processed;
              function handleKey(key2) {
                if (!(exclude && key2 in exclude) && !(processed && key2 in processed)) {
                  var value = source[key2];
                  if (value !== undefined2)
                    dest[key2] = value;
                }
              }
              if (prioritize) {
                var keys = {};
                for (var i2 = 0, key, l2 = prioritize.length; i2 < l2; i2++) {
                  if ((key = prioritize[i2]) in source) {
                    handleKey(key);
                    keys[key] = true;
                  }
                }
                processed = keys;
              }
              Object.keys(source.__unfiltered || source).forEach(handleKey);
              return dest;
            },
            isPlainValue: function(obj, asString) {
              return Base.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === "string";
            },
            serialize: function(obj, options, compact, dictionary) {
              options = options || {};
              var isRoot = !dictionary, res;
              if (isRoot) {
                options.formatter = new Formatter(options.precision);
                dictionary = {
                  length: 0,
                  definitions: {},
                  references: {},
                  add: function(item, create) {
                    var id2 = "#" + item._id, ref = this.references[id2];
                    if (!ref) {
                      this.length++;
                      var res2 = create.call(item), name2 = item._class;
                      if (name2 && res2[0] !== name2)
                        res2.unshift(name2);
                      this.definitions[id2] = res2;
                      ref = this.references[id2] = [id2];
                    }
                    return ref;
                  }
                };
              }
              if (obj && obj._serialize) {
                res = obj._serialize(options, dictionary);
                var name = obj._class;
                if (name && !obj._compactSerialize && (isRoot || !compact) && res[0] !== name) {
                  res.unshift(name);
                }
              } else if (Array.isArray(obj)) {
                res = [];
                for (var i2 = 0, l2 = obj.length; i2 < l2; i2++)
                  res[i2] = Base.serialize(obj[i2], options, compact, dictionary);
              } else if (Base.isPlainObject(obj)) {
                res = {};
                var keys = Object.keys(obj);
                for (var i2 = 0, l2 = keys.length; i2 < l2; i2++) {
                  var key = keys[i2];
                  res[key] = Base.serialize(obj[key], options, compact, dictionary);
                }
              } else if (typeof obj === "number") {
                res = options.formatter.number(obj, options.precision);
              } else {
                res = obj;
              }
              return isRoot && dictionary.length > 0 ? [["dictionary", dictionary.definitions], res] : res;
            },
            deserialize: function(json, create, _data, _setDictionary, _isRoot) {
              var res = json, isFirst = !_data, hasDictionary = isFirst && json && json.length && json[0][0] === "dictionary";
              _data = _data || {};
              if (Array.isArray(json)) {
                var type = json[0], isDictionary = type === "dictionary";
                if (json.length == 1 && /^#/.test(type)) {
                  return _data.dictionary[type];
                }
                type = Base.exports[type];
                res = [];
                for (var i2 = type ? 1 : 0, l2 = json.length; i2 < l2; i2++) {
                  res.push(Base.deserialize(json[i2], create, _data, isDictionary, hasDictionary));
                }
                if (type) {
                  var args = res;
                  if (create) {
                    res = create(type, args, isFirst || _isRoot);
                  } else {
                    res = new type(args);
                  }
                }
              } else if (Base.isPlainObject(json)) {
                res = {};
                if (_setDictionary)
                  _data.dictionary = res;
                for (var key in json)
                  res[key] = Base.deserialize(json[key], create, _data);
              }
              return hasDictionary ? res[1] : res;
            },
            exportJSON: function(obj, options) {
              var json = Base.serialize(obj, options);
              return options && options.asString == false ? json : JSON.stringify(json);
            },
            importJSON: function(json, target) {
              return Base.deserialize(typeof json === "string" ? JSON.parse(json) : json, function(ctor, args, isRoot) {
                var useTarget = isRoot && target && target.constructor === ctor, obj = useTarget ? target : Base.create(ctor.prototype);
                if (args.length === 1 && obj instanceof Item && (useTarget || !(obj instanceof Layer))) {
                  var arg = args[0];
                  if (Base.isPlainObject(arg)) {
                    arg.insert = false;
                    if (useTarget) {
                      args = args.concat([{ insert: true }]);
                    }
                  }
                }
                (useTarget ? obj.set : ctor).apply(obj, args);
                if (useTarget)
                  target = null;
                return obj;
              });
            },
            push: function(list, items) {
              var itemsLength = items.length;
              if (itemsLength < 4096) {
                list.push.apply(list, items);
              } else {
                var startLength = list.length;
                list.length += itemsLength;
                for (var i2 = 0; i2 < itemsLength; i2++) {
                  list[startLength + i2] = items[i2];
                }
              }
              return list;
            },
            splice: function(list, items, index, remove) {
              var amount = items && items.length, append = index === undefined2;
              index = append ? list.length : index;
              if (index > list.length)
                index = list.length;
              for (var i2 = 0; i2 < amount; i2++)
                items[i2]._index = index + i2;
              if (append) {
                Base.push(list, items);
                return [];
              } else {
                var args = [index, remove];
                if (items)
                  Base.push(args, items);
                var removed = list.splice.apply(list, args);
                for (var i2 = 0, l2 = removed.length; i2 < l2; i2++)
                  removed[i2]._index = undefined2;
                for (var i2 = index + amount, l2 = list.length; i2 < l2; i2++)
                  list[i2]._index = i2;
                return removed;
              }
            },
            capitalize: function(str) {
              return str.replace(/\b[a-z]/g, function(match) {
                return match.toUpperCase();
              });
            },
            camelize: function(str) {
              return str.replace(/-(.)/g, function(match, chr) {
                return chr.toUpperCase();
              });
            },
            hyphenate: function(str) {
              return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            }
          }
        });
        var Emitter = {
          on: function(type, func) {
            if (typeof type !== "string") {
              Base.each(type, function(value, key) {
                this.on(key, value);
              }, this);
            } else {
              var types = this._eventTypes, entry = types && types[type], handlers = this._callbacks = this._callbacks || {};
              handlers = handlers[type] = handlers[type] || [];
              if (handlers.indexOf(func) === -1) {
                handlers.push(func);
                if (entry && entry.install && handlers.length === 1)
                  entry.install.call(this, type);
              }
            }
            return this;
          },
          off: function(type, func) {
            if (typeof type !== "string") {
              Base.each(type, function(value, key) {
                this.off(key, value);
              }, this);
              return;
            }
            var types = this._eventTypes, entry = types && types[type], handlers = this._callbacks && this._callbacks[type], index;
            if (handlers) {
              if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
                if (entry && entry.uninstall)
                  entry.uninstall.call(this, type);
                delete this._callbacks[type];
              } else if (index !== -1) {
                handlers.splice(index, 1);
              }
            }
            return this;
          },
          once: function(type, func) {
            return this.on(type, function handler() {
              func.apply(this, arguments);
              this.off(type, handler);
            });
          },
          emit: function(type, event) {
            var handlers = this._callbacks && this._callbacks[type];
            if (!handlers)
              return false;
            var args = Base.slice(arguments, 1), setTarget = event && event.target && !event.currentTarget;
            handlers = handlers.slice();
            if (setTarget)
              event.currentTarget = this;
            for (var i2 = 0, l2 = handlers.length; i2 < l2; i2++) {
              if (handlers[i2].apply(this, args) == false) {
                if (event && event.stop)
                  event.stop();
                break;
              }
            }
            if (setTarget)
              delete event.currentTarget;
            return true;
          },
          responds: function(type) {
            return !!(this._callbacks && this._callbacks[type]);
          },
          attach: "#on",
          detach: "#off",
          fire: "#emit",
          _installEvents: function(install) {
            var types = this._eventTypes, handlers = this._callbacks, key = install ? "install" : "uninstall";
            if (types) {
              for (var type in handlers) {
                if (handlers[type].length > 0) {
                  var entry = types[type], func = entry && entry[key];
                  if (func)
                    func.call(this, type);
                }
              }
            }
          },
          statics: {
            inject: function inject(src) {
              var events = src._events;
              if (events) {
                var types = {};
                Base.each(events, function(entry, key) {
                  var isString = typeof entry === "string", name = isString ? entry : key, part = Base.capitalize(name), type = name.substring(2).toLowerCase();
                  types[type] = isString ? {} : entry;
                  name = "_" + name;
                  src["get" + part] = function() {
                    return this[name];
                  };
                  src["set" + part] = function(func) {
                    var prev = this[name];
                    if (prev)
                      this.off(type, prev);
                    if (func)
                      this.on(type, func);
                    this[name] = func;
                  };
                });
                src._eventTypes = types;
              }
              return inject.base.apply(this, arguments);
            }
          }
        };
        var PaperScope = Base.extend({
          _class: "PaperScope",
          initialize: function PaperScope2() {
            paper2 = this;
            this.settings = new Base({
              applyMatrix: true,
              insertItems: true,
              handleSize: 4,
              hitTolerance: 0
            });
            this.project = null;
            this.projects = [];
            this.tools = [];
            this._id = PaperScope2._id++;
            PaperScope2._scopes[this._id] = this;
            var proto = PaperScope2.prototype;
            if (!this.support) {
              var ctx = CanvasProvider.getContext(1, 1) || {};
              proto.support = {
                nativeDash: "setLineDash" in ctx || "mozDash" in ctx,
                nativeBlendModes: BlendMode.nativeModes
              };
              CanvasProvider.release(ctx);
            }
            if (!this.agent) {
              var user = self2.navigator.userAgent.toLowerCase(), os2 = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user) || [])[0], platform = os2 === "darwin" ? "mac" : os2, agent = proto.agent = proto.browser = { platform };
              if (platform)
                agent[platform] = true;
              user.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, function(match, n2, v1, v2, rv) {
                if (!agent.chrome) {
                  var v3 = n2 === "opera" ? v2 : /^(node|trident)$/.test(n2) ? rv : v1;
                  agent.version = v3;
                  agent.versionNumber = parseFloat(v3);
                  n2 = { trident: "msie", jsdom: "node" }[n2] || n2;
                  agent.name = n2;
                  agent[n2] = true;
                }
              });
              if (agent.chrome)
                delete agent.webkit;
              if (agent.atom)
                delete agent.chrome;
            }
          },
          version: "0.12.15",
          getView: function() {
            var project = this.project;
            return project && project._view;
          },
          getPaper: function() {
            return this;
          },
          execute: function(code, options) {
            var exports2 = paper2.PaperScript.execute(code, this, options);
            View.updateFocus();
            return exports2;
          },
          install: function(scope) {
            var that = this;
            Base.each(["project", "view", "tool"], function(key2) {
              Base.define(scope, key2, {
                configurable: true,
                get: function() {
                  return that[key2];
                }
              });
            });
            for (var key in this)
              if (!/^_/.test(key) && this[key])
                scope[key] = this[key];
          },
          setup: function(element) {
            paper2 = this;
            this.project = new Project(element);
            return this;
          },
          createCanvas: function(width, height) {
            return CanvasProvider.getCanvas(width, height);
          },
          activate: function() {
            paper2 = this;
          },
          clear: function() {
            var projects = this.projects, tools = this.tools;
            for (var i2 = projects.length - 1; i2 >= 0; i2--)
              projects[i2].remove();
            for (var i2 = tools.length - 1; i2 >= 0; i2--)
              tools[i2].remove();
          },
          remove: function() {
            this.clear();
            delete PaperScope._scopes[this._id];
          },
          statics: new function() {
            function handleAttribute(name) {
              name += "Attribute";
              return function(el2, attr) {
                return el2[name](attr) || el2[name]("data-paper-" + attr);
              };
            }
            return {
              _scopes: {},
              _id: 0,
              get: function(id2) {
                return this._scopes[id2] || null;
              },
              getAttribute: handleAttribute("get"),
              hasAttribute: handleAttribute("has")
            };
          }()
        });
        var PaperScopeItem = Base.extend(Emitter, {
          initialize: function(activate) {
            this._scope = paper2;
            this._index = this._scope[this._list].push(this) - 1;
            if (activate || !this._scope[this._reference])
              this.activate();
          },
          activate: function() {
            if (!this._scope)
              return false;
            var prev = this._scope[this._reference];
            if (prev && prev !== this)
              prev.emit("deactivate");
            this._scope[this._reference] = this;
            this.emit("activate", prev);
            return true;
          },
          isActive: function() {
            return this._scope[this._reference] === this;
          },
          remove: function() {
            if (this._index == null)
              return false;
            Base.splice(this._scope[this._list], null, this._index, 1);
            if (this._scope[this._reference] == this)
              this._scope[this._reference] = null;
            this._scope = null;
            return true;
          },
          getView: function() {
            return this._scope.getView();
          }
        });
        var CollisionDetection = {
          findItemBoundsCollisions: function(items1, items2, tolerance) {
            function getBounds(items) {
              var bounds = new Array(items.length);
              for (var i2 = 0; i2 < items.length; i2++) {
                var rect = items[i2].getBounds();
                bounds[i2] = [rect.left, rect.top, rect.right, rect.bottom];
              }
              return bounds;
            }
            var bounds1 = getBounds(items1), bounds2 = !items2 || items2 === items1 ? bounds1 : getBounds(items2);
            return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
          },
          findCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {
            function getBounds(curves) {
              var min = Math.min, max = Math.max, bounds = new Array(curves.length);
              for (var i3 = 0; i3 < curves.length; i3++) {
                var v2 = curves[i3];
                bounds[i3] = [
                  min(v2[0], v2[2], v2[4], v2[6]),
                  min(v2[1], v2[3], v2[5], v2[7]),
                  max(v2[0], v2[2], v2[4], v2[6]),
                  max(v2[1], v2[3], v2[5], v2[7])
                ];
              }
              return bounds;
            }
            var bounds1 = getBounds(curves1), bounds2 = !curves2 || curves2 === curves1 ? bounds1 : getBounds(curves2);
            if (bothAxis) {
              var hor = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, false, true), ver = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, true, true), list = [];
              for (var i2 = 0, l2 = hor.length; i2 < l2; i2++) {
                list[i2] = { hor: hor[i2], ver: ver[i2] };
              }
              return list;
            }
            return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
          },
          findBoundsCollisions: function(boundsA, boundsB, tolerance, sweepVertical, onlySweepAxisCollisions) {
            var self3 = !boundsB || boundsA === boundsB, allBounds = self3 ? boundsA : boundsA.concat(boundsB), lengthA = boundsA.length, lengthAll = allBounds.length;
            function binarySearch(indices, coord, value) {
              var lo2 = 0, hi2 = indices.length;
              while (lo2 < hi2) {
                var mid = hi2 + lo2 >>> 1;
                if (allBounds[indices[mid]][coord] < value) {
                  lo2 = mid + 1;
                } else {
                  hi2 = mid;
                }
              }
              return lo2 - 1;
            }
            var pri0 = sweepVertical ? 1 : 0, pri1 = pri0 + 2, sec0 = sweepVertical ? 0 : 1, sec1 = sec0 + 2;
            var allIndicesByPri0 = new Array(lengthAll);
            for (var i2 = 0; i2 < lengthAll; i2++) {
              allIndicesByPri0[i2] = i2;
            }
            allIndicesByPri0.sort(function(i1, i22) {
              return allBounds[i1][pri0] - allBounds[i22][pri0];
            });
            var activeIndicesByPri1 = [], allCollisions = new Array(lengthA);
            for (var i2 = 0; i2 < lengthAll; i2++) {
              var curIndex = allIndicesByPri0[i2], curBounds = allBounds[curIndex], origIndex = self3 ? curIndex : curIndex - lengthA, isCurrentA = curIndex < lengthA, isCurrentB = self3 || !isCurrentA, curCollisions = isCurrentA ? [] : null;
              if (activeIndicesByPri1.length) {
                var pruneCount = binarySearch(activeIndicesByPri1, pri1, curBounds[pri0] - tolerance) + 1;
                activeIndicesByPri1.splice(0, pruneCount);
                if (self3 && onlySweepAxisCollisions) {
                  curCollisions = curCollisions.concat(activeIndicesByPri1);
                  for (var j2 = 0; j2 < activeIndicesByPri1.length; j2++) {
                    var activeIndex = activeIndicesByPri1[j2];
                    allCollisions[activeIndex].push(origIndex);
                  }
                } else {
                  var curSec1 = curBounds[sec1], curSec0 = curBounds[sec0];
                  for (var j2 = 0; j2 < activeIndicesByPri1.length; j2++) {
                    var activeIndex = activeIndicesByPri1[j2], activeBounds = allBounds[activeIndex], isActiveA = activeIndex < lengthA, isActiveB = self3 || activeIndex >= lengthA;
                    if (onlySweepAxisCollisions || (isCurrentA && isActiveB || isCurrentB && isActiveA) && (curSec1 >= activeBounds[sec0] - tolerance && curSec0 <= activeBounds[sec1] + tolerance)) {
                      if (isCurrentA && isActiveB) {
                        curCollisions.push(self3 ? activeIndex : activeIndex - lengthA);
                      }
                      if (isCurrentB && isActiveA) {
                        allCollisions[activeIndex].push(origIndex);
                      }
                    }
                  }
                }
              }
              if (isCurrentA) {
                if (boundsA === boundsB) {
                  curCollisions.push(curIndex);
                }
                allCollisions[curIndex] = curCollisions;
              }
              if (activeIndicesByPri1.length) {
                var curPri1 = curBounds[pri1], index = binarySearch(activeIndicesByPri1, pri1, curPri1);
                activeIndicesByPri1.splice(index + 1, 0, curIndex);
              } else {
                activeIndicesByPri1.push(curIndex);
              }
            }
            for (var i2 = 0; i2 < allCollisions.length; i2++) {
              var collisions = allCollisions[i2];
              if (collisions) {
                collisions.sort(function(i1, i22) {
                  return i1 - i22;
                });
              }
            }
            return allCollisions;
          }
        };
        var Formatter = Base.extend({
          initialize: function(precision) {
            this.precision = Base.pick(precision, 5);
            this.multiplier = Math.pow(10, this.precision);
          },
          number: function(val) {
            return this.precision < 16 ? Math.round(val * this.multiplier) / this.multiplier : val;
          },
          pair: function(val1, val2, separator) {
            return this.number(val1) + (separator || ",") + this.number(val2);
          },
          point: function(val, separator) {
            return this.number(val.x) + (separator || ",") + this.number(val.y);
          },
          size: function(val, separator) {
            return this.number(val.width) + (separator || ",") + this.number(val.height);
          },
          rectangle: function(val, separator) {
            return this.point(val, separator) + (separator || ",") + this.size(val, separator);
          }
        });
        Formatter.instance = new Formatter();
        var Numerical = new function() {
          var abscissas = [
            [0.5773502691896257],
            [0, 0.7745966692414834],
            [0.33998104358485626, 0.8611363115940526],
            [0, 0.5384693101056831, 0.906179845938664],
            [0.2386191860831969, 0.6612093864662645, 0.932469514203152],
            [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585],
            [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363],
            [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261],
            [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717],
            [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057],
            [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192],
            [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881],
            [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123],
            [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854],
            [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499]
          ];
          var weights = [
            [1],
            [0.8888888888888888, 0.5555555555555556],
            [0.6521451548625461, 0.34785484513745385],
            [0.5688888888888889, 0.47862867049936647, 0.23692688505618908],
            [0.46791393457269104, 0.3607615730481386, 0.17132449237917036],
            [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697],
            [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626],
            [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441],
            [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814],
            [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366],
            [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183],
            [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588],
            [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186],
            [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727],
            [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096]
          ];
          var abs = Math.abs, sqrt = Math.sqrt, pow = Math.pow, log2 = Math.log2 || function(x2) {
            return Math.log(x2) * Math.LOG2E;
          }, EPSILON = 1e-12, MACHINE_EPSILON = 112e-18;
          function clamp(value, min, max) {
            return value < min ? min : value > max ? max : value;
          }
          function getDiscriminant(a2, b2, c2) {
            function split(v2) {
              var x2 = v2 * 134217729, y2 = v2 - x2, hi2 = y2 + x2, lo2 = v2 - hi2;
              return [hi2, lo2];
            }
            var D2 = b2 * b2 - a2 * c2, E2 = b2 * b2 + a2 * c2;
            if (abs(D2) * 3 < E2) {
              var ad2 = split(a2), bd2 = split(b2), cd2 = split(c2), p = b2 * b2, dp2 = bd2[0] * bd2[0] - p + 2 * bd2[0] * bd2[1] + bd2[1] * bd2[1], q2 = a2 * c2, dq = ad2[0] * cd2[0] - q2 + ad2[0] * cd2[1] + ad2[1] * cd2[0] + ad2[1] * cd2[1];
              D2 = p - q2 + (dp2 - dq);
            }
            return D2;
          }
          function getNormalizationFactor() {
            var norm = Math.max.apply(Math, arguments);
            return norm && (norm < 1e-8 || norm > 1e8) ? pow(2, -Math.round(log2(norm))) : 0;
          }
          return {
            EPSILON,
            MACHINE_EPSILON,
            CURVETIME_EPSILON: 1e-8,
            GEOMETRIC_EPSILON: 1e-7,
            TRIGONOMETRIC_EPSILON: 1e-8,
            KAPPA: 4 * (sqrt(2) - 1) / 3,
            isZero: function(val) {
              return val >= -EPSILON && val <= EPSILON;
            },
            isMachineZero: function(val) {
              return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
            },
            clamp,
            integrate: function(f, a2, b2, n2) {
              var x2 = abscissas[n2 - 2], w2 = weights[n2 - 2], A2 = (b2 - a2) * 0.5, B2 = A2 + a2, i2 = 0, m2 = n2 + 1 >> 1, sum = n2 & 1 ? w2[i2++] * f(B2) : 0;
              while (i2 < m2) {
                var Ax = A2 * x2[i2];
                sum += w2[i2++] * (f(B2 + Ax) + f(B2 - Ax));
              }
              return A2 * sum;
            },
            findRoot: function(f, df2, x2, a2, b2, n2, tolerance) {
              for (var i2 = 0; i2 < n2; i2++) {
                var fx = f(x2), dx = fx / df2(x2), nx = x2 - dx;
                if (abs(dx) < tolerance) {
                  x2 = nx;
                  break;
                }
                if (fx > 0) {
                  b2 = x2;
                  x2 = nx <= a2 ? (a2 + b2) * 0.5 : nx;
                } else {
                  a2 = x2;
                  x2 = nx >= b2 ? (a2 + b2) * 0.5 : nx;
                }
              }
              return clamp(x2, a2, b2);
            },
            solveQuadratic: function(a2, b2, c2, roots, min, max) {
              var x1, x2 = Infinity;
              if (abs(a2) < EPSILON) {
                if (abs(b2) < EPSILON)
                  return abs(c2) < EPSILON ? -1 : 0;
                x1 = -c2 / b2;
              } else {
                b2 *= -0.5;
                var D2 = getDiscriminant(a2, b2, c2);
                if (D2 && abs(D2) < MACHINE_EPSILON) {
                  var f = getNormalizationFactor(abs(a2), abs(b2), abs(c2));
                  if (f) {
                    a2 *= f;
                    b2 *= f;
                    c2 *= f;
                    D2 = getDiscriminant(a2, b2, c2);
                  }
                }
                if (D2 >= -MACHINE_EPSILON) {
                  var Q2 = D2 < 0 ? 0 : sqrt(D2), R2 = b2 + (b2 < 0 ? -Q2 : Q2);
                  if (R2 === 0) {
                    x1 = c2 / a2;
                    x2 = -x1;
                  } else {
                    x1 = R2 / a2;
                    x2 = c2 / R2;
                  }
                }
              }
              var count = 0, boundless = min == null, minB = min - EPSILON, maxB = max + EPSILON;
              if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
                roots[count++] = boundless ? x1 : clamp(x1, min, max);
              if (x2 !== x1 && isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
                roots[count++] = boundless ? x2 : clamp(x2, min, max);
              return count;
            },
            solveCubic: function(a2, b2, c2, d, roots, min, max) {
              var f = getNormalizationFactor(abs(a2), abs(b2), abs(c2), abs(d)), x2, b1, c22, qd2, q2;
              if (f) {
                a2 *= f;
                b2 *= f;
                c2 *= f;
                d *= f;
              }
              function evaluate(x02) {
                x2 = x02;
                var tmp = a2 * x2;
                b1 = tmp + b2;
                c22 = b1 * x2 + c2;
                qd2 = (tmp + b1) * x2 + c22;
                q2 = c22 * x2 + d;
              }
              if (abs(a2) < EPSILON) {
                a2 = b2;
                b1 = c2;
                c22 = d;
                x2 = Infinity;
              } else if (abs(d) < EPSILON) {
                b1 = b2;
                c22 = c2;
                x2 = 0;
              } else {
                evaluate(-(b2 / a2) / 3);
                var t2 = q2 / a2, r2 = pow(abs(t2), 1 / 3), s2 = t2 < 0 ? -1 : 1, td2 = -qd2 / a2, rd2 = td2 > 0 ? 1.324717957244746 * Math.max(r2, sqrt(td2)) : r2, x0 = x2 - s2 * rd2;
                if (x0 !== x2) {
                  do {
                    evaluate(x0);
                    x0 = qd2 === 0 ? x2 : x2 - q2 / qd2 / (1 + MACHINE_EPSILON);
                  } while (s2 * x0 > s2 * x2);
                  if (abs(a2) * x2 * x2 > abs(d / x2)) {
                    c22 = -d / x2;
                    b1 = (c22 - c2) / x2;
                  }
                }
              }
              var count = Numerical.solveQuadratic(a2, b1, c22, roots, min, max), boundless = min == null;
              if (isFinite(x2) && (count === 0 || count > 0 && x2 !== roots[0] && x2 !== roots[1]) && (boundless || x2 > min - EPSILON && x2 < max + EPSILON))
                roots[count++] = boundless ? x2 : clamp(x2, min, max);
              return count;
            }
          };
        }();
        var UID = {
          _id: 1,
          _pools: {},
          get: function(name) {
            if (name) {
              var pool = this._pools[name];
              if (!pool)
                pool = this._pools[name] = { _id: 1 };
              return pool._id++;
            } else {
              return this._id++;
            }
          }
        };
        var Point = Base.extend({
          _class: "Point",
          _readIndex: true,
          initialize: function Point2(arg0, arg1) {
            var type = typeof arg0, reading = this.__read, read = 0;
            if (type === "number") {
              var hasY = typeof arg1 === "number";
              this._set(arg0, hasY ? arg1 : arg0);
              if (reading)
                read = hasY ? 2 : 1;
            } else if (type === "undefined" || arg0 === null) {
              this._set(0, 0);
              if (reading)
                read = arg0 === null ? 1 : 0;
            } else {
              var obj = type === "string" ? arg0.split(/[\s,]+/) || [] : arg0;
              read = 1;
              if (Array.isArray(obj)) {
                this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
              } else if ("x" in obj) {
                this._set(obj.x || 0, obj.y || 0);
              } else if ("width" in obj) {
                this._set(obj.width || 0, obj.height || 0);
              } else if ("angle" in obj) {
                this._set(obj.length || 0, 0);
                this.setAngle(obj.angle || 0);
              } else {
                this._set(0, 0);
                read = 0;
              }
            }
            if (reading)
              this.__read = read;
            return this;
          },
          set: "#initialize",
          _set: function(x2, y2) {
            this.x = x2;
            this.y = y2;
            return this;
          },
          equals: function(point) {
            return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
          },
          clone: function() {
            return new Point(this.x, this.y);
          },
          toString: function() {
            var f = Formatter.instance;
            return "{ x: " + f.number(this.x) + ", y: " + f.number(this.y) + " }";
          },
          _serialize: function(options) {
            var f = options.formatter;
            return [f.number(this.x), f.number(this.y)];
          },
          getLength: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          setLength: function(length) {
            if (this.isZero()) {
              var angle = this._angle || 0;
              this._set(Math.cos(angle) * length, Math.sin(angle) * length);
            } else {
              var scale = length / this.getLength();
              if (Numerical.isZero(scale))
                this.getAngle();
              this._set(this.x * scale, this.y * scale);
            }
          },
          getAngle: function() {
            return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
          },
          setAngle: function(angle) {
            this.setAngleInRadians.call(this, angle * Math.PI / 180);
          },
          getAngleInDegrees: "#getAngle",
          setAngleInDegrees: "#setAngle",
          getAngleInRadians: function() {
            if (!arguments.length) {
              return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
            } else {
              var point = Point.read(arguments), div = this.getLength() * point.getLength();
              if (Numerical.isZero(div)) {
                return NaN;
              } else {
                var a2 = this.dot(point) / div;
                return Math.acos(a2 < -1 ? -1 : a2 > 1 ? 1 : a2);
              }
            }
          },
          setAngleInRadians: function(angle) {
            this._angle = angle;
            if (!this.isZero()) {
              var length = this.getLength();
              this._set(Math.cos(angle) * length, Math.sin(angle) * length);
            }
          },
          getQuadrant: function() {
            return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
          }
        }, {
          beans: false,
          getDirectedAngle: function() {
            var point = Point.read(arguments);
            return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
          },
          getDistance: function() {
            var args = arguments, point = Point.read(args), x2 = point.x - this.x, y2 = point.y - this.y, d = x2 * x2 + y2 * y2, squared = Base.read(args);
            return squared ? d : Math.sqrt(d);
          },
          normalize: function(length) {
            if (length === undefined2)
              length = 1;
            var current = this.getLength(), scale = current !== 0 ? length / current : 0, point = new Point(this.x * scale, this.y * scale);
            if (scale >= 0)
              point._angle = this._angle;
            return point;
          },
          rotate: function(angle, center) {
            if (angle === 0)
              return this.clone();
            angle = angle * Math.PI / 180;
            var point = center ? this.subtract(center) : this, sin = Math.sin(angle), cos = Math.cos(angle);
            point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);
            return center ? point.add(center) : point;
          },
          transform: function(matrix) {
            return matrix ? matrix._transformPoint(this) : this;
          },
          add: function() {
            var point = Point.read(arguments);
            return new Point(this.x + point.x, this.y + point.y);
          },
          subtract: function() {
            var point = Point.read(arguments);
            return new Point(this.x - point.x, this.y - point.y);
          },
          multiply: function() {
            var point = Point.read(arguments);
            return new Point(this.x * point.x, this.y * point.y);
          },
          divide: function() {
            var point = Point.read(arguments);
            return new Point(this.x / point.x, this.y / point.y);
          },
          modulo: function() {
            var point = Point.read(arguments);
            return new Point(this.x % point.x, this.y % point.y);
          },
          negate: function() {
            return new Point(-this.x, -this.y);
          },
          isInside: function() {
            return Rectangle.read(arguments).contains(this);
          },
          isClose: function() {
            var args = arguments, point = Point.read(args), tolerance = Base.read(args);
            return this.getDistance(point) <= tolerance;
          },
          isCollinear: function() {
            var point = Point.read(arguments);
            return Point.isCollinear(this.x, this.y, point.x, point.y);
          },
          isColinear: "#isCollinear",
          isOrthogonal: function() {
            var point = Point.read(arguments);
            return Point.isOrthogonal(this.x, this.y, point.x, point.y);
          },
          isZero: function() {
            var isZero = Numerical.isZero;
            return isZero(this.x) && isZero(this.y);
          },
          isNaN: function() {
            return isNaN(this.x) || isNaN(this.y);
          },
          isInQuadrant: function(q2) {
            return this.x * (q2 > 1 && q2 < 4 ? -1 : 1) >= 0 && this.y * (q2 > 2 ? -1 : 1) >= 0;
          },
          dot: function() {
            var point = Point.read(arguments);
            return this.x * point.x + this.y * point.y;
          },
          cross: function() {
            var point = Point.read(arguments);
            return this.x * point.y - this.y * point.x;
          },
          project: function() {
            var point = Point.read(arguments), scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
            return new Point(point.x * scale, point.y * scale);
          },
          statics: {
            min: function() {
              var args = arguments, point1 = Point.read(args), point2 = Point.read(args);
              return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
            },
            max: function() {
              var args = arguments, point1 = Point.read(args), point2 = Point.read(args);
              return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
            },
            random: function() {
              return new Point(Math.random(), Math.random());
            },
            isCollinear: function(x1, y1, x2, y2) {
              return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
            },
            isOrthogonal: function(x1, y1, x2, y2) {
              return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
            }
          }
        }, Base.each(["round", "ceil", "floor", "abs"], function(key) {
          var op2 = Math[key];
          this[key] = function() {
            return new Point(op2(this.x), op2(this.y));
          };
        }, {}));
        var LinkedPoint = Point.extend({
          initialize: function Point2(x2, y2, owner, setter) {
            this._x = x2;
            this._y = y2;
            this._owner = owner;
            this._setter = setter;
          },
          _set: function(x2, y2, _dontNotify) {
            this._x = x2;
            this._y = y2;
            if (!_dontNotify)
              this._owner[this._setter](this);
            return this;
          },
          getX: function() {
            return this._x;
          },
          setX: function(x2) {
            this._x = x2;
            this._owner[this._setter](this);
          },
          getY: function() {
            return this._y;
          },
          setY: function(y2) {
            this._y = y2;
            this._owner[this._setter](this);
          },
          isSelected: function() {
            return !!(this._owner._selection & this._getSelection());
          },
          setSelected: function(selected) {
            this._owner._changeSelection(this._getSelection(), selected);
          },
          _getSelection: function() {
            return this._setter === "setPosition" ? 4 : 0;
          }
        });
        var Size = Base.extend({
          _class: "Size",
          _readIndex: true,
          initialize: function Size2(arg0, arg1) {
            var type = typeof arg0, reading = this.__read, read = 0;
            if (type === "number") {
              var hasHeight = typeof arg1 === "number";
              this._set(arg0, hasHeight ? arg1 : arg0);
              if (reading)
                read = hasHeight ? 2 : 1;
            } else if (type === "undefined" || arg0 === null) {
              this._set(0, 0);
              if (reading)
                read = arg0 === null ? 1 : 0;
            } else {
              var obj = type === "string" ? arg0.split(/[\s,]+/) || [] : arg0;
              read = 1;
              if (Array.isArray(obj)) {
                this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
              } else if ("width" in obj) {
                this._set(obj.width || 0, obj.height || 0);
              } else if ("x" in obj) {
                this._set(obj.x || 0, obj.y || 0);
              } else {
                this._set(0, 0);
                read = 0;
              }
            }
            if (reading)
              this.__read = read;
            return this;
          },
          set: "#initialize",
          _set: function(width, height) {
            this.width = width;
            this.height = height;
            return this;
          },
          equals: function(size) {
            return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
          },
          clone: function() {
            return new Size(this.width, this.height);
          },
          toString: function() {
            var f = Formatter.instance;
            return "{ width: " + f.number(this.width) + ", height: " + f.number(this.height) + " }";
          },
          _serialize: function(options) {
            var f = options.formatter;
            return [
              f.number(this.width),
              f.number(this.height)
            ];
          },
          add: function() {
            var size = Size.read(arguments);
            return new Size(this.width + size.width, this.height + size.height);
          },
          subtract: function() {
            var size = Size.read(arguments);
            return new Size(this.width - size.width, this.height - size.height);
          },
          multiply: function() {
            var size = Size.read(arguments);
            return new Size(this.width * size.width, this.height * size.height);
          },
          divide: function() {
            var size = Size.read(arguments);
            return new Size(this.width / size.width, this.height / size.height);
          },
          modulo: function() {
            var size = Size.read(arguments);
            return new Size(this.width % size.width, this.height % size.height);
          },
          negate: function() {
            return new Size(-this.width, -this.height);
          },
          isZero: function() {
            var isZero = Numerical.isZero;
            return isZero(this.width) && isZero(this.height);
          },
          isNaN: function() {
            return isNaN(this.width) || isNaN(this.height);
          },
          statics: {
            min: function(size1, size2) {
              return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
            },
            max: function(size1, size2) {
              return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
            },
            random: function() {
              return new Size(Math.random(), Math.random());
            }
          }
        }, Base.each(["round", "ceil", "floor", "abs"], function(key) {
          var op2 = Math[key];
          this[key] = function() {
            return new Size(op2(this.width), op2(this.height));
          };
        }, {}));
        var LinkedSize = Size.extend({
          initialize: function Size2(width, height, owner, setter) {
            this._width = width;
            this._height = height;
            this._owner = owner;
            this._setter = setter;
          },
          _set: function(width, height, _dontNotify) {
            this._width = width;
            this._height = height;
            if (!_dontNotify)
              this._owner[this._setter](this);
            return this;
          },
          getWidth: function() {
            return this._width;
          },
          setWidth: function(width) {
            this._width = width;
            this._owner[this._setter](this);
          },
          getHeight: function() {
            return this._height;
          },
          setHeight: function(height) {
            this._height = height;
            this._owner[this._setter](this);
          }
        });
        var Rectangle = Base.extend({
          _class: "Rectangle",
          _readIndex: true,
          beans: true,
          initialize: function Rectangle2(arg0, arg1, arg2, arg3) {
            var args = arguments, type = typeof arg0, read;
            if (type === "number") {
              this._set(arg0, arg1, arg2, arg3);
              read = 4;
            } else if (type === "undefined" || arg0 === null) {
              this._set(0, 0, 0, 0);
              read = arg0 === null ? 1 : 0;
            } else if (args.length === 1) {
              if (Array.isArray(arg0)) {
                this._set.apply(this, arg0);
                read = 1;
              } else if (arg0.x !== undefined2 || arg0.width !== undefined2) {
                this._set(arg0.x || 0, arg0.y || 0, arg0.width || 0, arg0.height || 0);
                read = 1;
              } else if (arg0.from === undefined2 && arg0.to === undefined2) {
                this._set(0, 0, 0, 0);
                if (Base.readSupported(args, this)) {
                  read = 1;
                }
              }
            }
            if (read === undefined2) {
              var frm = Point.readNamed(args, "from"), next = Base.peek(args), x2 = frm.x, y2 = frm.y, width, height;
              if (next && next.x !== undefined2 || Base.hasNamed(args, "to")) {
                var to2 = Point.readNamed(args, "to");
                width = to2.x - x2;
                height = to2.y - y2;
                if (width < 0) {
                  x2 = to2.x;
                  width = -width;
                }
                if (height < 0) {
                  y2 = to2.y;
                  height = -height;
                }
              } else {
                var size = Size.read(args);
                width = size.width;
                height = size.height;
              }
              this._set(x2, y2, width, height);
              read = args.__index;
            }
            var filtered = args.__filtered;
            if (filtered)
              this.__filtered = filtered;
            if (this.__read)
              this.__read = read;
            return this;
          },
          set: "#initialize",
          _set: function(x2, y2, width, height) {
            this.x = x2;
            this.y = y2;
            this.width = width;
            this.height = height;
            return this;
          },
          clone: function() {
            return new Rectangle(this.x, this.y, this.width, this.height);
          },
          equals: function(rect) {
            var rt2 = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
            return rt2 === this || rt2 && this.x === rt2.x && this.y === rt2.y && this.width === rt2.width && this.height === rt2.height || false;
          },
          toString: function() {
            var f = Formatter.instance;
            return "{ x: " + f.number(this.x) + ", y: " + f.number(this.y) + ", width: " + f.number(this.width) + ", height: " + f.number(this.height) + " }";
          },
          _serialize: function(options) {
            var f = options.formatter;
            return [
              f.number(this.x),
              f.number(this.y),
              f.number(this.width),
              f.number(this.height)
            ];
          },
          getPoint: function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            return new ctor(this.x, this.y, this, "setPoint");
          },
          setPoint: function() {
            var point = Point.read(arguments);
            this.x = point.x;
            this.y = point.y;
          },
          getSize: function(_dontLink) {
            var ctor = _dontLink ? Size : LinkedSize;
            return new ctor(this.width, this.height, this, "setSize");
          },
          _fw: 1,
          _fh: 1,
          setSize: function() {
            var size = Size.read(arguments), sx = this._sx, sy = this._sy, w2 = size.width, h2 = size.height;
            if (sx) {
              this.x += (this.width - w2) * sx;
            }
            if (sy) {
              this.y += (this.height - h2) * sy;
            }
            this.width = w2;
            this.height = h2;
            this._fw = this._fh = 1;
          },
          getLeft: function() {
            return this.x;
          },
          setLeft: function(left) {
            if (!this._fw) {
              var amount = left - this.x;
              this.width -= this._sx === 0.5 ? amount * 2 : amount;
            }
            this.x = left;
            this._sx = this._fw = 0;
          },
          getTop: function() {
            return this.y;
          },
          setTop: function(top) {
            if (!this._fh) {
              var amount = top - this.y;
              this.height -= this._sy === 0.5 ? amount * 2 : amount;
            }
            this.y = top;
            this._sy = this._fh = 0;
          },
          getRight: function() {
            return this.x + this.width;
          },
          setRight: function(right) {
            if (!this._fw) {
              var amount = right - this.x;
              this.width = this._sx === 0.5 ? amount * 2 : amount;
            }
            this.x = right - this.width;
            this._sx = 1;
            this._fw = 0;
          },
          getBottom: function() {
            return this.y + this.height;
          },
          setBottom: function(bottom) {
            if (!this._fh) {
              var amount = bottom - this.y;
              this.height = this._sy === 0.5 ? amount * 2 : amount;
            }
            this.y = bottom - this.height;
            this._sy = 1;
            this._fh = 0;
          },
          getCenterX: function() {
            return this.x + this.width / 2;
          },
          setCenterX: function(x2) {
            if (this._fw || this._sx === 0.5) {
              this.x = x2 - this.width / 2;
            } else {
              if (this._sx) {
                this.x += (x2 - this.x) * 2 * this._sx;
              }
              this.width = (x2 - this.x) * 2;
            }
            this._sx = 0.5;
            this._fw = 0;
          },
          getCenterY: function() {
            return this.y + this.height / 2;
          },
          setCenterY: function(y2) {
            if (this._fh || this._sy === 0.5) {
              this.y = y2 - this.height / 2;
            } else {
              if (this._sy) {
                this.y += (y2 - this.y) * 2 * this._sy;
              }
              this.height = (y2 - this.y) * 2;
            }
            this._sy = 0.5;
            this._fh = 0;
          },
          getCenter: function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            return new ctor(this.getCenterX(), this.getCenterY(), this, "setCenter");
          },
          setCenter: function() {
            var point = Point.read(arguments);
            this.setCenterX(point.x);
            this.setCenterY(point.y);
            return this;
          },
          getArea: function() {
            return this.width * this.height;
          },
          isEmpty: function() {
            return this.width === 0 || this.height === 0;
          },
          contains: function(arg) {
            return arg && arg.width !== undefined2 || (Array.isArray(arg) ? arg : arguments).length === 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
          },
          _containsPoint: function(point) {
            var x2 = point.x, y2 = point.y;
            return x2 >= this.x && y2 >= this.y && x2 <= this.x + this.width && y2 <= this.y + this.height;
          },
          _containsRectangle: function(rect) {
            var x2 = rect.x, y2 = rect.y;
            return x2 >= this.x && y2 >= this.y && x2 + rect.width <= this.x + this.width && y2 + rect.height <= this.y + this.height;
          },
          intersects: function() {
            var rect = Rectangle.read(arguments), epsilon = Base.read(arguments) || 0;
            return rect.x + rect.width > this.x - epsilon && rect.y + rect.height > this.y - epsilon && rect.x < this.x + this.width + epsilon && rect.y < this.y + this.height + epsilon;
          },
          intersect: function() {
            var rect = Rectangle.read(arguments), x1 = Math.max(this.x, rect.x), y1 = Math.max(this.y, rect.y), x2 = Math.min(this.x + this.width, rect.x + rect.width), y2 = Math.min(this.y + this.height, rect.y + rect.height);
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
          },
          unite: function() {
            var rect = Rectangle.read(arguments), x1 = Math.min(this.x, rect.x), y1 = Math.min(this.y, rect.y), x2 = Math.max(this.x + this.width, rect.x + rect.width), y2 = Math.max(this.y + this.height, rect.y + rect.height);
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
          },
          include: function() {
            var point = Point.read(arguments);
            var x1 = Math.min(this.x, point.x), y1 = Math.min(this.y, point.y), x2 = Math.max(this.x + this.width, point.x), y2 = Math.max(this.y + this.height, point.y);
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
          },
          expand: function() {
            var amount = Size.read(arguments), hor = amount.width, ver = amount.height;
            return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
          },
          scale: function(hor, ver) {
            return this.expand(this.width * hor - this.width, this.height * (ver === undefined2 ? hor : ver) - this.height);
          }
        }, Base.each([
          ["Top", "Left"],
          ["Top", "Right"],
          ["Bottom", "Left"],
          ["Bottom", "Right"],
          ["Left", "Center"],
          ["Top", "Center"],
          ["Right", "Center"],
          ["Bottom", "Center"]
        ], function(parts, index) {
          var part = parts.join(""), xFirst = /^[RL]/.test(part);
          if (index >= 4)
            parts[1] += xFirst ? "Y" : "X";
          var x2 = parts[xFirst ? 0 : 1], y2 = parts[xFirst ? 1 : 0], getX = "get" + x2, getY = "get" + y2, setX = "set" + x2, setY = "set" + y2, get = "get" + part, set = "set" + part;
          this[get] = function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            return new ctor(this[getX](), this[getY](), this, set);
          };
          this[set] = function() {
            var point = Point.read(arguments);
            this[setX](point.x);
            this[setY](point.y);
          };
        }, {
          beans: true
        }));
        var LinkedRectangle = Rectangle.extend({
          initialize: function Rectangle2(x2, y2, width, height, owner, setter) {
            this._set(x2, y2, width, height, true);
            this._owner = owner;
            this._setter = setter;
          },
          _set: function(x2, y2, width, height, _dontNotify) {
            this._x = x2;
            this._y = y2;
            this._width = width;
            this._height = height;
            if (!_dontNotify)
              this._owner[this._setter](this);
            return this;
          }
        }, new function() {
          var proto = Rectangle.prototype;
          return Base.each(["x", "y", "width", "height"], function(key) {
            var part = Base.capitalize(key), internal = "_" + key;
            this["get" + part] = function() {
              return this[internal];
            };
            this["set" + part] = function(value) {
              this[internal] = value;
              if (!this._dontNotify)
                this._owner[this._setter](this);
            };
          }, Base.each([
            "Point",
            "Size",
            "Center",
            "Left",
            "Top",
            "Right",
            "Bottom",
            "CenterX",
            "CenterY",
            "TopLeft",
            "TopRight",
            "BottomLeft",
            "BottomRight",
            "LeftCenter",
            "TopCenter",
            "RightCenter",
            "BottomCenter"
          ], function(key) {
            var name = "set" + key;
            this[name] = function() {
              this._dontNotify = true;
              proto[name].apply(this, arguments);
              this._dontNotify = false;
              this._owner[this._setter](this);
            };
          }, {
            isSelected: function() {
              return !!(this._owner._selection & 2);
            },
            setSelected: function(selected) {
              var owner = this._owner;
              if (owner._changeSelection) {
                owner._changeSelection(2, selected);
              }
            }
          }));
        }());
        var Matrix = Base.extend({
          _class: "Matrix",
          initialize: function Matrix2(arg, _dontNotify) {
            var args = arguments, count = args.length, ok = true;
            if (count >= 6) {
              this._set.apply(this, args);
            } else if (count === 1 || count === 2) {
              if (arg instanceof Matrix2) {
                this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty, _dontNotify);
              } else if (Array.isArray(arg)) {
                this._set.apply(this, _dontNotify ? arg.concat([_dontNotify]) : arg);
              } else {
                ok = false;
              }
            } else if (!count) {
              this.reset();
            } else {
              ok = false;
            }
            if (!ok) {
              throw new Error("Unsupported matrix parameters");
            }
            return this;
          },
          set: "#initialize",
          _set: function(a2, b2, c2, d, tx, ty, _dontNotify) {
            this._a = a2;
            this._b = b2;
            this._c = c2;
            this._d = d;
            this._tx = tx;
            this._ty = ty;
            if (!_dontNotify)
              this._changed();
            return this;
          },
          _serialize: function(options, dictionary) {
            return Base.serialize(this.getValues(), options, true, dictionary);
          },
          _changed: function() {
            var owner = this._owner;
            if (owner) {
              if (owner._applyMatrix) {
                owner.transform(null, true);
              } else {
                owner._changed(25);
              }
            }
          },
          clone: function() {
            return new Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
          },
          equals: function(mx) {
            return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty;
          },
          toString: function() {
            var f = Formatter.instance;
            return "[[" + [
              f.number(this._a),
              f.number(this._c),
              f.number(this._tx)
            ].join(", ") + "], [" + [
              f.number(this._b),
              f.number(this._d),
              f.number(this._ty)
            ].join(", ") + "]]";
          },
          reset: function(_dontNotify) {
            this._a = this._d = 1;
            this._b = this._c = this._tx = this._ty = 0;
            if (!_dontNotify)
              this._changed();
            return this;
          },
          apply: function(recursively, _setApplyMatrix) {
            var owner = this._owner;
            if (owner) {
              owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
              return this.isIdentity();
            }
            return false;
          },
          translate: function() {
            var point = Point.read(arguments), x2 = point.x, y2 = point.y;
            this._tx += x2 * this._a + y2 * this._c;
            this._ty += x2 * this._b + y2 * this._d;
            this._changed();
            return this;
          },
          scale: function() {
            var args = arguments, scale = Point.read(args), center = Point.read(args, 0, { readNull: true });
            if (center)
              this.translate(center);
            this._a *= scale.x;
            this._b *= scale.x;
            this._c *= scale.y;
            this._d *= scale.y;
            if (center)
              this.translate(center.negate());
            this._changed();
            return this;
          },
          rotate: function(angle) {
            angle *= Math.PI / 180;
            var center = Point.read(arguments, 1), x2 = center.x, y2 = center.y, cos = Math.cos(angle), sin = Math.sin(angle), tx = x2 - x2 * cos + y2 * sin, ty = y2 - x2 * sin - y2 * cos, a2 = this._a, b2 = this._b, c2 = this._c, d = this._d;
            this._a = cos * a2 + sin * c2;
            this._b = cos * b2 + sin * d;
            this._c = -sin * a2 + cos * c2;
            this._d = -sin * b2 + cos * d;
            this._tx += tx * a2 + ty * c2;
            this._ty += tx * b2 + ty * d;
            this._changed();
            return this;
          },
          shear: function() {
            var args = arguments, shear = Point.read(args), center = Point.read(args, 0, { readNull: true });
            if (center)
              this.translate(center);
            var a2 = this._a, b2 = this._b;
            this._a += shear.y * this._c;
            this._b += shear.y * this._d;
            this._c += shear.x * a2;
            this._d += shear.x * b2;
            if (center)
              this.translate(center.negate());
            this._changed();
            return this;
          },
          skew: function() {
            var args = arguments, skew = Point.read(args), center = Point.read(args, 0, { readNull: true }), toRadians = Math.PI / 180, shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
            return this.shear(shear, center);
          },
          append: function(mx, _dontNotify) {
            if (mx) {
              var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, a2 = mx._a, b2 = mx._c, c2 = mx._b, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;
              this._a = a2 * a1 + c2 * c1;
              this._c = b2 * a1 + d2 * c1;
              this._b = a2 * b1 + c2 * d1;
              this._d = b2 * b1 + d2 * d1;
              this._tx += tx2 * a1 + ty2 * c1;
              this._ty += tx2 * b1 + ty2 * d1;
              if (!_dontNotify)
                this._changed();
            }
            return this;
          },
          prepend: function(mx, _dontNotify) {
            if (mx) {
              var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, tx1 = this._tx, ty1 = this._ty, a2 = mx._a, b2 = mx._c, c2 = mx._b, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;
              this._a = a2 * a1 + b2 * b1;
              this._c = a2 * c1 + b2 * d1;
              this._b = c2 * a1 + d2 * b1;
              this._d = c2 * c1 + d2 * d1;
              this._tx = a2 * tx1 + b2 * ty1 + tx2;
              this._ty = c2 * tx1 + d2 * ty1 + ty2;
              if (!_dontNotify)
                this._changed();
            }
            return this;
          },
          appended: function(mx) {
            return this.clone().append(mx);
          },
          prepended: function(mx) {
            return this.clone().prepend(mx);
          },
          invert: function() {
            var a2 = this._a, b2 = this._b, c2 = this._c, d = this._d, tx = this._tx, ty = this._ty, det = a2 * d - b2 * c2, res = null;
            if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
              this._a = d / det;
              this._b = -b2 / det;
              this._c = -c2 / det;
              this._d = a2 / det;
              this._tx = (c2 * ty - d * tx) / det;
              this._ty = (b2 * tx - a2 * ty) / det;
              res = this;
            }
            return res;
          },
          inverted: function() {
            return this.clone().invert();
          },
          concatenate: "#append",
          preConcatenate: "#prepend",
          chain: "#appended",
          _shiftless: function() {
            return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
          },
          _orNullIfIdentity: function() {
            return this.isIdentity() ? null : this;
          },
          isIdentity: function() {
            return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
          },
          isInvertible: function() {
            var det = this._a * this._d - this._c * this._b;
            return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
          },
          isSingular: function() {
            return !this.isInvertible();
          },
          transform: function(src, dst, count) {
            return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
          },
          _transformPoint: function(point, dest, _dontNotify) {
            var x2 = point.x, y2 = point.y;
            if (!dest)
              dest = new Point();
            return dest._set(x2 * this._a + y2 * this._c + this._tx, x2 * this._b + y2 * this._d + this._ty, _dontNotify);
          },
          _transformCoordinates: function(src, dst, count) {
            for (var i2 = 0, max = 2 * count; i2 < max; i2 += 2) {
              var x2 = src[i2], y2 = src[i2 + 1];
              dst[i2] = x2 * this._a + y2 * this._c + this._tx;
              dst[i2 + 1] = x2 * this._b + y2 * this._d + this._ty;
            }
            return dst;
          },
          _transformCorners: function(rect) {
            var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, coords = [x1, y1, x2, y1, x2, y2, x1, y2];
            return this._transformCoordinates(coords, coords, 4);
          },
          _transformBounds: function(bounds, dest, _dontNotify) {
            var coords = this._transformCorners(bounds), min = coords.slice(0, 2), max = min.slice();
            for (var i2 = 2; i2 < 8; i2++) {
              var val = coords[i2], j2 = i2 & 1;
              if (val < min[j2]) {
                min[j2] = val;
              } else if (val > max[j2]) {
                max[j2] = val;
              }
            }
            if (!dest)
              dest = new Rectangle();
            return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
          },
          inverseTransform: function() {
            return this._inverseTransform(Point.read(arguments));
          },
          _inverseTransform: function(point, dest, _dontNotify) {
            var a2 = this._a, b2 = this._b, c2 = this._c, d = this._d, tx = this._tx, ty = this._ty, det = a2 * d - b2 * c2, res = null;
            if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
              var x2 = point.x - this._tx, y2 = point.y - this._ty;
              if (!dest)
                dest = new Point();
              res = dest._set((x2 * d - y2 * c2) / det, (y2 * a2 - x2 * b2) / det, _dontNotify);
            }
            return res;
          },
          decompose: function() {
            var a2 = this._a, b2 = this._b, c2 = this._c, d = this._d, det = a2 * d - b2 * c2, sqrt = Math.sqrt, atan2 = Math.atan2, degrees = 180 / Math.PI, rotate, scale, skew;
            if (a2 !== 0 || b2 !== 0) {
              var r2 = sqrt(a2 * a2 + b2 * b2);
              rotate = Math.acos(a2 / r2) * (b2 > 0 ? 1 : -1);
              scale = [r2, det / r2];
              skew = [atan2(a2 * c2 + b2 * d, r2 * r2), 0];
            } else if (c2 !== 0 || d !== 0) {
              var s2 = sqrt(c2 * c2 + d * d);
              rotate = Math.asin(c2 / s2) * (d > 0 ? 1 : -1);
              scale = [det / s2, s2];
              skew = [0, atan2(a2 * c2 + b2 * d, s2 * s2)];
            } else {
              rotate = 0;
              skew = scale = [0, 0];
            }
            return {
              translation: this.getTranslation(),
              rotation: rotate * degrees,
              scaling: new Point(scale),
              skewing: new Point(skew[0] * degrees, skew[1] * degrees)
            };
          },
          getValues: function() {
            return [this._a, this._b, this._c, this._d, this._tx, this._ty];
          },
          getTranslation: function() {
            return new Point(this._tx, this._ty);
          },
          getScaling: function() {
            return this.decompose().scaling;
          },
          getRotation: function() {
            return this.decompose().rotation;
          },
          applyToContext: function(ctx) {
            if (!this.isIdentity()) {
              ctx.transform(this._a, this._b, this._c, this._d, this._tx, this._ty);
            }
          }
        }, Base.each(["a", "b", "c", "d", "tx", "ty"], function(key) {
          var part = Base.capitalize(key), prop = "_" + key;
          this["get" + part] = function() {
            return this[prop];
          };
          this["set" + part] = function(value) {
            this[prop] = value;
            this._changed();
          };
        }, {}));
        var Line = Base.extend({
          _class: "Line",
          initialize: function Line2(arg0, arg1, arg2, arg3, arg4) {
            var asVector = false;
            if (arguments.length >= 4) {
              this._px = arg0;
              this._py = arg1;
              this._vx = arg2;
              this._vy = arg3;
              asVector = arg4;
            } else {
              this._px = arg0.x;
              this._py = arg0.y;
              this._vx = arg1.x;
              this._vy = arg1.y;
              asVector = arg2;
            }
            if (!asVector) {
              this._vx -= this._px;
              this._vy -= this._py;
            }
          },
          getPoint: function() {
            return new Point(this._px, this._py);
          },
          getVector: function() {
            return new Point(this._vx, this._vy);
          },
          getLength: function() {
            return this.getVector().getLength();
          },
          intersect: function(line, isInfinite) {
            return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
          },
          getSide: function(point, isInfinite) {
            return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);
          },
          getDistance: function(point) {
            return Math.abs(this.getSignedDistance(point));
          },
          getSignedDistance: function(point) {
            return Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true);
          },
          isCollinear: function(line) {
            return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
          },
          isOrthogonal: function(line) {
            return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
          },
          statics: {
            intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {
              if (!asVector) {
                v1x -= p1x;
                v1y -= p1y;
                v2x -= p2x;
                v2y -= p2y;
              }
              var cross = v1x * v2y - v1y * v2x;
              if (!Numerical.isMachineZero(cross)) {
                var dx = p1x - p2x, dy = p1y - p2y, u1 = (v2x * dy - v2y * dx) / cross, u2 = (v1x * dy - v1y * dx) / cross, epsilon = 1e-12, uMin = -epsilon, uMax = 1 + epsilon;
                if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
                  if (!isInfinite) {
                    u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
                  }
                  return new Point(p1x + u1 * v1x, p1y + u1 * v1y);
                }
              }
            },
            getSide: function(px, py, vx, vy, x2, y2, asVector, isInfinite) {
              if (!asVector) {
                vx -= px;
                vy -= py;
              }
              var v2x = x2 - px, v2y = y2 - py, ccw = v2x * vy - v2y * vx;
              if (!isInfinite && Numerical.isMachineZero(ccw)) {
                ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
                if (ccw >= 0 && ccw <= 1)
                  ccw = 0;
              }
              return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
            },
            getSignedDistance: function(px, py, vx, vy, x2, y2, asVector) {
              if (!asVector) {
                vx -= px;
                vy -= py;
              }
              return vx === 0 ? vy > 0 ? x2 - px : px - x2 : vy === 0 ? vx < 0 ? y2 - py : py - y2 : ((x2 - px) * vy - (y2 - py) * vx) / (vy > vx ? vy * Math.sqrt(1 + vx * vx / (vy * vy)) : vx * Math.sqrt(1 + vy * vy / (vx * vx)));
            },
            getDistance: function(px, py, vx, vy, x2, y2, asVector) {
              return Math.abs(Line.getSignedDistance(px, py, vx, vy, x2, y2, asVector));
            }
          }
        });
        var Project = PaperScopeItem.extend({
          _class: "Project",
          _list: "projects",
          _reference: "project",
          _compactSerialize: true,
          initialize: function Project2(element) {
            PaperScopeItem.call(this, true);
            this._children = [];
            this._namedChildren = {};
            this._activeLayer = null;
            this._currentStyle = new Style(null, null, this);
            this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
            this._selectionItems = {};
            this._selectionCount = 0;
            this._updateVersion = 0;
          },
          _serialize: function(options, dictionary) {
            return Base.serialize(this._children, options, true, dictionary);
          },
          _changed: function(flags, item) {
            if (flags & 1) {
              var view = this._view;
              if (view) {
                view._needsUpdate = true;
                if (!view._requested && view._autoUpdate)
                  view.requestUpdate();
              }
            }
            var changes = this._changes;
            if (changes && item) {
              var changesById = this._changesById, id2 = item._id, entry = changesById[id2];
              if (entry) {
                entry.flags |= flags;
              } else {
                changes.push(changesById[id2] = { item, flags });
              }
            }
          },
          clear: function() {
            var children = this._children;
            for (var i2 = children.length - 1; i2 >= 0; i2--)
              children[i2].remove();
          },
          isEmpty: function() {
            return !this._children.length;
          },
          remove: function remove() {
            if (!remove.base.call(this))
              return false;
            if (this._view)
              this._view.remove();
            return true;
          },
          getView: function() {
            return this._view;
          },
          getCurrentStyle: function() {
            return this._currentStyle;
          },
          setCurrentStyle: function(style) {
            this._currentStyle.set(style);
          },
          getIndex: function() {
            return this._index;
          },
          getOptions: function() {
            return this._scope.settings;
          },
          getLayers: function() {
            return this._children;
          },
          getActiveLayer: function() {
            return this._activeLayer || new Layer({ project: this, insert: true });
          },
          getSymbolDefinitions: function() {
            var definitions = [], ids = {};
            this.getItems({
              class: SymbolItem,
              match: function(item) {
                var definition = item._definition, id2 = definition._id;
                if (!ids[id2]) {
                  ids[id2] = true;
                  definitions.push(definition);
                }
                return false;
              }
            });
            return definitions;
          },
          getSymbols: "getSymbolDefinitions",
          getSelectedItems: function() {
            var selectionItems = this._selectionItems, items = [];
            for (var id2 in selectionItems) {
              var item = selectionItems[id2], selection = item._selection;
              if (selection & 1 && item.isInserted()) {
                items.push(item);
              } else if (!selection) {
                this._updateSelection(item);
              }
            }
            return items;
          },
          _updateSelection: function(item) {
            var id2 = item._id, selectionItems = this._selectionItems;
            if (item._selection) {
              if (selectionItems[id2] !== item) {
                this._selectionCount++;
                selectionItems[id2] = item;
              }
            } else if (selectionItems[id2] === item) {
              this._selectionCount--;
              delete selectionItems[id2];
            }
          },
          selectAll: function() {
            var children = this._children;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
              children[i2].setFullySelected(true);
          },
          deselectAll: function() {
            var selectionItems = this._selectionItems;
            for (var i2 in selectionItems)
              selectionItems[i2].setFullySelected(false);
          },
          addLayer: function(layer) {
            return this.insertLayer(undefined2, layer);
          },
          insertLayer: function(index, layer) {
            if (layer instanceof Layer) {
              layer._remove(false, true);
              Base.splice(this._children, [layer], index, 0);
              layer._setProject(this, true);
              var name = layer._name;
              if (name)
                layer.setName(name);
              if (this._changes)
                layer._changed(5);
              if (!this._activeLayer)
                this._activeLayer = layer;
            } else {
              layer = null;
            }
            return layer;
          },
          _insertItem: function(index, item, _created) {
            item = this.insertLayer(index, item) || (this._activeLayer || this._insertItem(undefined2, new Layer(Item.NO_INSERT), true)).insertChild(index, item);
            if (_created && item.activate)
              item.activate();
            return item;
          },
          getItems: function(options) {
            return Item._getItems(this, options);
          },
          getItem: function(options) {
            return Item._getItems(this, options, null, null, true)[0] || null;
          },
          importJSON: function(json) {
            this.activate();
            var layer = this._activeLayer;
            return Base.importJSON(json, layer && layer.isEmpty() && layer);
          },
          removeOn: function(type) {
            var sets = this._removeSets;
            if (sets) {
              if (type === "mouseup")
                sets.mousedrag = null;
              var set = sets[type];
              if (set) {
                for (var id2 in set) {
                  var item = set[id2];
                  for (var key in sets) {
                    var other = sets[key];
                    if (other && other != set)
                      delete other[item._id];
                  }
                  item.remove();
                }
                sets[type] = null;
              }
            }
          },
          draw: function(ctx, matrix, pixelRatio) {
            this._updateVersion++;
            ctx.save();
            matrix.applyToContext(ctx);
            var children = this._children, param = new Base({
              offset: new Point(0, 0),
              pixelRatio,
              viewMatrix: matrix.isIdentity() ? null : matrix,
              matrices: [new Matrix()],
              updateMatrix: true
            });
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              children[i2].draw(ctx, param);
            }
            ctx.restore();
            if (this._selectionCount > 0) {
              ctx.save();
              ctx.strokeWidth = 1;
              var items = this._selectionItems, size = this._scope.settings.handleSize, version = this._updateVersion;
              for (var id2 in items) {
                items[id2]._drawSelection(ctx, matrix, size, items, version);
              }
              ctx.restore();
            }
          }
        });
        var Item = Base.extend(Emitter, {
          statics: {
            extend: function extend(src) {
              if (src._serializeFields)
                src._serializeFields = Base.set({}, this.prototype._serializeFields, src._serializeFields);
              return extend.base.apply(this, arguments);
            },
            NO_INSERT: { insert: false }
          },
          _class: "Item",
          _name: null,
          _applyMatrix: true,
          _canApplyMatrix: true,
          _canScaleStroke: false,
          _pivot: null,
          _visible: true,
          _blendMode: "normal",
          _opacity: 1,
          _locked: false,
          _guide: false,
          _clipMask: false,
          _selection: 0,
          _selectBounds: true,
          _selectChildren: false,
          _serializeFields: {
            name: null,
            applyMatrix: null,
            matrix: new Matrix(),
            pivot: null,
            visible: true,
            blendMode: "normal",
            opacity: 1,
            locked: false,
            guide: false,
            clipMask: false,
            selected: false,
            data: {}
          },
          _prioritize: ["applyMatrix"]
        }, new function() {
          var handlers = [
            "onMouseDown",
            "onMouseUp",
            "onMouseDrag",
            "onClick",
            "onDoubleClick",
            "onMouseMove",
            "onMouseEnter",
            "onMouseLeave"
          ];
          return Base.each(handlers, function(name) {
            this._events[name] = {
              install: function(type) {
                this.getView()._countItemEvent(type, 1);
              },
              uninstall: function(type) {
                this.getView()._countItemEvent(type, -1);
              }
            };
          }, {
            _events: {
              onFrame: {
                install: function() {
                  this.getView()._animateItem(this, true);
                },
                uninstall: function() {
                  this.getView()._animateItem(this, false);
                }
              },
              onLoad: {},
              onError: {}
            },
            statics: {
              _itemHandlers: handlers
            }
          });
        }(), {
          initialize: function Item2() {
          },
          _initialize: function(props, point) {
            var hasProps = props && Base.isPlainObject(props), internal = hasProps && props.internal === true, matrix = this._matrix = new Matrix(), project = hasProps && props.project || paper2.project, settings = paper2.settings;
            this._id = internal ? null : UID.get();
            this._parent = this._index = null;
            this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
            if (point)
              matrix.translate(point);
            matrix._owner = this;
            this._style = new Style(project._currentStyle, this, project);
            if (internal || hasProps && props.insert == false || !settings.insertItems && !(hasProps && props.insert === true)) {
              this._setProject(project);
            } else {
              (hasProps && props.parent || project)._insertItem(undefined2, this, true);
            }
            if (hasProps && props !== Item.NO_INSERT) {
              this.set(props, {
                internal: true,
                insert: true,
                project: true,
                parent: true
              });
            }
            return hasProps;
          },
          _serialize: function(options, dictionary) {
            var props = {}, that = this;
            function serialize(fields) {
              for (var key in fields) {
                var value = that[key];
                if (!Base.equals(value, key === "leading" ? fields.fontSize * 1.2 : fields[key])) {
                  props[key] = Base.serialize(value, options, key !== "data", dictionary);
                }
              }
            }
            serialize(this._serializeFields);
            if (!(this instanceof Group))
              serialize(this._style._defaults);
            return [this._class, props];
          },
          _changed: function(flags) {
            var symbol = this._symbol, cacheParent = this._parent || symbol, project = this._project;
            if (flags & 8) {
              this._bounds = this._position = this._decomposed = undefined2;
            }
            if (flags & 16) {
              this._globalMatrix = undefined2;
            }
            if (cacheParent && flags & 72) {
              Item._clearBoundsCache(cacheParent);
            }
            if (flags & 2) {
              Item._clearBoundsCache(this);
            }
            if (project)
              project._changed(flags, this);
            if (symbol)
              symbol._changed(flags);
          },
          getId: function() {
            return this._id;
          },
          getName: function() {
            return this._name;
          },
          setName: function(name) {
            if (this._name)
              this._removeNamed();
            if (name === +name + "")
              throw new Error("Names consisting only of numbers are not supported.");
            var owner = this._getOwner();
            if (name && owner) {
              var children = owner._children, namedChildren = owner._namedChildren;
              (namedChildren[name] = namedChildren[name] || []).push(this);
              if (!(name in children))
                children[name] = this;
            }
            this._name = name || undefined2;
            this._changed(256);
          },
          getStyle: function() {
            return this._style;
          },
          setStyle: function(style) {
            this.getStyle().set(style);
          }
        }, Base.each(["locked", "visible", "blendMode", "opacity", "guide"], function(name) {
          var part = Base.capitalize(name), key = "_" + name, flags = {
            locked: 256,
            visible: 265
          };
          this["get" + part] = function() {
            return this[key];
          };
          this["set" + part] = function(value) {
            if (value != this[key]) {
              this[key] = value;
              this._changed(flags[name] || 257);
            }
          };
        }, {}), {
          beans: true,
          getSelection: function() {
            return this._selection;
          },
          setSelection: function(selection) {
            if (selection !== this._selection) {
              this._selection = selection;
              var project = this._project;
              if (project) {
                project._updateSelection(this);
                this._changed(257);
              }
            }
          },
          _changeSelection: function(flag, selected) {
            var selection = this._selection;
            this.setSelection(selected ? selection | flag : selection & ~flag);
          },
          isSelected: function() {
            if (this._selectChildren) {
              var children = this._children;
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
                if (children[i2].isSelected())
                  return true;
            }
            return !!(this._selection & 1);
          },
          setSelected: function(selected) {
            if (this._selectChildren) {
              var children = this._children;
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
                children[i2].setSelected(selected);
            }
            this._changeSelection(1, selected);
          },
          isFullySelected: function() {
            var children = this._children, selected = !!(this._selection & 1);
            if (children && selected) {
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
                if (!children[i2].isFullySelected())
                  return false;
              return true;
            }
            return selected;
          },
          setFullySelected: function(selected) {
            var children = this._children;
            if (children) {
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
                children[i2].setFullySelected(selected);
            }
            this._changeSelection(1, selected);
          },
          isClipMask: function() {
            return this._clipMask;
          },
          setClipMask: function(clipMask) {
            if (this._clipMask != (clipMask = !!clipMask)) {
              this._clipMask = clipMask;
              if (clipMask) {
                this.setFillColor(null);
                this.setStrokeColor(null);
              }
              this._changed(257);
              if (this._parent)
                this._parent._changed(2048);
            }
          },
          getData: function() {
            if (!this._data)
              this._data = {};
            return this._data;
          },
          setData: function(data) {
            this._data = data;
          },
          getPosition: function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            var position = this._position || (this._position = this._getPositionFromBounds());
            return new ctor(position.x, position.y, this, "setPosition");
          },
          setPosition: function() {
            this.translate(Point.read(arguments).subtract(this.getPosition(true)));
          },
          _getPositionFromBounds: function(bounds) {
            return this._pivot ? this._matrix._transformPoint(this._pivot) : (bounds || this.getBounds()).getCenter(true);
          },
          getPivot: function() {
            var pivot = this._pivot;
            return pivot ? new LinkedPoint(pivot.x, pivot.y, this, "setPivot") : null;
          },
          setPivot: function() {
            this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
            this._position = undefined2;
          }
        }, Base.each({
          getStrokeBounds: { stroke: true },
          getHandleBounds: { handle: true },
          getInternalBounds: { internal: true }
        }, function(options, key) {
          this[key] = function(matrix) {
            return this.getBounds(matrix, options);
          };
        }, {
          beans: true,
          getBounds: function(matrix, options) {
            var hasMatrix = options || matrix instanceof Matrix, opts = Base.set({}, hasMatrix ? options : matrix, this._boundsOptions);
            if (!opts.stroke || this.getStrokeScaling())
              opts.cacheItem = this;
            var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
            return !arguments.length ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height, this, "setBounds") : rect;
          },
          setBounds: function() {
            var rect = Rectangle.read(arguments), bounds = this.getBounds(), _matrix = this._matrix, matrix = new Matrix(), center = rect.getCenter();
            matrix.translate(center);
            if (rect.width != bounds.width || rect.height != bounds.height) {
              if (!_matrix.isInvertible()) {
                _matrix.set(_matrix._backup || new Matrix().translate(_matrix.getTranslation()));
                bounds = this.getBounds();
              }
              matrix.scale(bounds.width !== 0 ? rect.width / bounds.width : 0, bounds.height !== 0 ? rect.height / bounds.height : 0);
            }
            center = bounds.getCenter();
            matrix.translate(-center.x, -center.y);
            this.transform(matrix);
          },
          _getBounds: function(matrix, options) {
            var children = this._children;
            if (!children || !children.length)
              return new Rectangle();
            Item._updateBoundsCache(this, options.cacheItem);
            return Item._getBounds(children, matrix, options);
          },
          _getBoundsCacheKey: function(options, internal) {
            return [
              options.stroke ? 1 : 0,
              options.handle ? 1 : 0,
              internal ? 1 : 0
            ].join("");
          },
          _getCachedBounds: function(matrix, options, noInternal) {
            matrix = matrix && matrix._orNullIfIdentity();
            var internal = options.internal && !noInternal, cacheItem = options.cacheItem, _matrix = internal ? null : this._matrix._orNullIfIdentity(), cacheKey = cacheItem && (!matrix || matrix.equals(_matrix)) && this._getBoundsCacheKey(options, internal), bounds = this._bounds;
            Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
            if (cacheKey && bounds && cacheKey in bounds) {
              var cached = bounds[cacheKey];
              return {
                rect: cached.rect.clone(),
                nonscaling: cached.nonscaling
              };
            }
            var res = this._getBounds(matrix || _matrix, options), rect = res.rect || res, style = this._style, nonscaling = res.nonscaling || style.hasStroke() && !style.getStrokeScaling();
            if (cacheKey) {
              if (!bounds) {
                this._bounds = bounds = {};
              }
              var cached = bounds[cacheKey] = {
                rect: rect.clone(),
                nonscaling,
                internal
              };
            }
            return {
              rect,
              nonscaling
            };
          },
          _getStrokeMatrix: function(matrix, options) {
            var parent = this.getStrokeScaling() ? null : options && options.internal ? this : this._parent || this._symbol && this._symbol._item, mx = parent ? parent.getViewMatrix().invert() : matrix;
            return mx && mx._shiftless();
          },
          statics: {
            _updateBoundsCache: function(parent, item) {
              if (parent && item) {
                var id2 = item._id, ref = parent._boundsCache = parent._boundsCache || {
                  ids: {},
                  list: []
                };
                if (!ref.ids[id2]) {
                  ref.list.push(item);
                  ref.ids[id2] = item;
                }
              }
            },
            _clearBoundsCache: function(item) {
              var cache = item._boundsCache;
              if (cache) {
                item._bounds = item._position = item._boundsCache = undefined2;
                for (var i2 = 0, list = cache.list, l2 = list.length; i2 < l2; i2++) {
                  var other = list[i2];
                  if (other !== item) {
                    other._bounds = other._position = undefined2;
                    if (other._boundsCache)
                      Item._clearBoundsCache(other);
                  }
                }
              }
            },
            _getBounds: function(items, matrix, options) {
              var x1 = Infinity, x2 = -x1, y1 = x1, y2 = x2, nonscaling = false;
              options = options || {};
              for (var i2 = 0, l2 = items.length; i2 < l2; i2++) {
                var item = items[i2];
                if (item._visible && !item.isEmpty(true)) {
                  var bounds = item._getCachedBounds(matrix && matrix.appended(item._matrix), options, true), rect = bounds.rect;
                  x1 = Math.min(rect.x, x1);
                  y1 = Math.min(rect.y, y1);
                  x2 = Math.max(rect.x + rect.width, x2);
                  y2 = Math.max(rect.y + rect.height, y2);
                  if (bounds.nonscaling)
                    nonscaling = true;
                }
              }
              return {
                rect: isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle(),
                nonscaling
              };
            }
          }
        }), {
          beans: true,
          _decompose: function() {
            return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
          },
          getRotation: function() {
            var decomposed = this._decompose();
            return decomposed ? decomposed.rotation : 0;
          },
          setRotation: function(rotation) {
            var current = this.getRotation();
            if (current != null && rotation != null) {
              var decomposed = this._decomposed;
              this.rotate(rotation - current);
              if (decomposed) {
                decomposed.rotation = rotation;
                this._decomposed = decomposed;
              }
            }
          },
          getScaling: function() {
            var decomposed = this._decompose(), s2 = decomposed && decomposed.scaling;
            return new LinkedPoint(s2 ? s2.x : 1, s2 ? s2.y : 1, this, "setScaling");
          },
          setScaling: function() {
            var current = this.getScaling(), scaling = Point.read(arguments, 0, { clone: true, readNull: true });
            if (current && scaling && !current.equals(scaling)) {
              var rotation = this.getRotation(), decomposed = this._decomposed, matrix = new Matrix(), isZero = Numerical.isZero;
              if (isZero(current.x) || isZero(current.y)) {
                matrix.translate(decomposed.translation);
                if (rotation) {
                  matrix.rotate(rotation);
                }
                matrix.scale(scaling.x, scaling.y);
                this._matrix.set(matrix);
              } else {
                var center = this.getPosition(true);
                matrix.translate(center);
                if (rotation)
                  matrix.rotate(rotation);
                matrix.scale(scaling.x / current.x, scaling.y / current.y);
                if (rotation)
                  matrix.rotate(-rotation);
                matrix.translate(center.negate());
                this.transform(matrix);
              }
              if (decomposed) {
                decomposed.scaling = scaling;
                this._decomposed = decomposed;
              }
            }
          },
          getMatrix: function() {
            return this._matrix;
          },
          setMatrix: function() {
            var matrix = this._matrix;
            matrix.set.apply(matrix, arguments);
          },
          getGlobalMatrix: function(_dontClone) {
            var matrix = this._globalMatrix;
            if (matrix) {
              var parent = this._parent;
              var parents = [];
              while (parent) {
                if (!parent._globalMatrix) {
                  matrix = null;
                  for (var i2 = 0, l2 = parents.length; i2 < l2; i2++) {
                    parents[i2]._globalMatrix = null;
                  }
                  break;
                }
                parents.push(parent);
                parent = parent._parent;
              }
            }
            if (!matrix) {
              matrix = this._globalMatrix = this._matrix.clone();
              var parent = this._parent;
              if (parent)
                matrix.prepend(parent.getGlobalMatrix(true));
            }
            return _dontClone ? matrix : matrix.clone();
          },
          getViewMatrix: function() {
            return this.getGlobalMatrix().prepend(this.getView()._matrix);
          },
          getApplyMatrix: function() {
            return this._applyMatrix;
          },
          setApplyMatrix: function(apply) {
            if (this._applyMatrix = this._canApplyMatrix && !!apply)
              this.transform(null, true);
          },
          getTransformContent: "#getApplyMatrix",
          setTransformContent: "#setApplyMatrix"
        }, {
          getProject: function() {
            return this._project;
          },
          _setProject: function(project, installEvents) {
            if (this._project !== project) {
              if (this._project)
                this._installEvents(false);
              this._project = project;
              var children = this._children;
              for (var i2 = 0, l2 = children && children.length; i2 < l2; i2++)
                children[i2]._setProject(project);
              installEvents = true;
            }
            if (installEvents)
              this._installEvents(true);
          },
          getView: function() {
            return this._project._view;
          },
          _installEvents: function _installEvents(install) {
            _installEvents.base.call(this, install);
            var children = this._children;
            for (var i2 = 0, l2 = children && children.length; i2 < l2; i2++)
              children[i2]._installEvents(install);
          },
          getLayer: function() {
            var parent = this;
            while (parent = parent._parent) {
              if (parent instanceof Layer)
                return parent;
            }
            return null;
          },
          getParent: function() {
            return this._parent;
          },
          setParent: function(item) {
            return item.addChild(this);
          },
          _getOwner: "#getParent",
          getChildren: function() {
            return this._children;
          },
          setChildren: function(items) {
            this.removeChildren();
            this.addChildren(items);
          },
          getFirstChild: function() {
            return this._children && this._children[0] || null;
          },
          getLastChild: function() {
            return this._children && this._children[this._children.length - 1] || null;
          },
          getNextSibling: function() {
            var owner = this._getOwner();
            return owner && owner._children[this._index + 1] || null;
          },
          getPreviousSibling: function() {
            var owner = this._getOwner();
            return owner && owner._children[this._index - 1] || null;
          },
          getIndex: function() {
            return this._index;
          },
          equals: function(item) {
            return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
          },
          _equals: function(item) {
            return Base.equals(this._children, item._children);
          },
          clone: function(options) {
            var copy = new this.constructor(Item.NO_INSERT), children = this._children, insert = Base.pick(options ? options.insert : undefined2, options === undefined2 || options === true), deep = Base.pick(options ? options.deep : undefined2, true);
            if (children)
              copy.copyAttributes(this);
            if (!children || deep)
              copy.copyContent(this);
            if (!children)
              copy.copyAttributes(this);
            if (insert)
              copy.insertAbove(this);
            var name = this._name, parent = this._parent;
            if (name && parent) {
              var children = parent._children, orig = name, i2 = 1;
              while (children[name])
                name = orig + " " + i2++;
              if (name !== orig)
                copy.setName(name);
            }
            return copy;
          },
          copyContent: function(source) {
            var children = source._children;
            for (var i2 = 0, l2 = children && children.length; i2 < l2; i2++) {
              this.addChild(children[i2].clone(false), true);
            }
          },
          copyAttributes: function(source, excludeMatrix) {
            this.setStyle(source._style);
            var keys = [
              "_locked",
              "_visible",
              "_blendMode",
              "_opacity",
              "_clipMask",
              "_guide"
            ];
            for (var i2 = 0, l2 = keys.length; i2 < l2; i2++) {
              var key = keys[i2];
              if (source.hasOwnProperty(key))
                this[key] = source[key];
            }
            if (!excludeMatrix)
              this._matrix.set(source._matrix, true);
            this.setApplyMatrix(source._applyMatrix);
            this.setPivot(source._pivot);
            this.setSelection(source._selection);
            var data = source._data, name = source._name;
            this._data = data ? Base.clone(data) : null;
            if (name)
              this.setName(name);
          },
          rasterize: function(arg0, arg1) {
            var resolution, insert, raster;
            if (Base.isPlainObject(arg0)) {
              resolution = arg0.resolution;
              insert = arg0.insert;
              raster = arg0.raster;
            } else {
              resolution = arg0;
              insert = arg1;
            }
            if (raster) {
              raster.matrix.reset(true);
            } else {
              raster = new Raster(Item.NO_INSERT);
            }
            var bounds = this.getStrokeBounds(), scale = (resolution || this.getView().getResolution()) / 72, topLeft = bounds.getTopLeft().floor(), bottomRight = bounds.getBottomRight().ceil(), boundsSize = new Size(bottomRight.subtract(topLeft)), rasterSize = boundsSize.multiply(scale);
            raster.setSize(rasterSize, true);
            if (!rasterSize.isZero()) {
              var ctx = raster.getContext(true), matrix = new Matrix().scale(scale).translate(topLeft.negate());
              ctx.save();
              matrix.applyToContext(ctx);
              this.draw(ctx, new Base({ matrices: [matrix] }));
              ctx.restore();
            }
            raster.transform(new Matrix().translate(topLeft.add(boundsSize.divide(2))).scale(1 / scale));
            if (insert === undefined2 || insert) {
              raster.insertAbove(this);
            }
            return raster;
          },
          contains: function() {
            var matrix = this._matrix;
            return matrix.isInvertible() && !!this._contains(matrix._inverseTransform(Point.read(arguments)));
          },
          _contains: function(point) {
            var children = this._children;
            if (children) {
              for (var i2 = children.length - 1; i2 >= 0; i2--) {
                if (children[i2].contains(point))
                  return true;
              }
              return false;
            }
            return point.isInside(this.getInternalBounds());
          },
          isInside: function() {
            return Rectangle.read(arguments).contains(this.getBounds());
          },
          _asPathItem: function() {
            return new Path.Rectangle({
              rectangle: this.getInternalBounds(),
              matrix: this._matrix,
              insert: false
            });
          },
          intersects: function(item, _matrix) {
            if (!(item instanceof Item))
              return false;
            return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix, true).length > 0;
          }
        }, new function() {
          function hitTest() {
            var args = arguments;
            return this._hitTest(Point.read(args), HitResult.getOptions(args));
          }
          function hitTestAll() {
            var args = arguments, point = Point.read(args), options = HitResult.getOptions(args), all = [];
            this._hitTest(point, new Base({ all }, options));
            return all;
          }
          function hitTestChildren(point, options, viewMatrix, _exclude) {
            var children = this._children;
            if (children) {
              for (var i2 = children.length - 1; i2 >= 0; i2--) {
                var child = children[i2];
                var res = child !== _exclude && child._hitTest(point, options, viewMatrix);
                if (res && !options.all)
                  return res;
              }
            }
            return null;
          }
          Project.inject({
            hitTest,
            hitTestAll,
            _hitTest: hitTestChildren
          });
          return {
            hitTest,
            hitTestAll,
            _hitTestChildren: hitTestChildren
          };
        }(), {
          _hitTest: function(point, options, parentViewMatrix) {
            if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) {
              return null;
            }
            var matrix = this._matrix, viewMatrix = parentViewMatrix ? parentViewMatrix.appended(matrix) : this.getGlobalMatrix().prepend(this.getView()._matrix), tolerance = Math.max(options.tolerance, 1e-12), tolerancePadding = options._tolerancePadding = new Size(Path._getStrokePadding(tolerance, matrix._shiftless().invert()));
            point = matrix._inverseTransform(point);
            if (!point || !this._children && !this.getBounds({ internal: true, stroke: true, handle: true }).expand(tolerancePadding.multiply(2))._containsPoint(point)) {
              return null;
            }
            var checkSelf = !(options.guides && !this._guide || options.selected && !this.isSelected() || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)), match = options.match, that = this, bounds, res;
            function filter(hit) {
              if (hit && match && !match(hit))
                hit = null;
              if (hit && options.all)
                options.all.push(hit);
              return hit;
            }
            function checkPoint(type, part) {
              var pt2 = part ? bounds["get" + part]() : that.getPosition();
              if (point.subtract(pt2).divide(tolerancePadding).length <= 1) {
                return new HitResult(type, that, {
                  name: part ? Base.hyphenate(part) : type,
                  point: pt2
                });
              }
            }
            var checkPosition = options.position, checkCenter = options.center, checkBounds = options.bounds;
            if (checkSelf && this._parent && (checkPosition || checkCenter || checkBounds)) {
              if (checkCenter || checkBounds) {
                bounds = this.getInternalBounds();
              }
              res = checkPosition && checkPoint("position") || checkCenter && checkPoint("center", "Center");
              if (!res && checkBounds) {
                var points = [
                  "TopLeft",
                  "TopRight",
                  "BottomLeft",
                  "BottomRight",
                  "LeftCenter",
                  "TopCenter",
                  "RightCenter",
                  "BottomCenter"
                ];
                for (var i2 = 0; i2 < 8 && !res; i2++) {
                  res = checkPoint("bounds", points[i2]);
                }
              }
              res = filter(res);
            }
            if (!res) {
              res = this._hitTestChildren(point, options, viewMatrix) || checkSelf && filter(this._hitTestSelf(point, options, viewMatrix, this.getStrokeScaling() ? null : viewMatrix._shiftless().invert())) || null;
            }
            if (res && res.point) {
              res.point = matrix.transform(res.point);
            }
            return res;
          },
          _hitTestSelf: function(point, options) {
            if (options.fill && this.hasFill() && this._contains(point))
              return new HitResult("fill", this);
          },
          matches: function(name, compare) {
            function matchObject(obj1, obj2) {
              for (var i2 in obj1) {
                if (obj1.hasOwnProperty(i2)) {
                  var val1 = obj1[i2], val2 = obj2[i2];
                  if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
                    if (!matchObject(val1, val2))
                      return false;
                  } else if (!Base.equals(val1, val2)) {
                    return false;
                  }
                }
              }
              return true;
            }
            var type = typeof name;
            if (type === "object") {
              for (var key in name) {
                if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
                  return false;
              }
              return true;
            } else if (type === "function") {
              return name(this);
            } else if (name === "match") {
              return compare(this);
            } else {
              var value = /^(empty|editable)$/.test(name) ? this["is" + Base.capitalize(name)]() : name === "type" ? Base.hyphenate(this._class) : this[name];
              if (name === "class") {
                if (typeof compare === "function")
                  return this instanceof compare;
                value = this._class;
              }
              if (typeof compare === "function") {
                return !!compare(value);
              } else if (compare) {
                if (compare.test) {
                  return compare.test(value);
                } else if (Base.isPlainObject(compare)) {
                  return matchObject(compare, value);
                }
              }
              return Base.equals(value, compare);
            }
          },
          getItems: function(options) {
            return Item._getItems(this, options, this._matrix);
          },
          getItem: function(options) {
            return Item._getItems(this, options, this._matrix, null, true)[0] || null;
          },
          statics: {
            _getItems: function _getItems(item, options, matrix, param, firstOnly) {
              if (!param) {
                var obj = typeof options === "object" && options, overlapping = obj && obj.overlapping, inside = obj && obj.inside, bounds = overlapping || inside, rect = bounds && Rectangle.read([bounds]);
                param = {
                  items: [],
                  recursive: obj && obj.recursive !== false,
                  inside: !!inside,
                  overlapping: !!overlapping,
                  rect,
                  path: overlapping && new Path.Rectangle({
                    rectangle: rect,
                    insert: false
                  })
                };
                if (obj) {
                  options = Base.filter({}, options, {
                    recursive: true,
                    inside: true,
                    overlapping: true
                  });
                }
              }
              var children = item._children, items = param.items, rect = param.rect;
              matrix = rect && (matrix || new Matrix());
              for (var i2 = 0, l2 = children && children.length; i2 < l2; i2++) {
                var child = children[i2], childMatrix = matrix && matrix.appended(child._matrix), add = true;
                if (rect) {
                  var bounds = child.getBounds(childMatrix);
                  if (!rect.intersects(bounds))
                    continue;
                  if (!(rect.contains(bounds) || param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix))))
                    add = false;
                }
                if (add && child.matches(options)) {
                  items.push(child);
                  if (firstOnly)
                    break;
                }
                if (param.recursive !== false) {
                  _getItems(child, options, childMatrix, param, firstOnly);
                }
                if (firstOnly && items.length > 0)
                  break;
              }
              return items;
            }
          }
        }, {
          importJSON: function(json) {
            var res = Base.importJSON(json, this);
            return res !== this ? this.addChild(res) : res;
          },
          addChild: function(item) {
            return this.insertChild(undefined2, item);
          },
          insertChild: function(index, item) {
            var res = item ? this.insertChildren(index, [item]) : null;
            return res && res[0];
          },
          addChildren: function(items) {
            return this.insertChildren(this._children.length, items);
          },
          insertChildren: function(index, items) {
            var children = this._children;
            if (children && items && items.length > 0) {
              items = Base.slice(items);
              var inserted = {};
              for (var i2 = items.length - 1; i2 >= 0; i2--) {
                var item = items[i2], id2 = item && item._id;
                if (!item || inserted[id2]) {
                  items.splice(i2, 1);
                } else {
                  item._remove(false, true);
                  inserted[id2] = true;
                }
              }
              Base.splice(children, items, index, 0);
              var project = this._project, notifySelf = project._changes;
              for (var i2 = 0, l2 = items.length; i2 < l2; i2++) {
                var item = items[i2], name = item._name;
                item._parent = this;
                item._setProject(project, true);
                if (name)
                  item.setName(name);
                if (notifySelf)
                  item._changed(5);
              }
              this._changed(11);
            } else {
              items = null;
            }
            return items;
          },
          _insertItem: "#insertChild",
          _insertAt: function(item, offset) {
            var owner = item && item._getOwner(), res = item !== this && owner ? this : null;
            if (res) {
              res._remove(false, true);
              owner._insertItem(item._index + offset, res);
            }
            return res;
          },
          insertAbove: function(item) {
            return this._insertAt(item, 1);
          },
          insertBelow: function(item) {
            return this._insertAt(item, 0);
          },
          sendToBack: function() {
            var owner = this._getOwner();
            return owner ? owner._insertItem(0, this) : null;
          },
          bringToFront: function() {
            var owner = this._getOwner();
            return owner ? owner._insertItem(undefined2, this) : null;
          },
          appendTop: "#addChild",
          appendBottom: function(item) {
            return this.insertChild(0, item);
          },
          moveAbove: "#insertAbove",
          moveBelow: "#insertBelow",
          addTo: function(owner) {
            return owner._insertItem(undefined2, this);
          },
          copyTo: function(owner) {
            return this.clone(false).addTo(owner);
          },
          reduce: function(options) {
            var children = this._children;
            if (children && children.length === 1) {
              var child = children[0].reduce(options);
              if (this._parent) {
                child.insertAbove(this);
                this.remove();
              } else {
                child.remove();
              }
              return child;
            }
            return this;
          },
          _removeNamed: function() {
            var owner = this._getOwner();
            if (owner) {
              var children = owner._children, namedChildren = owner._namedChildren, name = this._name, namedArray = namedChildren[name], index = namedArray ? namedArray.indexOf(this) : -1;
              if (index !== -1) {
                if (children[name] == this)
                  delete children[name];
                namedArray.splice(index, 1);
                if (namedArray.length) {
                  children[name] = namedArray[0];
                } else {
                  delete namedChildren[name];
                }
              }
            }
          },
          _remove: function(notifySelf, notifyParent) {
            var owner = this._getOwner(), project = this._project, index = this._index;
            if (this._style)
              this._style._dispose();
            if (owner) {
              if (this._name)
                this._removeNamed();
              if (index != null) {
                if (project._activeLayer === this)
                  project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
                Base.splice(owner._children, null, index, 1);
              }
              this._installEvents(false);
              if (notifySelf && project._changes)
                this._changed(5);
              if (notifyParent)
                owner._changed(11, this);
              this._parent = null;
              return true;
            }
            return false;
          },
          remove: function() {
            return this._remove(true, true);
          },
          replaceWith: function(item) {
            var ok = item && item.insertBelow(this);
            if (ok)
              this.remove();
            return ok;
          },
          removeChildren: function(start, end) {
            if (!this._children)
              return null;
            start = start || 0;
            end = Base.pick(end, this._children.length);
            var removed = Base.splice(this._children, null, start, end - start);
            for (var i2 = removed.length - 1; i2 >= 0; i2--) {
              removed[i2]._remove(true, false);
            }
            if (removed.length > 0)
              this._changed(11);
            return removed;
          },
          clear: "#removeChildren",
          reverseChildren: function() {
            if (this._children) {
              this._children.reverse();
              for (var i2 = 0, l2 = this._children.length; i2 < l2; i2++)
                this._children[i2]._index = i2;
              this._changed(11);
            }
          },
          isEmpty: function(recursively) {
            var children = this._children;
            var numChildren = children ? children.length : 0;
            if (recursively) {
              for (var i2 = 0; i2 < numChildren; i2++) {
                if (!children[i2].isEmpty(recursively)) {
                  return false;
                }
              }
              return true;
            }
            return !numChildren;
          },
          isEditable: function() {
            var item = this;
            while (item) {
              if (!item._visible || item._locked)
                return false;
              item = item._parent;
            }
            return true;
          },
          hasFill: function() {
            return this.getStyle().hasFill();
          },
          hasStroke: function() {
            return this.getStyle().hasStroke();
          },
          hasShadow: function() {
            return this.getStyle().hasShadow();
          },
          _getOrder: function(item) {
            function getList(item2) {
              var list = [];
              do {
                list.unshift(item2);
              } while (item2 = item2._parent);
              return list;
            }
            var list1 = getList(this), list2 = getList(item);
            for (var i2 = 0, l2 = Math.min(list1.length, list2.length); i2 < l2; i2++) {
              if (list1[i2] != list2[i2]) {
                return list1[i2]._index < list2[i2]._index ? 1 : -1;
              }
            }
            return 0;
          },
          hasChildren: function() {
            return this._children && this._children.length > 0;
          },
          isInserted: function() {
            return this._parent ? this._parent.isInserted() : false;
          },
          isAbove: function(item) {
            return this._getOrder(item) === -1;
          },
          isBelow: function(item) {
            return this._getOrder(item) === 1;
          },
          isParent: function(item) {
            return this._parent === item;
          },
          isChild: function(item) {
            return item && item._parent === this;
          },
          isDescendant: function(item) {
            var parent = this;
            while (parent = parent._parent) {
              if (parent === item)
                return true;
            }
            return false;
          },
          isAncestor: function(item) {
            return item ? item.isDescendant(this) : false;
          },
          isSibling: function(item) {
            return this._parent === item._parent;
          },
          isGroupedWith: function(item) {
            var parent = this._parent;
            while (parent) {
              if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent))
                return true;
              parent = parent._parent;
            }
            return false;
          }
        }, Base.each(["rotate", "scale", "shear", "skew"], function(key) {
          var rotate = key === "rotate";
          this[key] = function() {
            var args = arguments, value = (rotate ? Base : Point).read(args), center = Point.read(args, 0, { readNull: true });
            return this.transform(new Matrix()[key](value, center || this.getPosition(true)));
          };
        }, {
          translate: function() {
            var mx = new Matrix();
            return this.transform(mx.translate.apply(mx, arguments));
          },
          transform: function(matrix, _applyRecursively, _setApplyMatrix) {
            var _matrix = this._matrix, transformMatrix = matrix && !matrix.isIdentity(), applyMatrix = _setApplyMatrix && this._canApplyMatrix || this._applyMatrix && (transformMatrix || !_matrix.isIdentity() || _applyRecursively && this._children);
            if (!transformMatrix && !applyMatrix)
              return this;
            if (transformMatrix) {
              if (!matrix.isInvertible() && _matrix.isInvertible())
                _matrix._backup = _matrix.getValues();
              _matrix.prepend(matrix, true);
              var style = this._style, fillColor = style.getFillColor(true), strokeColor = style.getStrokeColor(true);
              if (fillColor)
                fillColor.transform(matrix);
              if (strokeColor)
                strokeColor.transform(matrix);
            }
            if (applyMatrix && (applyMatrix = this._transformContent(_matrix, _applyRecursively, _setApplyMatrix))) {
              var pivot = this._pivot;
              if (pivot)
                _matrix._transformPoint(pivot, pivot, true);
              _matrix.reset(true);
              if (_setApplyMatrix && this._canApplyMatrix)
                this._applyMatrix = true;
            }
            var bounds = this._bounds, position = this._position;
            if (transformMatrix || applyMatrix) {
              this._changed(25);
            }
            var decomp = transformMatrix && bounds && matrix.decompose();
            if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
              for (var key in bounds) {
                var cache = bounds[key];
                if (cache.nonscaling) {
                  delete bounds[key];
                } else if (applyMatrix || !cache.internal) {
                  var rect = cache.rect;
                  matrix._transformBounds(rect, rect);
                }
              }
              this._bounds = bounds;
              var cached = bounds[this._getBoundsCacheKey(this._boundsOptions || {})];
              if (cached) {
                this._position = this._getPositionFromBounds(cached.rect);
              }
            } else if (transformMatrix && position && this._pivot) {
              this._position = matrix._transformPoint(position, position);
            }
            return this;
          },
          _transformContent: function(matrix, applyRecursively, setApplyMatrix) {
            var children = this._children;
            if (children) {
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
                children[i2].transform(matrix, applyRecursively, setApplyMatrix);
              }
              return true;
            }
          },
          globalToLocal: function() {
            return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
          },
          localToGlobal: function() {
            return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
          },
          parentToLocal: function() {
            return this._matrix._inverseTransform(Point.read(arguments));
          },
          localToParent: function() {
            return this._matrix._transformPoint(Point.read(arguments));
          },
          fitBounds: function(rectangle, fill) {
            rectangle = Rectangle.read(arguments);
            var bounds = this.getBounds(), itemRatio = bounds.height / bounds.width, rectRatio = rectangle.height / rectangle.width, scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height, newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
            newBounds.setCenter(rectangle.getCenter());
            this.setBounds(newBounds);
          }
        }), {
          _setStyles: function(ctx, param, viewMatrix) {
            var style = this._style, matrix = this._matrix;
            if (style.hasFill()) {
              ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
            }
            if (style.hasStroke()) {
              ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
              ctx.lineWidth = style.getStrokeWidth();
              var strokeJoin = style.getStrokeJoin(), strokeCap = style.getStrokeCap(), miterLimit = style.getMiterLimit();
              if (strokeJoin)
                ctx.lineJoin = strokeJoin;
              if (strokeCap)
                ctx.lineCap = strokeCap;
              if (miterLimit)
                ctx.miterLimit = miterLimit;
              if (paper2.support.nativeDash) {
                var dashArray = style.getDashArray(), dashOffset = style.getDashOffset();
                if (dashArray && dashArray.length) {
                  if ("setLineDash" in ctx) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashOffset;
                  } else {
                    ctx.mozDash = dashArray;
                    ctx.mozDashOffset = dashOffset;
                  }
                }
              }
            }
            if (style.hasShadow()) {
              var pixelRatio = param.pixelRatio || 1, mx = viewMatrix._shiftless().prepend(new Matrix().scale(pixelRatio, pixelRatio)), blur = mx.transform(new Point(style.getShadowBlur(), 0)), offset = mx.transform(this.getShadowOffset());
              ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
              ctx.shadowBlur = blur.getLength();
              ctx.shadowOffsetX = offset.x;
              ctx.shadowOffsetY = offset.y;
            }
          },
          draw: function(ctx, param, parentStrokeMatrix) {
            var updateVersion = this._updateVersion = this._project._updateVersion;
            if (!this._visible || this._opacity === 0)
              return;
            var matrices = param.matrices, viewMatrix = param.viewMatrix, matrix = this._matrix, globalMatrix = matrices[matrices.length - 1].appended(matrix);
            if (!globalMatrix.isInvertible())
              return;
            viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix) : globalMatrix;
            matrices.push(globalMatrix);
            if (param.updateMatrix) {
              this._globalMatrix = globalMatrix;
            }
            var blendMode = this._blendMode, opacity = Numerical.clamp(this._opacity, 0, 1), normalBlend = blendMode === "normal", nativeBlend = BlendMode.nativeModes[blendMode], direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(), pixelRatio = param.pixelRatio || 1, mainCtx, itemOffset, prevOffset;
            if (!direct) {
              var bounds = this.getStrokeBounds(viewMatrix);
              if (!bounds.width || !bounds.height) {
                matrices.pop();
                return;
              }
              prevOffset = param.offset;
              itemOffset = param.offset = bounds.getTopLeft().floor();
              mainCtx = ctx;
              ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
              if (pixelRatio !== 1)
                ctx.scale(pixelRatio, pixelRatio);
            }
            ctx.save();
            var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.appended(matrix) : this._canScaleStroke && !this.getStrokeScaling(true) && viewMatrix, clip = !direct && param.clipItem, transform = !strokeMatrix || clip;
            if (direct) {
              ctx.globalAlpha = opacity;
              if (nativeBlend)
                ctx.globalCompositeOperation = blendMode;
            } else if (transform) {
              ctx.translate(-itemOffset.x, -itemOffset.y);
            }
            if (transform) {
              (direct ? matrix : viewMatrix).applyToContext(ctx);
            }
            if (clip) {
              param.clipItem.draw(ctx, param.extend({ clip: true }));
            }
            if (strokeMatrix) {
              ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
              var offset = param.offset;
              if (offset)
                ctx.translate(-offset.x, -offset.y);
            }
            this._draw(ctx, param, viewMatrix, strokeMatrix);
            ctx.restore();
            matrices.pop();
            if (param.clip && !param.dontFinish) {
              ctx.clip(this.getFillRule());
            }
            if (!direct) {
              BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
              CanvasProvider.release(ctx);
              param.offset = prevOffset;
            }
          },
          _isUpdated: function(updateVersion) {
            var parent = this._parent;
            if (parent instanceof CompoundPath)
              return parent._isUpdated(updateVersion);
            var updated = this._updateVersion === updateVersion;
            if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
              this._updateVersion = updateVersion;
              updated = true;
            }
            return updated;
          },
          _drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
            var selection = this._selection, itemSelected = selection & 1, boundsSelected = selection & 2 || itemSelected && this._selectBounds, positionSelected = selection & 4;
            if (!this._drawSelected)
              itemSelected = false;
            if ((itemSelected || boundsSelected || positionSelected) && this._isUpdated(updateVersion)) {
              var layer, color = this.getSelectedColor(true) || (layer = this.getLayer()) && layer.getSelectedColor(true), mx = matrix.appended(this.getGlobalMatrix(true)), half = size / 2;
              ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : "#009dec";
              if (itemSelected)
                this._drawSelected(ctx, mx, selectionItems);
              if (positionSelected) {
                var pos = this.getPosition(true), parent = this._parent, point = parent ? parent.localToGlobal(pos) : pos, x2 = point.x, y2 = point.y;
                ctx.beginPath();
                ctx.arc(x2, y2, half, 0, Math.PI * 2, true);
                ctx.stroke();
                var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]], start = half, end = size + 1;
                for (var i2 = 0; i2 < 4; i2++) {
                  var delta = deltas[i2], dx = delta[0], dy = delta[1];
                  ctx.moveTo(x2 + dx * start, y2 + dy * start);
                  ctx.lineTo(x2 + dx * end, y2 + dy * end);
                  ctx.stroke();
                }
              }
              if (boundsSelected) {
                var coords = mx._transformCorners(this.getInternalBounds());
                ctx.beginPath();
                for (var i2 = 0; i2 < 8; i2++) {
                  ctx[!i2 ? "moveTo" : "lineTo"](coords[i2], coords[++i2]);
                }
                ctx.closePath();
                ctx.stroke();
                for (var i2 = 0; i2 < 8; i2++) {
                  ctx.fillRect(coords[i2] - half, coords[++i2] - half, size, size);
                }
              }
            }
          },
          _canComposite: function() {
            return false;
          }
        }, Base.each(["down", "drag", "up", "move"], function(key) {
          this["removeOn" + Base.capitalize(key)] = function() {
            var hash = {};
            hash[key] = true;
            return this.removeOn(hash);
          };
        }, {
          removeOn: function(obj) {
            for (var name in obj) {
              if (obj[name]) {
                var key = "mouse" + name, project = this._project, sets = project._removeSets = project._removeSets || {};
                sets[key] = sets[key] || {};
                sets[key][this._id] = this;
              }
            }
            return this;
          }
        }), {
          tween: function(from, to2, options) {
            if (!options) {
              options = to2;
              to2 = from;
              from = null;
              if (!options) {
                options = to2;
                to2 = null;
              }
            }
            var easing = options && options.easing, start = options && options.start, duration = options != null && (typeof options === "number" ? options : options.duration), tween = new Tween(this, from, to2, duration, easing, start);
            function onFrame(event) {
              tween._handleFrame(event.time * 1e3);
              if (!tween.running) {
                this.off("frame", onFrame);
              }
            }
            if (duration) {
              this.on("frame", onFrame);
            }
            return tween;
          },
          tweenTo: function(to2, options) {
            return this.tween(null, to2, options);
          },
          tweenFrom: function(from, options) {
            return this.tween(from, null, options);
          }
        });
        var Group = Item.extend({
          _class: "Group",
          _selectBounds: false,
          _selectChildren: true,
          _serializeFields: {
            children: []
          },
          initialize: function Group2(arg) {
            this._children = [];
            this._namedChildren = {};
            if (!this._initialize(arg))
              this.addChildren(Array.isArray(arg) ? arg : arguments);
          },
          _changed: function _changed(flags) {
            _changed.base.call(this, flags);
            if (flags & 2050) {
              this._clipItem = undefined2;
            }
          },
          _getClipItem: function() {
            var clipItem = this._clipItem;
            if (clipItem === undefined2) {
              clipItem = null;
              var children = this._children;
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
                if (children[i2]._clipMask) {
                  clipItem = children[i2];
                  break;
                }
              }
              this._clipItem = clipItem;
            }
            return clipItem;
          },
          isClipped: function() {
            return !!this._getClipItem();
          },
          setClipped: function(clipped) {
            var child = this.getFirstChild();
            if (child)
              child.setClipMask(clipped);
          },
          _getBounds: function _getBounds(matrix, options) {
            var clipItem = this._getClipItem();
            return clipItem ? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix), Base.set({}, options, { stroke: false })) : _getBounds.base.call(this, matrix, options);
          },
          _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
            var clipItem = this._getClipItem();
            return (!clipItem || clipItem.contains(point)) && _hitTestChildren.base.call(this, point, options, viewMatrix, clipItem);
          },
          _draw: function(ctx, param) {
            var clip = param.clip, clipItem = !clip && this._getClipItem();
            param = param.extend({ clipItem, clip: false });
            if (clip) {
              ctx.beginPath();
              param.dontStart = param.dontFinish = true;
            } else if (clipItem) {
              clipItem.draw(ctx, param.extend({ clip: true }));
            }
            var children = this._children;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              var item = children[i2];
              if (item !== clipItem)
                item.draw(ctx, param);
            }
          }
        });
        var Layer = Group.extend({
          _class: "Layer",
          initialize: function Layer2() {
            Group.apply(this, arguments);
          },
          _getOwner: function() {
            return this._parent || this._index != null && this._project;
          },
          isInserted: function isInserted() {
            return this._parent ? isInserted.base.call(this) : this._index != null;
          },
          activate: function() {
            this._project._activeLayer = this;
          },
          _hitTestSelf: function() {
          }
        });
        var Shape = Item.extend({
          _class: "Shape",
          _applyMatrix: false,
          _canApplyMatrix: false,
          _canScaleStroke: true,
          _serializeFields: {
            type: null,
            size: null,
            radius: null
          },
          initialize: function Shape2(props, point) {
            this._initialize(props, point);
          },
          _equals: function(item) {
            return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
          },
          copyContent: function(source) {
            this.setType(source._type);
            this.setSize(source._size);
            this.setRadius(source._radius);
          },
          getType: function() {
            return this._type;
          },
          setType: function(type) {
            this._type = type;
          },
          getShape: "#getType",
          setShape: "#setType",
          getSize: function() {
            var size = this._size;
            return new LinkedSize(size.width, size.height, this, "setSize");
          },
          setSize: function() {
            var size = Size.read(arguments);
            if (!this._size) {
              this._size = size.clone();
            } else if (!this._size.equals(size)) {
              var type = this._type, width = size.width, height = size.height;
              if (type === "rectangle") {
                this._radius.set(Size.min(this._radius, size.divide(2).abs()));
              } else if (type === "circle") {
                width = height = (width + height) / 2;
                this._radius = width / 2;
              } else if (type === "ellipse") {
                this._radius._set(width / 2, height / 2);
              }
              this._size._set(width, height);
              this._changed(9);
            }
          },
          getRadius: function() {
            var rad = this._radius;
            return this._type === "circle" ? rad : new LinkedSize(rad.width, rad.height, this, "setRadius");
          },
          setRadius: function(radius) {
            var type = this._type;
            if (type === "circle") {
              if (radius === this._radius)
                return;
              var size = radius * 2;
              this._radius = radius;
              this._size._set(size, size);
            } else {
              radius = Size.read(arguments);
              if (!this._radius) {
                this._radius = radius.clone();
              } else {
                if (this._radius.equals(radius))
                  return;
                this._radius.set(radius);
                if (type === "rectangle") {
                  var size = Size.max(this._size, radius.multiply(2));
                  this._size.set(size);
                } else if (type === "ellipse") {
                  this._size._set(radius.width * 2, radius.height * 2);
                }
              }
            }
            this._changed(9);
          },
          isEmpty: function() {
            return false;
          },
          toPath: function(insert) {
            var path = new Path[Base.capitalize(this._type)]({
              center: new Point(),
              size: this._size,
              radius: this._radius,
              insert: false
            });
            path.copyAttributes(this);
            if (paper2.settings.applyMatrix)
              path.setApplyMatrix(true);
            if (insert === undefined2 || insert)
              path.insertAbove(this);
            return path;
          },
          toShape: "#clone",
          _asPathItem: function() {
            return this.toPath(false);
          },
          _draw: function(ctx, param, viewMatrix, strokeMatrix) {
            var style = this._style, hasFill = style.hasFill(), hasStroke = style.hasStroke(), dontPaint = param.dontFinish || param.clip, untransformed = !strokeMatrix;
            if (hasFill || hasStroke || dontPaint) {
              var type = this._type, radius = this._radius, isCircle = type === "circle";
              if (!param.dontStart)
                ctx.beginPath();
              if (untransformed && isCircle) {
                ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
              } else {
                var rx = isCircle ? radius : radius.width, ry = isCircle ? radius : radius.height, size = this._size, width = size.width, height = size.height;
                if (untransformed && type === "rectangle" && rx === 0 && ry === 0) {
                  ctx.rect(-width / 2, -height / 2, width, height);
                } else {
                  var x2 = width / 2, y2 = height / 2, kappa = 1 - 0.5522847498307936, cx = rx * kappa, cy = ry * kappa, c2 = [
                    -x2,
                    -y2 + ry,
                    -x2,
                    -y2 + cy,
                    -x2 + cx,
                    -y2,
                    -x2 + rx,
                    -y2,
                    x2 - rx,
                    -y2,
                    x2 - cx,
                    -y2,
                    x2,
                    -y2 + cy,
                    x2,
                    -y2 + ry,
                    x2,
                    y2 - ry,
                    x2,
                    y2 - cy,
                    x2 - cx,
                    y2,
                    x2 - rx,
                    y2,
                    -x2 + rx,
                    y2,
                    -x2 + cx,
                    y2,
                    -x2,
                    y2 - cy,
                    -x2,
                    y2 - ry
                  ];
                  if (strokeMatrix)
                    strokeMatrix.transform(c2, c2, 32);
                  ctx.moveTo(c2[0], c2[1]);
                  ctx.bezierCurveTo(c2[2], c2[3], c2[4], c2[5], c2[6], c2[7]);
                  if (x2 !== rx)
                    ctx.lineTo(c2[8], c2[9]);
                  ctx.bezierCurveTo(c2[10], c2[11], c2[12], c2[13], c2[14], c2[15]);
                  if (y2 !== ry)
                    ctx.lineTo(c2[16], c2[17]);
                  ctx.bezierCurveTo(c2[18], c2[19], c2[20], c2[21], c2[22], c2[23]);
                  if (x2 !== rx)
                    ctx.lineTo(c2[24], c2[25]);
                  ctx.bezierCurveTo(c2[26], c2[27], c2[28], c2[29], c2[30], c2[31]);
                }
              }
              ctx.closePath();
            }
            if (!dontPaint && (hasFill || hasStroke)) {
              this._setStyles(ctx, param, viewMatrix);
              if (hasFill) {
                ctx.fill(style.getFillRule());
                ctx.shadowColor = "rgba(0,0,0,0)";
              }
              if (hasStroke)
                ctx.stroke();
            }
          },
          _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
          },
          _getBounds: function(matrix, options) {
            var rect = new Rectangle(this._size).setCenter(0, 0), style = this._style, strokeWidth = options.stroke && style.hasStroke() && style.getStrokeWidth();
            if (matrix)
              rect = matrix._transformBounds(rect);
            return strokeWidth ? rect.expand(Path._getStrokePadding(strokeWidth, this._getStrokeMatrix(matrix, options))) : rect;
          }
        }, new function() {
          function getCornerCenter(that, point, expand) {
            var radius = that._radius;
            if (!radius.isZero()) {
              var halfSize = that._size.divide(2);
              for (var q2 = 1; q2 <= 4; q2++) {
                var dir = new Point(q2 > 1 && q2 < 4 ? -1 : 1, q2 > 2 ? -1 : 1), corner = dir.multiply(halfSize), center = corner.subtract(dir.multiply(radius)), rect = new Rectangle(expand ? corner.add(dir.multiply(expand)) : corner, center);
                if (rect.contains(point))
                  return { point: center, quadrant: q2 };
              }
            }
          }
          function isOnEllipseStroke(point, radius, padding, quadrant) {
            var vector = point.divide(radius);
            return (!quadrant || vector.isInQuadrant(quadrant)) && vector.subtract(vector.normalize()).multiply(radius).divide(padding).length <= 1;
          }
          return {
            _contains: function _contains(point) {
              if (this._type === "rectangle") {
                var center = getCornerCenter(this, point);
                return center ? point.subtract(center.point).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
              } else {
                return point.divide(this.size).getLength() <= 0.5;
              }
            },
            _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {
              var hit = false, style = this._style, hitStroke = options.stroke && style.hasStroke(), hitFill = options.fill && style.hasFill();
              if (hitStroke || hitFill) {
                var type = this._type, radius = this._radius, strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0, strokePadding = options._tolerancePadding.add(Path._getStrokePadding(strokeRadius, !style.getStrokeScaling() && strokeMatrix));
                if (type === "rectangle") {
                  var padding = strokePadding.multiply(2), center = getCornerCenter(this, point, padding);
                  if (center) {
                    hit = isOnEllipseStroke(point.subtract(center.point), radius, strokePadding, center.quadrant);
                  } else {
                    var rect = new Rectangle(this._size).setCenter(0, 0), outer = rect.expand(padding), inner = rect.expand(padding.negate());
                    hit = outer._containsPoint(point) && !inner._containsPoint(point);
                  }
                } else {
                  hit = isOnEllipseStroke(point, radius, strokePadding);
                }
              }
              return hit ? new HitResult(hitStroke ? "stroke" : "fill", this) : _hitTestSelf.base.apply(this, arguments);
            }
          };
        }(), {
          statics: new function() {
            function createShape(type, point, size, radius, args) {
              var item = Base.create(Shape.prototype);
              item._type = type;
              item._size = size;
              item._radius = radius;
              item._initialize(Base.getNamed(args), point);
              return item;
            }
            return {
              Circle: function() {
                var args = arguments, center = Point.readNamed(args, "center"), radius = Base.readNamed(args, "radius");
                return createShape("circle", center, new Size(radius * 2), radius, args);
              },
              Rectangle: function() {
                var args = arguments, rect = Rectangle.readNamed(args, "rectangle"), radius = Size.min(Size.readNamed(args, "radius"), rect.getSize(true).divide(2));
                return createShape("rectangle", rect.getCenter(true), rect.getSize(true), radius, args);
              },
              Ellipse: function() {
                var args = arguments, ellipse = Shape._readEllipse(args), radius = ellipse.radius;
                return createShape("ellipse", ellipse.center, radius.multiply(2), radius, args);
              },
              _readEllipse: function(args) {
                var center, radius;
                if (Base.hasNamed(args, "radius")) {
                  center = Point.readNamed(args, "center");
                  radius = Size.readNamed(args, "radius");
                } else {
                  var rect = Rectangle.readNamed(args, "rectangle");
                  center = rect.getCenter(true);
                  radius = rect.getSize(true).divide(2);
                }
                return { center, radius };
              }
            };
          }()
        });
        var Raster = Item.extend({
          _class: "Raster",
          _applyMatrix: false,
          _canApplyMatrix: false,
          _boundsOptions: { stroke: false, handle: false },
          _serializeFields: {
            crossOrigin: null,
            source: null
          },
          _prioritize: ["crossOrigin"],
          _smoothing: "low",
          beans: true,
          initialize: function Raster2(source, position) {
            if (!this._initialize(source, position !== undefined2 && Point.read(arguments))) {
              var image, type = typeof source, object = type === "string" ? document2.getElementById(source) : type === "object" ? source : null;
              if (object && object !== Item.NO_INSERT) {
                if (object.getContext || object.naturalHeight != null) {
                  image = object;
                } else if (object) {
                  var size = Size.read(arguments);
                  if (!size.isZero()) {
                    image = CanvasProvider.getCanvas(size);
                  }
                }
              }
              if (image) {
                this.setImage(image);
              } else {
                this.setSource(source);
              }
            }
            if (!this._size) {
              this._size = new Size();
              this._loaded = false;
            }
          },
          _equals: function(item) {
            return this.getSource() === item.getSource();
          },
          copyContent: function(source) {
            var image = source._image, canvas2 = source._canvas;
            if (image) {
              this._setImage(image);
            } else if (canvas2) {
              var copyCanvas = CanvasProvider.getCanvas(source._size);
              copyCanvas.getContext("2d").drawImage(canvas2, 0, 0);
              this._setImage(copyCanvas);
            }
            this._crossOrigin = source._crossOrigin;
          },
          getSize: function() {
            var size = this._size;
            return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, "setSize");
          },
          setSize: function(_size, _clear) {
            var size = Size.read(arguments);
            if (!size.equals(this._size)) {
              if (size.width > 0 && size.height > 0) {
                var element = !_clear && this.getElement();
                this._setImage(CanvasProvider.getCanvas(size));
                if (element) {
                  this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
                }
              } else {
                if (this._canvas)
                  CanvasProvider.release(this._canvas);
                this._size = size.clone();
              }
            } else if (_clear) {
              this.clear();
            }
          },
          getWidth: function() {
            return this._size ? this._size.width : 0;
          },
          setWidth: function(width) {
            this.setSize(width, this.getHeight());
          },
          getHeight: function() {
            return this._size ? this._size.height : 0;
          },
          setHeight: function(height) {
            this.setSize(this.getWidth(), height);
          },
          getLoaded: function() {
            return this._loaded;
          },
          isEmpty: function() {
            var size = this._size;
            return !size || size.width === 0 && size.height === 0;
          },
          getResolution: function() {
            var matrix = this._matrix, orig = new Point(0, 0).transform(matrix), u2 = new Point(1, 0).transform(matrix).subtract(orig), v2 = new Point(0, 1).transform(matrix).subtract(orig);
            return new Size(72 / u2.getLength(), 72 / v2.getLength());
          },
          getPpi: "#getResolution",
          getImage: function() {
            return this._image;
          },
          setImage: function(image) {
            var that = this;
            function emit(event) {
              var view = that.getView(), type = event && event.type || "load";
              if (view && that.responds(type)) {
                paper2 = view._scope;
                that.emit(type, new Event(event));
              }
            }
            this._setImage(image);
            if (this._loaded) {
              setTimeout(emit, 0);
            } else if (image) {
              DomEvent.add(image, {
                load: function(event) {
                  that._setImage(image);
                  emit(event);
                },
                error: emit
              });
            }
          },
          _setImage: function(image) {
            if (this._canvas)
              CanvasProvider.release(this._canvas);
            if (image && image.getContext) {
              this._image = null;
              this._canvas = image;
              this._loaded = true;
            } else {
              this._image = image;
              this._canvas = null;
              this._loaded = !!(image && image.src && image.complete);
            }
            this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
            this._context = null;
            this._changed(1033);
          },
          getCanvas: function() {
            if (!this._canvas) {
              var ctx = CanvasProvider.getContext(this._size);
              try {
                if (this._image)
                  ctx.drawImage(this._image, 0, 0);
                this._canvas = ctx.canvas;
              } catch (e4) {
                CanvasProvider.release(ctx);
              }
            }
            return this._canvas;
          },
          setCanvas: "#setImage",
          getContext: function(_change) {
            if (!this._context)
              this._context = this.getCanvas().getContext("2d");
            if (_change) {
              this._image = null;
              this._changed(1025);
            }
            return this._context;
          },
          setContext: function(context) {
            this._context = context;
          },
          getSource: function() {
            var image = this._image;
            return image && image.src || this.toDataURL();
          },
          setSource: function(src) {
            var image = new self2.Image(), crossOrigin = this._crossOrigin;
            if (crossOrigin)
              image.crossOrigin = crossOrigin;
            if (src)
              image.src = src;
            this.setImage(image);
          },
          getCrossOrigin: function() {
            var image = this._image;
            return image && image.crossOrigin || this._crossOrigin || "";
          },
          setCrossOrigin: function(crossOrigin) {
            this._crossOrigin = crossOrigin;
            var image = this._image;
            if (image)
              image.crossOrigin = crossOrigin;
          },
          getSmoothing: function() {
            return this._smoothing;
          },
          setSmoothing: function(smoothing) {
            this._smoothing = typeof smoothing === "string" ? smoothing : smoothing ? "low" : "off";
            this._changed(257);
          },
          getElement: function() {
            return this._canvas || this._loaded && this._image;
          }
        }, {
          beans: false,
          getSubCanvas: function() {
            var rect = Rectangle.read(arguments), ctx = CanvasProvider.getContext(rect.getSize());
            ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
            return ctx.canvas;
          },
          getSubRaster: function() {
            var rect = Rectangle.read(arguments), raster = new Raster(Item.NO_INSERT);
            raster._setImage(this.getSubCanvas(rect));
            raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
            raster._matrix.prepend(this._matrix);
            raster.insertAbove(this);
            return raster;
          },
          toDataURL: function() {
            var image = this._image, src = image && image.src;
            if (/^data:/.test(src))
              return src;
            var canvas2 = this.getCanvas();
            return canvas2 ? canvas2.toDataURL.apply(canvas2, arguments) : null;
          },
          drawImage: function(image) {
            var point = Point.read(arguments, 1);
            this.getContext(true).drawImage(image, point.x, point.y);
          },
          getAverageColor: function(object) {
            var bounds, path;
            if (!object) {
              bounds = this.getBounds();
            } else if (object instanceof PathItem) {
              path = object;
              bounds = object.getBounds();
            } else if (typeof object === "object") {
              if ("width" in object) {
                bounds = new Rectangle(object);
              } else if ("x" in object) {
                bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
              }
            }
            if (!bounds)
              return null;
            var sampleSize = 32, width = Math.min(bounds.width, sampleSize), height = Math.min(bounds.height, sampleSize);
            var ctx = Raster._sampleContext;
            if (!ctx) {
              ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
            } else {
              ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
            }
            ctx.save();
            var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
            matrix.applyToContext(ctx);
            if (path)
              path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
            this._matrix.applyToContext(ctx);
            var element = this.getElement(), size = this._size;
            if (element)
              ctx.drawImage(element, -size.width / 2, -size.height / 2);
            ctx.restore();
            var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data, channels = [0, 0, 0], total = 0;
            for (var i2 = 0, l2 = pixels.length; i2 < l2; i2 += 4) {
              var alpha = pixels[i2 + 3];
              total += alpha;
              alpha /= 255;
              channels[0] += pixels[i2] * alpha;
              channels[1] += pixels[i2 + 1] * alpha;
              channels[2] += pixels[i2 + 2] * alpha;
            }
            for (var i2 = 0; i2 < 3; i2++)
              channels[i2] /= total;
            return total ? Color.read(channels) : null;
          },
          getPixel: function() {
            var point = Point.read(arguments);
            var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
            return new Color("rgb", [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255);
          },
          setPixel: function() {
            var args = arguments, point = Point.read(args), color = Color.read(args), components = color._convert("rgb"), alpha = color._alpha, ctx = this.getContext(true), imageData = ctx.createImageData(1, 1), data = imageData.data;
            data[0] = components[0] * 255;
            data[1] = components[1] * 255;
            data[2] = components[2] * 255;
            data[3] = alpha != null ? alpha * 255 : 255;
            ctx.putImageData(imageData, point.x, point.y);
          },
          clear: function() {
            var size = this._size;
            this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
          },
          createImageData: function() {
            var size = Size.read(arguments);
            return this.getContext().createImageData(size.width, size.height);
          },
          getImageData: function() {
            var rect = Rectangle.read(arguments);
            if (rect.isEmpty())
              rect = new Rectangle(this._size);
            return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
          },
          setImageData: function(data) {
            var point = Point.read(arguments, 1);
            this.getContext(true).putImageData(data, point.x, point.y);
          },
          _getBounds: function(matrix, options) {
            var rect = new Rectangle(this._size).setCenter(0, 0);
            return matrix ? matrix._transformBounds(rect) : rect;
          },
          _hitTestSelf: function(point) {
            if (this._contains(point)) {
              var that = this;
              return new HitResult("pixel", that, {
                offset: point.add(that._size.divide(2)).round(),
                color: {
                  get: function() {
                    return that.getPixel(this.offset);
                  }
                }
              });
            }
          },
          _draw: function(ctx, param, viewMatrix) {
            var element = this.getElement();
            if (element && element.width > 0 && element.height > 0) {
              ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);
              this._setStyles(ctx, param, viewMatrix);
              var smoothing = this._smoothing, disabled = smoothing === "off";
              DomElement.setPrefixed(ctx, disabled ? "imageSmoothingEnabled" : "imageSmoothingQuality", disabled ? false : smoothing);
              ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
            }
          },
          _canComposite: function() {
            return true;
          }
        });
        var SymbolItem = Item.extend({
          _class: "SymbolItem",
          _applyMatrix: false,
          _canApplyMatrix: false,
          _boundsOptions: { stroke: true },
          _serializeFields: {
            symbol: null
          },
          initialize: function SymbolItem2(arg0, arg1) {
            if (!this._initialize(arg0, arg1 !== undefined2 && Point.read(arguments, 1)))
              this.setDefinition(arg0 instanceof SymbolDefinition ? arg0 : new SymbolDefinition(arg0));
          },
          _equals: function(item) {
            return this._definition === item._definition;
          },
          copyContent: function(source) {
            this.setDefinition(source._definition);
          },
          getDefinition: function() {
            return this._definition;
          },
          setDefinition: function(definition) {
            this._definition = definition;
            this._changed(9);
          },
          getSymbol: "#getDefinition",
          setSymbol: "#setDefinition",
          isEmpty: function() {
            return this._definition._item.isEmpty();
          },
          _getBounds: function(matrix, options) {
            var item = this._definition._item;
            return item._getCachedBounds(item._matrix.prepended(matrix), options);
          },
          _hitTestSelf: function(point, options, viewMatrix) {
            var opts = options.extend({ all: false });
            var res = this._definition._item._hitTest(point, opts, viewMatrix);
            if (res)
              res.item = this;
            return res;
          },
          _draw: function(ctx, param) {
            this._definition._item.draw(ctx, param);
          }
        });
        var SymbolDefinition = Base.extend({
          _class: "SymbolDefinition",
          initialize: function SymbolDefinition2(item, dontCenter) {
            this._id = UID.get();
            this.project = paper2.project;
            if (item)
              this.setItem(item, dontCenter);
          },
          _serialize: function(options, dictionary) {
            return dictionary.add(this, function() {
              return Base.serialize([this._class, this._item], options, false, dictionary);
            });
          },
          _changed: function(flags) {
            if (flags & 8)
              Item._clearBoundsCache(this);
            if (flags & 1)
              this.project._changed(flags);
          },
          getItem: function() {
            return this._item;
          },
          setItem: function(item, _dontCenter) {
            if (item._symbol)
              item = item.clone();
            if (this._item)
              this._item._symbol = null;
            this._item = item;
            item.remove();
            item.setSelected(false);
            if (!_dontCenter)
              item.setPosition(new Point());
            item._symbol = this;
            this._changed(9);
          },
          getDefinition: "#getItem",
          setDefinition: "#setItem",
          place: function(position) {
            return new SymbolItem(this, position);
          },
          clone: function() {
            return new SymbolDefinition(this._item.clone(false));
          },
          equals: function(symbol) {
            return symbol === this || symbol && this._item.equals(symbol._item) || false;
          }
        });
        var HitResult = Base.extend({
          _class: "HitResult",
          initialize: function HitResult2(type, item, values) {
            this.type = type;
            this.item = item;
            if (values)
              this.inject(values);
          },
          statics: {
            getOptions: function(args) {
              var options = args && Base.read(args);
              return new Base({
                type: null,
                tolerance: paper2.settings.hitTolerance,
                fill: !options,
                stroke: !options,
                segments: !options,
                handles: false,
                ends: false,
                position: false,
                center: false,
                bounds: false,
                guides: false,
                selected: false
              }, options);
            }
          }
        });
        var Segment = Base.extend({
          _class: "Segment",
          beans: true,
          _selection: 0,
          initialize: function Segment2(arg0, arg1, arg2, arg3, arg4, arg5) {
            var count = arguments.length, point, handleIn, handleOut, selection;
            if (count > 0) {
              if (arg0 == null || typeof arg0 === "object") {
                if (count === 1 && arg0 && "point" in arg0) {
                  point = arg0.point;
                  handleIn = arg0.handleIn;
                  handleOut = arg0.handleOut;
                  selection = arg0.selection;
                } else {
                  point = arg0;
                  handleIn = arg1;
                  handleOut = arg2;
                  selection = arg3;
                }
              } else {
                point = [arg0, arg1];
                handleIn = arg2 !== undefined2 ? [arg2, arg3] : null;
                handleOut = arg4 !== undefined2 ? [arg4, arg5] : null;
              }
            }
            new SegmentPoint(point, this, "_point");
            new SegmentPoint(handleIn, this, "_handleIn");
            new SegmentPoint(handleOut, this, "_handleOut");
            if (selection)
              this.setSelection(selection);
          },
          _serialize: function(options, dictionary) {
            var point = this._point, selection = this._selection, obj = selection || this.hasHandles() ? [point, this._handleIn, this._handleOut] : point;
            if (selection)
              obj.push(selection);
            return Base.serialize(obj, options, true, dictionary);
          },
          _changed: function(point) {
            var path = this._path;
            if (!path)
              return;
            var curves = path._curves, index = this._index, curve;
            if (curves) {
              if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null))
                curve._changed();
              if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index]))
                curve._changed();
            }
            path._changed(41);
          },
          getPoint: function() {
            return this._point;
          },
          setPoint: function() {
            this._point.set(Point.read(arguments));
          },
          getHandleIn: function() {
            return this._handleIn;
          },
          setHandleIn: function() {
            this._handleIn.set(Point.read(arguments));
          },
          getHandleOut: function() {
            return this._handleOut;
          },
          setHandleOut: function() {
            this._handleOut.set(Point.read(arguments));
          },
          hasHandles: function() {
            return !this._handleIn.isZero() || !this._handleOut.isZero();
          },
          isSmooth: function() {
            var handleIn = this._handleIn, handleOut = this._handleOut;
            return !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut);
          },
          clearHandles: function() {
            this._handleIn._set(0, 0);
            this._handleOut._set(0, 0);
          },
          getSelection: function() {
            return this._selection;
          },
          setSelection: function(selection) {
            var oldSelection = this._selection, path = this._path;
            this._selection = selection = selection || 0;
            if (path && selection !== oldSelection) {
              path._updateSelection(this, oldSelection, selection);
              path._changed(257);
            }
          },
          _changeSelection: function(flag, selected) {
            var selection = this._selection;
            this.setSelection(selected ? selection | flag : selection & ~flag);
          },
          isSelected: function() {
            return !!(this._selection & 7);
          },
          setSelected: function(selected) {
            this._changeSelection(7, selected);
          },
          getIndex: function() {
            return this._index !== undefined2 ? this._index : null;
          },
          getPath: function() {
            return this._path || null;
          },
          getCurve: function() {
            var path = this._path, index = this._index;
            if (path) {
              if (index > 0 && !path._closed && index === path._segments.length - 1)
                index--;
              return path.getCurves()[index] || null;
            }
            return null;
          },
          getLocation: function() {
            var curve = this.getCurve();
            return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
          },
          getNext: function() {
            var segments = this._path && this._path._segments;
            return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
          },
          smooth: function(options, _first, _last) {
            var opts = options || {}, type = opts.type, factor = opts.factor, prev = this.getPrevious(), next = this.getNext(), p0 = (prev || this)._point, p1 = this._point, p2 = (next || this)._point, d1 = p0.getDistance(p1), d2 = p1.getDistance(p2);
            if (!type || type === "catmull-rom") {
              var a2 = factor === undefined2 ? 0.5 : factor, d1_a = Math.pow(d1, a2), d1_2a = d1_a * d1_a, d2_a = Math.pow(d2, a2), d2_2a = d2_a * d2_a;
              if (!_first && prev) {
                var A2 = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a, N2 = 3 * d2_a * (d2_a + d1_a);
                this.setHandleIn(N2 !== 0 ? new Point((d2_2a * p0._x + A2 * p1._x - d1_2a * p2._x) / N2 - p1._x, (d2_2a * p0._y + A2 * p1._y - d1_2a * p2._y) / N2 - p1._y) : new Point());
              }
              if (!_last && next) {
                var A2 = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a, N2 = 3 * d1_a * (d1_a + d2_a);
                this.setHandleOut(N2 !== 0 ? new Point((d1_2a * p2._x + A2 * p1._x - d2_2a * p0._x) / N2 - p1._x, (d1_2a * p2._y + A2 * p1._y - d2_2a * p0._y) / N2 - p1._y) : new Point());
              }
            } else if (type === "geometric") {
              if (prev && next) {
                var vector = p0.subtract(p2), t2 = factor === undefined2 ? 0.4 : factor, k2 = t2 * d1 / (d1 + d2);
                if (!_first)
                  this.setHandleIn(vector.multiply(k2));
                if (!_last)
                  this.setHandleOut(vector.multiply(k2 - t2));
              }
            } else {
              throw new Error("Smoothing method '" + type + "' not supported.");
            }
          },
          getPrevious: function() {
            var segments = this._path && this._path._segments;
            return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
          },
          isFirst: function() {
            return !this._index;
          },
          isLast: function() {
            var path = this._path;
            return path && this._index === path._segments.length - 1 || false;
          },
          reverse: function() {
            var handleIn = this._handleIn, handleOut = this._handleOut, tmp = handleIn.clone();
            handleIn.set(handleOut);
            handleOut.set(tmp);
          },
          reversed: function() {
            return new Segment(this._point, this._handleOut, this._handleIn);
          },
          remove: function() {
            return this._path ? !!this._path.removeSegment(this._index) : false;
          },
          clone: function() {
            return new Segment(this._point, this._handleIn, this._handleOut);
          },
          equals: function(segment) {
            return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
          },
          toString: function() {
            var parts = ["point: " + this._point];
            if (!this._handleIn.isZero())
              parts.push("handleIn: " + this._handleIn);
            if (!this._handleOut.isZero())
              parts.push("handleOut: " + this._handleOut);
            return "{ " + parts.join(", ") + " }";
          },
          transform: function(matrix) {
            this._transformCoordinates(matrix, new Array(6), true);
            this._changed();
          },
          interpolate: function(from, to2, factor) {
            var u2 = 1 - factor, v2 = factor, point1 = from._point, point2 = to2._point, handleIn1 = from._handleIn, handleIn2 = to2._handleIn, handleOut2 = to2._handleOut, handleOut1 = from._handleOut;
            this._point._set(u2 * point1._x + v2 * point2._x, u2 * point1._y + v2 * point2._y, true);
            this._handleIn._set(u2 * handleIn1._x + v2 * handleIn2._x, u2 * handleIn1._y + v2 * handleIn2._y, true);
            this._handleOut._set(u2 * handleOut1._x + v2 * handleOut2._x, u2 * handleOut1._y + v2 * handleOut2._y, true);
            this._changed();
          },
          _transformCoordinates: function(matrix, coords, change) {
            var point = this._point, handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null, handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null, x2 = point._x, y2 = point._y, i2 = 2;
            coords[0] = x2;
            coords[1] = y2;
            if (handleIn) {
              coords[i2++] = handleIn._x + x2;
              coords[i2++] = handleIn._y + y2;
            }
            if (handleOut) {
              coords[i2++] = handleOut._x + x2;
              coords[i2++] = handleOut._y + y2;
            }
            if (matrix) {
              matrix._transformCoordinates(coords, coords, i2 / 2);
              x2 = coords[0];
              y2 = coords[1];
              if (change) {
                point._x = x2;
                point._y = y2;
                i2 = 2;
                if (handleIn) {
                  handleIn._x = coords[i2++] - x2;
                  handleIn._y = coords[i2++] - y2;
                }
                if (handleOut) {
                  handleOut._x = coords[i2++] - x2;
                  handleOut._y = coords[i2++] - y2;
                }
              } else {
                if (!handleIn) {
                  coords[i2++] = x2;
                  coords[i2++] = y2;
                }
                if (!handleOut) {
                  coords[i2++] = x2;
                  coords[i2++] = y2;
                }
              }
            }
            return coords;
          }
        });
        var SegmentPoint = Point.extend({
          initialize: function SegmentPoint2(point, owner, key) {
            var x2, y2, selected;
            if (!point) {
              x2 = y2 = 0;
            } else if ((x2 = point[0]) !== undefined2) {
              y2 = point[1];
            } else {
              var pt2 = point;
              if ((x2 = pt2.x) === undefined2) {
                pt2 = Point.read(arguments);
                x2 = pt2.x;
              }
              y2 = pt2.y;
              selected = pt2.selected;
            }
            this._x = x2;
            this._y = y2;
            this._owner = owner;
            owner[key] = this;
            if (selected)
              this.setSelected(true);
          },
          _set: function(x2, y2) {
            this._x = x2;
            this._y = y2;
            this._owner._changed(this);
            return this;
          },
          getX: function() {
            return this._x;
          },
          setX: function(x2) {
            this._x = x2;
            this._owner._changed(this);
          },
          getY: function() {
            return this._y;
          },
          setY: function(y2) {
            this._y = y2;
            this._owner._changed(this);
          },
          isZero: function() {
            var isZero = Numerical.isZero;
            return isZero(this._x) && isZero(this._y);
          },
          isSelected: function() {
            return !!(this._owner._selection & this._getSelection());
          },
          setSelected: function(selected) {
            this._owner._changeSelection(this._getSelection(), selected);
          },
          _getSelection: function() {
            var owner = this._owner;
            return this === owner._point ? 1 : this === owner._handleIn ? 2 : this === owner._handleOut ? 4 : 0;
          }
        });
        var Curve = Base.extend({
          _class: "Curve",
          beans: true,
          initialize: function Curve2(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
            var count = arguments.length, seg1, seg2, point1, point2, handle1, handle2;
            if (count === 3) {
              this._path = arg0;
              seg1 = arg1;
              seg2 = arg2;
            } else if (!count) {
              seg1 = new Segment();
              seg2 = new Segment();
            } else if (count === 1) {
              if ("segment1" in arg0) {
                seg1 = new Segment(arg0.segment1);
                seg2 = new Segment(arg0.segment2);
              } else if ("point1" in arg0) {
                point1 = arg0.point1;
                handle1 = arg0.handle1;
                handle2 = arg0.handle2;
                point2 = arg0.point2;
              } else if (Array.isArray(arg0)) {
                point1 = [arg0[0], arg0[1]];
                point2 = [arg0[6], arg0[7]];
                handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
                handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
              }
            } else if (count === 2) {
              seg1 = new Segment(arg0);
              seg2 = new Segment(arg1);
            } else if (count === 4) {
              point1 = arg0;
              handle1 = arg1;
              handle2 = arg2;
              point2 = arg3;
            } else if (count === 8) {
              point1 = [arg0, arg1];
              point2 = [arg6, arg7];
              handle1 = [arg2 - arg0, arg3 - arg1];
              handle2 = [arg4 - arg6, arg5 - arg7];
            }
            this._segment1 = seg1 || new Segment(point1, null, handle1);
            this._segment2 = seg2 || new Segment(point2, handle2, null);
          },
          _serialize: function(options, dictionary) {
            return Base.serialize(this.hasHandles() ? [
              this.getPoint1(),
              this.getHandle1(),
              this.getHandle2(),
              this.getPoint2()
            ] : [this.getPoint1(), this.getPoint2()], options, true, dictionary);
          },
          _changed: function() {
            this._length = this._bounds = undefined2;
          },
          clone: function() {
            return new Curve(this._segment1, this._segment2);
          },
          toString: function() {
            var parts = ["point1: " + this._segment1._point];
            if (!this._segment1._handleOut.isZero())
              parts.push("handle1: " + this._segment1._handleOut);
            if (!this._segment2._handleIn.isZero())
              parts.push("handle2: " + this._segment2._handleIn);
            parts.push("point2: " + this._segment2._point);
            return "{ " + parts.join(", ") + " }";
          },
          classify: function() {
            return Curve.classify(this.getValues());
          },
          remove: function() {
            var removed = false;
            if (this._path) {
              var segment2 = this._segment2, handleOut = segment2._handleOut;
              removed = segment2.remove();
              if (removed)
                this._segment1._handleOut.set(handleOut);
            }
            return removed;
          },
          getPoint1: function() {
            return this._segment1._point;
          },
          setPoint1: function() {
            this._segment1._point.set(Point.read(arguments));
          },
          getPoint2: function() {
            return this._segment2._point;
          },
          setPoint2: function() {
            this._segment2._point.set(Point.read(arguments));
          },
          getHandle1: function() {
            return this._segment1._handleOut;
          },
          setHandle1: function() {
            this._segment1._handleOut.set(Point.read(arguments));
          },
          getHandle2: function() {
            return this._segment2._handleIn;
          },
          setHandle2: function() {
            this._segment2._handleIn.set(Point.read(arguments));
          },
          getSegment1: function() {
            return this._segment1;
          },
          getSegment2: function() {
            return this._segment2;
          },
          getPath: function() {
            return this._path;
          },
          getIndex: function() {
            return this._segment1._index;
          },
          getNext: function() {
            var curves = this._path && this._path._curves;
            return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
          },
          getPrevious: function() {
            var curves = this._path && this._path._curves;
            return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
          },
          isFirst: function() {
            return !this._segment1._index;
          },
          isLast: function() {
            var path = this._path;
            return path && this._segment1._index === path._curves.length - 1 || false;
          },
          isSelected: function() {
            return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
          },
          setSelected: function(selected) {
            this.getPoint1().setSelected(selected);
            this.getHandle1().setSelected(selected);
            this.getHandle2().setSelected(selected);
            this.getPoint2().setSelected(selected);
          },
          getValues: function(matrix) {
            return Curve.getValues(this._segment1, this._segment2, matrix);
          },
          getPoints: function() {
            var coords = this.getValues(), points = [];
            for (var i2 = 0; i2 < 8; i2 += 2)
              points.push(new Point(coords[i2], coords[i2 + 1]));
            return points;
          }
        }, {
          getLength: function() {
            if (this._length == null)
              this._length = Curve.getLength(this.getValues(), 0, 1);
            return this._length;
          },
          getArea: function() {
            return Curve.getArea(this.getValues());
          },
          getLine: function() {
            return new Line(this._segment1._point, this._segment2._point);
          },
          getPart: function(from, to2) {
            return new Curve(Curve.getPart(this.getValues(), from, to2));
          },
          getPartLength: function(from, to2) {
            return Curve.getLength(this.getValues(), from, to2);
          },
          divideAt: function(location) {
            return this.divideAtTime(location && location.curve === this ? location.time : this.getTimeAt(location));
          },
          divideAtTime: function(time, _setHandles) {
            var tMin = 1e-8, tMax = 1 - tMin, res = null;
            if (time >= tMin && time <= tMax) {
              var parts = Curve.subdivide(this.getValues(), time), left = parts[0], right = parts[1], setHandles = _setHandles || this.hasHandles(), seg1 = this._segment1, seg2 = this._segment2, path = this._path;
              if (setHandles) {
                seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
                seg2._handleIn._set(right[4] - right[6], right[5] - right[7]);
              }
              var x2 = left[6], y2 = left[7], segment = new Segment(new Point(x2, y2), setHandles && new Point(left[4] - x2, left[5] - y2), setHandles && new Point(right[2] - x2, right[3] - y2));
              if (path) {
                path.insert(seg1._index + 1, segment);
                res = this.getNext();
              } else {
                this._segment2 = segment;
                this._changed();
                res = new Curve(segment, seg2);
              }
            }
            return res;
          },
          splitAt: function(location) {
            var path = this._path;
            return path ? path.splitAt(location) : null;
          },
          splitAtTime: function(time) {
            return this.splitAt(this.getLocationAtTime(time));
          },
          divide: function(offset, isTime) {
            return this.divideAtTime(offset === undefined2 ? 0.5 : isTime ? offset : this.getTimeAt(offset));
          },
          split: function(offset, isTime) {
            return this.splitAtTime(offset === undefined2 ? 0.5 : isTime ? offset : this.getTimeAt(offset));
          },
          reversed: function() {
            return new Curve(this._segment2.reversed(), this._segment1.reversed());
          },
          clearHandles: function() {
            this._segment1._handleOut._set(0, 0);
            this._segment2._handleIn._set(0, 0);
          },
          statics: {
            getValues: function(segment1, segment2, matrix, straight) {
              var p1 = segment1._point, h1 = segment1._handleOut, h2 = segment2._handleIn, p2 = segment2._point, x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, values = straight ? [x1, y1, x1, y1, x2, y2, x2, y2] : [
                x1,
                y1,
                x1 + h1._x,
                y1 + h1._y,
                x2 + h2._x,
                y2 + h2._y,
                x2,
                y2
              ];
              if (matrix)
                matrix._transformCoordinates(values, values, 4);
              return values;
            },
            subdivide: function(v2, t2) {
              var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7];
              if (t2 === undefined2)
                t2 = 0.5;
              var u2 = 1 - t2, x4 = u2 * x0 + t2 * x1, y4 = u2 * y0 + t2 * y1, x5 = u2 * x1 + t2 * x2, y5 = u2 * y1 + t2 * y2, x6 = u2 * x2 + t2 * x3, y6 = u2 * y2 + t2 * y3, x7 = u2 * x4 + t2 * x5, y7 = u2 * y4 + t2 * y5, x8 = u2 * x5 + t2 * x6, y8 = u2 * y5 + t2 * y6, x9 = u2 * x7 + t2 * x8, y9 = u2 * y7 + t2 * y8;
              return [
                [x0, y0, x4, y4, x7, y7, x9, y9],
                [x9, y9, x8, y8, x6, y6, x3, y3]
              ];
            },
            getMonoCurves: function(v2, dir) {
              var curves = [], io2 = dir ? 0 : 1, o0 = v2[io2 + 0], o1 = v2[io2 + 2], o2 = v2[io2 + 4], o3 = v2[io2 + 6];
              if (o0 >= o1 === o1 >= o2 && o1 >= o2 === o2 >= o3 || Curve.isStraight(v2)) {
                curves.push(v2);
              } else {
                var a2 = 3 * (o1 - o2) - o0 + o3, b2 = 2 * (o0 + o2) - 4 * o1, c2 = o1 - o0, tMin = 1e-8, tMax = 1 - tMin, roots = [], n2 = Numerical.solveQuadratic(a2, b2, c2, roots, tMin, tMax);
                if (!n2) {
                  curves.push(v2);
                } else {
                  roots.sort();
                  var t2 = roots[0], parts = Curve.subdivide(v2, t2);
                  curves.push(parts[0]);
                  if (n2 > 1) {
                    t2 = (roots[1] - t2) / (1 - t2);
                    parts = Curve.subdivide(parts[1], t2);
                    curves.push(parts[0]);
                  }
                  curves.push(parts[1]);
                }
              }
              return curves;
            },
            solveCubic: function(v2, coord, val, roots, min, max) {
              var v0 = v2[coord], v1 = v2[coord + 2], v22 = v2[coord + 4], v3 = v2[coord + 6], res = 0;
              if (!(v0 < val && v3 < val && v1 < val && v22 < val || v0 > val && v3 > val && v1 > val && v22 > val)) {
                var c2 = 3 * (v1 - v0), b2 = 3 * (v22 - v1) - c2, a2 = v3 - v0 - c2 - b2;
                res = Numerical.solveCubic(a2, b2, c2, v0 - val, roots, min, max);
              }
              return res;
            },
            getTimeOf: function(v2, point) {
              var p0 = new Point(v2[0], v2[1]), p3 = new Point(v2[6], v2[7]), epsilon = 1e-12, geomEpsilon = 1e-7, t2 = point.isClose(p0, epsilon) ? 0 : point.isClose(p3, epsilon) ? 1 : null;
              if (t2 === null) {
                var coords = [point.x, point.y], roots = [];
                for (var c2 = 0; c2 < 2; c2++) {
                  var count = Curve.solveCubic(v2, c2, coords[c2], roots, 0, 1);
                  for (var i2 = 0; i2 < count; i2++) {
                    var u2 = roots[i2];
                    if (point.isClose(Curve.getPoint(v2, u2), geomEpsilon))
                      return u2;
                  }
                }
              }
              return point.isClose(p0, geomEpsilon) ? 0 : point.isClose(p3, geomEpsilon) ? 1 : null;
            },
            getNearestTime: function(v2, point) {
              if (Curve.isStraight(v2)) {
                var x0 = v2[0], y0 = v2[1], x3 = v2[6], y3 = v2[7], vx = x3 - x0, vy = y3 - y0, det = vx * vx + vy * vy;
                if (det === 0)
                  return 0;
                var u2 = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
                return u2 < 1e-12 ? 0 : u2 > 0.999999999999 ? 1 : Curve.getTimeOf(v2, new Point(x0 + u2 * vx, y0 + u2 * vy));
              }
              var count = 100, minDist = Infinity, minT = 0;
              function refine(t2) {
                if (t2 >= 0 && t2 <= 1) {
                  var dist = point.getDistance(Curve.getPoint(v2, t2), true);
                  if (dist < minDist) {
                    minDist = dist;
                    minT = t2;
                    return true;
                  }
                }
              }
              for (var i2 = 0; i2 <= count; i2++)
                refine(i2 / count);
              var step = 1 / (count * 2);
              while (step > 1e-8) {
                if (!refine(minT - step) && !refine(minT + step))
                  step /= 2;
              }
              return minT;
            },
            getPart: function(v2, from, to2) {
              var flip = from > to2;
              if (flip) {
                var tmp = from;
                from = to2;
                to2 = tmp;
              }
              if (from > 0)
                v2 = Curve.subdivide(v2, from)[1];
              if (to2 < 1)
                v2 = Curve.subdivide(v2, (to2 - from) / (1 - from))[0];
              return flip ? [v2[6], v2[7], v2[4], v2[5], v2[2], v2[3], v2[0], v2[1]] : v2;
            },
            isFlatEnough: function(v2, flatness) {
              var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7], ux = 3 * x1 - 2 * x0 - x3, uy = 3 * y1 - 2 * y0 - y3, vx = 3 * x2 - 2 * x3 - x0, vy = 3 * y2 - 2 * y3 - y0;
              return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;
            },
            getArea: function(v2) {
              var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7];
              return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
            },
            getBounds: function(v2) {
              var min = v2.slice(0, 2), max = min.slice(), roots = [0, 0];
              for (var i2 = 0; i2 < 2; i2++)
                Curve._addBounds(v2[i2], v2[i2 + 2], v2[i2 + 4], v2[i2 + 6], i2, 0, min, max, roots);
              return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
            },
            _addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
              function add(value, padding2) {
                var left = value - padding2, right = value + padding2;
                if (left < min[coord])
                  min[coord] = left;
                if (right > max[coord])
                  max[coord] = right;
              }
              padding /= 2;
              var minPad = min[coord] + padding, maxPad = max[coord] - padding;
              if (v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad || v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
                if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
                  add(v0, 0);
                  add(v3, 0);
                } else {
                  var a2 = 3 * (v1 - v2) - v0 + v3, b2 = 2 * (v0 + v2) - 4 * v1, c2 = v1 - v0, count = Numerical.solveQuadratic(a2, b2, c2, roots), tMin = 1e-8, tMax = 1 - tMin;
                  add(v3, 0);
                  for (var i2 = 0; i2 < count; i2++) {
                    var t2 = roots[i2], u2 = 1 - t2;
                    if (tMin <= t2 && t2 <= tMax)
                      add(u2 * u2 * u2 * v0 + 3 * u2 * u2 * t2 * v1 + 3 * u2 * t2 * t2 * v2 + t2 * t2 * t2 * v3, padding);
                  }
                }
              }
            }
          }
        }, Base.each(["getBounds", "getStrokeBounds", "getHandleBounds"], function(name) {
          this[name] = function() {
            if (!this._bounds)
              this._bounds = {};
            var bounds = this._bounds[name];
            if (!bounds) {
              bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], false, this._path);
            }
            return bounds.clone();
          };
        }, {}), Base.each({
          isStraight: function(p1, h1, h2, p2) {
            if (h1.isZero() && h2.isZero()) {
              return true;
            } else {
              var v2 = p2.subtract(p1);
              if (v2.isZero()) {
                return false;
              } else if (v2.isCollinear(h1) && v2.isCollinear(h2)) {
                var l2 = new Line(p1, p2), epsilon = 1e-7;
                if (l2.getDistance(p1.add(h1)) < epsilon && l2.getDistance(p2.add(h2)) < epsilon) {
                  var div = v2.dot(v2), s1 = v2.dot(h1) / div, s2 = v2.dot(h2) / div;
                  return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
                }
              }
            }
            return false;
          },
          isLinear: function(p1, h1, h2, p2) {
            var third = p2.subtract(p1).divide(3);
            return h1.equals(third) && h2.negate().equals(third);
          }
        }, function(test, name) {
          this[name] = function(epsilon) {
            var seg1 = this._segment1, seg2 = this._segment2;
            return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point, epsilon);
          };
          this.statics[name] = function(v2, epsilon) {
            var x0 = v2[0], y0 = v2[1], x3 = v2[6], y3 = v2[7];
            return test(new Point(x0, y0), new Point(v2[2] - x0, v2[3] - y0), new Point(v2[4] - x3, v2[5] - y3), new Point(x3, y3), epsilon);
          };
        }, {
          statics: {},
          hasHandles: function() {
            return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
          },
          hasLength: function(epsilon) {
            return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (epsilon || 0);
          },
          isCollinear: function(curve) {
            return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());
          },
          isHorizontal: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
          },
          isVertical: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
          }
        }), {
          beans: false,
          getLocationAt: function(offset, _isTime) {
            return this.getLocationAtTime(_isTime ? offset : this.getTimeAt(offset));
          },
          getLocationAtTime: function(t2) {
            return t2 != null && t2 >= 0 && t2 <= 1 ? new CurveLocation(this, t2) : null;
          },
          getTimeAt: function(offset, start) {
            return Curve.getTimeAt(this.getValues(), offset, start);
          },
          getParameterAt: "#getTimeAt",
          getTimesWithTangent: function() {
            var tangent = Point.read(arguments);
            return tangent.isZero() ? [] : Curve.getTimesWithTangent(this.getValues(), tangent);
          },
          getOffsetAtTime: function(t2) {
            return this.getPartLength(0, t2);
          },
          getLocationOf: function() {
            return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
          },
          getOffsetOf: function() {
            var loc = this.getLocationOf.apply(this, arguments);
            return loc ? loc.getOffset() : null;
          },
          getTimeOf: function() {
            return Curve.getTimeOf(this.getValues(), Point.read(arguments));
          },
          getParameterOf: "#getTimeOf",
          getNearestLocation: function() {
            var point = Point.read(arguments), values = this.getValues(), t2 = Curve.getNearestTime(values, point), pt2 = Curve.getPoint(values, t2);
            return new CurveLocation(this, t2, pt2, null, point.getDistance(pt2));
          },
          getNearestPoint: function() {
            var loc = this.getNearestLocation.apply(this, arguments);
            return loc ? loc.getPoint() : loc;
          }
        }, new function() {
          var methods = [
            "getPoint",
            "getTangent",
            "getNormal",
            "getWeightedTangent",
            "getWeightedNormal",
            "getCurvature"
          ];
          return Base.each(methods, function(name) {
            this[name + "At"] = function(location, _isTime) {
              var values = this.getValues();
              return Curve[name](values, _isTime ? location : Curve.getTimeAt(values, location));
            };
            this[name + "AtTime"] = function(time) {
              return Curve[name](this.getValues(), time);
            };
          }, {
            statics: {
              _evaluateMethods: methods
            }
          });
        }(), new function() {
          function getLengthIntegrand(v2) {
            var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7], ax = 9 * (x1 - x2) + 3 * (x3 - x0), bx = 6 * (x0 + x2) - 12 * x1, cx = 3 * (x1 - x0), ay = 9 * (y1 - y2) + 3 * (y3 - y0), by = 6 * (y0 + y2) - 12 * y1, cy = 3 * (y1 - y0);
            return function(t2) {
              var dx = (ax * t2 + bx) * t2 + cx, dy = (ay * t2 + by) * t2 + cy;
              return Math.sqrt(dx * dx + dy * dy);
            };
          }
          function getIterations(a2, b2) {
            return Math.max(2, Math.min(16, Math.ceil(Math.abs(b2 - a2) * 32)));
          }
          function evaluate(v2, t2, type, normalized) {
            if (t2 == null || t2 < 0 || t2 > 1)
              return null;
            var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7], isZero = Numerical.isZero;
            if (isZero(x1 - x0) && isZero(y1 - y0)) {
              x1 = x0;
              y1 = y0;
            }
            if (isZero(x2 - x3) && isZero(y2 - y3)) {
              x2 = x3;
              y2 = y3;
            }
            var cx = 3 * (x1 - x0), bx = 3 * (x2 - x1) - cx, ax = x3 - x0 - cx - bx, cy = 3 * (y1 - y0), by = 3 * (y2 - y1) - cy, ay = y3 - y0 - cy - by, x4, y4;
            if (type === 0) {
              x4 = t2 === 0 ? x0 : t2 === 1 ? x3 : ((ax * t2 + bx) * t2 + cx) * t2 + x0;
              y4 = t2 === 0 ? y0 : t2 === 1 ? y3 : ((ay * t2 + by) * t2 + cy) * t2 + y0;
            } else {
              var tMin = 1e-8, tMax = 1 - tMin;
              if (t2 < tMin) {
                x4 = cx;
                y4 = cy;
              } else if (t2 > tMax) {
                x4 = 3 * (x3 - x2);
                y4 = 3 * (y3 - y2);
              } else {
                x4 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                y4 = (3 * ay * t2 + 2 * by) * t2 + cy;
              }
              if (normalized) {
                if (x4 === 0 && y4 === 0 && (t2 < tMin || t2 > tMax)) {
                  x4 = x2 - x1;
                  y4 = y2 - y1;
                }
                var len = Math.sqrt(x4 * x4 + y4 * y4);
                if (len) {
                  x4 /= len;
                  y4 /= len;
                }
              }
              if (type === 3) {
                var x2 = 6 * ax * t2 + 2 * bx, y2 = 6 * ay * t2 + 2 * by, d = Math.pow(x4 * x4 + y4 * y4, 3 / 2);
                x4 = d !== 0 ? (x4 * y2 - y4 * x2) / d : 0;
                y4 = 0;
              }
            }
            return type === 2 ? new Point(y4, -x4) : new Point(x4, y4);
          }
          return { statics: {
            classify: function(v2) {
              var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7], a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2, a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3, a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0, d3 = 3 * a3, d2 = d3 - a2, d1 = d2 - a2 + a1, l2 = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3), s2 = l2 !== 0 ? 1 / l2 : 0, isZero = Numerical.isZero, serpentine = "serpentine";
              d1 *= s2;
              d2 *= s2;
              d3 *= s2;
              function type(type2, t1, t2) {
                var hasRoots = t1 !== undefined2, t1Ok = hasRoots && t1 > 0 && t1 < 1, t2Ok = hasRoots && t2 > 0 && t2 < 1;
                if (hasRoots && (!(t1Ok || t2Ok) || type2 === "loop" && !(t1Ok && t2Ok))) {
                  type2 = "arch";
                  t1Ok = t2Ok = false;
                }
                return {
                  type: type2,
                  roots: t1Ok || t2Ok ? t1Ok && t2Ok ? t1 < t2 ? [t1, t2] : [t2, t1] : [t1Ok ? t1 : t2] : null
                };
              }
              if (isZero(d1)) {
                return isZero(d2) ? type(isZero(d3) ? "line" : "quadratic") : type(serpentine, d3 / (3 * d2));
              }
              var d = 3 * d2 * d2 - 4 * d1 * d3;
              if (isZero(d)) {
                return type("cusp", d2 / (2 * d1));
              }
              var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d), f2 = 2 * d1;
              return type(d > 0 ? serpentine : "loop", (d2 + f1) / f2, (d2 - f1) / f2);
            },
            getLength: function(v2, a2, b2, ds2) {
              if (a2 === undefined2)
                a2 = 0;
              if (b2 === undefined2)
                b2 = 1;
              if (Curve.isStraight(v2)) {
                var c2 = v2;
                if (b2 < 1) {
                  c2 = Curve.subdivide(c2, b2)[0];
                  a2 /= b2;
                }
                if (a2 > 0) {
                  c2 = Curve.subdivide(c2, a2)[1];
                }
                var dx = c2[6] - c2[0], dy = c2[7] - c2[1];
                return Math.sqrt(dx * dx + dy * dy);
              }
              return Numerical.integrate(ds2 || getLengthIntegrand(v2), a2, b2, getIterations(a2, b2));
            },
            getTimeAt: function(v2, offset, start) {
              if (start === undefined2)
                start = offset < 0 ? 1 : 0;
              if (offset === 0)
                return start;
              var abs = Math.abs, epsilon = 1e-12, forward = offset > 0, a2 = forward ? start : 0, b2 = forward ? 1 : start, ds2 = getLengthIntegrand(v2), rangeLength = Curve.getLength(v2, a2, b2, ds2), diff = abs(offset) - rangeLength;
              if (abs(diff) < epsilon) {
                return forward ? b2 : a2;
              } else if (diff > epsilon) {
                return null;
              }
              var guess = offset / rangeLength, length = 0;
              function f(t2) {
                length += Numerical.integrate(ds2, start, t2, getIterations(start, t2));
                start = t2;
                return length - offset;
              }
              return Numerical.findRoot(f, ds2, start + guess, a2, b2, 32, 1e-12);
            },
            getPoint: function(v2, t2) {
              return evaluate(v2, t2, 0, false);
            },
            getTangent: function(v2, t2) {
              return evaluate(v2, t2, 1, true);
            },
            getWeightedTangent: function(v2, t2) {
              return evaluate(v2, t2, 1, false);
            },
            getNormal: function(v2, t2) {
              return evaluate(v2, t2, 2, true);
            },
            getWeightedNormal: function(v2, t2) {
              return evaluate(v2, t2, 2, false);
            },
            getCurvature: function(v2, t2) {
              return evaluate(v2, t2, 3, false).x;
            },
            getPeaks: function(v2) {
              var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7], ax = -x0 + 3 * x1 - 3 * x2 + x3, bx = 3 * x0 - 6 * x1 + 3 * x2, cx = -3 * x0 + 3 * x1, ay = -y0 + 3 * y1 - 3 * y2 + y3, by = 3 * y0 - 6 * y1 + 3 * y2, cy = -3 * y0 + 3 * y1, tMin = 1e-8, tMax = 1 - tMin, roots = [];
              Numerical.solveCubic(9 * (ax * ax + ay * ay), 9 * (ax * bx + by * ay), 2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay), cx * bx + by * cy, roots, tMin, tMax);
              return roots.sort();
            }
          } };
        }(), new function() {
          function addLocation(locations, include, c1, t1, c2, t2, overlap) {
            var excludeStart = !overlap && c1.getPrevious() === c2, excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2, tMin = 1e-8, tMax = 1 - tMin;
            if (t1 !== null && t1 >= (excludeStart ? tMin : 0) && t1 <= (excludeEnd ? tMax : 1)) {
              if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) && t2 <= (excludeStart ? tMax : 1)) {
                var loc1 = new CurveLocation(c1, t1, null, overlap), loc2 = new CurveLocation(c2, t2, null, overlap);
                loc1._intersection = loc2;
                loc2._intersection = loc1;
                if (!include || include(loc1)) {
                  CurveLocation.insert(locations, loc1, true);
                }
              }
            }
          }
          function addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMin, tMax, uMin, uMax) {
            if (++calls >= 4096 || ++recursion >= 40)
              return calls;
            var fatLineEpsilon = 1e-9, q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7], getSignedDistance = Line.getSignedDistance, d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]), d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]), factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9, dMin = factor * Math.min(0, d1, d2), dMax = factor * Math.max(0, d1, d2), dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]), dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]), dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]), dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]), hull = getConvexHull(dp0, dp1, dp2, dp3), top = hull[0], bottom = hull[1], tMinClip, tMaxClip;
            if (d1 === 0 && d2 === 0 && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0 || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null)
              return calls;
            var tMinNew = tMin + (tMax - tMin) * tMinClip, tMaxNew = tMin + (tMax - tMin) * tMaxClip;
            if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
              var t2 = (tMinNew + tMaxNew) / 2, u2 = (uMin + uMax) / 2;
              addLocation(locations, include, flip ? c2 : c1, flip ? u2 : t2, flip ? c1 : c2, flip ? t2 : u2);
            } else {
              v1 = Curve.getPart(v1, tMinClip, tMaxClip);
              var uDiff = uMax - uMin;
              if (tMaxClip - tMinClip > 0.8) {
                if (tMaxNew - tMinNew > uDiff) {
                  var parts = Curve.subdivide(v1, 0.5), t2 = (tMinNew + tMaxNew) / 2;
                  calls = addCurveIntersections(v2, parts[0], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, t2);
                  calls = addCurveIntersections(v2, parts[1], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, t2, tMaxNew);
                } else {
                  var parts = Curve.subdivide(v2, 0.5), u2 = (uMin + uMax) / 2;
                  calls = addCurveIntersections(parts[0], v1, c2, c1, locations, include, !flip, recursion, calls, uMin, u2, tMinNew, tMaxNew);
                  calls = addCurveIntersections(parts[1], v1, c2, c1, locations, include, !flip, recursion, calls, u2, uMax, tMinNew, tMaxNew);
                }
              } else {
                if (uDiff === 0 || uDiff >= fatLineEpsilon) {
                  calls = addCurveIntersections(v2, v1, c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, tMaxNew);
                } else {
                  calls = addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMinNew, tMaxNew, uMin, uMax);
                }
              }
            }
            return calls;
          }
          function getConvexHull(dq0, dq1, dq2, dq3) {
            var p0 = [0, dq0], p1 = [1 / 3, dq1], p2 = [2 / 3, dq2], p3 = [1, dq3], dist1 = dq1 - (2 * dq0 + dq3) / 3, dist2 = dq2 - (dq0 + 2 * dq3) / 3, hull;
            if (dist1 * dist2 < 0) {
              hull = [[p0, p1, p3], [p0, p2, p3]];
            } else {
              var distRatio = dist1 / dist2;
              hull = [
                distRatio >= 2 ? [p0, p1, p3] : distRatio <= 0.5 ? [p0, p2, p3] : [p0, p1, p2, p3],
                [p0, p3]
              ];
            }
            return (dist1 || dist2) < 0 ? hull.reverse() : hull;
          }
          function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
            if (hullTop[0][1] < dMin) {
              return clipConvexHullPart(hullTop, true, dMin);
            } else if (hullBottom[0][1] > dMax) {
              return clipConvexHullPart(hullBottom, false, dMax);
            } else {
              return hullTop[0][0];
            }
          }
          function clipConvexHullPart(part, top, threshold) {
            var px = part[0][0], py = part[0][1];
            for (var i2 = 1, l2 = part.length; i2 < l2; i2++) {
              var qx = part[i2][0], qy = part[i2][1];
              if (top ? qy >= threshold : qy <= threshold) {
                return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);
              }
              px = qx;
              py = qy;
            }
            return null;
          }
          function getCurveLineIntersections(v2, px, py, vx, vy) {
            var isZero = Numerical.isZero;
            if (isZero(vx) && isZero(vy)) {
              var t2 = Curve.getTimeOf(v2, new Point(px, py));
              return t2 === null ? [] : [t2];
            }
            var angle = Math.atan2(-vy, vx), sin = Math.sin(angle), cos = Math.cos(angle), rv = [], roots = [];
            for (var i2 = 0; i2 < 8; i2 += 2) {
              var x2 = v2[i2] - px, y2 = v2[i2 + 1] - py;
              rv.push(x2 * cos - y2 * sin, x2 * sin + y2 * cos);
            }
            Curve.solveCubic(rv, 1, 0, roots, 0, 1);
            return roots;
          }
          function addCurveLineIntersections(v1, v2, c1, c2, locations, include, flip) {
            var x1 = v2[0], y1 = v2[1], x2 = v2[6], y2 = v2[7], roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
            for (var i2 = 0, l2 = roots.length; i2 < l2; i2++) {
              var t1 = roots[i2], p1 = Curve.getPoint(v1, t1), t2 = Curve.getTimeOf(v2, p1);
              if (t2 !== null) {
                addLocation(locations, include, flip ? c2 : c1, flip ? t2 : t1, flip ? c1 : c2, flip ? t1 : t2);
              }
            }
          }
          function addLineIntersection(v1, v2, c1, c2, locations, include) {
            var pt2 = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);
            if (pt2) {
              addLocation(locations, include, c1, Curve.getTimeOf(v1, pt2), c2, Curve.getTimeOf(v2, pt2));
            }
          }
          function getCurveIntersections(v1, v2, c1, c2, locations, include) {
            var epsilon = 1e-12, min = Math.min, max = Math.max;
            if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon > min(v2[0], v2[2], v2[4], v2[6]) && min(v1[0], v1[2], v1[4], v1[6]) - epsilon < max(v2[0], v2[2], v2[4], v2[6]) && max(v1[1], v1[3], v1[5], v1[7]) + epsilon > min(v2[1], v2[3], v2[5], v2[7]) && min(v1[1], v1[3], v1[5], v1[7]) - epsilon < max(v2[1], v2[3], v2[5], v2[7])) {
              var overlaps = getOverlaps(v1, v2);
              if (overlaps) {
                for (var i2 = 0; i2 < 2; i2++) {
                  var overlap = overlaps[i2];
                  addLocation(locations, include, c1, overlap[0], c2, overlap[1], true);
                }
              } else {
                var straight1 = Curve.isStraight(v1), straight2 = Curve.isStraight(v2), straight = straight1 && straight2, flip = straight1 && !straight2, before = locations.length;
                (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(flip ? v2 : v1, flip ? v1 : v2, flip ? c2 : c1, flip ? c1 : c2, locations, include, flip, 0, 0, 0, 1, 0, 1);
                if (!straight || locations.length === before) {
                  for (var i2 = 0; i2 < 4; i2++) {
                    var t1 = i2 >> 1, t2 = i2 & 1, i1 = t1 * 6, i22 = t2 * 6, p1 = new Point(v1[i1], v1[i1 + 1]), p2 = new Point(v2[i22], v2[i22 + 1]);
                    if (p1.isClose(p2, epsilon)) {
                      addLocation(locations, include, c1, t1, c2, t2);
                    }
                  }
                }
              }
            }
            return locations;
          }
          function getSelfIntersection(v1, c1, locations, include) {
            var info = Curve.classify(v1);
            if (info.type === "loop") {
              var roots = info.roots;
              addLocation(locations, include, c1, roots[0], c1, roots[1]);
            }
            return locations;
          }
          function getIntersections(curves1, curves2, include, matrix1, matrix2, _returnFirst) {
            var epsilon = 1e-7, self3 = !curves2;
            if (self3)
              curves2 = curves1;
            var length1 = curves1.length, length2 = curves2.length, values1 = new Array(length1), values2 = self3 ? values1 : new Array(length2), locations = [];
            for (var i2 = 0; i2 < length1; i2++) {
              values1[i2] = curves1[i2].getValues(matrix1);
            }
            if (!self3) {
              for (var i2 = 0; i2 < length2; i2++) {
                values2[i2] = curves2[i2].getValues(matrix2);
              }
            }
            var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(values1, values2, epsilon);
            for (var index1 = 0; index1 < length1; index1++) {
              var curve1 = curves1[index1], v1 = values1[index1];
              if (self3) {
                getSelfIntersection(v1, curve1, locations, include);
              }
              var collisions1 = boundsCollisions[index1];
              if (collisions1) {
                for (var j2 = 0; j2 < collisions1.length; j2++) {
                  if (_returnFirst && locations.length)
                    return locations;
                  var index2 = collisions1[j2];
                  if (!self3 || index2 > index1) {
                    var curve2 = curves2[index2], v2 = values2[index2];
                    getCurveIntersections(v1, v2, curve1, curve2, locations, include);
                  }
                }
              }
            }
            return locations;
          }
          function getOverlaps(v1, v2) {
            function getSquaredLineLength(v4) {
              var x2 = v4[6] - v4[0], y2 = v4[7] - v4[1];
              return x2 * x2 + y2 * y2;
            }
            var abs = Math.abs, getDistance = Line.getDistance, timeEpsilon = 1e-8, geomEpsilon = 1e-7, straight1 = Curve.isStraight(v1), straight2 = Curve.isStraight(v2), straightBoth = straight1 && straight2, flip = getSquaredLineLength(v1) < getSquaredLineLength(v2), l1 = flip ? v2 : v1, l2 = flip ? v1 : v2, px = l1[0], py = l1[1], vx = l1[6] - px, vy = l1[7] - py;
            if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
              if (!straightBoth && getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
                straight1 = straight2 = straightBoth = true;
              }
            } else if (straightBoth) {
              return null;
            }
            if (straight1 ^ straight2) {
              return null;
            }
            var v3 = [v1, v2], pairs = [];
            for (var i2 = 0; i2 < 4 && pairs.length < 2; i2++) {
              var i1 = i2 & 1, i22 = i1 ^ 1, t1 = i2 >> 1, t2 = Curve.getTimeOf(v3[i1], new Point(v3[i22][t1 ? 6 : 0], v3[i22][t1 ? 7 : 1]));
              if (t2 != null) {
                var pair = i1 ? [t1, t2] : [t2, t1];
                if (!pairs.length || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon) {
                  pairs.push(pair);
                }
              }
              if (i2 > 2 && !pairs.length)
                break;
            }
            if (pairs.length !== 2) {
              pairs = null;
            } else if (!straightBoth) {
              var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]), o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
              if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon)
                pairs = null;
            }
            return pairs;
          }
          function getTimesWithTangent(v2, tangent) {
            var x0 = v2[0], y0 = v2[1], x1 = v2[2], y1 = v2[3], x2 = v2[4], y2 = v2[5], x3 = v2[6], y3 = v2[7], normalized = tangent.normalize(), tx = normalized.x, ty = normalized.y, ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0, ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0, bx = 6 * x2 - 12 * x1 + 6 * x0, by = 6 * y2 - 12 * y1 + 6 * y0, cx = 3 * x1 - 3 * x0, cy = 3 * y1 - 3 * y0, den = 2 * ax * ty - 2 * ay * tx, times = [];
            if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
              var num = ax * cy - ay * cx, den = ax * by - ay * bx;
              if (den != 0) {
                var t2 = -num / den;
                if (t2 >= 0 && t2 <= 1)
                  times.push(t2);
              }
            } else {
              var delta = (bx * bx - 4 * ax * cx) * ty * ty + (-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty + (by * by - 4 * ay * cy) * tx * tx, k2 = bx * ty - by * tx;
              if (delta >= 0 && den != 0) {
                var d = Math.sqrt(delta), t0 = -(k2 + d) / den, t1 = (-k2 + d) / den;
                if (t0 >= 0 && t0 <= 1)
                  times.push(t0);
                if (t1 >= 0 && t1 <= 1)
                  times.push(t1);
              }
            }
            return times;
          }
          return {
            getIntersections: function(curve) {
              var v1 = this.getValues(), v2 = curve && curve !== this && curve.getValues();
              return v2 ? getCurveIntersections(v1, v2, this, curve, []) : getSelfIntersection(v1, this, []);
            },
            statics: {
              getOverlaps,
              getIntersections,
              getCurveLineIntersections,
              getTimesWithTangent
            }
          };
        }());
        var CurveLocation = Base.extend({
          _class: "CurveLocation",
          initialize: function CurveLocation2(curve, time, point, _overlap, _distance) {
            if (time >= 0.99999999) {
              var next = curve.getNext();
              if (next) {
                time = 0;
                curve = next;
              }
            }
            this._setCurve(curve);
            this._time = time;
            this._point = point || curve.getPointAtTime(time);
            this._overlap = _overlap;
            this._distance = _distance;
            this._intersection = this._next = this._previous = null;
          },
          _setPath: function(path) {
            this._path = path;
            this._version = path ? path._version : 0;
          },
          _setCurve: function(curve) {
            this._setPath(curve._path);
            this._curve = curve;
            this._segment = null;
            this._segment1 = curve._segment1;
            this._segment2 = curve._segment2;
          },
          _setSegment: function(segment) {
            var curve = segment.getCurve();
            if (curve) {
              this._setCurve(curve);
            } else {
              this._setPath(segment._path);
              this._segment1 = segment;
              this._segment2 = null;
            }
            this._segment = segment;
            this._time = segment === this._segment1 ? 0 : 1;
            this._point = segment._point.clone();
          },
          getSegment: function() {
            var segment = this._segment;
            if (!segment) {
              var curve = this.getCurve(), time = this.getTime();
              if (time === 0) {
                segment = curve._segment1;
              } else if (time === 1) {
                segment = curve._segment2;
              } else if (time != null) {
                segment = curve.getPartLength(0, time) < curve.getPartLength(time, 1) ? curve._segment1 : curve._segment2;
              }
              this._segment = segment;
            }
            return segment;
          },
          getCurve: function() {
            var path = this._path, that = this;
            if (path && path._version !== this._version) {
              this._time = this._offset = this._curveOffset = this._curve = null;
            }
            function trySegment(segment) {
              var curve = segment && segment.getCurve();
              if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
                that._setCurve(curve);
                return curve;
              }
            }
            return this._curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());
          },
          getPath: function() {
            var curve = this.getCurve();
            return curve && curve._path;
          },
          getIndex: function() {
            var curve = this.getCurve();
            return curve && curve.getIndex();
          },
          getTime: function() {
            var curve = this.getCurve(), time = this._time;
            return curve && time == null ? this._time = curve.getTimeOf(this._point) : time;
          },
          getParameter: "#getTime",
          getPoint: function() {
            return this._point;
          },
          getOffset: function() {
            var offset = this._offset;
            if (offset == null) {
              offset = 0;
              var path = this.getPath(), index = this.getIndex();
              if (path && index != null) {
                var curves = path.getCurves();
                for (var i2 = 0; i2 < index; i2++)
                  offset += curves[i2].getLength();
              }
              this._offset = offset += this.getCurveOffset();
            }
            return offset;
          },
          getCurveOffset: function() {
            var offset = this._curveOffset;
            if (offset == null) {
              var curve = this.getCurve(), time = this.getTime();
              this._curveOffset = offset = time != null && curve && curve.getPartLength(0, time);
            }
            return offset;
          },
          getIntersection: function() {
            return this._intersection;
          },
          getDistance: function() {
            return this._distance;
          },
          divide: function() {
            var curve = this.getCurve(), res = curve && curve.divideAtTime(this.getTime());
            if (res) {
              this._setSegment(res._segment1);
            }
            return res;
          },
          split: function() {
            var curve = this.getCurve(), path = curve._path, res = curve && curve.splitAtTime(this.getTime());
            if (res) {
              this._setSegment(path.getLastSegment());
            }
            return res;
          },
          equals: function(loc, _ignoreOther) {
            var res = this === loc;
            if (!res && loc instanceof CurveLocation) {
              var c1 = this.getCurve(), c2 = loc.getCurve(), p1 = c1._path, p2 = c2._path;
              if (p1 === p2) {
                var abs = Math.abs, epsilon = 1e-7, diff = abs(this.getOffset() - loc.getOffset()), i1 = !_ignoreOther && this._intersection, i2 = !_ignoreOther && loc._intersection;
                res = (diff < epsilon || p1 && abs(p1.getLength() - diff) < epsilon) && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
              }
            }
            return res;
          },
          toString: function() {
            var parts = [], point = this.getPoint(), f = Formatter.instance;
            if (point)
              parts.push("point: " + point);
            var index = this.getIndex();
            if (index != null)
              parts.push("index: " + index);
            var time = this.getTime();
            if (time != null)
              parts.push("time: " + f.number(time));
            if (this._distance != null)
              parts.push("distance: " + f.number(this._distance));
            return "{ " + parts.join(", ") + " }";
          },
          isTouching: function() {
            var inter = this._intersection;
            if (inter && this.getTangent().isCollinear(inter.getTangent())) {
              var curve1 = this.getCurve(), curve2 = inter.getCurve();
              return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));
            }
            return false;
          },
          isCrossing: function() {
            var inter = this._intersection;
            if (!inter)
              return false;
            var t1 = this.getTime(), t2 = inter.getTime(), tMin = 1e-8, tMax = 1 - tMin, t1Inside = t1 >= tMin && t1 <= tMax, t2Inside = t2 >= tMin && t2 <= tMax;
            if (t1Inside && t2Inside)
              return !this.isTouching();
            var c2 = this.getCurve(), c1 = c2 && t1 < tMin ? c2.getPrevious() : c2, c4 = inter.getCurve(), c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
            if (t1 > tMax)
              c2 = c2.getNext();
            if (t2 > tMax)
              c4 = c4.getNext();
            if (!c1 || !c2 || !c3 || !c4)
              return false;
            var offsets = [];
            function addOffsets(curve, end) {
              var v5 = curve.getValues(), roots = Curve.classify(v5).roots || Curve.getPeaks(v5), count = roots.length, offset2 = Curve.getLength(v5, end && count ? roots[count - 1] : 0, !end && count ? roots[0] : 1);
              offsets.push(count ? offset2 : offset2 / 32);
            }
            function isInRange(angle, min, max) {
              return min < max ? angle > min && angle < max : angle > min || angle < max;
            }
            if (!t1Inside) {
              addOffsets(c1, true);
              addOffsets(c2, false);
            }
            if (!t2Inside) {
              addOffsets(c3, true);
              addOffsets(c4, false);
            }
            var pt2 = this.getPoint(), offset = Math.min.apply(Math, offsets), v2 = t1Inside ? c2.getTangentAtTime(t1) : c2.getPointAt(offset).subtract(pt2), v1 = t1Inside ? v2.negate() : c1.getPointAt(-offset).subtract(pt2), v4 = t2Inside ? c4.getTangentAtTime(t2) : c4.getPointAt(offset).subtract(pt2), v3 = t2Inside ? v4.negate() : c3.getPointAt(-offset).subtract(pt2), a1 = v1.getAngle(), a2 = v2.getAngle(), a3 = v3.getAngle(), a4 = v4.getAngle();
            return !!(t1Inside ? isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4) && isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3) : isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2) && isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
          },
          hasOverlap: function() {
            return !!this._overlap;
          }
        }, Base.each(Curve._evaluateMethods, function(name) {
          var get = name + "At";
          this[name] = function() {
            var curve = this.getCurve(), time = this.getTime();
            return time != null && curve && curve[get](time, true);
          };
        }, {
          preserve: true
        }), new function() {
          function insert(locations, loc, merge) {
            var length = locations.length, l2 = 0, r2 = length - 1;
            function search(index, dir) {
              for (var i2 = index + dir; i2 >= -1 && i2 <= length; i2 += dir) {
                var loc22 = locations[(i2 % length + length) % length];
                if (!loc.getPoint().isClose(loc22.getPoint(), 1e-7))
                  break;
                if (loc.equals(loc22))
                  return loc22;
              }
              return null;
            }
            while (l2 <= r2) {
              var m2 = l2 + r2 >>> 1, loc2 = locations[m2], found;
              if (merge && (found = loc.equals(loc2) ? loc2 : search(m2, -1) || search(m2, 1))) {
                if (loc._overlap) {
                  found._overlap = found._intersection._overlap = true;
                }
                return found;
              }
              var path1 = loc.getPath(), path2 = loc2.getPath(), diff = path1 !== path2 ? path1._id - path2._id : loc.getIndex() + loc.getTime() - (loc2.getIndex() + loc2.getTime());
              if (diff < 0) {
                r2 = m2 - 1;
              } else {
                l2 = m2 + 1;
              }
            }
            locations.splice(l2, 0, loc);
            return loc;
          }
          return { statics: {
            insert,
            expand: function(locations) {
              var expanded = locations.slice();
              for (var i2 = locations.length - 1; i2 >= 0; i2--) {
                insert(expanded, locations[i2]._intersection, false);
              }
              return expanded;
            }
          } };
        }());
        var PathItem = Item.extend({
          _class: "PathItem",
          _selectBounds: false,
          _canScaleStroke: true,
          beans: true,
          initialize: function PathItem2() {
          },
          statics: {
            create: function(arg) {
              var data, segments, compound;
              if (Base.isPlainObject(arg)) {
                segments = arg.segments;
                data = arg.pathData;
              } else if (Array.isArray(arg)) {
                segments = arg;
              } else if (typeof arg === "string") {
                data = arg;
              }
              if (segments) {
                var first = segments[0];
                compound = first && Array.isArray(first[0]);
              } else if (data) {
                compound = (data.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(data);
              }
              var ctor = compound ? CompoundPath : Path;
              return new ctor(arg);
            }
          },
          _asPathItem: function() {
            return this;
          },
          isClockwise: function() {
            return this.getArea() >= 0;
          },
          setClockwise: function(clockwise) {
            if (this.isClockwise() != (clockwise = !!clockwise))
              this.reverse();
          },
          setPathData: function(data) {
            var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig), coords, relative = false, previous, control, current = new Point(), start = new Point();
            function getCoord(index, coord2) {
              var val = +coords[index];
              if (relative)
                val += current[coord2];
              return val;
            }
            function getPoint(index) {
              return new Point(getCoord(index, "x"), getCoord(index + 1, "y"));
            }
            this.clear();
            for (var i2 = 0, l2 = parts && parts.length; i2 < l2; i2++) {
              var part = parts[i2], command = part[0], lower = command.toLowerCase();
              coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
              var length = coords && coords.length;
              relative = command === lower;
              if (previous === "z" && !/[mz]/.test(lower))
                this.moveTo(current);
              switch (lower) {
                case "m":
                case "l":
                  var move = lower === "m";
                  for (var j2 = 0; j2 < length; j2 += 2) {
                    this[move ? "moveTo" : "lineTo"](current = getPoint(j2));
                    if (move) {
                      start = current;
                      move = false;
                    }
                  }
                  control = current;
                  break;
                case "h":
                case "v":
                  var coord = lower === "h" ? "x" : "y";
                  current = current.clone();
                  for (var j2 = 0; j2 < length; j2++) {
                    current[coord] = getCoord(j2, coord);
                    this.lineTo(current);
                  }
                  control = current;
                  break;
                case "c":
                  for (var j2 = 0; j2 < length; j2 += 6) {
                    this.cubicCurveTo(getPoint(j2), control = getPoint(j2 + 2), current = getPoint(j2 + 4));
                  }
                  break;
                case "s":
                  for (var j2 = 0; j2 < length; j2 += 4) {
                    this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j2), current = getPoint(j2 + 2));
                    previous = lower;
                  }
                  break;
                case "q":
                  for (var j2 = 0; j2 < length; j2 += 4) {
                    this.quadraticCurveTo(control = getPoint(j2), current = getPoint(j2 + 2));
                  }
                  break;
                case "t":
                  for (var j2 = 0; j2 < length; j2 += 2) {
                    this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j2));
                    previous = lower;
                  }
                  break;
                case "a":
                  for (var j2 = 0; j2 < length; j2 += 7) {
                    this.arcTo(current = getPoint(j2 + 5), new Size(+coords[j2], +coords[j2 + 1]), +coords[j2 + 2], +coords[j2 + 4], +coords[j2 + 3]);
                  }
                  break;
                case "z":
                  this.closePath(1e-12);
                  current = start;
                  break;
              }
              previous = lower;
            }
          },
          _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
          },
          _contains: function(point) {
            var winding = point.isInside(this.getBounds({ internal: true, handle: true })) ? this._getWinding(point) : {};
            return winding.onPath || !!(this.getFillRule() === "evenodd" ? winding.windingL & 1 || winding.windingR & 1 : winding.winding);
          },
          getIntersections: function(path, include, _matrix, _returnFirst) {
            var self3 = this === path || !path, matrix1 = this._matrix._orNullIfIdentity(), matrix2 = self3 ? matrix1 : (_matrix || path._matrix)._orNullIfIdentity();
            return self3 || this.getBounds(matrix1).intersects(path.getBounds(matrix2), 1e-12) ? Curve.getIntersections(this.getCurves(), !self3 && path.getCurves(), include, matrix1, matrix2, _returnFirst) : [];
          },
          getCrossings: function(path) {
            return this.getIntersections(path, function(inter) {
              return inter.isCrossing();
            });
          },
          getNearestLocation: function() {
            var point = Point.read(arguments), curves = this.getCurves(), minDist = Infinity, minLoc = null;
            for (var i2 = 0, l2 = curves.length; i2 < l2; i2++) {
              var loc = curves[i2].getNearestLocation(point);
              if (loc._distance < minDist) {
                minDist = loc._distance;
                minLoc = loc;
              }
            }
            return minLoc;
          },
          getNearestPoint: function() {
            var loc = this.getNearestLocation.apply(this, arguments);
            return loc ? loc.getPoint() : loc;
          },
          interpolate: function(from, to2, factor) {
            var isPath = !this._children, name = isPath ? "_segments" : "_children", itemsFrom = from[name], itemsTo = to2[name], items = this[name];
            if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
              throw new Error("Invalid operands in interpolate() call: " + from + ", " + to2);
            }
            var current = items.length, length = itemsTo.length;
            if (current < length) {
              var ctor = isPath ? Segment : Path;
              for (var i2 = current; i2 < length; i2++) {
                this.add(new ctor());
              }
            } else if (current > length) {
              this[isPath ? "removeSegments" : "removeChildren"](length, current);
            }
            for (var i2 = 0; i2 < length; i2++) {
              items[i2].interpolate(itemsFrom[i2], itemsTo[i2], factor);
            }
            if (isPath) {
              this.setClosed(from._closed);
              this._changed(9);
            }
          },
          compare: function(path) {
            var ok = false;
            if (path) {
              var paths1 = this._children || [this], paths2 = path._children ? path._children.slice() : [path], length1 = paths1.length, length2 = paths2.length, matched = [], count = 0;
              ok = true;
              var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);
              for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
                var path1 = paths1[i1];
                ok = false;
                var pathBoundsOverlaps = boundsOverlaps[i1];
                if (pathBoundsOverlaps) {
                  for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
                    if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
                      if (!matched[pathBoundsOverlaps[i2]]) {
                        matched[pathBoundsOverlaps[i2]] = true;
                        count++;
                      }
                      ok = true;
                    }
                  }
                }
              }
              ok = ok && count === length2;
            }
            return ok;
          }
        });
        var Path = PathItem.extend({
          _class: "Path",
          _serializeFields: {
            segments: [],
            closed: false
          },
          initialize: function Path2(arg) {
            this._closed = false;
            this._segments = [];
            this._version = 0;
            var args = arguments, segments = Array.isArray(arg) ? typeof arg[0] === "object" ? arg : args : arg && (arg.size === undefined2 && (arg.x !== undefined2 || arg.point !== undefined2)) ? args : null;
            if (segments && segments.length > 0) {
              this.setSegments(segments);
            } else {
              this._curves = undefined2;
              this._segmentSelection = 0;
              if (!segments && typeof arg === "string") {
                this.setPathData(arg);
                arg = null;
              }
            }
            this._initialize(!segments && arg);
          },
          _equals: function(item) {
            return this._closed === item._closed && Base.equals(this._segments, item._segments);
          },
          copyContent: function(source) {
            this.setSegments(source._segments);
            this._closed = source._closed;
          },
          _changed: function _changed(flags) {
            _changed.base.call(this, flags);
            if (flags & 8) {
              this._length = this._area = undefined2;
              if (flags & 32) {
                this._version++;
              } else if (this._curves) {
                for (var i2 = 0, l2 = this._curves.length; i2 < l2; i2++)
                  this._curves[i2]._changed();
              }
            } else if (flags & 64) {
              this._bounds = undefined2;
            }
          },
          getStyle: function() {
            var parent = this._parent;
            return (parent instanceof CompoundPath ? parent : this)._style;
          },
          getSegments: function() {
            return this._segments;
          },
          setSegments: function(segments) {
            var fullySelected = this.isFullySelected(), length = segments && segments.length;
            this._segments.length = 0;
            this._segmentSelection = 0;
            this._curves = undefined2;
            if (length) {
              var last = segments[length - 1];
              if (typeof last === "boolean") {
                this.setClosed(last);
                length--;
              }
              this._add(Segment.readList(segments, 0, {}, length));
            }
            if (fullySelected)
              this.setFullySelected(true);
          },
          getFirstSegment: function() {
            return this._segments[0];
          },
          getLastSegment: function() {
            return this._segments[this._segments.length - 1];
          },
          getCurves: function() {
            var curves = this._curves, segments = this._segments;
            if (!curves) {
              var length = this._countCurves();
              curves = this._curves = new Array(length);
              for (var i2 = 0; i2 < length; i2++)
                curves[i2] = new Curve(this, segments[i2], segments[i2 + 1] || segments[0]);
            }
            return curves;
          },
          getFirstCurve: function() {
            return this.getCurves()[0];
          },
          getLastCurve: function() {
            var curves = this.getCurves();
            return curves[curves.length - 1];
          },
          isClosed: function() {
            return this._closed;
          },
          setClosed: function(closed) {
            if (this._closed != (closed = !!closed)) {
              this._closed = closed;
              if (this._curves) {
                var length = this._curves.length = this._countCurves();
                if (closed)
                  this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
              }
              this._changed(41);
            }
          }
        }, {
          beans: true,
          getPathData: function(_matrix, _precision) {
            var segments = this._segments, length = segments.length, f = new Formatter(_precision), coords = new Array(6), first = true, curX, curY, prevX, prevY, inX, inY, outX, outY, parts = [];
            function addSegment(segment, skipLine) {
              segment._transformCoordinates(_matrix, coords);
              curX = coords[0];
              curY = coords[1];
              if (first) {
                parts.push("M" + f.pair(curX, curY));
                first = false;
              } else {
                inX = coords[2];
                inY = coords[3];
                if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
                  if (!skipLine) {
                    var dx = curX - prevX, dy = curY - prevY;
                    parts.push(dx === 0 ? "v" + f.number(dy) : dy === 0 ? "h" + f.number(dx) : "l" + f.pair(dx, dy));
                  }
                } else {
                  parts.push("c" + f.pair(outX - prevX, outY - prevY) + " " + f.pair(inX - prevX, inY - prevY) + " " + f.pair(curX - prevX, curY - prevY));
                }
              }
              prevX = curX;
              prevY = curY;
              outX = coords[4];
              outY = coords[5];
            }
            if (!length)
              return "";
            for (var i2 = 0; i2 < length; i2++)
              addSegment(segments[i2]);
            if (this._closed && length > 0) {
              addSegment(segments[0], true);
              parts.push("z");
            }
            return parts.join("");
          },
          isEmpty: function() {
            return !this._segments.length;
          },
          _transformContent: function(matrix) {
            var segments = this._segments, coords = new Array(6);
            for (var i2 = 0, l2 = segments.length; i2 < l2; i2++)
              segments[i2]._transformCoordinates(matrix, coords, true);
            return true;
          },
          _add: function(segs, index) {
            var segments = this._segments, curves = this._curves, amount = segs.length, append = index == null, index = append ? segments.length : index;
            for (var i2 = 0; i2 < amount; i2++) {
              var segment = segs[i2];
              if (segment._path)
                segment = segs[i2] = segment.clone();
              segment._path = this;
              segment._index = index + i2;
              if (segment._selection)
                this._updateSelection(segment, 0, segment._selection);
            }
            if (append) {
              Base.push(segments, segs);
            } else {
              segments.splice.apply(segments, [index, 0].concat(segs));
              for (var i2 = index + amount, l2 = segments.length; i2 < l2; i2++)
                segments[i2]._index = i2;
            }
            if (curves) {
              var total = this._countCurves(), start = index > 0 && index + amount - 1 === total ? index - 1 : index, insert = start, end = Math.min(start + amount, total);
              if (segs._curves) {
                curves.splice.apply(curves, [start, 0].concat(segs._curves));
                insert += segs._curves.length;
              }
              for (var i2 = insert; i2 < end; i2++)
                curves.splice(i2, 0, new Curve(this, null, null));
              this._adjustCurves(start, end);
            }
            this._changed(41);
            return segs;
          },
          _adjustCurves: function(start, end) {
            var segments = this._segments, curves = this._curves, curve;
            for (var i2 = start; i2 < end; i2++) {
              curve = curves[i2];
              curve._path = this;
              curve._segment1 = segments[i2];
              curve._segment2 = segments[i2 + 1] || segments[0];
              curve._changed();
            }
            if (curve = curves[this._closed && !start ? segments.length - 1 : start - 1]) {
              curve._segment2 = segments[start] || segments[0];
              curve._changed();
            }
            if (curve = curves[end]) {
              curve._segment1 = segments[end];
              curve._changed();
            }
          },
          _countCurves: function() {
            var length = this._segments.length;
            return !this._closed && length > 0 ? length - 1 : length;
          },
          add: function(segment1) {
            var args = arguments;
            return args.length > 1 && typeof segment1 !== "number" ? this._add(Segment.readList(args)) : this._add([Segment.read(args)])[0];
          },
          insert: function(index, segment1) {
            var args = arguments;
            return args.length > 2 && typeof segment1 !== "number" ? this._add(Segment.readList(args, 1), index) : this._add([Segment.read(args, 1)], index)[0];
          },
          addSegment: function() {
            return this._add([Segment.read(arguments)])[0];
          },
          insertSegment: function(index) {
            return this._add([Segment.read(arguments, 1)], index)[0];
          },
          addSegments: function(segments) {
            return this._add(Segment.readList(segments));
          },
          insertSegments: function(index, segments) {
            return this._add(Segment.readList(segments), index);
          },
          removeSegment: function(index) {
            return this.removeSegments(index, index + 1)[0] || null;
          },
          removeSegments: function(start, end, _includeCurves) {
            start = start || 0;
            end = Base.pick(end, this._segments.length);
            var segments = this._segments, curves = this._curves, count = segments.length, removed = segments.splice(start, end - start), amount = removed.length;
            if (!amount)
              return removed;
            for (var i2 = 0; i2 < amount; i2++) {
              var segment = removed[i2];
              if (segment._selection)
                this._updateSelection(segment, segment._selection, 0);
              segment._index = segment._path = null;
            }
            for (var i2 = start, l2 = segments.length; i2 < l2; i2++)
              segments[i2]._index = i2;
            if (curves) {
              var index = start > 0 && end === count + (this._closed ? 1 : 0) ? start - 1 : start, curves = curves.splice(index, amount);
              for (var i2 = curves.length - 1; i2 >= 0; i2--)
                curves[i2]._path = null;
              if (_includeCurves)
                removed._curves = curves.slice(1);
              this._adjustCurves(index, index);
            }
            this._changed(41);
            return removed;
          },
          clear: "#removeSegments",
          hasHandles: function() {
            var segments = this._segments;
            for (var i2 = 0, l2 = segments.length; i2 < l2; i2++) {
              if (segments[i2].hasHandles())
                return true;
            }
            return false;
          },
          clearHandles: function() {
            var segments = this._segments;
            for (var i2 = 0, l2 = segments.length; i2 < l2; i2++)
              segments[i2].clearHandles();
          },
          getLength: function() {
            if (this._length == null) {
              var curves = this.getCurves(), length = 0;
              for (var i2 = 0, l2 = curves.length; i2 < l2; i2++)
                length += curves[i2].getLength();
              this._length = length;
            }
            return this._length;
          },
          getArea: function() {
            var area = this._area;
            if (area == null) {
              var segments = this._segments, closed = this._closed;
              area = 0;
              for (var i2 = 0, l2 = segments.length; i2 < l2; i2++) {
                var last = i2 + 1 === l2;
                area += Curve.getArea(Curve.getValues(segments[i2], segments[last ? 0 : i2 + 1], null, last && !closed));
              }
              this._area = area;
            }
            return area;
          },
          isFullySelected: function() {
            var length = this._segments.length;
            return this.isSelected() && length > 0 && this._segmentSelection === length * 7;
          },
          setFullySelected: function(selected) {
            if (selected)
              this._selectSegments(true);
            this.setSelected(selected);
          },
          setSelection: function setSelection(selection) {
            if (!(selection & 1))
              this._selectSegments(false);
            setSelection.base.call(this, selection);
          },
          _selectSegments: function(selected) {
            var segments = this._segments, length = segments.length, selection = selected ? 7 : 0;
            this._segmentSelection = selection * length;
            for (var i2 = 0; i2 < length; i2++)
              segments[i2]._selection = selection;
          },
          _updateSelection: function(segment, oldSelection, newSelection) {
            segment._selection = newSelection;
            var selection = this._segmentSelection += newSelection - oldSelection;
            if (selection > 0)
              this.setSelected(true);
          },
          divideAt: function(location) {
            var loc = this.getLocationAt(location), curve;
            return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset())) ? curve._segment1 : null;
          },
          splitAt: function(location) {
            var loc = this.getLocationAt(location), index = loc && loc.index, time = loc && loc.time, tMin = 1e-8, tMax = 1 - tMin;
            if (time > tMax) {
              index++;
              time = 0;
            }
            var curves = this.getCurves();
            if (index >= 0 && index < curves.length) {
              if (time >= tMin) {
                curves[index++].divideAtTime(time);
              }
              var segs = this.removeSegments(index, this._segments.length, true), path;
              if (this._closed) {
                this.setClosed(false);
                path = this;
              } else {
                path = new Path(Item.NO_INSERT);
                path.insertAbove(this);
                path.copyAttributes(this);
              }
              path._add(segs, 0);
              this.addSegment(segs[0]);
              return path;
            }
            return null;
          },
          split: function(index, time) {
            var curve, location = time === undefined2 ? index : (curve = this.getCurves()[index]) && curve.getLocationAtTime(time);
            return location != null ? this.splitAt(location) : null;
          },
          join: function(path, tolerance) {
            var epsilon = tolerance || 0;
            if (path && path !== this) {
              var segments = path._segments, last1 = this.getLastSegment(), last2 = path.getLastSegment();
              if (!last2)
                return this;
              if (last1 && last1._point.isClose(last2._point, epsilon))
                path.reverse();
              var first2 = path.getFirstSegment();
              if (last1 && last1._point.isClose(first2._point, epsilon)) {
                last1.setHandleOut(first2._handleOut);
                this._add(segments.slice(1));
              } else {
                var first1 = this.getFirstSegment();
                if (first1 && first1._point.isClose(first2._point, epsilon))
                  path.reverse();
                last2 = path.getLastSegment();
                if (first1 && first1._point.isClose(last2._point, epsilon)) {
                  first1.setHandleIn(last2._handleIn);
                  this._add(segments.slice(0, segments.length - 1), 0);
                } else {
                  this._add(segments.slice());
                }
              }
              if (path._closed)
                this._add([segments[0]]);
              path.remove();
            }
            var first = this.getFirstSegment(), last = this.getLastSegment();
            if (first !== last && first._point.isClose(last._point, epsilon)) {
              first.setHandleIn(last._handleIn);
              last.remove();
              this.setClosed(true);
            }
            return this;
          },
          reduce: function(options) {
            var curves = this.getCurves(), simplify = options && options.simplify, tolerance = simplify ? 1e-7 : 0;
            for (var i2 = curves.length - 1; i2 >= 0; i2--) {
              var curve = curves[i2];
              if (!curve.hasHandles() && (!curve.hasLength(tolerance) || simplify && curve.isCollinear(curve.getNext())))
                curve.remove();
            }
            return this;
          },
          reverse: function() {
            this._segments.reverse();
            for (var i2 = 0, l2 = this._segments.length; i2 < l2; i2++) {
              var segment = this._segments[i2];
              var handleIn = segment._handleIn;
              segment._handleIn = segment._handleOut;
              segment._handleOut = handleIn;
              segment._index = i2;
            }
            this._curves = null;
            this._changed(9);
          },
          flatten: function(flatness) {
            var flattener = new PathFlattener(this, flatness || 0.25, 256, true), parts = flattener.parts, length = parts.length, segments = [];
            for (var i2 = 0; i2 < length; i2++) {
              segments.push(new Segment(parts[i2].curve.slice(0, 2)));
            }
            if (!this._closed && length > 0) {
              segments.push(new Segment(parts[length - 1].curve.slice(6)));
            }
            this.setSegments(segments);
          },
          simplify: function(tolerance) {
            var segments = new PathFitter(this).fit(tolerance || 2.5);
            if (segments)
              this.setSegments(segments);
            return !!segments;
          },
          smooth: function(options) {
            var that = this, opts = options || {}, type = opts.type || "asymmetric", segments = this._segments, length = segments.length, closed = this._closed;
            function getIndex(value, _default) {
              var index = value && value.index;
              if (index != null) {
                var path = value.path;
                if (path && path !== that)
                  throw new Error(value._class + " " + index + " of " + path + " is not part of " + that);
                if (_default && value instanceof Curve)
                  index++;
              } else {
                index = typeof value === "number" ? value : _default;
              }
              return Math.min(index < 0 && closed ? index % length : index < 0 ? index + length : index, length - 1);
            }
            var loop = closed && opts.from === undefined2 && opts.to === undefined2, from = getIndex(opts.from, 0), to2 = getIndex(opts.to, length - 1);
            if (from > to2) {
              if (closed) {
                from -= length;
              } else {
                var tmp = from;
                from = to2;
                to2 = tmp;
              }
            }
            if (/^(?:asymmetric|continuous)$/.test(type)) {
              var asymmetric = type === "asymmetric", min = Math.min, amount = to2 - from + 1, n2 = amount - 1, padding = loop ? min(amount, 4) : 1, paddingLeft = padding, paddingRight = padding, knots = [];
              if (!closed) {
                paddingLeft = min(1, from);
                paddingRight = min(1, length - to2 - 1);
              }
              n2 += paddingLeft + paddingRight;
              if (n2 <= 1)
                return;
              for (var i2 = 0, j2 = from - paddingLeft; i2 <= n2; i2++, j2++) {
                knots[i2] = segments[(j2 < 0 ? j2 + length : j2) % length]._point;
              }
              var x2 = knots[0]._x + 2 * knots[1]._x, y2 = knots[0]._y + 2 * knots[1]._y, f = 2, n_1 = n2 - 1, rx = [x2], ry = [y2], rf2 = [f], px = [], py = [];
              for (var i2 = 1; i2 < n2; i2++) {
                var internal = i2 < n_1, a2 = internal ? 1 : asymmetric ? 1 : 2, b2 = internal ? 4 : asymmetric ? 2 : 7, u2 = internal ? 4 : asymmetric ? 3 : 8, v2 = internal ? 2 : asymmetric ? 0 : 1, m2 = a2 / f;
                f = rf2[i2] = b2 - m2;
                x2 = rx[i2] = u2 * knots[i2]._x + v2 * knots[i2 + 1]._x - m2 * x2;
                y2 = ry[i2] = u2 * knots[i2]._y + v2 * knots[i2 + 1]._y - m2 * y2;
              }
              px[n_1] = rx[n_1] / rf2[n_1];
              py[n_1] = ry[n_1] / rf2[n_1];
              for (var i2 = n2 - 2; i2 >= 0; i2--) {
                px[i2] = (rx[i2] - px[i2 + 1]) / rf2[i2];
                py[i2] = (ry[i2] - py[i2 + 1]) / rf2[i2];
              }
              px[n2] = (3 * knots[n2]._x - px[n_1]) / 2;
              py[n2] = (3 * knots[n2]._y - py[n_1]) / 2;
              for (var i2 = paddingLeft, max = n2 - paddingRight, j2 = from; i2 <= max; i2++, j2++) {
                var segment = segments[j2 < 0 ? j2 + length : j2], pt2 = segment._point, hx = px[i2] - pt2._x, hy = py[i2] - pt2._y;
                if (loop || i2 < max)
                  segment.setHandleOut(hx, hy);
                if (loop || i2 > paddingLeft)
                  segment.setHandleIn(-hx, -hy);
              }
            } else {
              for (var i2 = from; i2 <= to2; i2++) {
                segments[i2 < 0 ? i2 + length : i2].smooth(opts, !loop && i2 === from, !loop && i2 === to2);
              }
            }
          },
          toShape: function(insert) {
            if (!this._closed)
              return null;
            var segments = this._segments, type, size, radius, topCenter;
            function isCollinear(i2, j2) {
              var seg1 = segments[i2], seg2 = seg1.getNext(), seg3 = segments[j2], seg4 = seg3.getNext();
              return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));
            }
            function isOrthogonal(i2) {
              var seg2 = segments[i2], seg1 = seg2.getPrevious(), seg3 = seg2.getNext();
              return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));
            }
            function isArc(i2) {
              var seg1 = segments[i2], seg2 = seg1.getNext(), handle1 = seg1._handleOut, handle2 = seg2._handleIn, kappa = 0.5522847498307936;
              if (handle1.isOrthogonal(handle2)) {
                var pt1 = seg1._point, pt2 = seg2._point, corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);
                return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);
              }
              return false;
            }
            function getDistance(i2, j2) {
              return segments[i2]._point.getDistance(segments[j2]._point);
            }
            if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
              type = Shape.Rectangle;
              size = new Size(getDistance(0, 3), getDistance(0, 1));
              topCenter = segments[1]._point.add(segments[2]._point).divide(2);
            } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
              type = Shape.Rectangle;
              size = new Size(getDistance(1, 6), getDistance(0, 3));
              radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
              topCenter = segments[3]._point.add(segments[4]._point).divide(2);
            } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
              if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
                type = Shape.Circle;
                radius = getDistance(0, 2) / 2;
              } else {
                type = Shape.Ellipse;
                radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
              }
              topCenter = segments[1]._point;
            }
            if (type) {
              var center = this.getPosition(true), shape = new type({
                center,
                size,
                radius,
                insert: false
              });
              shape.copyAttributes(this, true);
              shape._matrix.prepend(this._matrix);
              shape.rotate(topCenter.subtract(center).getAngle() + 90);
              if (insert === undefined2 || insert)
                shape.insertAbove(this);
              return shape;
            }
            return null;
          },
          toPath: "#clone",
          compare: function compare(path) {
            if (!path || path instanceof CompoundPath)
              return compare.base.call(this, path);
            var curves1 = this.getCurves(), curves2 = path.getCurves(), length1 = curves1.length, length2 = curves2.length;
            if (!length1 || !length2) {
              return length1 == length2;
            }
            var v1 = curves1[0].getValues(), values2 = [], pos1 = 0, pos2, end1 = 0, end2;
            for (var i2 = 0; i2 < length2; i2++) {
              var v2 = curves2[i2].getValues();
              values2.push(v2);
              var overlaps = Curve.getOverlaps(v1, v2);
              if (overlaps) {
                pos2 = !i2 && overlaps[0][0] > 0 ? length2 - 1 : i2;
                end2 = overlaps[0][1];
                break;
              }
            }
            var abs = Math.abs, epsilon = 1e-8, v2 = values2[pos2], start2;
            while (v1 && v2) {
              var overlaps = Curve.getOverlaps(v1, v2);
              if (overlaps) {
                var t1 = overlaps[0][0];
                if (abs(t1 - end1) < epsilon) {
                  end1 = overlaps[1][0];
                  if (end1 === 1) {
                    v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
                    end1 = 0;
                  }
                  var t2 = overlaps[0][1];
                  if (abs(t2 - end2) < epsilon) {
                    if (!start2)
                      start2 = [pos2, t2];
                    end2 = overlaps[1][1];
                    if (end2 === 1) {
                      if (++pos2 >= length2)
                        pos2 = 0;
                      v2 = values2[pos2] || curves2[pos2].getValues();
                      end2 = 0;
                    }
                    if (!v1) {
                      return start2[0] === pos2 && start2[1] === end2;
                    }
                    continue;
                  }
                }
              }
              break;
            }
            return false;
          },
          _hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
            var that = this, style = this.getStyle(), segments = this._segments, numSegments = segments.length, closed = this._closed, tolerancePadding = options._tolerancePadding, strokePadding = tolerancePadding, join, cap, miterLimit, area, loc, res, hitStroke = options.stroke && style.hasStroke(), hitFill = options.fill && style.hasFill(), hitCurves = options.curves, strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;
            if (strokeRadius !== null) {
              if (strokeRadius > 0) {
                join = style.getStrokeJoin();
                cap = style.getStrokeCap();
                miterLimit = style.getMiterLimit();
                strokePadding = strokePadding.add(Path._getStrokePadding(strokeRadius, strokeMatrix));
              } else {
                join = cap = "round";
              }
            }
            function isCloseEnough(pt2, padding) {
              return point.subtract(pt2).divide(padding).length <= 1;
            }
            function checkSegmentPoint(seg, pt2, name) {
              if (!options.selected || pt2.isSelected()) {
                var anchor = seg._point;
                if (pt2 !== anchor)
                  pt2 = pt2.add(anchor);
                if (isCloseEnough(pt2, strokePadding)) {
                  return new HitResult(name, that, {
                    segment: seg,
                    point: pt2
                  });
                }
              }
            }
            function checkSegmentPoints(seg, ends) {
              return (ends || options.segments) && checkSegmentPoint(seg, seg._point, "segment") || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, "handle-in") || checkSegmentPoint(seg, seg._handleOut, "handle-out"));
            }
            function addToArea(point2) {
              area.add(point2);
            }
            function checkSegmentStroke(segment2) {
              var isJoin = closed || segment2._index > 0 && segment2._index < numSegments - 1;
              if ((isJoin ? join : cap) === "round") {
                return isCloseEnough(segment2._point, strokePadding);
              } else {
                area = new Path({ internal: true, closed: true });
                if (isJoin) {
                  if (!segment2.isSmooth()) {
                    Path._addBevelJoin(segment2, join, strokeRadius, miterLimit, null, strokeMatrix, addToArea, true);
                  }
                } else if (cap === "square") {
                  Path._addSquareCap(segment2, cap, strokeRadius, null, strokeMatrix, addToArea, true);
                }
                if (!area.isEmpty()) {
                  var loc2;
                  return area.contains(point) || (loc2 = area.getNearestLocation(point)) && isCloseEnough(loc2.getPoint(), tolerancePadding);
                }
              }
            }
            if (options.ends && !options.segments && !closed) {
              if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true))
                return res;
            } else if (options.segments || options.handles) {
              for (var i2 = 0; i2 < numSegments; i2++)
                if (res = checkSegmentPoints(segments[i2]))
                  return res;
            }
            if (strokeRadius !== null) {
              loc = this.getNearestLocation(point);
              if (loc) {
                var time = loc.getTime();
                if (time === 0 || time === 1 && numSegments > 1) {
                  if (!checkSegmentStroke(loc.getSegment()))
                    loc = null;
                } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
                  loc = null;
                }
              }
              if (!loc && join === "miter" && numSegments > 1) {
                for (var i2 = 0; i2 < numSegments; i2++) {
                  var segment = segments[i2];
                  if (point.getDistance(segment._point) <= miterLimit * strokeRadius && checkSegmentStroke(segment)) {
                    loc = segment.getLocation();
                    break;
                  }
                }
              }
            }
            return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult("fill", this) : loc ? new HitResult(hitStroke ? "stroke" : "curve", this, {
              location: loc,
              point: loc.getPoint()
            }) : null;
          }
        }, Base.each(Curve._evaluateMethods, function(name) {
          this[name + "At"] = function(offset) {
            var loc = this.getLocationAt(offset);
            return loc && loc[name]();
          };
        }, {
          beans: false,
          getLocationOf: function() {
            var point = Point.read(arguments), curves = this.getCurves();
            for (var i2 = 0, l2 = curves.length; i2 < l2; i2++) {
              var loc = curves[i2].getLocationOf(point);
              if (loc)
                return loc;
            }
            return null;
          },
          getOffsetOf: function() {
            var loc = this.getLocationOf.apply(this, arguments);
            return loc ? loc.getOffset() : null;
          },
          getLocationAt: function(offset) {
            if (typeof offset === "number") {
              var curves = this.getCurves(), length = 0;
              for (var i2 = 0, l2 = curves.length; i2 < l2; i2++) {
                var start = length, curve = curves[i2];
                length += curve.getLength();
                if (length > offset) {
                  return curve.getLocationAt(offset - start);
                }
              }
              if (curves.length > 0 && offset <= this.getLength()) {
                return new CurveLocation(curves[curves.length - 1], 1);
              }
            } else if (offset && offset.getPath && offset.getPath() === this) {
              return offset;
            }
            return null;
          },
          getOffsetsWithTangent: function() {
            var tangent = Point.read(arguments);
            if (tangent.isZero()) {
              return [];
            }
            var offsets = [];
            var curveStart = 0;
            var curves = this.getCurves();
            for (var i2 = 0, l2 = curves.length; i2 < l2; i2++) {
              var curve = curves[i2];
              var curveTimes = curve.getTimesWithTangent(tangent);
              for (var j2 = 0, m2 = curveTimes.length; j2 < m2; j2++) {
                var offset = curveStart + curve.getOffsetAtTime(curveTimes[j2]);
                if (offsets.indexOf(offset) < 0) {
                  offsets.push(offset);
                }
              }
              curveStart += curve.length;
            }
            return offsets;
          }
        }), new function() {
          function drawHandles(ctx, segments, matrix, size) {
            if (size <= 0)
              return;
            var half = size / 2, miniSize = size - 2, miniHalf = half - 1, coords = new Array(6), pX, pY;
            function drawHandle(index) {
              var hX = coords[index], hY = coords[index + 1];
              if (pX != hX || pY != hY) {
                ctx.beginPath();
                ctx.moveTo(pX, pY);
                ctx.lineTo(hX, hY);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
                ctx.fill();
              }
            }
            for (var i2 = 0, l2 = segments.length; i2 < l2; i2++) {
              var segment = segments[i2], selection = segment._selection;
              segment._transformCoordinates(matrix, coords);
              pX = coords[0];
              pY = coords[1];
              if (selection & 2)
                drawHandle(2);
              if (selection & 4)
                drawHandle(4);
              ctx.fillRect(pX - half, pY - half, size, size);
              if (miniSize > 0 && !(selection & 1)) {
                var fillStyle = ctx.fillStyle;
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
                ctx.fillStyle = fillStyle;
              }
            }
          }
          function drawSegments(ctx, path, matrix) {
            var segments = path._segments, length = segments.length, coords = new Array(6), first = true, curX, curY, prevX, prevY, inX, inY, outX, outY;
            function drawSegment(segment) {
              if (matrix) {
                segment._transformCoordinates(matrix, coords);
                curX = coords[0];
                curY = coords[1];
              } else {
                var point = segment._point;
                curX = point._x;
                curY = point._y;
              }
              if (first) {
                ctx.moveTo(curX, curY);
                first = false;
              } else {
                if (matrix) {
                  inX = coords[2];
                  inY = coords[3];
                } else {
                  var handle = segment._handleIn;
                  inX = curX + handle._x;
                  inY = curY + handle._y;
                }
                if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
                  ctx.lineTo(curX, curY);
                } else {
                  ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
                }
              }
              prevX = curX;
              prevY = curY;
              if (matrix) {
                outX = coords[4];
                outY = coords[5];
              } else {
                var handle = segment._handleOut;
                outX = prevX + handle._x;
                outY = prevY + handle._y;
              }
            }
            for (var i2 = 0; i2 < length; i2++)
              drawSegment(segments[i2]);
            if (path._closed && length > 0)
              drawSegment(segments[0]);
          }
          return {
            _draw: function(ctx, param, viewMatrix, strokeMatrix) {
              var dontStart = param.dontStart, dontPaint = param.dontFinish || param.clip, style = this.getStyle(), hasFill = style.hasFill(), hasStroke = style.hasStroke(), dashArray = style.getDashArray(), dashLength = !paper2.support.nativeDash && hasStroke && dashArray && dashArray.length;
              if (!dontStart)
                ctx.beginPath();
              if (hasFill || hasStroke && !dashLength || dontPaint) {
                drawSegments(ctx, this, strokeMatrix);
                if (this._closed)
                  ctx.closePath();
              }
              function getOffset(i3) {
                return dashArray[(i3 % dashLength + dashLength) % dashLength];
              }
              if (!dontPaint && (hasFill || hasStroke)) {
                this._setStyles(ctx, param, viewMatrix);
                if (hasFill) {
                  ctx.fill(style.getFillRule());
                  ctx.shadowColor = "rgba(0,0,0,0)";
                }
                if (hasStroke) {
                  if (dashLength) {
                    if (!dontStart)
                      ctx.beginPath();
                    var flattener = new PathFlattener(this, 0.25, 32, false, strokeMatrix), length = flattener.length, from = -style.getDashOffset(), to2, i2 = 0;
                    while (from > 0) {
                      from -= getOffset(i2--) + getOffset(i2--);
                    }
                    while (from < length) {
                      to2 = from + getOffset(i2++);
                      if (from > 0 || to2 > 0)
                        flattener.drawPart(ctx, Math.max(from, 0), Math.max(to2, 0));
                      from = to2 + getOffset(i2++);
                    }
                  }
                  ctx.stroke();
                }
              }
            },
            _drawSelected: function(ctx, matrix) {
              ctx.beginPath();
              drawSegments(ctx, this, matrix);
              ctx.stroke();
              drawHandles(ctx, this._segments, matrix, paper2.settings.handleSize);
            }
          };
        }(), new function() {
          function getCurrentSegment(that) {
            var segments = that._segments;
            if (!segments.length)
              throw new Error("Use a moveTo() command first");
            return segments[segments.length - 1];
          }
          return {
            moveTo: function() {
              var segments = this._segments;
              if (segments.length === 1)
                this.removeSegment(0);
              if (!segments.length)
                this._add([new Segment(Point.read(arguments))]);
            },
            moveBy: function() {
              throw new Error("moveBy() is unsupported on Path items.");
            },
            lineTo: function() {
              this._add([new Segment(Point.read(arguments))]);
            },
            cubicCurveTo: function() {
              var args = arguments, handle1 = Point.read(args), handle2 = Point.read(args), to2 = Point.read(args), current = getCurrentSegment(this);
              current.setHandleOut(handle1.subtract(current._point));
              this._add([new Segment(to2, handle2.subtract(to2))]);
            },
            quadraticCurveTo: function() {
              var args = arguments, handle = Point.read(args), to2 = Point.read(args), current = getCurrentSegment(this)._point;
              this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to2.subtract(handle).multiply(1 / 3)), to2);
            },
            curveTo: function() {
              var args = arguments, through = Point.read(args), to2 = Point.read(args), t2 = Base.pick(Base.read(args), 0.5), t1 = 1 - t2, current = getCurrentSegment(this)._point, handle = through.subtract(current.multiply(t1 * t1)).subtract(to2.multiply(t2 * t2)).divide(2 * t2 * t1);
              if (handle.isNaN())
                throw new Error("Cannot put a curve through points with parameter = " + t2);
              this.quadraticCurveTo(handle, to2);
            },
            arcTo: function() {
              var args = arguments, abs = Math.abs, sqrt = Math.sqrt, current = getCurrentSegment(this), from = current._point, to2 = Point.read(args), through, peek = Base.peek(args), clockwise = Base.pick(peek, true), center, extent, vector, matrix;
              if (typeof clockwise === "boolean") {
                var middle = from.add(to2).divide(2), through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
              } else if (Base.remain(args) <= 2) {
                through = to2;
                to2 = Point.read(args);
              } else if (!from.equals(to2)) {
                var radius = Size.read(args), isZero = Numerical.isZero;
                if (isZero(radius.width) || isZero(radius.height))
                  return this.lineTo(to2);
                var rotation = Base.read(args), clockwise = !!Base.read(args), large = !!Base.read(args), middle = from.add(to2).divide(2), pt2 = from.subtract(middle).rotate(-rotation), x2 = pt2.x, y2 = pt2.y, rx = abs(radius.width), ry = abs(radius.height), rxSq = rx * rx, rySq = ry * ry, xSq = x2 * x2, ySq = y2 * y2;
                var factor = sqrt(xSq / rxSq + ySq / rySq);
                if (factor > 1) {
                  rx *= factor;
                  ry *= factor;
                  rxSq = rx * rx;
                  rySq = ry * ry;
                }
                factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
                if (abs(factor) < 1e-12)
                  factor = 0;
                if (factor < 0)
                  throw new Error("Cannot create an arc with the given arguments");
                center = new Point(rx * y2 / ry, -ry * x2 / rx).multiply((large === clockwise ? -1 : 1) * sqrt(factor)).rotate(rotation).add(middle);
                matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
                vector = matrix._inverseTransform(from);
                extent = vector.getDirectedAngle(matrix._inverseTransform(to2));
                if (!clockwise && extent > 0)
                  extent -= 360;
                else if (clockwise && extent < 0)
                  extent += 360;
              }
              if (through) {
                var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true), l2 = new Line(through.add(to2).divide(2), to2.subtract(through).rotate(90), true), line = new Line(from, to2), throughSide = line.getSide(through);
                center = l1.intersect(l2, true);
                if (!center) {
                  if (!throughSide)
                    return this.lineTo(to2);
                  throw new Error("Cannot create an arc with the given arguments");
                }
                vector = from.subtract(center);
                extent = vector.getDirectedAngle(to2.subtract(center));
                var centerSide = line.getSide(center, true);
                if (centerSide === 0) {
                  extent = throughSide * abs(extent);
                } else if (throughSide === centerSide) {
                  extent += extent < 0 ? 360 : -360;
                }
              }
              if (extent) {
                var epsilon = 1e-7, ext = abs(extent), count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90), inc = extent / count, half = inc * Math.PI / 360, z2 = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)), segments = [];
                for (var i2 = 0; i2 <= count; i2++) {
                  var pt2 = to2, out = null;
                  if (i2 < count) {
                    out = vector.rotate(90).multiply(z2);
                    if (matrix) {
                      pt2 = matrix._transformPoint(vector);
                      out = matrix._transformPoint(vector.add(out)).subtract(pt2);
                    } else {
                      pt2 = center.add(vector);
                    }
                  }
                  if (!i2) {
                    current.setHandleOut(out);
                  } else {
                    var _in = vector.rotate(-90).multiply(z2);
                    if (matrix) {
                      _in = matrix._transformPoint(vector.add(_in)).subtract(pt2);
                    }
                    segments.push(new Segment(pt2, _in, out));
                  }
                  vector = vector.rotate(inc);
                }
                this._add(segments);
              }
            },
            lineBy: function() {
              var to2 = Point.read(arguments), current = getCurrentSegment(this)._point;
              this.lineTo(current.add(to2));
            },
            curveBy: function() {
              var args = arguments, through = Point.read(args), to2 = Point.read(args), parameter = Base.read(args), current = getCurrentSegment(this)._point;
              this.curveTo(current.add(through), current.add(to2), parameter);
            },
            cubicCurveBy: function() {
              var args = arguments, handle1 = Point.read(args), handle2 = Point.read(args), to2 = Point.read(args), current = getCurrentSegment(this)._point;
              this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to2));
            },
            quadraticCurveBy: function() {
              var args = arguments, handle = Point.read(args), to2 = Point.read(args), current = getCurrentSegment(this)._point;
              this.quadraticCurveTo(current.add(handle), current.add(to2));
            },
            arcBy: function() {
              var args = arguments, current = getCurrentSegment(this)._point, point = current.add(Point.read(args)), clockwise = Base.pick(Base.peek(args), true);
              if (typeof clockwise === "boolean") {
                this.arcTo(point, clockwise);
              } else {
                this.arcTo(point, current.add(Point.read(args)));
              }
            },
            closePath: function(tolerance) {
              this.setClosed(true);
              this.join(this, tolerance);
            }
          };
        }(), {
          _getBounds: function(matrix, options) {
            var method = options.handle ? "getHandleBounds" : options.stroke ? "getStrokeBounds" : "getBounds";
            return Path[method](this._segments, this._closed, this, matrix, options);
          },
          statics: {
            getBounds: function(segments, closed, path, matrix, options, strokePadding) {
              var first = segments[0];
              if (!first)
                return new Rectangle();
              var coords = new Array(6), prevCoords = first._transformCoordinates(matrix, new Array(6)), min = prevCoords.slice(0, 2), max = min.slice(), roots = new Array(2);
              function processSegment(segment) {
                segment._transformCoordinates(matrix, coords);
                for (var i3 = 0; i3 < 2; i3++) {
                  Curve._addBounds(prevCoords[i3], prevCoords[i3 + 4], coords[i3 + 2], coords[i3], i3, strokePadding ? strokePadding[i3] : 0, min, max, roots);
                }
                var tmp = prevCoords;
                prevCoords = coords;
                coords = tmp;
              }
              for (var i2 = 1, l2 = segments.length; i2 < l2; i2++)
                processSegment(segments[i2]);
              if (closed)
                processSegment(first);
              return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
            },
            getStrokeBounds: function(segments, closed, path, matrix, options) {
              var style = path.getStyle(), stroke = style.hasStroke(), strokeWidth = style.getStrokeWidth(), strokeMatrix = stroke && path._getStrokeMatrix(matrix, options), strokePadding = stroke && Path._getStrokePadding(strokeWidth, strokeMatrix), bounds = Path.getBounds(segments, closed, path, matrix, options, strokePadding);
              if (!stroke)
                return bounds;
              var strokeRadius = strokeWidth / 2, join = style.getStrokeJoin(), cap = style.getStrokeCap(), miterLimit = style.getMiterLimit(), joinBounds = new Rectangle(new Size(strokePadding));
              function addPoint(point) {
                bounds = bounds.include(point);
              }
              function addRound(segment) {
                bounds = bounds.unite(joinBounds.setCenter(segment._point.transform(matrix)));
              }
              function addJoin(segment, join2) {
                if (join2 === "round" || segment.isSmooth()) {
                  addRound(segment);
                } else {
                  Path._addBevelJoin(segment, join2, strokeRadius, miterLimit, matrix, strokeMatrix, addPoint);
                }
              }
              function addCap(segment, cap2) {
                if (cap2 === "round") {
                  addRound(segment);
                } else {
                  Path._addSquareCap(segment, cap2, strokeRadius, matrix, strokeMatrix, addPoint);
                }
              }
              var length = segments.length - (closed ? 0 : 1);
              if (length > 0) {
                for (var i2 = 1; i2 < length; i2++) {
                  addJoin(segments[i2], join);
                }
                if (closed) {
                  addJoin(segments[0], join);
                } else {
                  addCap(segments[0], cap);
                  addCap(segments[segments.length - 1], cap);
                }
              }
              return bounds;
            },
            _getStrokePadding: function(radius, matrix) {
              if (!matrix)
                return [radius, radius];
              var hor = new Point(radius, 0).transform(matrix), ver = new Point(0, radius).transform(matrix), phi = hor.getAngleInRadians(), a2 = hor.getLength(), b2 = ver.getLength();
              var sin = Math.sin(phi), cos = Math.cos(phi), tan = Math.tan(phi), tx = Math.atan2(b2 * tan, a2), ty = Math.atan2(b2, tan * a2);
              return [
                Math.abs(a2 * Math.cos(tx) * cos + b2 * Math.sin(tx) * sin),
                Math.abs(b2 * Math.sin(ty) * cos + a2 * Math.cos(ty) * sin)
              ];
            },
            _addBevelJoin: function(segment, join, radius, miterLimit, matrix, strokeMatrix, addPoint, isArea) {
              var curve2 = segment.getCurve(), curve1 = curve2.getPrevious(), point = curve2.getPoint1().transform(matrix), normal1 = curve1.getNormalAtTime(1).multiply(radius).transform(strokeMatrix), normal2 = curve2.getNormalAtTime(0).multiply(radius).transform(strokeMatrix), angle = normal1.getDirectedAngle(normal2);
              if (angle < 0 || angle >= 180) {
                normal1 = normal1.negate();
                normal2 = normal2.negate();
              }
              if (isArea)
                addPoint(point);
              addPoint(point.add(normal1));
              if (join === "miter") {
                var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);
                if (corner && point.getDistance(corner) <= miterLimit * radius) {
                  addPoint(corner);
                }
              }
              addPoint(point.add(normal2));
            },
            _addSquareCap: function(segment, cap, radius, matrix, strokeMatrix, addPoint, isArea) {
              var point = segment._point.transform(matrix), loc = segment.getLocation(), normal = loc.getNormal().multiply(loc.getTime() === 0 ? radius : -radius).transform(strokeMatrix);
              if (cap === "square") {
                if (isArea) {
                  addPoint(point.subtract(normal));
                  addPoint(point.add(normal));
                }
                point = point.add(normal.rotate(-90));
              }
              addPoint(point.add(normal));
              addPoint(point.subtract(normal));
            },
            getHandleBounds: function(segments, closed, path, matrix, options) {
              var style = path.getStyle(), stroke = options.stroke && style.hasStroke(), strokePadding, joinPadding;
              if (stroke) {
                var strokeMatrix = path._getStrokeMatrix(matrix, options), strokeRadius = style.getStrokeWidth() / 2, joinRadius = strokeRadius;
                if (style.getStrokeJoin() === "miter")
                  joinRadius = strokeRadius * style.getMiterLimit();
                if (style.getStrokeCap() === "square")
                  joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
                strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
                joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
              }
              var coords = new Array(6), x1 = Infinity, x2 = -x1, y1 = x1, y2 = x2;
              for (var i2 = 0, l2 = segments.length; i2 < l2; i2++) {
                var segment = segments[i2];
                segment._transformCoordinates(matrix, coords);
                for (var j2 = 0; j2 < 6; j2 += 2) {
                  var padding = !j2 ? joinPadding : strokePadding, paddingX = padding ? padding[0] : 0, paddingY = padding ? padding[1] : 0, x3 = coords[j2], y3 = coords[j2 + 1], xn2 = x3 - paddingX, xx = x3 + paddingX, yn2 = y3 - paddingY, yx = y3 + paddingY;
                  if (xn2 < x1)
                    x1 = xn2;
                  if (xx > x2)
                    x2 = xx;
                  if (yn2 < y1)
                    y1 = yn2;
                  if (yx > y2)
                    y2 = yx;
                }
              }
              return new Rectangle(x1, y1, x2 - x1, y2 - y1);
            }
          }
        });
        Path.inject({ statics: new function() {
          var kappa = 0.5522847498307936, ellipseSegments = [
            new Segment([-1, 0], [0, kappa], [0, -kappa]),
            new Segment([0, -1], [-kappa, 0], [kappa, 0]),
            new Segment([1, 0], [0, -kappa], [0, kappa]),
            new Segment([0, 1], [kappa, 0], [-kappa, 0])
          ];
          function createPath(segments, closed, args) {
            var props = Base.getNamed(args), path = new Path(props && props.insert == false && Item.NO_INSERT);
            path._add(segments);
            path._closed = closed;
            return path.set(props, { insert: true });
          }
          function createEllipse(center, radius, args) {
            var segments = new Array(4);
            for (var i2 = 0; i2 < 4; i2++) {
              var segment = ellipseSegments[i2];
              segments[i2] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
            }
            return createPath(segments, true, args);
          }
          return {
            Line: function() {
              var args = arguments;
              return createPath([
                new Segment(Point.readNamed(args, "from")),
                new Segment(Point.readNamed(args, "to"))
              ], false, args);
            },
            Circle: function() {
              var args = arguments, center = Point.readNamed(args, "center"), radius = Base.readNamed(args, "radius");
              return createEllipse(center, new Size(radius), args);
            },
            Rectangle: function() {
              var args = arguments, rect = Rectangle.readNamed(args, "rectangle"), radius = Size.readNamed(args, "radius", 0, { readNull: true }), bl2 = rect.getBottomLeft(true), tl2 = rect.getTopLeft(true), tr2 = rect.getTopRight(true), br2 = rect.getBottomRight(true), segments;
              if (!radius || radius.isZero()) {
                segments = [
                  new Segment(bl2),
                  new Segment(tl2),
                  new Segment(tr2),
                  new Segment(br2)
                ];
              } else {
                radius = Size.min(radius, rect.getSize(true).divide(2));
                var rx = radius.width, ry = radius.height, hx = rx * kappa, hy = ry * kappa;
                segments = [
                  new Segment(bl2.add(rx, 0), null, [-hx, 0]),
                  new Segment(bl2.subtract(0, ry), [0, hy]),
                  new Segment(tl2.add(0, ry), null, [0, -hy]),
                  new Segment(tl2.add(rx, 0), [-hx, 0], null),
                  new Segment(tr2.subtract(rx, 0), null, [hx, 0]),
                  new Segment(tr2.add(0, ry), [0, -hy], null),
                  new Segment(br2.subtract(0, ry), null, [0, hy]),
                  new Segment(br2.subtract(rx, 0), [hx, 0])
                ];
              }
              return createPath(segments, true, args);
            },
            RoundRectangle: "#Rectangle",
            Ellipse: function() {
              var args = arguments, ellipse = Shape._readEllipse(args);
              return createEllipse(ellipse.center, ellipse.radius, args);
            },
            Oval: "#Ellipse",
            Arc: function() {
              var args = arguments, from = Point.readNamed(args, "from"), through = Point.readNamed(args, "through"), to2 = Point.readNamed(args, "to"), props = Base.getNamed(args), path = new Path(props && props.insert == false && Item.NO_INSERT);
              path.moveTo(from);
              path.arcTo(through, to2);
              return path.set(props);
            },
            RegularPolygon: function() {
              var args = arguments, center = Point.readNamed(args, "center"), sides = Base.readNamed(args, "sides"), radius = Base.readNamed(args, "radius"), step = 360 / sides, three = sides % 3 === 0, vector = new Point(0, three ? -radius : radius), offset = three ? -1 : 0.5, segments = new Array(sides);
              for (var i2 = 0; i2 < sides; i2++)
                segments[i2] = new Segment(center.add(vector.rotate((i2 + offset) * step)));
              return createPath(segments, true, args);
            },
            Star: function() {
              var args = arguments, center = Point.readNamed(args, "center"), points = Base.readNamed(args, "points") * 2, radius1 = Base.readNamed(args, "radius1"), radius2 = Base.readNamed(args, "radius2"), step = 360 / points, vector = new Point(0, -1), segments = new Array(points);
              for (var i2 = 0; i2 < points; i2++)
                segments[i2] = new Segment(center.add(vector.rotate(step * i2).multiply(i2 % 2 ? radius2 : radius1)));
              return createPath(segments, true, args);
            }
          };
        }() });
        var CompoundPath = PathItem.extend({
          _class: "CompoundPath",
          _serializeFields: {
            children: []
          },
          beans: true,
          initialize: function CompoundPath2(arg) {
            this._children = [];
            this._namedChildren = {};
            if (!this._initialize(arg)) {
              if (typeof arg === "string") {
                this.setPathData(arg);
              } else {
                this.addChildren(Array.isArray(arg) ? arg : arguments);
              }
            }
          },
          insertChildren: function insertChildren(index, items) {
            var list = items, first = list[0];
            if (first && typeof first[0] === "number")
              list = [list];
            for (var i2 = items.length - 1; i2 >= 0; i2--) {
              var item = list[i2];
              if (list === items && !(item instanceof Path))
                list = Base.slice(list);
              if (Array.isArray(item)) {
                list[i2] = new Path({ segments: item, insert: false });
              } else if (item instanceof CompoundPath) {
                list.splice.apply(list, [i2, 1].concat(item.removeChildren()));
                item.remove();
              }
            }
            return insertChildren.base.call(this, index, list);
          },
          reduce: function reduce(options) {
            var children = this._children;
            for (var i2 = children.length - 1; i2 >= 0; i2--) {
              var path = children[i2].reduce(options);
              if (path.isEmpty())
                path.remove();
            }
            if (!children.length) {
              var path = new Path(Item.NO_INSERT);
              path.copyAttributes(this);
              path.insertAbove(this);
              this.remove();
              return path;
            }
            return reduce.base.call(this);
          },
          isClosed: function() {
            var children = this._children;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              if (!children[i2]._closed)
                return false;
            }
            return true;
          },
          setClosed: function(closed) {
            var children = this._children;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              children[i2].setClosed(closed);
            }
          },
          getFirstSegment: function() {
            var first = this.getFirstChild();
            return first && first.getFirstSegment();
          },
          getLastSegment: function() {
            var last = this.getLastChild();
            return last && last.getLastSegment();
          },
          getCurves: function() {
            var children = this._children, curves = [];
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              Base.push(curves, children[i2].getCurves());
            }
            return curves;
          },
          getFirstCurve: function() {
            var first = this.getFirstChild();
            return first && first.getFirstCurve();
          },
          getLastCurve: function() {
            var last = this.getLastChild();
            return last && last.getLastCurve();
          },
          getArea: function() {
            var children = this._children, area = 0;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
              area += children[i2].getArea();
            return area;
          },
          getLength: function() {
            var children = this._children, length = 0;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
              length += children[i2].getLength();
            return length;
          },
          getPathData: function(_matrix, _precision) {
            var children = this._children, paths = [];
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              var child = children[i2], mx = child._matrix;
              paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.appended(mx) : _matrix, _precision));
            }
            return paths.join("");
          },
          _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
            return _hitTestChildren.base.call(this, point, options.class === Path || options.type === "path" ? options : Base.set({}, options, { fill: false }), viewMatrix);
          },
          _draw: function(ctx, param, viewMatrix, strokeMatrix) {
            var children = this._children;
            if (!children.length)
              return;
            param = param.extend({ dontStart: true, dontFinish: true });
            ctx.beginPath();
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
              children[i2].draw(ctx, param, strokeMatrix);
            if (!param.clip) {
              this._setStyles(ctx, param, viewMatrix);
              var style = this._style;
              if (style.hasFill()) {
                ctx.fill(style.getFillRule());
                ctx.shadowColor = "rgba(0,0,0,0)";
              }
              if (style.hasStroke())
                ctx.stroke();
            }
          },
          _drawSelected: function(ctx, matrix, selectionItems) {
            var children = this._children;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              var child = children[i2], mx = child._matrix;
              if (!selectionItems[child._id]) {
                child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.appended(mx));
              }
            }
          }
        }, new function() {
          function getCurrentPath(that, check) {
            var children = that._children;
            if (check && !children.length)
              throw new Error("Use a moveTo() command first");
            return children[children.length - 1];
          }
          return Base.each([
            "lineTo",
            "cubicCurveTo",
            "quadraticCurveTo",
            "curveTo",
            "arcTo",
            "lineBy",
            "cubicCurveBy",
            "quadraticCurveBy",
            "curveBy",
            "arcBy"
          ], function(key) {
            this[key] = function() {
              var path = getCurrentPath(this, true);
              path[key].apply(path, arguments);
            };
          }, {
            moveTo: function() {
              var current = getCurrentPath(this), path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);
              if (path !== current)
                this.addChild(path);
              path.moveTo.apply(path, arguments);
            },
            moveBy: function() {
              var current = getCurrentPath(this, true), last = current && current.getLastSegment(), point = Point.read(arguments);
              this.moveTo(last ? point.add(last._point) : point);
            },
            closePath: function(tolerance) {
              getCurrentPath(this, true).closePath(tolerance);
            }
          });
        }(), Base.each(["reverse", "flatten", "simplify", "smooth"], function(key) {
          this[key] = function(param) {
            var children = this._children, res;
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              res = children[i2][key](param) || res;
            }
            return res;
          };
        }, {}));
        PathItem.inject(new function() {
          var min = Math.min, max = Math.max, abs = Math.abs, operators = {
            unite: { "1": true, "2": true },
            intersect: { "2": true },
            subtract: { "1": true },
            exclude: { "1": true, "-1": true }
          };
          function getPaths(path) {
            return path._children || [path];
          }
          function preparePath(path, resolve) {
            var res = path.clone(false).reduce({ simplify: true }).transform(null, true, true);
            if (resolve) {
              var paths = getPaths(res);
              for (var i2 = 0, l2 = paths.length; i2 < l2; i2++) {
                var path = paths[i2];
                if (!path._closed && !path.isEmpty()) {
                  path.closePath(1e-12);
                  path.getFirstSegment().setHandleIn(0, 0);
                  path.getLastSegment().setHandleOut(0, 0);
                }
              }
              res = res.resolveCrossings().reorient(res.getFillRule() === "nonzero", true);
            }
            return res;
          }
          function createResult(paths, simplify, path1, path2, options) {
            var result = new CompoundPath(Item.NO_INSERT);
            result.addChildren(paths, true);
            result = result.reduce({ simplify });
            if (!(options && options.insert == false)) {
              result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);
            }
            result.copyAttributes(path1, true);
            return result;
          }
          function filterIntersection(inter) {
            return inter.hasOverlap() || inter.isCrossing();
          }
          function traceBoolean(path1, path2, operation, options) {
            if (options && (options.trace == false || options.stroke) && /^(subtract|intersect)$/.test(operation))
              return splitBoolean(path1, path2, operation);
            var _path1 = preparePath(path1, true), _path2 = path2 && path1 !== path2 && preparePath(path2, true), operator = operators[operation];
            operator[operation] = true;
            if (_path2 && (operator.subtract || operator.exclude) ^ (_path2.isClockwise() ^ _path1.isClockwise()))
              _path2.reverse();
            var crossings = divideLocations(CurveLocation.expand(_path1.getIntersections(_path2, filterIntersection))), paths1 = getPaths(_path1), paths2 = _path2 && getPaths(_path2), segments = [], curves = [], paths;
            function collectPaths(paths3) {
              for (var i3 = 0, l3 = paths3.length; i3 < l3; i3++) {
                var path = paths3[i3];
                Base.push(segments, path._segments);
                Base.push(curves, path.getCurves());
                path._overlapsOnly = true;
              }
            }
            function getCurves(indices) {
              var list = [];
              for (var i3 = 0, l3 = indices && indices.length; i3 < l3; i3++) {
                list.push(curves[indices[i3]]);
              }
              return list;
            }
            if (crossings.length) {
              collectPaths(paths1);
              if (paths2)
                collectPaths(paths2);
              var curvesValues = new Array(curves.length);
              for (var i2 = 0, l2 = curves.length; i2 < l2; i2++) {
                curvesValues[i2] = curves[i2].getValues();
              }
              var curveCollisions = CollisionDetection.findCurveBoundsCollisions(curvesValues, curvesValues, 0, true);
              var curveCollisionsMap = {};
              for (var i2 = 0; i2 < curves.length; i2++) {
                var curve = curves[i2], id2 = curve._path._id, map = curveCollisionsMap[id2] = curveCollisionsMap[id2] || {};
                map[curve.getIndex()] = {
                  hor: getCurves(curveCollisions[i2].hor),
                  ver: getCurves(curveCollisions[i2].ver)
                };
              }
              for (var i2 = 0, l2 = crossings.length; i2 < l2; i2++) {
                propagateWinding(crossings[i2]._segment, _path1, _path2, curveCollisionsMap, operator);
              }
              for (var i2 = 0, l2 = segments.length; i2 < l2; i2++) {
                var segment = segments[i2], inter = segment._intersection;
                if (!segment._winding) {
                  propagateWinding(segment, _path1, _path2, curveCollisionsMap, operator);
                }
                if (!(inter && inter._overlap))
                  segment._path._overlapsOnly = false;
              }
              paths = tracePaths(segments, operator);
            } else {
              paths = reorientPaths(paths2 ? paths1.concat(paths2) : paths1.slice(), function(w2) {
                return !!operator[w2];
              });
            }
            return createResult(paths, true, path1, path2, options);
          }
          function splitBoolean(path1, path2, operation) {
            var _path1 = preparePath(path1), _path2 = preparePath(path2), crossings = _path1.getIntersections(_path2, filterIntersection), subtract = operation === "subtract", divide = operation === "divide", added = {}, paths = [];
            function addPath(path3) {
              if (!added[path3._id] && (divide || _path2.contains(path3.getPointAt(path3.getLength() / 2)) ^ subtract)) {
                paths.unshift(path3);
                return added[path3._id] = true;
              }
            }
            for (var i2 = crossings.length - 1; i2 >= 0; i2--) {
              var path = crossings[i2].split();
              if (path) {
                if (addPath(path))
                  path.getFirstSegment().setHandleIn(0, 0);
                _path1.getLastSegment().setHandleOut(0, 0);
              }
            }
            addPath(_path1);
            return createResult(paths, false, path1, path2);
          }
          function linkIntersections(from, to2) {
            var prev = from;
            while (prev) {
              if (prev === to2)
                return;
              prev = prev._previous;
            }
            while (from._next && from._next !== to2)
              from = from._next;
            if (!from._next) {
              while (to2._previous)
                to2 = to2._previous;
              from._next = to2;
              to2._previous = from;
            }
          }
          function clearCurveHandles(curves) {
            for (var i2 = curves.length - 1; i2 >= 0; i2--)
              curves[i2].clearHandles();
          }
          function reorientPaths(paths, isInside, clockwise) {
            var length = paths && paths.length;
            if (length) {
              var lookup = Base.each(paths, function(path, i3) {
                this[path._id] = {
                  container: null,
                  winding: path.isClockwise() ? 1 : -1,
                  index: i3
                };
              }, {}), sorted = paths.slice().sort(function(a2, b2) {
                return abs(b2.getArea()) - abs(a2.getArea());
              }), first = sorted[0];
              var collisions = CollisionDetection.findItemBoundsCollisions(sorted, null, Numerical.GEOMETRIC_EPSILON);
              if (clockwise == null)
                clockwise = first.isClockwise();
              for (var i2 = 0; i2 < length; i2++) {
                var path1 = sorted[i2], entry1 = lookup[path1._id], containerWinding = 0, indices = collisions[i2];
                if (indices) {
                  var point = null;
                  for (var j2 = indices.length - 1; j2 >= 0; j2--) {
                    if (indices[j2] < i2) {
                      point = point || path1.getInteriorPoint();
                      var path2 = sorted[indices[j2]];
                      if (path2.contains(point)) {
                        var entry2 = lookup[path2._id];
                        containerWinding = entry2.winding;
                        entry1.winding += containerWinding;
                        entry1.container = entry2.exclude ? entry2.container : path2;
                        break;
                      }
                    }
                  }
                }
                if (isInside(entry1.winding) === isInside(containerWinding)) {
                  entry1.exclude = true;
                  paths[entry1.index] = null;
                } else {
                  var container = entry1.container;
                  path1.setClockwise(container ? !container.isClockwise() : clockwise);
                }
              }
            }
            return paths;
          }
          function divideLocations(locations, include, clearLater) {
            var results = include && [], tMin = 1e-8, tMax = 1 - tMin, clearHandles = false, clearCurves = clearLater || [], clearLookup = clearLater && {}, renormalizeLocs, prevCurve, prevTime;
            function getId(curve2) {
              return curve2._path._id + "." + curve2._segment1._index;
            }
            for (var i2 = (clearLater && clearLater.length) - 1; i2 >= 0; i2--) {
              var curve = clearLater[i2];
              if (curve._path)
                clearLookup[getId(curve)] = true;
            }
            for (var i2 = locations.length - 1; i2 >= 0; i2--) {
              var loc = locations[i2], time = loc._time, origTime = time, exclude = include && !include(loc), curve = loc._curve, segment;
              if (curve) {
                if (curve !== prevCurve) {
                  clearHandles = !curve.hasHandles() || clearLookup && clearLookup[getId(curve)];
                  renormalizeLocs = [];
                  prevTime = null;
                  prevCurve = curve;
                } else if (prevTime >= tMin) {
                  time /= prevTime;
                }
              }
              if (exclude) {
                if (renormalizeLocs)
                  renormalizeLocs.push(loc);
                continue;
              } else if (include) {
                results.unshift(loc);
              }
              prevTime = origTime;
              if (time < tMin) {
                segment = curve._segment1;
              } else if (time > tMax) {
                segment = curve._segment2;
              } else {
                var newCurve = curve.divideAtTime(time, true);
                if (clearHandles)
                  clearCurves.push(curve, newCurve);
                segment = newCurve._segment1;
                for (var j2 = renormalizeLocs.length - 1; j2 >= 0; j2--) {
                  var l2 = renormalizeLocs[j2];
                  l2._time = (l2._time - time) / (1 - time);
                }
              }
              loc._setSegment(segment);
              var inter = segment._intersection, dest = loc._intersection;
              if (inter) {
                linkIntersections(inter, dest);
                var other = inter;
                while (other) {
                  linkIntersections(other._intersection, inter);
                  other = other._next;
                }
              } else {
                segment._intersection = dest;
              }
            }
            if (!clearLater)
              clearCurveHandles(clearCurves);
            return results || locations;
          }
          function getWinding(point, curves, dir, closed, dontFlip) {
            var curvesList = Array.isArray(curves) ? curves : curves[dir ? "hor" : "ver"];
            var ia2 = dir ? 1 : 0, io2 = ia2 ^ 1, pv = [point.x, point.y], pa2 = pv[ia2], po2 = pv[io2], windingEpsilon = 1e-9, qualityEpsilon = 1e-6, paL = pa2 - windingEpsilon, paR = pa2 + windingEpsilon, windingL = 0, windingR = 0, pathWindingL = 0, pathWindingR = 0, onPath = false, onAnyPath = false, quality = 1, roots = [], vPrev, vClose;
            function addWinding(v3) {
              var o0 = v3[io2 + 0], o3 = v3[io2 + 6];
              if (po2 < min(o0, o3) || po2 > max(o0, o3)) {
                return;
              }
              var a0 = v3[ia2 + 0], a1 = v3[ia2 + 2], a2 = v3[ia2 + 4], a3 = v3[ia2 + 6];
              if (o0 === o3) {
                if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
                  onPath = true;
                }
                return;
              }
              var t2 = po2 === o0 ? 0 : po2 === o3 ? 1 : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? 1 : Curve.solveCubic(v3, io2, po2, roots, 0, 1) > 0 ? roots[0] : 1, a4 = t2 === 0 ? a0 : t2 === 1 ? a3 : Curve.getPoint(v3, t2)[dir ? "y" : "x"], winding = o0 > o3 ? 1 : -1, windingPrev = vPrev[io2] > vPrev[io2 + 6] ? 1 : -1, a3Prev = vPrev[ia2 + 6];
              if (po2 !== o0) {
                if (a4 < paL) {
                  pathWindingL += winding;
                } else if (a4 > paR) {
                  pathWindingR += winding;
                } else {
                  onPath = true;
                }
                if (a4 > pa2 - qualityEpsilon && a4 < pa2 + qualityEpsilon)
                  quality /= 2;
              } else {
                if (winding !== windingPrev) {
                  if (a0 < paL) {
                    pathWindingL += winding;
                  } else if (a0 > paR) {
                    pathWindingR += winding;
                  }
                } else if (a0 != a3Prev) {
                  if (a3Prev < paR && a4 > paR) {
                    pathWindingR += winding;
                    onPath = true;
                  } else if (a3Prev > paL && a4 < paL) {
                    pathWindingL += winding;
                    onPath = true;
                  }
                }
                quality /= 4;
              }
              vPrev = v3;
              return !dontFlip && a4 > paL && a4 < paR && Curve.getTangent(v3, t2)[dir ? "x" : "y"] === 0 && getWinding(point, curves, !dir, closed, true);
            }
            function handleCurve(v3) {
              var o0 = v3[io2 + 0], o1 = v3[io2 + 2], o2 = v3[io2 + 4], o3 = v3[io2 + 6];
              if (po2 <= max(o0, o1, o2, o3) && po2 >= min(o0, o1, o2, o3)) {
                var a0 = v3[ia2 + 0], a1 = v3[ia2 + 2], a2 = v3[ia2 + 4], a3 = v3[ia2 + 6], monoCurves = paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? [v3] : Curve.getMonoCurves(v3, dir), res2;
                for (var i3 = 0, l3 = monoCurves.length; i3 < l3; i3++) {
                  if (res2 = addWinding(monoCurves[i3]))
                    return res2;
                }
              }
            }
            for (var i2 = 0, l2 = curvesList.length; i2 < l2; i2++) {
              var curve = curvesList[i2], path = curve._path, v2 = curve.getValues(), res;
              if (!i2 || curvesList[i2 - 1]._path !== path) {
                vPrev = null;
                if (!path._closed) {
                  vClose = Curve.getValues(path.getLastCurve().getSegment2(), curve.getSegment1(), null, !closed);
                  if (vClose[io2] !== vClose[io2 + 6]) {
                    vPrev = vClose;
                  }
                }
                if (!vPrev) {
                  vPrev = v2;
                  var prev = path.getLastCurve();
                  while (prev && prev !== curve) {
                    var v22 = prev.getValues();
                    if (v22[io2] !== v22[io2 + 6]) {
                      vPrev = v22;
                      break;
                    }
                    prev = prev.getPrevious();
                  }
                }
              }
              if (res = handleCurve(v2))
                return res;
              if (i2 + 1 === l2 || curvesList[i2 + 1]._path !== path) {
                if (vClose && (res = handleCurve(vClose)))
                  return res;
                if (onPath && !pathWindingL && !pathWindingR) {
                  pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir ? 1 : -1;
                }
                windingL += pathWindingL;
                windingR += pathWindingR;
                pathWindingL = pathWindingR = 0;
                if (onPath) {
                  onAnyPath = true;
                  onPath = false;
                }
                vClose = null;
              }
            }
            windingL = abs(windingL);
            windingR = abs(windingR);
            return {
              winding: max(windingL, windingR),
              windingL,
              windingR,
              quality,
              onPath: onAnyPath
            };
          }
          function propagateWinding(segment, path1, path2, curveCollisionsMap, operator) {
            var chain = [], start = segment, totalLength = 0, winding;
            do {
              var curve = segment.getCurve();
              if (curve) {
                var length = curve.getLength();
                chain.push({ segment, curve, length });
                totalLength += length;
              }
              segment = segment.getNext();
            } while (segment && !segment._intersection && segment !== start);
            var offsets = [0.5, 0.25, 0.75], winding = { winding: 0, quality: -1 }, tMin = 1e-3, tMax = 1 - tMin;
            for (var i2 = 0; i2 < offsets.length && winding.quality < 0.5; i2++) {
              var length = totalLength * offsets[i2];
              for (var j2 = 0, l2 = chain.length; j2 < l2; j2++) {
                var entry = chain[j2], curveLength = entry.length;
                if (length <= curveLength) {
                  var curve = entry.curve, path = curve._path, parent = path._parent, operand = parent instanceof CompoundPath ? parent : path, t2 = Numerical.clamp(curve.getTimeAt(length), tMin, tMax), pt2 = curve.getPointAtTime(t2), dir = abs(curve.getTangentAtTime(t2).y) < Math.SQRT1_2;
                  var wind = null;
                  if (operator.subtract && path2) {
                    var otherPath = operand === path1 ? path2 : path1, pathWinding = otherPath._getWinding(pt2, dir, true);
                    if (operand === path1 && pathWinding.winding || operand === path2 && !pathWinding.winding) {
                      if (pathWinding.quality < 1) {
                        continue;
                      } else {
                        wind = { winding: 0, quality: 1 };
                      }
                    }
                  }
                  wind = wind || getWinding(pt2, curveCollisionsMap[path._id][curve.getIndex()], dir, true);
                  if (wind.quality > winding.quality)
                    winding = wind;
                  break;
                }
                length -= curveLength;
              }
            }
            for (var j2 = chain.length - 1; j2 >= 0; j2--) {
              chain[j2].segment._winding = winding;
            }
          }
          function tracePaths(segments, operator) {
            var paths = [], starts;
            function isValid(seg2) {
              var winding;
              return !!(seg2 && !seg2._visited && (!operator || operator[(winding = seg2._winding || {}).winding] && !(operator.unite && winding.winding === 2 && winding.windingL && winding.windingR)));
            }
            function isStart(seg2) {
              if (seg2) {
                for (var i3 = 0, l3 = starts.length; i3 < l3; i3++) {
                  if (seg2 === starts[i3])
                    return true;
                }
              }
              return false;
            }
            function visitPath(path3) {
              var segments2 = path3._segments;
              for (var i3 = 0, l3 = segments2.length; i3 < l3; i3++) {
                segments2[i3]._visited = true;
              }
            }
            function getCrossingSegments(segment, collectStarts) {
              var inter = segment._intersection, start = inter, crossings2 = [];
              if (collectStarts)
                starts = [segment];
              function collect(inter2, end) {
                while (inter2 && inter2 !== end) {
                  var other2 = inter2._segment, path3 = other2 && other2._path;
                  if (path3) {
                    var next2 = other2.getNext() || path3.getFirstSegment(), nextInter = next2._intersection;
                    if (other2 !== segment && (isStart(other2) || isStart(next2) || next2 && (isValid(other2) && (isValid(next2) || nextInter && isValid(nextInter._segment))))) {
                      crossings2.push(other2);
                    }
                    if (collectStarts)
                      starts.push(other2);
                  }
                  inter2 = inter2._next;
                }
              }
              if (inter) {
                collect(inter);
                while (inter && inter._previous)
                  inter = inter._previous;
                collect(inter, start);
              }
              return crossings2;
            }
            segments.sort(function(seg1, seg2) {
              var inter1 = seg1._intersection, inter2 = seg2._intersection, over1 = !!(inter1 && inter1._overlap), over2 = !!(inter2 && inter2._overlap), path12 = seg1._path, path22 = seg2._path;
              return over1 ^ over2 ? over1 ? 1 : -1 : !inter1 ^ !inter2 ? inter1 ? 1 : -1 : path12 !== path22 ? path12._id - path22._id : seg1._index - seg2._index;
            });
            for (var i2 = 0, l2 = segments.length; i2 < l2; i2++) {
              var seg = segments[i2], valid = isValid(seg), path = null, finished = false, closed = true, branches = [], branch, visited, handleIn;
              if (valid && seg._path._overlapsOnly) {
                var path1 = seg._path, path2 = seg._intersection._segment._path;
                if (path1.compare(path2)) {
                  if (path1.getArea())
                    paths.push(path1.clone(false));
                  visitPath(path1);
                  visitPath(path2);
                  valid = false;
                }
              }
              while (valid) {
                var first = !path, crossings = getCrossingSegments(seg, first), other = crossings.shift(), finished = !first && (isStart(seg) || isStart(other)), cross = !finished && other;
                if (first) {
                  path = new Path(Item.NO_INSERT);
                  branch = null;
                }
                if (finished) {
                  if (seg.isFirst() || seg.isLast())
                    closed = seg._path._closed;
                  seg._visited = true;
                  break;
                }
                if (cross && branch) {
                  branches.push(branch);
                  branch = null;
                }
                if (!branch) {
                  if (cross)
                    crossings.push(seg);
                  branch = {
                    start: path._segments.length,
                    crossings,
                    visited: visited = [],
                    handleIn
                  };
                }
                if (cross)
                  seg = other;
                if (!isValid(seg)) {
                  path.removeSegments(branch.start);
                  for (var j2 = 0, k2 = visited.length; j2 < k2; j2++) {
                    visited[j2]._visited = false;
                  }
                  visited.length = 0;
                  do {
                    seg = branch && branch.crossings.shift();
                    if (!seg || !seg._path) {
                      seg = null;
                      branch = branches.pop();
                      if (branch) {
                        visited = branch.visited;
                        handleIn = branch.handleIn;
                      }
                    }
                  } while (branch && !isValid(seg));
                  if (!seg)
                    break;
                }
                var next = seg.getNext();
                path.add(new Segment(seg._point, handleIn, next && seg._handleOut));
                seg._visited = true;
                visited.push(seg);
                seg = next || seg._path.getFirstSegment();
                handleIn = next && next._handleIn;
              }
              if (finished) {
                if (closed) {
                  path.getFirstSegment().setHandleIn(handleIn);
                  path.setClosed(closed);
                }
                if (path.getArea() !== 0) {
                  paths.push(path);
                }
              }
            }
            return paths;
          }
          return {
            _getWinding: function(point, dir, closed) {
              return getWinding(point, this.getCurves(), dir, closed);
            },
            unite: function(path, options) {
              return traceBoolean(this, path, "unite", options);
            },
            intersect: function(path, options) {
              return traceBoolean(this, path, "intersect", options);
            },
            subtract: function(path, options) {
              return traceBoolean(this, path, "subtract", options);
            },
            exclude: function(path, options) {
              return traceBoolean(this, path, "exclude", options);
            },
            divide: function(path, options) {
              return options && (options.trace == false || options.stroke) ? splitBoolean(this, path, "divide") : createResult([
                this.subtract(path, options),
                this.intersect(path, options)
              ], true, this, path, options);
            },
            resolveCrossings: function() {
              var children = this._children, paths = children || [this];
              function hasOverlap(seg2, path2) {
                var inter = seg2 && seg2._intersection;
                return inter && inter._overlap && inter._path === path2;
              }
              var hasOverlaps = false, hasCrossings = false, intersections = this.getIntersections(null, function(inter) {
                return inter.hasOverlap() && (hasOverlaps = true) || inter.isCrossing() && (hasCrossings = true);
              }), clearCurves = hasOverlaps && hasCrossings && [];
              intersections = CurveLocation.expand(intersections);
              if (hasOverlaps) {
                var overlaps = divideLocations(intersections, function(inter) {
                  return inter.hasOverlap();
                }, clearCurves);
                for (var i2 = overlaps.length - 1; i2 >= 0; i2--) {
                  var overlap = overlaps[i2], path = overlap._path, seg = overlap._segment, prev = seg.getPrevious(), next = seg.getNext();
                  if (hasOverlap(prev, path) && hasOverlap(next, path)) {
                    seg.remove();
                    prev._handleOut._set(0, 0);
                    next._handleIn._set(0, 0);
                    if (prev !== seg && !prev.getCurve().hasLength()) {
                      next._handleIn.set(prev._handleIn);
                      prev.remove();
                    }
                  }
                }
              }
              if (hasCrossings) {
                divideLocations(intersections, hasOverlaps && function(inter) {
                  var curve1 = inter.getCurve(), seg1 = inter.getSegment(), other = inter._intersection, curve2 = other._curve, seg2 = other._segment;
                  if (curve1 && curve2 && curve1._path && curve2._path)
                    return true;
                  if (seg1)
                    seg1._intersection = null;
                  if (seg2)
                    seg2._intersection = null;
                }, clearCurves);
                if (clearCurves)
                  clearCurveHandles(clearCurves);
                paths = tracePaths(Base.each(paths, function(path2) {
                  Base.push(this, path2._segments);
                }, []));
              }
              var length = paths.length, item;
              if (length > 1 && children) {
                if (paths !== children)
                  this.setChildren(paths);
                item = this;
              } else if (length === 1 && !children) {
                if (paths[0] !== this)
                  this.setSegments(paths[0].removeSegments());
                item = this;
              }
              if (!item) {
                item = new CompoundPath(Item.NO_INSERT);
                item.addChildren(paths);
                item = item.reduce();
                item.copyAttributes(this);
                this.replaceWith(item);
              }
              return item;
            },
            reorient: function(nonZero, clockwise) {
              var children = this._children;
              if (children && children.length) {
                this.setChildren(reorientPaths(this.removeChildren(), function(w2) {
                  return !!(nonZero ? w2 : w2 & 1);
                }, clockwise));
              } else if (clockwise !== undefined2) {
                this.setClockwise(clockwise);
              }
              return this;
            },
            getInteriorPoint: function() {
              var bounds = this.getBounds(), point = bounds.getCenter(true);
              if (!this.contains(point)) {
                var curves = this.getCurves(), y2 = point.y, intercepts = [], roots = [];
                for (var i2 = 0, l2 = curves.length; i2 < l2; i2++) {
                  var v2 = curves[i2].getValues(), o0 = v2[1], o1 = v2[3], o2 = v2[5], o3 = v2[7];
                  if (y2 >= min(o0, o1, o2, o3) && y2 <= max(o0, o1, o2, o3)) {
                    var monoCurves = Curve.getMonoCurves(v2);
                    for (var j2 = 0, m2 = monoCurves.length; j2 < m2; j2++) {
                      var mv = monoCurves[j2], mo0 = mv[1], mo3 = mv[7];
                      if (mo0 !== mo3 && (y2 >= mo0 && y2 <= mo3 || y2 >= mo3 && y2 <= mo0)) {
                        var x2 = y2 === mo0 ? mv[0] : y2 === mo3 ? mv[6] : Curve.solveCubic(mv, 1, y2, roots, 0, 1) === 1 ? Curve.getPoint(mv, roots[0]).x : (mv[0] + mv[6]) / 2;
                        intercepts.push(x2);
                      }
                    }
                  }
                }
                if (intercepts.length > 1) {
                  intercepts.sort(function(a2, b2) {
                    return a2 - b2;
                  });
                  point.x = (intercepts[0] + intercepts[1]) / 2;
                }
              }
              return point;
            }
          };
        }());
        var PathFlattener = Base.extend({
          _class: "PathFlattener",
          initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
            var curves = [], parts = [], length = 0, minSpan = 1 / (maxRecursion || 32), segments = path._segments, segment1 = segments[0], segment2;
            function addCurve(segment12, segment22) {
              var curve = Curve.getValues(segment12, segment22, matrix);
              curves.push(curve);
              computeParts(curve, segment12._index, 0, 1);
            }
            function computeParts(curve, index, t1, t2) {
              if (t2 - t1 > minSpan && !(ignoreStraight && Curve.isStraight(curve)) && !Curve.isFlatEnough(curve, flatness || 0.25)) {
                var halves = Curve.subdivide(curve, 0.5), tMid = (t1 + t2) / 2;
                computeParts(halves[0], index, t1, tMid);
                computeParts(halves[1], index, tMid, t2);
              } else {
                var dx = curve[6] - curve[0], dy = curve[7] - curve[1], dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                  length += dist;
                  parts.push({
                    offset: length,
                    curve,
                    index,
                    time: t2
                  });
                }
              }
            }
            for (var i2 = 1, l2 = segments.length; i2 < l2; i2++) {
              segment2 = segments[i2];
              addCurve(segment1, segment2);
              segment1 = segment2;
            }
            if (path._closed)
              addCurve(segment2 || segment1, segments[0]);
            this.curves = curves;
            this.parts = parts;
            this.length = length;
            this.index = 0;
          },
          _get: function(offset) {
            var parts = this.parts, length = parts.length, start, i2, j2 = this.index;
            for (; ; ) {
              i2 = j2;
              if (!j2 || parts[--j2].offset < offset)
                break;
            }
            for (; i2 < length; i2++) {
              var part = parts[i2];
              if (part.offset >= offset) {
                this.index = i2;
                var prev = parts[i2 - 1], prevTime = prev && prev.index === part.index ? prev.time : 0, prevOffset = prev ? prev.offset : 0;
                return {
                  index: part.index,
                  time: prevTime + (part.time - prevTime) * (offset - prevOffset) / (part.offset - prevOffset)
                };
              }
            }
            return {
              index: parts[length - 1].index,
              time: 1
            };
          },
          drawPart: function(ctx, from, to2) {
            var start = this._get(from), end = this._get(to2);
            for (var i2 = start.index, l2 = end.index; i2 <= l2; i2++) {
              var curve = Curve.getPart(this.curves[i2], i2 === start.index ? start.time : 0, i2 === end.index ? end.time : 1);
              if (i2 === start.index)
                ctx.moveTo(curve[0], curve[1]);
              ctx.bezierCurveTo.apply(ctx, curve.slice(2));
            }
          }
        }, Base.each(Curve._evaluateMethods, function(name) {
          this[name + "At"] = function(offset) {
            var param = this._get(offset);
            return Curve[name](this.curves[param.index], param.time);
          };
        }, {}));
        var PathFitter = Base.extend({
          initialize: function(path) {
            var points = this.points = [], segments = path._segments, closed = path._closed;
            for (var i2 = 0, prev, l2 = segments.length; i2 < l2; i2++) {
              var point = segments[i2].point;
              if (!prev || !prev.equals(point)) {
                points.push(prev = point.clone());
              }
            }
            if (closed) {
              points.unshift(points[points.length - 1]);
              points.push(points[1]);
            }
            this.closed = closed;
          },
          fit: function(error) {
            var points = this.points, length = points.length, segments = null;
            if (length > 0) {
              segments = [new Segment(points[0])];
              if (length > 1) {
                this.fitCubic(segments, error, 0, length - 1, points[1].subtract(points[0]), points[length - 2].subtract(points[length - 1]));
                if (this.closed) {
                  segments.shift();
                  segments.pop();
                }
              }
            }
            return segments;
          },
          fitCubic: function(segments, error, first, last, tan1, tan2) {
            var points = this.points;
            if (last - first === 1) {
              var pt1 = points[first], pt2 = points[last], dist = pt1.getDistance(pt2) / 3;
              this.addCurve(segments, [
                pt1,
                pt1.add(tan1.normalize(dist)),
                pt2.add(tan2.normalize(dist)),
                pt2
              ]);
              return;
            }
            var uPrime = this.chordLengthParameterize(first, last), maxError = Math.max(error, error * error), split, parametersInOrder = true;
            for (var i2 = 0; i2 <= 4; i2++) {
              var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
              var max = this.findMaxError(first, last, curve, uPrime);
              if (max.error < error && parametersInOrder) {
                this.addCurve(segments, curve);
                return;
              }
              split = max.index;
              if (max.error >= maxError)
                break;
              parametersInOrder = this.reparameterize(first, last, uPrime, curve);
              maxError = max.error;
            }
            var tanCenter = points[split - 1].subtract(points[split + 1]);
            this.fitCubic(segments, error, first, split, tan1, tanCenter);
            this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
          },
          addCurve: function(segments, curve) {
            var prev = segments[segments.length - 1];
            prev.setHandleOut(curve[1].subtract(curve[0]));
            segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
          },
          generateBezier: function(first, last, uPrime, tan1, tan2) {
            var epsilon = 1e-12, abs = Math.abs, points = this.points, pt1 = points[first], pt2 = points[last], C2 = [[0, 0], [0, 0]], X2 = [0, 0];
            for (var i2 = 0, l2 = last - first + 1; i2 < l2; i2++) {
              var u2 = uPrime[i2], t2 = 1 - u2, b2 = 3 * u2 * t2, b0 = t2 * t2 * t2, b1 = b2 * t2, b22 = b2 * u2, b3 = u2 * u2 * u2, a1 = tan1.normalize(b1), a2 = tan2.normalize(b22), tmp = points[first + i2].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b22 + b3));
              C2[0][0] += a1.dot(a1);
              C2[0][1] += a1.dot(a2);
              C2[1][0] = C2[0][1];
              C2[1][1] += a2.dot(a2);
              X2[0] += a1.dot(tmp);
              X2[1] += a2.dot(tmp);
            }
            var detC0C1 = C2[0][0] * C2[1][1] - C2[1][0] * C2[0][1], alpha1, alpha2;
            if (abs(detC0C1) > epsilon) {
              var detC0X = C2[0][0] * X2[1] - C2[1][0] * X2[0], detXC1 = X2[0] * C2[1][1] - X2[1] * C2[0][1];
              alpha1 = detXC1 / detC0C1;
              alpha2 = detC0X / detC0C1;
            } else {
              var c0 = C2[0][0] + C2[0][1], c1 = C2[1][0] + C2[1][1];
              alpha1 = alpha2 = abs(c0) > epsilon ? X2[0] / c0 : abs(c1) > epsilon ? X2[1] / c1 : 0;
            }
            var segLength = pt2.getDistance(pt1), eps = epsilon * segLength, handle1, handle2;
            if (alpha1 < eps || alpha2 < eps) {
              alpha1 = alpha2 = segLength / 3;
            } else {
              var line = pt2.subtract(pt1);
              handle1 = tan1.normalize(alpha1);
              handle2 = tan2.normalize(alpha2);
              if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
                alpha1 = alpha2 = segLength / 3;
                handle1 = handle2 = null;
              }
            }
            return [
              pt1,
              pt1.add(handle1 || tan1.normalize(alpha1)),
              pt2.add(handle2 || tan2.normalize(alpha2)),
              pt2
            ];
          },
          reparameterize: function(first, last, u2, curve) {
            for (var i2 = first; i2 <= last; i2++) {
              u2[i2 - first] = this.findRoot(curve, this.points[i2], u2[i2 - first]);
            }
            for (var i2 = 1, l2 = u2.length; i2 < l2; i2++) {
              if (u2[i2] <= u2[i2 - 1])
                return false;
            }
            return true;
          },
          findRoot: function(curve, point, u2) {
            var curve1 = [], curve2 = [];
            for (var i2 = 0; i2 <= 2; i2++) {
              curve1[i2] = curve[i2 + 1].subtract(curve[i2]).multiply(3);
            }
            for (var i2 = 0; i2 <= 1; i2++) {
              curve2[i2] = curve1[i2 + 1].subtract(curve1[i2]).multiply(2);
            }
            var pt2 = this.evaluate(3, curve, u2), pt1 = this.evaluate(2, curve1, u2), pt22 = this.evaluate(1, curve2, u2), diff = pt2.subtract(point), df2 = pt1.dot(pt1) + diff.dot(pt22);
            return Numerical.isMachineZero(df2) ? u2 : u2 - diff.dot(pt1) / df2;
          },
          evaluate: function(degree, curve, t2) {
            var tmp = curve.slice();
            for (var i2 = 1; i2 <= degree; i2++) {
              for (var j2 = 0; j2 <= degree - i2; j2++) {
                tmp[j2] = tmp[j2].multiply(1 - t2).add(tmp[j2 + 1].multiply(t2));
              }
            }
            return tmp[0];
          },
          chordLengthParameterize: function(first, last) {
            var u2 = [0];
            for (var i2 = first + 1; i2 <= last; i2++) {
              u2[i2 - first] = u2[i2 - first - 1] + this.points[i2].getDistance(this.points[i2 - 1]);
            }
            for (var i2 = 1, m2 = last - first; i2 <= m2; i2++) {
              u2[i2] /= u2[m2];
            }
            return u2;
          },
          findMaxError: function(first, last, curve, u2) {
            var index = Math.floor((last - first + 1) / 2), maxDist = 0;
            for (var i2 = first + 1; i2 < last; i2++) {
              var P2 = this.evaluate(3, curve, u2[i2 - first]);
              var v2 = P2.subtract(this.points[i2]);
              var dist = v2.x * v2.x + v2.y * v2.y;
              if (dist >= maxDist) {
                maxDist = dist;
                index = i2;
              }
            }
            return {
              error: maxDist,
              index
            };
          }
        });
        var TextItem = Item.extend({
          _class: "TextItem",
          _applyMatrix: false,
          _canApplyMatrix: false,
          _serializeFields: {
            content: null
          },
          _boundsOptions: { stroke: false, handle: false },
          initialize: function TextItem2(arg) {
            this._content = "";
            this._lines = [];
            var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined2 && arg.y === undefined2;
            this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
          },
          _equals: function(item) {
            return this._content === item._content;
          },
          copyContent: function(source) {
            this.setContent(source._content);
          },
          getContent: function() {
            return this._content;
          },
          setContent: function(content) {
            this._content = "" + content;
            this._lines = this._content.split(/\r\n|\n|\r/mg);
            this._changed(521);
          },
          isEmpty: function() {
            return !this._content;
          },
          getCharacterStyle: "#getStyle",
          setCharacterStyle: "#setStyle",
          getParagraphStyle: "#getStyle",
          setParagraphStyle: "#setStyle"
        });
        var PointText = TextItem.extend({
          _class: "PointText",
          initialize: function PointText2() {
            TextItem.apply(this, arguments);
          },
          getPoint: function() {
            var point = this._matrix.getTranslation();
            return new LinkedPoint(point.x, point.y, this, "setPoint");
          },
          setPoint: function() {
            var point = Point.read(arguments);
            this.translate(point.subtract(this._matrix.getTranslation()));
          },
          _draw: function(ctx, param, viewMatrix) {
            if (!this._content)
              return;
            this._setStyles(ctx, param, viewMatrix);
            var lines = this._lines, style = this._style, hasFill = style.hasFill(), hasStroke = style.hasStroke(), leading = style.getLeading(), shadowColor = ctx.shadowColor;
            ctx.font = style.getFontStyle();
            ctx.textAlign = style.getJustification();
            for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
              ctx.shadowColor = shadowColor;
              var line = lines[i2];
              if (hasFill) {
                ctx.fillText(line, 0, 0);
                ctx.shadowColor = "rgba(0,0,0,0)";
              }
              if (hasStroke)
                ctx.strokeText(line, 0, 0);
              ctx.translate(0, leading);
            }
          },
          _getBounds: function(matrix, options) {
            var style = this._style, lines = this._lines, numLines = lines.length, justification = style.getJustification(), leading = style.getLeading(), width = this.getView().getTextWidth(style.getFontStyle(), lines), x2 = 0;
            if (justification !== "left")
              x2 -= width / (justification === "center" ? 2 : 1);
            var rect = new Rectangle(x2, numLines ? -0.75 * leading : 0, width, numLines * leading);
            return matrix ? matrix._transformBounds(rect, rect) : rect;
          }
        });
        var Color = Base.extend(new function() {
          var types = {
            gray: ["gray"],
            rgb: ["red", "green", "blue"],
            hsb: ["hue", "saturation", "brightness"],
            hsl: ["hue", "saturation", "lightness"],
            gradient: ["gradient", "origin", "destination", "highlight"]
          };
          var componentParsers = {}, namedColors = {
            transparent: [0, 0, 0, 0]
          }, colorCtx;
          function fromCSS(string) {
            var match = string.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i) || string.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i), type = "rgb", components;
            if (match) {
              var amount = match[4] ? 4 : 3;
              components = new Array(amount);
              for (var i2 = 0; i2 < amount; i2++) {
                var value = match[i2 + 1];
                components[i2] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
              }
            } else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
              type = match[1];
              components = match[2].trim().split(/[,\s]+/g);
              var isHSL = type === "hsl";
              for (var i2 = 0, l2 = Math.min(components.length, 4); i2 < l2; i2++) {
                var component = components[i2];
                var value = parseFloat(component);
                if (isHSL) {
                  if (i2 === 0) {
                    var unit = component.match(/([a-z]*)$/)[1];
                    value *= {
                      turn: 360,
                      rad: 180 / Math.PI,
                      grad: 0.9
                    }[unit] || 1;
                  } else if (i2 < 3) {
                    value /= 100;
                  }
                } else if (i2 < 3) {
                  value /= /%$/.test(component) ? 100 : 255;
                }
                components[i2] = value;
              }
            } else {
              var color = namedColors[string];
              if (!color) {
                if (window2) {
                  if (!colorCtx) {
                    colorCtx = CanvasProvider.getContext(1, 1);
                    colorCtx.globalCompositeOperation = "copy";
                  }
                  colorCtx.fillStyle = "rgba(0,0,0,0)";
                  colorCtx.fillStyle = string;
                  colorCtx.fillRect(0, 0, 1, 1);
                  var data = colorCtx.getImageData(0, 0, 1, 1).data;
                  color = namedColors[string] = [
                    data[0] / 255,
                    data[1] / 255,
                    data[2] / 255
                  ];
                } else {
                  color = [0, 0, 0];
                }
              }
              components = color.slice();
            }
            return [type, components];
          }
          var hsbIndices = [
            [0, 3, 1],
            [2, 0, 1],
            [1, 0, 3],
            [1, 2, 0],
            [3, 1, 0],
            [0, 1, 2]
          ];
          var converters = {
            "rgb-hsb": function(r2, g2, b2) {
              var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2), delta = max - min, h2 = delta === 0 ? 0 : (max == r2 ? (g2 - b2) / delta + (g2 < b2 ? 6 : 0) : max == g2 ? (b2 - r2) / delta + 2 : (r2 - g2) / delta + 4) * 60;
              return [h2, max === 0 ? 0 : delta / max, max];
            },
            "hsb-rgb": function(h2, s2, b2) {
              h2 = (h2 / 60 % 6 + 6) % 6;
              var i2 = Math.floor(h2), f = h2 - i2, i2 = hsbIndices[i2], v2 = [
                b2,
                b2 * (1 - s2),
                b2 * (1 - s2 * f),
                b2 * (1 - s2 * (1 - f))
              ];
              return [v2[i2[0]], v2[i2[1]], v2[i2[2]]];
            },
            "rgb-hsl": function(r2, g2, b2) {
              var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2), delta = max - min, achromatic = delta === 0, h2 = achromatic ? 0 : (max == r2 ? (g2 - b2) / delta + (g2 < b2 ? 6 : 0) : max == g2 ? (b2 - r2) / delta + 2 : (r2 - g2) / delta + 4) * 60, l2 = (max + min) / 2, s2 = achromatic ? 0 : l2 < 0.5 ? delta / (max + min) : delta / (2 - max - min);
              return [h2, s2, l2];
            },
            "hsl-rgb": function(h2, s2, l2) {
              h2 = (h2 / 360 % 1 + 1) % 1;
              if (s2 === 0)
                return [l2, l2, l2];
              var t3s = [h2 + 1 / 3, h2, h2 - 1 / 3], t2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2, t1 = 2 * l2 - t2, c2 = [];
              for (var i2 = 0; i2 < 3; i2++) {
                var t3 = t3s[i2];
                if (t3 < 0)
                  t3 += 1;
                if (t3 > 1)
                  t3 -= 1;
                c2[i2] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
              }
              return c2;
            },
            "rgb-gray": function(r2, g2, b2) {
              return [r2 * 0.2989 + g2 * 0.587 + b2 * 0.114];
            },
            "gray-rgb": function(g2) {
              return [g2, g2, g2];
            },
            "gray-hsb": function(g2) {
              return [0, 0, g2];
            },
            "gray-hsl": function(g2) {
              return [0, 0, g2];
            },
            "gradient-rgb": function() {
              return [];
            },
            "rgb-gradient": function() {
              return [];
            }
          };
          return Base.each(types, function(properties, type) {
            componentParsers[type] = [];
            Base.each(properties, function(name, index) {
              var part = Base.capitalize(name), hasOverlap = /^(hue|saturation)$/.test(name), parser = componentParsers[type][index] = type === "gradient" ? name === "gradient" ? function(value) {
                var current = this._components[0];
                value = Gradient.read(Array.isArray(value) ? value : arguments, 0, { readNull: true });
                if (current !== value) {
                  if (current)
                    current._removeOwner(this);
                  if (value)
                    value._addOwner(this);
                }
                return value;
              } : function() {
                return Point.read(arguments, 0, {
                  readNull: name === "highlight",
                  clone: true
                });
              } : function(value) {
                return value == null || isNaN(value) ? 0 : +value;
              };
              this["get" + part] = function() {
                return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
              };
              this["set" + part] = function(value) {
                if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
                  this._components = this._convert(type);
                  this._properties = types[type];
                  this._type = type;
                }
                this._components[index] = parser.call(this, value);
                this._changed();
              };
            }, this);
          }, {
            _class: "Color",
            _readIndex: true,
            initialize: function Color2(arg) {
              var args = arguments, reading = this.__read, read = 0, type, components, alpha, values;
              if (Array.isArray(arg)) {
                args = arg;
                arg = args[0];
              }
              var argType = arg != null && typeof arg;
              if (argType === "string" && arg in types) {
                type = arg;
                arg = args[1];
                if (Array.isArray(arg)) {
                  components = arg;
                  alpha = args[2];
                } else {
                  if (reading)
                    read = 1;
                  args = Base.slice(args, 1);
                  argType = typeof arg;
                }
              }
              if (!components) {
                values = argType === "number" ? args : argType === "object" && arg.length != null ? arg : null;
                if (values) {
                  if (!type)
                    type = values.length >= 3 ? "rgb" : "gray";
                  var length = types[type].length;
                  alpha = values[length];
                  if (reading) {
                    read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
                  }
                  if (values.length > length)
                    values = Base.slice(values, 0, length);
                } else if (argType === "string") {
                  var converted = fromCSS(arg);
                  type = converted[0];
                  components = converted[1];
                  if (components.length === 4) {
                    alpha = components[3];
                    components.length--;
                  }
                } else if (argType === "object") {
                  if (arg.constructor === Color2) {
                    type = arg._type;
                    components = arg._components.slice();
                    alpha = arg._alpha;
                    if (type === "gradient") {
                      for (var i2 = 1, l2 = components.length; i2 < l2; i2++) {
                        var point = components[i2];
                        if (point)
                          components[i2] = point.clone();
                      }
                    }
                  } else if (arg.constructor === Gradient) {
                    type = "gradient";
                    values = args;
                  } else {
                    type = "hue" in arg ? "lightness" in arg ? "hsl" : "hsb" : "gradient" in arg || "stops" in arg || "radial" in arg ? "gradient" : "gray" in arg ? "gray" : "rgb";
                    var properties = types[type], parsers = componentParsers[type];
                    this._components = components = [];
                    for (var i2 = 0, l2 = properties.length; i2 < l2; i2++) {
                      var value = arg[properties[i2]];
                      if (value == null && !i2 && type === "gradient" && "stops" in arg) {
                        value = {
                          stops: arg.stops,
                          radial: arg.radial
                        };
                      }
                      value = parsers[i2].call(this, value);
                      if (value != null)
                        components[i2] = value;
                    }
                    alpha = arg.alpha;
                  }
                }
                if (reading && type)
                  read = 1;
              }
              this._type = type || "rgb";
              if (!components) {
                this._components = components = [];
                var parsers = componentParsers[this._type];
                for (var i2 = 0, l2 = parsers.length; i2 < l2; i2++) {
                  var value = parsers[i2].call(this, values && values[i2]);
                  if (value != null)
                    components[i2] = value;
                }
              }
              this._components = components;
              this._properties = types[this._type];
              this._alpha = alpha;
              if (reading)
                this.__read = read;
              return this;
            },
            set: "#initialize",
            _serialize: function(options, dictionary) {
              var components = this.getComponents();
              return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, true, dictionary);
            },
            _changed: function() {
              this._canvasStyle = null;
              if (this._owner) {
                if (this._setter) {
                  this._owner[this._setter](this);
                } else {
                  this._owner._changed(129);
                }
              }
            },
            _convert: function(type) {
              var converter;
              return this._type === type ? this._components.slice() : (converter = converters[this._type + "-" + type]) ? converter.apply(this, this._components) : converters["rgb-" + type].apply(this, converters[this._type + "-rgb"].apply(this, this._components));
            },
            convert: function(type) {
              return new Color(type, this._convert(type), this._alpha);
            },
            getType: function() {
              return this._type;
            },
            setType: function(type) {
              this._components = this._convert(type);
              this._properties = types[type];
              this._type = type;
            },
            getComponents: function() {
              var components = this._components.slice();
              if (this._alpha != null)
                components.push(this._alpha);
              return components;
            },
            getAlpha: function() {
              return this._alpha != null ? this._alpha : 1;
            },
            setAlpha: function(alpha) {
              this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
              this._changed();
            },
            hasAlpha: function() {
              return this._alpha != null;
            },
            equals: function(color) {
              var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
              return col === this || col && this._class === col._class && this._type === col._type && this.getAlpha() === col.getAlpha() && Base.equals(this._components, col._components) || false;
            },
            toString: function() {
              var properties = this._properties, parts = [], isGradient = this._type === "gradient", f = Formatter.instance;
              for (var i2 = 0, l2 = properties.length; i2 < l2; i2++) {
                var value = this._components[i2];
                if (value != null)
                  parts.push(properties[i2] + ": " + (isGradient ? value : f.number(value)));
              }
              if (this._alpha != null)
                parts.push("alpha: " + f.number(this._alpha));
              return "{ " + parts.join(", ") + " }";
            },
            toCSS: function(hex) {
              var components = this._convert("rgb"), alpha = hex || this._alpha == null ? 1 : this._alpha;
              function convert(val) {
                return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
              }
              components = [
                convert(components[0]),
                convert(components[1]),
                convert(components[2])
              ];
              if (alpha < 1)
                components.push(alpha < 0 ? 0 : alpha);
              return hex ? "#" + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? "rgba(" : "rgb(") + components.join(",") + ")";
            },
            toCanvasStyle: function(ctx, matrix) {
              if (this._canvasStyle)
                return this._canvasStyle;
              if (this._type !== "gradient")
                return this._canvasStyle = this.toCSS();
              var components = this._components, gradient = components[0], stops = gradient._stops, origin = components[1], destination = components[2], highlight = components[3], inverse = matrix && matrix.inverted(), canvasGradient;
              if (inverse) {
                origin = inverse._transformPoint(origin);
                destination = inverse._transformPoint(destination);
                if (highlight)
                  highlight = inverse._transformPoint(highlight);
              }
              if (gradient._radial) {
                var radius = destination.getDistance(origin);
                if (highlight) {
                  var vector = highlight.subtract(origin);
                  if (vector.getLength() > radius)
                    highlight = origin.add(vector.normalize(radius - 0.1));
                }
                var start = highlight || origin;
                canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
              } else {
                canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
              }
              for (var i2 = 0, l2 = stops.length; i2 < l2; i2++) {
                var stop = stops[i2], offset = stop._offset;
                canvasGradient.addColorStop(offset == null ? i2 / (l2 - 1) : offset, stop._color.toCanvasStyle());
              }
              return this._canvasStyle = canvasGradient;
            },
            transform: function(matrix) {
              if (this._type === "gradient") {
                var components = this._components;
                for (var i2 = 1, l2 = components.length; i2 < l2; i2++) {
                  var point = components[i2];
                  matrix._transformPoint(point, point, true);
                }
                this._changed();
              }
            },
            statics: {
              _types: types,
              random: function() {
                var random = Math.random;
                return new Color(random(), random(), random());
              },
              _setOwner: function(color, owner, setter) {
                if (color) {
                  if (color._owner && owner && color._owner !== owner) {
                    color = color.clone();
                  }
                  if (!color._owner ^ !owner) {
                    color._owner = owner || null;
                    color._setter = setter || null;
                  }
                }
                return color;
              }
            }
          });
        }(), new function() {
          var operators = {
            add: function(a2, b2) {
              return a2 + b2;
            },
            subtract: function(a2, b2) {
              return a2 - b2;
            },
            multiply: function(a2, b2) {
              return a2 * b2;
            },
            divide: function(a2, b2) {
              return a2 / b2;
            }
          };
          return Base.each(operators, function(operator, name) {
            this[name] = function(color) {
              color = Color.read(arguments);
              var type = this._type, components1 = this._components, components2 = color._convert(type);
              for (var i2 = 0, l2 = components1.length; i2 < l2; i2++)
                components2[i2] = operator(components1[i2], components2[i2]);
              return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
            };
          }, {});
        }());
        var Gradient = Base.extend({
          _class: "Gradient",
          initialize: function Gradient2(stops, radial) {
            this._id = UID.get();
            if (stops && Base.isPlainObject(stops)) {
              this.set(stops);
              stops = radial = null;
            }
            if (this._stops == null) {
              this.setStops(stops || ["white", "black"]);
            }
            if (this._radial == null) {
              this.setRadial(typeof radial === "string" && radial === "radial" || radial || false);
            }
          },
          _serialize: function(options, dictionary) {
            return dictionary.add(this, function() {
              return Base.serialize([this._stops, this._radial], options, true, dictionary);
            });
          },
          _changed: function() {
            for (var i2 = 0, l2 = this._owners && this._owners.length; i2 < l2; i2++) {
              this._owners[i2]._changed();
            }
          },
          _addOwner: function(color) {
            if (!this._owners)
              this._owners = [];
            this._owners.push(color);
          },
          _removeOwner: function(color) {
            var index = this._owners ? this._owners.indexOf(color) : -1;
            if (index != -1) {
              this._owners.splice(index, 1);
              if (!this._owners.length)
                this._owners = undefined2;
            }
          },
          clone: function() {
            var stops = [];
            for (var i2 = 0, l2 = this._stops.length; i2 < l2; i2++) {
              stops[i2] = this._stops[i2].clone();
            }
            return new Gradient(stops, this._radial);
          },
          getStops: function() {
            return this._stops;
          },
          setStops: function(stops) {
            if (stops.length < 2) {
              throw new Error("Gradient stop list needs to contain at least two stops.");
            }
            var _stops = this._stops;
            if (_stops) {
              for (var i2 = 0, l2 = _stops.length; i2 < l2; i2++)
                _stops[i2]._owner = undefined2;
            }
            _stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
            for (var i2 = 0, l2 = _stops.length; i2 < l2; i2++)
              _stops[i2]._owner = this;
            this._changed();
          },
          getRadial: function() {
            return this._radial;
          },
          setRadial: function(radial) {
            this._radial = radial;
            this._changed();
          },
          equals: function(gradient) {
            if (gradient === this)
              return true;
            if (gradient && this._class === gradient._class) {
              var stops1 = this._stops, stops2 = gradient._stops, length = stops1.length;
              if (length === stops2.length) {
                for (var i2 = 0; i2 < length; i2++) {
                  if (!stops1[i2].equals(stops2[i2]))
                    return false;
                }
                return true;
              }
            }
            return false;
          }
        });
        var GradientStop = Base.extend({
          _class: "GradientStop",
          initialize: function GradientStop2(arg0, arg1) {
            var color = arg0, offset = arg1;
            if (typeof arg0 === "object" && arg1 === undefined2) {
              if (Array.isArray(arg0) && typeof arg0[0] !== "number") {
                color = arg0[0];
                offset = arg0[1];
              } else if ("color" in arg0 || "offset" in arg0 || "rampPoint" in arg0) {
                color = arg0.color;
                offset = arg0.offset || arg0.rampPoint || 0;
              }
            }
            this.setColor(color);
            this.setOffset(offset);
          },
          clone: function() {
            return new GradientStop(this._color.clone(), this._offset);
          },
          _serialize: function(options, dictionary) {
            var color = this._color, offset = this._offset;
            return Base.serialize(offset == null ? [color] : [color, offset], options, true, dictionary);
          },
          _changed: function() {
            if (this._owner)
              this._owner._changed(129);
          },
          getOffset: function() {
            return this._offset;
          },
          setOffset: function(offset) {
            this._offset = offset;
            this._changed();
          },
          getRampPoint: "#getOffset",
          setRampPoint: "#setOffset",
          getColor: function() {
            return this._color;
          },
          setColor: function() {
            Color._setOwner(this._color, null);
            this._color = Color._setOwner(Color.read(arguments, 0), this, "setColor");
            this._changed();
          },
          equals: function(stop) {
            return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._offset == stop._offset || false;
          }
        });
        var Style = Base.extend(new function() {
          var itemDefaults = {
            fillColor: null,
            fillRule: "nonzero",
            strokeColor: null,
            strokeWidth: 1,
            strokeCap: "butt",
            strokeJoin: "miter",
            strokeScaling: true,
            miterLimit: 10,
            dashOffset: 0,
            dashArray: [],
            shadowColor: null,
            shadowBlur: 0,
            shadowOffset: new Point(),
            selectedColor: null
          }, groupDefaults = Base.set({}, itemDefaults, {
            fontFamily: "sans-serif",
            fontWeight: "normal",
            fontSize: 12,
            leading: null,
            justification: "left"
          }), textDefaults = Base.set({}, groupDefaults, {
            fillColor: new Color()
          }), flags = {
            strokeWidth: 193,
            strokeCap: 193,
            strokeJoin: 193,
            strokeScaling: 201,
            miterLimit: 193,
            fontFamily: 9,
            fontWeight: 9,
            fontSize: 9,
            font: 9,
            leading: 9,
            justification: 9
          }, item = {
            beans: true
          }, fields = {
            _class: "Style",
            beans: true,
            initialize: function Style2(style, _owner, _project) {
              this._values = {};
              this._owner = _owner;
              this._project = _owner && _owner._project || _project || paper2.project;
              this._defaults = !_owner || _owner instanceof Group ? groupDefaults : _owner instanceof TextItem ? textDefaults : itemDefaults;
              if (style)
                this.set(style);
            }
          };
          Base.each(groupDefaults, function(value, key) {
            var isColor = /Color$/.test(key), isPoint = key === "shadowOffset", part = Base.capitalize(key), flag = flags[key], set = "set" + part, get = "get" + part;
            fields[set] = function(value2) {
              var owner = this._owner, children = owner && owner._children, applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath);
              if (applyToChildren) {
                for (var i2 = 0, l2 = children.length; i2 < l2; i2++)
                  children[i2]._style[set](value2);
              }
              if ((key === "selectedColor" || !applyToChildren) && key in this._defaults) {
                var old = this._values[key];
                if (old !== value2) {
                  if (isColor) {
                    if (old) {
                      Color._setOwner(old, null);
                      old._canvasStyle = null;
                    }
                    if (value2 && value2.constructor === Color) {
                      value2 = Color._setOwner(value2, owner, applyToChildren && set);
                    }
                  }
                  this._values[key] = value2;
                  if (owner)
                    owner._changed(flag || 129);
                }
              }
            };
            fields[get] = function(_dontMerge) {
              var owner = this._owner, children = owner && owner._children, applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath), value2;
              if (applyToChildren && !_dontMerge) {
                for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
                  var childValue = children[i2]._style[get]();
                  if (!i2) {
                    value2 = childValue;
                  } else if (!Base.equals(value2, childValue)) {
                    return undefined2;
                  }
                }
              } else if (key in this._defaults) {
                var value2 = this._values[key];
                if (value2 === undefined2) {
                  value2 = this._defaults[key];
                  if (value2 && value2.clone) {
                    value2 = value2.clone();
                  }
                } else {
                  var ctor = isColor ? Color : isPoint ? Point : null;
                  if (ctor && !(value2 && value2.constructor === ctor)) {
                    this._values[key] = value2 = ctor.read([value2], 0, { readNull: true, clone: true });
                  }
                }
              }
              if (value2 && isColor) {
                value2 = Color._setOwner(value2, owner, applyToChildren && set);
              }
              return value2;
            };
            item[get] = function(_dontMerge) {
              return this._style[get](_dontMerge);
            };
            item[set] = function(value2) {
              this._style[set](value2);
            };
          });
          Base.each({
            Font: "FontFamily",
            WindingRule: "FillRule"
          }, function(value, key) {
            var get = "get" + key, set = "set" + key;
            fields[get] = item[get] = "#get" + value;
            fields[set] = item[set] = "#set" + value;
          });
          Item.inject(item);
          return fields;
        }(), {
          set: function(style) {
            var isStyle = style instanceof Style, values = isStyle ? style._values : style;
            if (values) {
              for (var key in values) {
                if (key in this._defaults) {
                  var value = values[key];
                  this[key] = value && isStyle && value.clone ? value.clone() : value;
                }
              }
            }
          },
          equals: function(style) {
            function compare(style1, style2, secondary) {
              var values1 = style1._values, values2 = style2._values, defaults2 = style2._defaults;
              for (var key in values1) {
                var value1 = values1[key], value2 = values2[key];
                if (!(secondary && key in values2) && !Base.equals(value1, value2 === undefined2 ? defaults2[key] : value2))
                  return false;
              }
              return true;
            }
            return style === this || style && this._class === style._class && compare(this, style) && compare(style, this, true) || false;
          },
          _dispose: function() {
            var color;
            color = this.getFillColor();
            if (color)
              color._canvasStyle = null;
            color = this.getStrokeColor();
            if (color)
              color._canvasStyle = null;
            color = this.getShadowColor();
            if (color)
              color._canvasStyle = null;
          },
          hasFill: function() {
            var color = this.getFillColor();
            return !!color && color.alpha > 0;
          },
          hasStroke: function() {
            var color = this.getStrokeColor();
            return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
          },
          hasShadow: function() {
            var color = this.getShadowColor();
            return !!color && color.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
          },
          getView: function() {
            return this._project._view;
          },
          getFontStyle: function() {
            var fontSize = this.getFontSize();
            return this.getFontWeight() + " " + fontSize + (/[a-z]/i.test(fontSize + "") ? " " : "px ") + this.getFontFamily();
          },
          getFont: "#getFontFamily",
          setFont: "#setFontFamily",
          getLeading: function getLeading() {
            var leading = getLeading.base.call(this), fontSize = this.getFontSize();
            if (/pt|em|%|px/.test(fontSize))
              fontSize = this.getView().getPixelSize(fontSize);
            return leading != null ? leading : fontSize * 1.2;
          }
        });
        var DomElement = new function() {
          function handlePrefix(el2, name, set, value) {
            var prefixes = ["", "webkit", "moz", "Moz", "ms", "o"], suffix = name[0].toUpperCase() + name.substring(1);
            for (var i2 = 0; i2 < 6; i2++) {
              var prefix = prefixes[i2], key = prefix ? prefix + suffix : name;
              if (key in el2) {
                if (set) {
                  el2[key] = value;
                } else {
                  return el2[key];
                }
                break;
              }
            }
          }
          return {
            getStyles: function(el2) {
              var doc = el2 && el2.nodeType !== 9 ? el2.ownerDocument : el2, view = doc && doc.defaultView;
              return view && view.getComputedStyle(el2, "");
            },
            getBounds: function(el2, viewport) {
              var doc = el2.ownerDocument, body = doc.body, html = doc.documentElement, rect;
              try {
                rect = el2.getBoundingClientRect();
              } catch (e4) {
                rect = { left: 0, top: 0, width: 0, height: 0 };
              }
              var x2 = rect.left - (html.clientLeft || body.clientLeft || 0), y2 = rect.top - (html.clientTop || body.clientTop || 0);
              if (!viewport) {
                var view = doc.defaultView;
                x2 += view.pageXOffset || html.scrollLeft || body.scrollLeft;
                y2 += view.pageYOffset || html.scrollTop || body.scrollTop;
              }
              return new Rectangle(x2, y2, rect.width, rect.height);
            },
            getViewportBounds: function(el2) {
              var doc = el2.ownerDocument, view = doc.defaultView, html = doc.documentElement;
              return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
            },
            getOffset: function(el2, viewport) {
              return DomElement.getBounds(el2, viewport).getPoint();
            },
            getSize: function(el2) {
              return DomElement.getBounds(el2, true).getSize();
            },
            isInvisible: function(el2) {
              return DomElement.getSize(el2).equals(new Size(0, 0));
            },
            isInView: function(el2) {
              return !DomElement.isInvisible(el2) && DomElement.getViewportBounds(el2).intersects(DomElement.getBounds(el2, true));
            },
            isInserted: function(el2) {
              return document2.body.contains(el2);
            },
            getPrefixed: function(el2, name) {
              return el2 && handlePrefix(el2, name);
            },
            setPrefixed: function(el2, name, value) {
              if (typeof name === "object") {
                for (var key in name)
                  handlePrefix(el2, key, true, name[key]);
              } else {
                handlePrefix(el2, name, true, value);
              }
            }
          };
        }();
        var DomEvent = {
          add: function(el2, events) {
            if (el2) {
              for (var type in events) {
                var func = events[type], parts = type.split(/[\s,]+/g);
                for (var i2 = 0, l2 = parts.length; i2 < l2; i2++) {
                  var name = parts[i2];
                  var options = el2 === document2 && (name === "touchstart" || name === "touchmove") ? { passive: false } : false;
                  el2.addEventListener(name, func, options);
                }
              }
            }
          },
          remove: function(el2, events) {
            if (el2) {
              for (var type in events) {
                var func = events[type], parts = type.split(/[\s,]+/g);
                for (var i2 = 0, l2 = parts.length; i2 < l2; i2++)
                  el2.removeEventListener(parts[i2], func, false);
              }
            }
          },
          getPoint: function(event) {
            var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
            return new Point(pos.pageX || pos.clientX + document2.documentElement.scrollLeft, pos.pageY || pos.clientY + document2.documentElement.scrollTop);
          },
          getTarget: function(event) {
            return event.target || event.srcElement;
          },
          getRelatedTarget: function(event) {
            return event.relatedTarget || event.toElement;
          },
          getOffset: function(event, target) {
            return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
          }
        };
        DomEvent.requestAnimationFrame = new function() {
          var nativeRequest = DomElement.getPrefixed(window2, "requestAnimationFrame"), requested = false, callbacks = [], timer;
          function handleCallbacks() {
            var functions = callbacks;
            callbacks = [];
            for (var i2 = 0, l2 = functions.length; i2 < l2; i2++)
              functions[i2]();
            requested = nativeRequest && callbacks.length;
            if (requested)
              nativeRequest(handleCallbacks);
          }
          return function(callback) {
            callbacks.push(callback);
            if (nativeRequest) {
              if (!requested) {
                nativeRequest(handleCallbacks);
                requested = true;
              }
            } else if (!timer) {
              timer = setInterval(handleCallbacks, 1e3 / 60);
            }
          };
        }();
        var View = Base.extend(Emitter, {
          _class: "View",
          initialize: function View2(project, element) {
            function getSize(name) {
              return element[name] || parseInt(element.getAttribute(name), 10);
            }
            function getCanvasSize() {
              var size2 = DomElement.getSize(element);
              return size2.isNaN() || size2.isZero() ? new Size(getSize("width"), getSize("height")) : size2;
            }
            var size;
            if (window2 && element) {
              this._id = element.getAttribute("id");
              if (this._id == null)
                element.setAttribute("id", this._id = "paper-view-" + View2._id++);
              DomEvent.add(element, this._viewEvents);
              var none = "none";
              DomElement.setPrefixed(element.style, {
                userDrag: none,
                userSelect: none,
                touchCallout: none,
                contentZooming: none,
                tapHighlightColor: "rgba(0,0,0,0)"
              });
              if (PaperScope.hasAttribute(element, "resize")) {
                var that = this;
                DomEvent.add(window2, this._windowEvents = {
                  resize: function() {
                    that.setViewSize(getCanvasSize());
                  }
                });
              }
              size = getCanvasSize();
              if (PaperScope.hasAttribute(element, "stats") && typeof Stats !== "undefined") {
                this._stats = new Stats();
                var stats = this._stats.domElement, style = stats.style, offset = DomElement.getOffset(element);
                style.position = "absolute";
                style.left = offset.x + "px";
                style.top = offset.y + "px";
                document2.body.appendChild(stats);
              }
            } else {
              size = new Size(element);
              element = null;
            }
            this._project = project;
            this._scope = project._scope;
            this._element = element;
            if (!this._pixelRatio)
              this._pixelRatio = window2 && window2.devicePixelRatio || 1;
            this._setElementSize(size.width, size.height);
            this._viewSize = size;
            View2._views.push(this);
            View2._viewsById[this._id] = this;
            (this._matrix = new Matrix())._owner = this;
            if (!View2._focused)
              View2._focused = this;
            this._frameItems = {};
            this._frameItemCount = 0;
            this._itemEvents = { native: {}, virtual: {} };
            this._autoUpdate = !paper2.agent.node;
            this._needsUpdate = false;
          },
          remove: function() {
            if (!this._project)
              return false;
            if (View._focused === this)
              View._focused = null;
            View._views.splice(View._views.indexOf(this), 1);
            delete View._viewsById[this._id];
            var project = this._project;
            if (project._view === this)
              project._view = null;
            DomEvent.remove(this._element, this._viewEvents);
            DomEvent.remove(window2, this._windowEvents);
            this._element = this._project = null;
            this.off("frame");
            this._animate = false;
            this._frameItems = {};
            return true;
          },
          _events: Base.each(Item._itemHandlers.concat(["onResize", "onKeyDown", "onKeyUp"]), function(name) {
            this[name] = {};
          }, {
            onFrame: {
              install: function() {
                this.play();
              },
              uninstall: function() {
                this.pause();
              }
            }
          }),
          _animate: false,
          _time: 0,
          _count: 0,
          getAutoUpdate: function() {
            return this._autoUpdate;
          },
          setAutoUpdate: function(autoUpdate) {
            this._autoUpdate = autoUpdate;
            if (autoUpdate)
              this.requestUpdate();
          },
          update: function() {
          },
          draw: function() {
            this.update();
          },
          requestUpdate: function() {
            if (!this._requested) {
              var that = this;
              DomEvent.requestAnimationFrame(function() {
                that._requested = false;
                if (that._animate) {
                  that.requestUpdate();
                  var element = that._element;
                  if ((!DomElement.getPrefixed(document2, "hidden") || PaperScope.getAttribute(element, "keepalive") === "true") && DomElement.isInView(element)) {
                    that._handleFrame();
                  }
                }
                if (that._autoUpdate)
                  that.update();
              });
              this._requested = true;
            }
          },
          play: function() {
            this._animate = true;
            this.requestUpdate();
          },
          pause: function() {
            this._animate = false;
          },
          _handleFrame: function() {
            paper2 = this._scope;
            var now = Date.now() / 1e3, delta = this._last ? now - this._last : 0;
            this._last = now;
            this.emit("frame", new Base({
              delta,
              time: this._time += delta,
              count: this._count++
            }));
            if (this._stats)
              this._stats.update();
          },
          _animateItem: function(item, animate) {
            var items = this._frameItems;
            if (animate) {
              items[item._id] = {
                item,
                time: 0,
                count: 0
              };
              if (++this._frameItemCount === 1)
                this.on("frame", this._handleFrameItems);
            } else {
              delete items[item._id];
              if (--this._frameItemCount === 0) {
                this.off("frame", this._handleFrameItems);
              }
            }
          },
          _handleFrameItems: function(event) {
            for (var i2 in this._frameItems) {
              var entry = this._frameItems[i2];
              entry.item.emit("frame", new Base(event, {
                time: entry.time += event.delta,
                count: entry.count++
              }));
            }
          },
          _changed: function() {
            this._project._changed(4097);
            this._bounds = this._decomposed = undefined2;
          },
          getElement: function() {
            return this._element;
          },
          getPixelRatio: function() {
            return this._pixelRatio;
          },
          getResolution: function() {
            return this._pixelRatio * 72;
          },
          getViewSize: function() {
            var size = this._viewSize;
            return new LinkedSize(size.width, size.height, this, "setViewSize");
          },
          setViewSize: function() {
            var size = Size.read(arguments), delta = size.subtract(this._viewSize);
            if (delta.isZero())
              return;
            this._setElementSize(size.width, size.height);
            this._viewSize.set(size);
            this._changed();
            this.emit("resize", { size, delta });
            if (this._autoUpdate) {
              this.update();
            }
          },
          _setElementSize: function(width, height) {
            var element = this._element;
            if (element) {
              if (element.width !== width)
                element.width = width;
              if (element.height !== height)
                element.height = height;
            }
          },
          getBounds: function() {
            if (!this._bounds)
              this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));
            return this._bounds;
          },
          getSize: function() {
            return this.getBounds().getSize();
          },
          isVisible: function() {
            return DomElement.isInView(this._element);
          },
          isInserted: function() {
            return DomElement.isInserted(this._element);
          },
          getPixelSize: function(size) {
            var element = this._element, pixels;
            if (element) {
              var parent = element.parentNode, temp = document2.createElement("div");
              temp.style.fontSize = size;
              parent.appendChild(temp);
              pixels = parseFloat(DomElement.getStyles(temp).fontSize);
              parent.removeChild(temp);
            } else {
              pixels = parseFloat(pixels);
            }
            return pixels;
          },
          getTextWidth: function(font, lines) {
            return 0;
          }
        }, Base.each(["rotate", "scale", "shear", "skew"], function(key) {
          var rotate = key === "rotate";
          this[key] = function() {
            var args = arguments, value = (rotate ? Base : Point).read(args), center = Point.read(args, 0, { readNull: true });
            return this.transform(new Matrix()[key](value, center || this.getCenter(true)));
          };
        }, {
          _decompose: function() {
            return this._decomposed || (this._decomposed = this._matrix.decompose());
          },
          translate: function() {
            var mx = new Matrix();
            return this.transform(mx.translate.apply(mx, arguments));
          },
          getCenter: function() {
            return this.getBounds().getCenter();
          },
          setCenter: function() {
            var center = Point.read(arguments);
            this.translate(this.getCenter().subtract(center));
          },
          getZoom: function() {
            var scaling = this._decompose().scaling;
            return (scaling.x + scaling.y) / 2;
          },
          setZoom: function(zoom) {
            this.transform(new Matrix().scale(zoom / this.getZoom(), this.getCenter()));
          },
          getRotation: function() {
            return this._decompose().rotation;
          },
          setRotation: function(rotation) {
            var current = this.getRotation();
            if (current != null && rotation != null) {
              this.rotate(rotation - current);
            }
          },
          getScaling: function() {
            var scaling = this._decompose().scaling;
            return new LinkedPoint(scaling.x, scaling.y, this, "setScaling");
          },
          setScaling: function() {
            var current = this.getScaling(), scaling = Point.read(arguments, 0, { clone: true, readNull: true });
            if (current && scaling) {
              this.scale(scaling.x / current.x, scaling.y / current.y);
            }
          },
          getMatrix: function() {
            return this._matrix;
          },
          setMatrix: function() {
            var matrix = this._matrix;
            matrix.set.apply(matrix, arguments);
          },
          transform: function(matrix) {
            this._matrix.append(matrix);
          },
          scrollBy: function() {
            this.translate(Point.read(arguments).negate());
          }
        }), {
          projectToView: function() {
            return this._matrix._transformPoint(Point.read(arguments));
          },
          viewToProject: function() {
            return this._matrix._inverseTransform(Point.read(arguments));
          },
          getEventPoint: function(event) {
            return this.viewToProject(DomEvent.getOffset(event, this._element));
          }
        }, {
          statics: {
            _views: [],
            _viewsById: {},
            _id: 0,
            create: function(project, element) {
              if (document2 && typeof element === "string")
                element = document2.getElementById(element);
              var ctor = window2 ? CanvasView : View;
              return new ctor(project, element);
            }
          }
        }, new function() {
          if (!window2)
            return;
          var prevFocus, tempFocus, dragging = false, mouseDown = false;
          function getView(event) {
            var target = DomEvent.getTarget(event);
            return target.getAttribute && View._viewsById[target.getAttribute("id")];
          }
          function updateFocus() {
            var view = View._focused;
            if (!view || !view.isVisible()) {
              for (var i2 = 0, l2 = View._views.length; i2 < l2; i2++) {
                if ((view = View._views[i2]).isVisible()) {
                  View._focused = tempFocus = view;
                  break;
                }
              }
            }
          }
          function handleMouseMove(view, event, point) {
            view._handleMouseEvent("mousemove", event, point);
          }
          var navigator2 = window2.navigator, mousedown, mousemove, mouseup;
          if (navigator2.pointerEnabled || navigator2.msPointerEnabled) {
            mousedown = "pointerdown MSPointerDown";
            mousemove = "pointermove MSPointerMove";
            mouseup = "pointerup pointercancel MSPointerUp MSPointerCancel";
          } else {
            mousedown = "touchstart";
            mousemove = "touchmove";
            mouseup = "touchend touchcancel";
            if (!("ontouchstart" in window2 && navigator2.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
              mousedown += " mousedown";
              mousemove += " mousemove";
              mouseup += " mouseup";
            }
          }
          var viewEvents = {}, docEvents = {
            mouseout: function(event) {
              var view = View._focused, target = DomEvent.getRelatedTarget(event);
              if (view && (!target || target.nodeName === "HTML")) {
                var offset = DomEvent.getOffset(event, view._element), x2 = offset.x, abs = Math.abs, ax = abs(x2), max = 1 << 25, diff = ax - max;
                offset.x = abs(diff) < ax ? diff * (x2 < 0 ? -1 : 1) : x2;
                handleMouseMove(view, event, view.viewToProject(offset));
              }
            },
            scroll: updateFocus
          };
          viewEvents[mousedown] = function(event) {
            var view = View._focused = getView(event);
            if (!dragging) {
              dragging = true;
              view._handleMouseEvent("mousedown", event);
            }
          };
          docEvents[mousemove] = function(event) {
            var view = View._focused;
            if (!mouseDown) {
              var target = getView(event);
              if (target) {
                if (view !== target) {
                  if (view)
                    handleMouseMove(view, event);
                  if (!prevFocus)
                    prevFocus = view;
                  view = View._focused = tempFocus = target;
                }
              } else if (tempFocus && tempFocus === view) {
                if (prevFocus && !prevFocus.isInserted())
                  prevFocus = null;
                view = View._focused = prevFocus;
                prevFocus = null;
                updateFocus();
              }
            }
            if (view)
              handleMouseMove(view, event);
          };
          docEvents[mousedown] = function() {
            mouseDown = true;
          };
          docEvents[mouseup] = function(event) {
            var view = View._focused;
            if (view && dragging)
              view._handleMouseEvent("mouseup", event);
            mouseDown = dragging = false;
          };
          DomEvent.add(document2, docEvents);
          DomEvent.add(window2, {
            load: updateFocus
          });
          var called = false, prevented = false, fallbacks = {
            doubleclick: "click",
            mousedrag: "mousemove"
          }, wasInView = false, overView, downPoint, lastPoint, downItem, overItem, dragItem, clickItem, clickTime, dblClick;
          function emitMouseEvent(obj, target, type, event, point, prevPoint, stopItem) {
            var stopped = false, mouseEvent;
            function emit(obj2, type2) {
              if (obj2.responds(type2)) {
                if (!mouseEvent) {
                  mouseEvent = new MouseEvent(type2, event, point, target || obj2, prevPoint ? point.subtract(prevPoint) : null);
                }
                if (obj2.emit(type2, mouseEvent)) {
                  called = true;
                  if (mouseEvent.prevented)
                    prevented = true;
                  if (mouseEvent.stopped)
                    return stopped = true;
                }
              } else {
                var fallback = fallbacks[type2];
                if (fallback)
                  return emit(obj2, fallback);
              }
            }
            while (obj && obj !== stopItem) {
              if (emit(obj, type))
                break;
              obj = obj._parent;
            }
            return stopped;
          }
          function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
            view._project.removeOn(type);
            prevented = called = false;
            return dragItem && emitMouseEvent(dragItem, null, type, event, point, prevPoint) || hitItem && hitItem !== dragItem && !hitItem.isDescendant(dragItem) && emitMouseEvent(hitItem, null, type === "mousedrag" ? "mousemove" : type, event, point, prevPoint, dragItem) || emitMouseEvent(view, dragItem || hitItem || view, type, event, point, prevPoint);
          }
          var itemEventsMap = {
            mousedown: {
              mousedown: 1,
              mousedrag: 1,
              click: 1,
              doubleclick: 1
            },
            mouseup: {
              mouseup: 1,
              mousedrag: 1,
              click: 1,
              doubleclick: 1
            },
            mousemove: {
              mousedrag: 1,
              mousemove: 1,
              mouseenter: 1,
              mouseleave: 1
            }
          };
          return {
            _viewEvents: viewEvents,
            _handleMouseEvent: function(type, event, point) {
              var itemEvents = this._itemEvents, hitItems = itemEvents.native[type], nativeMove = type === "mousemove", tool = this._scope.tool, view = this;
              function responds(type2) {
                return itemEvents.virtual[type2] || view.responds(type2) || tool && tool.responds(type2);
              }
              if (nativeMove && dragging && responds("mousedrag"))
                type = "mousedrag";
              if (!point)
                point = this.getEventPoint(event);
              var inView = this.getBounds().contains(point), hit = hitItems && inView && view._project.hitTest(point, {
                tolerance: 0,
                fill: true,
                stroke: true
              }), hitItem = hit && hit.item || null, handle = false, mouse = {};
              mouse[type.substr(5)] = true;
              if (hitItems && hitItem !== overItem) {
                if (overItem) {
                  emitMouseEvent(overItem, null, "mouseleave", event, point);
                }
                if (hitItem) {
                  emitMouseEvent(hitItem, null, "mouseenter", event, point);
                }
                overItem = hitItem;
              }
              if (wasInView ^ inView) {
                emitMouseEvent(this, null, inView ? "mouseenter" : "mouseleave", event, point);
                overView = inView ? this : null;
                handle = true;
              }
              if ((inView || mouse.drag) && !point.equals(lastPoint)) {
                emitMouseEvents(this, hitItem, nativeMove ? type : "mousemove", event, point, lastPoint);
                handle = true;
              }
              wasInView = inView;
              if (mouse.down && inView || mouse.up && downPoint) {
                emitMouseEvents(this, hitItem, type, event, point, downPoint);
                if (mouse.down) {
                  dblClick = hitItem === clickItem && Date.now() - clickTime < 300;
                  downItem = clickItem = hitItem;
                  if (!prevented && hitItem) {
                    var item = hitItem;
                    while (item && !item.responds("mousedrag"))
                      item = item._parent;
                    if (item)
                      dragItem = hitItem;
                  }
                  downPoint = point;
                } else if (mouse.up) {
                  if (!prevented && hitItem === downItem) {
                    clickTime = Date.now();
                    emitMouseEvents(this, hitItem, dblClick ? "doubleclick" : "click", event, point, downPoint);
                    dblClick = false;
                  }
                  downItem = dragItem = null;
                }
                wasInView = false;
                handle = true;
              }
              lastPoint = point;
              if (handle && tool) {
                called = tool._handleMouseEvent(type, event, point, mouse) || called;
              }
              if (event.cancelable !== false && (called && !mouse.move || mouse.down && responds("mouseup"))) {
                event.preventDefault();
              }
            },
            _handleKeyEvent: function(type, event, key, character) {
              var scope = this._scope, tool = scope.tool, keyEvent;
              function emit(obj) {
                if (obj.responds(type)) {
                  paper2 = scope;
                  obj.emit(type, keyEvent = keyEvent || new KeyEvent(type, event, key, character));
                }
              }
              if (this.isVisible()) {
                emit(this);
                if (tool && tool.responds(type))
                  emit(tool);
              }
            },
            _countItemEvent: function(type, sign) {
              var itemEvents = this._itemEvents, native = itemEvents.native, virtual = itemEvents.virtual;
              for (var key in itemEventsMap) {
                native[key] = (native[key] || 0) + (itemEventsMap[key][type] || 0) * sign;
              }
              virtual[type] = (virtual[type] || 0) + sign;
            },
            statics: {
              updateFocus,
              _resetState: function() {
                dragging = mouseDown = called = wasInView = false;
                prevFocus = tempFocus = overView = downPoint = lastPoint = downItem = overItem = dragItem = clickItem = clickTime = dblClick = null;
              }
            }
          };
        }());
        var CanvasView = View.extend({
          _class: "CanvasView",
          initialize: function CanvasView2(project, canvas2) {
            if (!(canvas2 instanceof window2.HTMLCanvasElement)) {
              var size = Size.read(arguments, 1);
              if (size.isZero())
                throw new Error("Cannot create CanvasView with the provided argument: " + Base.slice(arguments, 1));
              canvas2 = CanvasProvider.getCanvas(size);
            }
            var ctx = this._context = canvas2.getContext("2d");
            ctx.save();
            this._pixelRatio = 1;
            if (!/^off|false$/.test(PaperScope.getAttribute(canvas2, "hidpi"))) {
              var deviceRatio = window2.devicePixelRatio || 1, backingStoreRatio = DomElement.getPrefixed(ctx, "backingStorePixelRatio") || 1;
              this._pixelRatio = deviceRatio / backingStoreRatio;
            }
            View.call(this, project, canvas2);
            this._needsUpdate = true;
          },
          remove: function remove() {
            this._context.restore();
            return remove.base.call(this);
          },
          _setElementSize: function _setElementSize(width, height) {
            var pixelRatio = this._pixelRatio;
            _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
            if (pixelRatio !== 1) {
              var element = this._element, ctx = this._context;
              if (!PaperScope.hasAttribute(element, "resize")) {
                var style = element.style;
                style.width = width + "px";
                style.height = height + "px";
              }
              ctx.restore();
              ctx.save();
              ctx.scale(pixelRatio, pixelRatio);
            }
          },
          getContext: function() {
            return this._context;
          },
          getPixelSize: function getPixelSize(size) {
            var agent = paper2.agent, pixels;
            if (agent && agent.firefox) {
              pixels = getPixelSize.base.call(this, size);
            } else {
              var ctx = this._context, prevFont = ctx.font;
              ctx.font = size + " serif";
              pixels = parseFloat(ctx.font);
              ctx.font = prevFont;
            }
            return pixels;
          },
          getTextWidth: function(font, lines) {
            var ctx = this._context, prevFont = ctx.font, width = 0;
            ctx.font = font;
            for (var i2 = 0, l2 = lines.length; i2 < l2; i2++)
              width = Math.max(width, ctx.measureText(lines[i2]).width);
            ctx.font = prevFont;
            return width;
          },
          update: function() {
            if (!this._needsUpdate)
              return false;
            var project = this._project, ctx = this._context, size = this._viewSize;
            ctx.clearRect(0, 0, size.width + 1, size.height + 1);
            if (project)
              project.draw(ctx, this._matrix, this._pixelRatio);
            this._needsUpdate = false;
            return true;
          }
        });
        var Event = Base.extend({
          _class: "Event",
          initialize: function Event2(event) {
            this.event = event;
            this.type = event && event.type;
          },
          prevented: false,
          stopped: false,
          preventDefault: function() {
            this.prevented = true;
            this.event.preventDefault();
          },
          stopPropagation: function() {
            this.stopped = true;
            this.event.stopPropagation();
          },
          stop: function() {
            this.stopPropagation();
            this.preventDefault();
          },
          getTimeStamp: function() {
            return this.event.timeStamp;
          },
          getModifiers: function() {
            return Key.modifiers;
          }
        });
        var KeyEvent = Event.extend({
          _class: "KeyEvent",
          initialize: function KeyEvent2(type, event, key, character) {
            this.type = type;
            this.event = event;
            this.key = key;
            this.character = character;
          },
          toString: function() {
            return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
          }
        });
        var Key = new function() {
          var keyLookup = {
            "	": "tab",
            " ": "space",
            "\b": "backspace",
            "\x7F": "delete",
            "Spacebar": "space",
            "Del": "delete",
            "Win": "meta",
            "Esc": "escape"
          }, charLookup = {
            "tab": "	",
            "space": " ",
            "enter": "\r"
          }, keyMap = {}, charMap = {}, metaFixMap, downKey, modifiers = new Base({
            shift: false,
            control: false,
            alt: false,
            meta: false,
            capsLock: false,
            space: false
          }).inject({
            option: {
              get: function() {
                return this.alt;
              }
            },
            command: {
              get: function() {
                var agent = paper2 && paper2.agent;
                return agent && agent.mac ? this.meta : this.control;
              }
            }
          });
          function getKey(event) {
            var key = event.key || event.keyIdentifier;
            key = /^U\+/.test(key) ? String.fromCharCode(parseInt(key.substr(2), 16)) : /^Arrow[A-Z]/.test(key) ? key.substr(5) : key === "Unidentified" || key === undefined2 ? String.fromCharCode(event.keyCode) : key;
            return keyLookup[key] || (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
          }
          function handleKey(down, key, character, event) {
            var type = down ? "keydown" : "keyup", view = View._focused, name;
            keyMap[key] = down;
            if (down) {
              charMap[key] = character;
            } else {
              delete charMap[key];
            }
            if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
              modifiers[name] = down;
              var agent = paper2 && paper2.agent;
              if (name === "meta" && agent && agent.mac) {
                if (down) {
                  metaFixMap = {};
                } else {
                  for (var k2 in metaFixMap) {
                    if (k2 in charMap)
                      handleKey(false, k2, metaFixMap[k2], event);
                  }
                  metaFixMap = null;
                }
              }
            } else if (down && metaFixMap) {
              metaFixMap[key] = character;
            }
            if (view) {
              view._handleKeyEvent(down ? "keydown" : "keyup", event, key, character);
            }
          }
          DomEvent.add(document2, {
            keydown: function(event) {
              var key = getKey(event), agent = paper2 && paper2.agent;
              if (key.length > 1 || agent && (agent.chrome && (event.altKey || agent.mac && event.metaKey || !agent.mac && event.ctrlKey))) {
                handleKey(true, key, charLookup[key] || (key.length > 1 ? "" : key), event);
              } else {
                downKey = key;
              }
            },
            keypress: function(event) {
              if (downKey) {
                var key = getKey(event), code = event.charCode, character = code >= 32 ? String.fromCharCode(code) : key.length > 1 ? "" : key;
                if (key !== downKey) {
                  key = character.toLowerCase();
                }
                handleKey(true, key, character, event);
                downKey = null;
              }
            },
            keyup: function(event) {
              var key = getKey(event);
              if (key in charMap)
                handleKey(false, key, charMap[key], event);
            }
          });
          DomEvent.add(window2, {
            blur: function(event) {
              for (var key in charMap)
                handleKey(false, key, charMap[key], event);
            }
          });
          return {
            modifiers,
            isDown: function(key) {
              return !!keyMap[key];
            }
          };
        }();
        var MouseEvent = Event.extend({
          _class: "MouseEvent",
          initialize: function MouseEvent2(type, event, point, target, delta) {
            this.type = type;
            this.event = event;
            this.point = point;
            this.target = target;
            this.delta = delta;
          },
          toString: function() {
            return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }";
          }
        });
        var ToolEvent = Event.extend({
          _class: "ToolEvent",
          _item: null,
          initialize: function ToolEvent2(tool, type, event) {
            this.tool = tool;
            this.type = type;
            this.event = event;
          },
          _choosePoint: function(point, toolPoint) {
            return point ? point : toolPoint ? toolPoint.clone() : null;
          },
          getPoint: function() {
            return this._choosePoint(this._point, this.tool._point);
          },
          setPoint: function(point) {
            this._point = point;
          },
          getLastPoint: function() {
            return this._choosePoint(this._lastPoint, this.tool._lastPoint);
          },
          setLastPoint: function(lastPoint) {
            this._lastPoint = lastPoint;
          },
          getDownPoint: function() {
            return this._choosePoint(this._downPoint, this.tool._downPoint);
          },
          setDownPoint: function(downPoint) {
            this._downPoint = downPoint;
          },
          getMiddlePoint: function() {
            if (!this._middlePoint && this.tool._lastPoint) {
              return this.tool._point.add(this.tool._lastPoint).divide(2);
            }
            return this._middlePoint;
          },
          setMiddlePoint: function(middlePoint) {
            this._middlePoint = middlePoint;
          },
          getDelta: function() {
            return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
          },
          setDelta: function(delta) {
            this._delta = delta;
          },
          getCount: function() {
            return this.tool[/^mouse(down|up)$/.test(this.type) ? "_downCount" : "_moveCount"];
          },
          setCount: function(count) {
            this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = count;
          },
          getItem: function() {
            if (!this._item) {
              var result = this.tool._scope.project.hitTest(this.getPoint());
              if (result) {
                var item = result.item, parent = item._parent;
                while (/^(Group|CompoundPath)$/.test(parent._class)) {
                  item = parent;
                  parent = parent._parent;
                }
                this._item = item;
              }
            }
            return this._item;
          },
          setItem: function(item) {
            this._item = item;
          },
          toString: function() {
            return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }";
          }
        });
        var Tool = PaperScopeItem.extend({
          _class: "Tool",
          _list: "tools",
          _reference: "tool",
          _events: [
            "onMouseDown",
            "onMouseUp",
            "onMouseDrag",
            "onMouseMove",
            "onActivate",
            "onDeactivate",
            "onEditOptions",
            "onKeyDown",
            "onKeyUp"
          ],
          initialize: function Tool2(props) {
            PaperScopeItem.call(this);
            this._moveCount = -1;
            this._downCount = -1;
            this.set(props);
          },
          getMinDistance: function() {
            return this._minDistance;
          },
          setMinDistance: function(minDistance) {
            this._minDistance = minDistance;
            if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
              this._maxDistance = minDistance;
            }
          },
          getMaxDistance: function() {
            return this._maxDistance;
          },
          setMaxDistance: function(maxDistance) {
            this._maxDistance = maxDistance;
            if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
              this._minDistance = maxDistance;
            }
          },
          getFixedDistance: function() {
            return this._minDistance == this._maxDistance ? this._minDistance : null;
          },
          setFixedDistance: function(distance) {
            this._minDistance = this._maxDistance = distance;
          },
          _handleMouseEvent: function(type, event, point, mouse) {
            paper2 = this._scope;
            if (mouse.drag && !this.responds(type))
              type = "mousemove";
            var move = mouse.move || mouse.drag, responds = this.responds(type), minDistance = this.minDistance, maxDistance = this.maxDistance, called = false, tool = this;
            function update(minDistance2, maxDistance2) {
              var pt2 = point, toolPoint = move ? tool._point : tool._downPoint || pt2;
              if (move) {
                if (tool._moveCount >= 0 && pt2.equals(toolPoint)) {
                  return false;
                }
                if (toolPoint && (minDistance2 != null || maxDistance2 != null)) {
                  var vector = pt2.subtract(toolPoint), distance = vector.getLength();
                  if (distance < (minDistance2 || 0))
                    return false;
                  if (maxDistance2) {
                    pt2 = toolPoint.add(vector.normalize(Math.min(distance, maxDistance2)));
                  }
                }
                tool._moveCount++;
              }
              tool._point = pt2;
              tool._lastPoint = toolPoint || pt2;
              if (mouse.down) {
                tool._moveCount = -1;
                tool._downPoint = pt2;
                tool._downCount++;
              }
              return true;
            }
            function emit() {
              if (responds) {
                called = tool.emit(type, new ToolEvent(tool, type, event)) || called;
              }
            }
            if (mouse.down) {
              update();
              emit();
            } else if (mouse.up) {
              update(null, maxDistance);
              emit();
            } else if (responds) {
              while (update(minDistance, maxDistance))
                emit();
            }
            return called;
          }
        });
        var Tween = Base.extend(Emitter, {
          _class: "Tween",
          statics: {
            easings: new Base({
              linear: function(t2) {
                return t2;
              },
              easeInQuad: function(t2) {
                return t2 * t2;
              },
              easeOutQuad: function(t2) {
                return t2 * (2 - t2);
              },
              easeInOutQuad: function(t2) {
                return t2 < 0.5 ? 2 * t2 * t2 : -1 + 2 * (2 - t2) * t2;
              },
              easeInCubic: function(t2) {
                return t2 * t2 * t2;
              },
              easeOutCubic: function(t2) {
                return --t2 * t2 * t2 + 1;
              },
              easeInOutCubic: function(t2) {
                return t2 < 0.5 ? 4 * t2 * t2 * t2 : (t2 - 1) * (2 * t2 - 2) * (2 * t2 - 2) + 1;
              },
              easeInQuart: function(t2) {
                return t2 * t2 * t2 * t2;
              },
              easeOutQuart: function(t2) {
                return 1 - --t2 * t2 * t2 * t2;
              },
              easeInOutQuart: function(t2) {
                return t2 < 0.5 ? 8 * t2 * t2 * t2 * t2 : 1 - 8 * --t2 * t2 * t2 * t2;
              },
              easeInQuint: function(t2) {
                return t2 * t2 * t2 * t2 * t2;
              },
              easeOutQuint: function(t2) {
                return 1 + --t2 * t2 * t2 * t2 * t2;
              },
              easeInOutQuint: function(t2) {
                return t2 < 0.5 ? 16 * t2 * t2 * t2 * t2 * t2 : 1 + 16 * --t2 * t2 * t2 * t2 * t2;
              }
            })
          },
          initialize: function Tween2(object, from, to2, duration, easing, start) {
            this.object = object;
            var type = typeof easing;
            var isFunction = type === "function";
            this.type = isFunction ? type : type === "string" ? easing : "linear";
            this.easing = isFunction ? easing : Tween2.easings[this.type];
            this.duration = duration;
            this.running = false;
            this._then = null;
            this._startTime = null;
            var state = from || to2;
            this._keys = state ? Object.keys(state) : [];
            this._parsedKeys = this._parseKeys(this._keys);
            this._from = state && this._getState(from);
            this._to = state && this._getState(to2);
            if (start !== false) {
              this.start();
            }
          },
          then: function(then) {
            this._then = then;
            return this;
          },
          start: function() {
            this._startTime = null;
            this.running = true;
            return this;
          },
          stop: function() {
            this.running = false;
            return this;
          },
          update: function(progress) {
            if (this.running) {
              if (progress >= 1) {
                progress = 1;
                this.running = false;
              }
              var factor = this.easing(progress), keys = this._keys, getValue = function(value2) {
                return typeof value2 === "function" ? value2(factor, progress) : value2;
              };
              for (var i2 = 0, l2 = keys && keys.length; i2 < l2; i2++) {
                var key = keys[i2], from = getValue(this._from[key]), to2 = getValue(this._to[key]), value = from && to2 && from.__add && to2.__add ? to2.__subtract(from).__multiply(factor).__add(from) : (to2 - from) * factor + from;
                this._setProperty(this._parsedKeys[key], value);
              }
              if (this.responds("update")) {
                this.emit("update", new Base({
                  progress,
                  factor
                }));
              }
              if (!this.running && this._then) {
                this._then(this.object);
              }
            }
            return this;
          },
          _events: {
            onUpdate: {}
          },
          _handleFrame: function(time) {
            var startTime = this._startTime, progress = startTime ? (time - startTime) / this.duration : 0;
            if (!startTime) {
              this._startTime = time;
            }
            this.update(progress);
          },
          _getState: function(state) {
            var keys = this._keys, result = {};
            for (var i2 = 0, l2 = keys.length; i2 < l2; i2++) {
              var key = keys[i2], path = this._parsedKeys[key], current = this._getProperty(path), value;
              if (state) {
                var resolved = this._resolveValue(current, state[key]);
                this._setProperty(path, resolved);
                value = this._getProperty(path);
                value = value && value.clone ? value.clone() : value;
                this._setProperty(path, current);
              } else {
                value = current && current.clone ? current.clone() : current;
              }
              result[key] = value;
            }
            return result;
          },
          _resolveValue: function(current, value) {
            if (value) {
              if (Array.isArray(value) && value.length === 2) {
                var operator = value[0];
                return operator && operator.match && operator.match(/^[+\-\*\/]=/) ? this._calculate(current, operator[0], value[1]) : value;
              } else if (typeof value === "string") {
                var match = value.match(/^[+\-*/]=(.*)/);
                if (match) {
                  var parsed = JSON.parse(match[1].replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": '));
                  return this._calculate(current, value[0], parsed);
                }
              }
            }
            return value;
          },
          _calculate: function(left, operator, right) {
            return paper2.PaperScript.calculateBinary(left, operator, right);
          },
          _parseKeys: function(keys) {
            var parsed = {};
            for (var i2 = 0, l2 = keys.length; i2 < l2; i2++) {
              var key = keys[i2], path = key.replace(/\.([^.]*)/g, "/$1").replace(/\[['"]?([^'"\]]*)['"]?\]/g, "/$1");
              parsed[key] = path.split("/");
            }
            return parsed;
          },
          _getProperty: function(path, offset) {
            var obj = this.object;
            for (var i2 = 0, l2 = path.length - (offset || 0); i2 < l2 && obj; i2++) {
              obj = obj[path[i2]];
            }
            return obj;
          },
          _setProperty: function(path, value) {
            var dest = this._getProperty(path, 1);
            if (dest) {
              dest[path[path.length - 1]] = value;
            }
          }
        });
        var Http = {
          request: function(options) {
            var xhr = new self2.XMLHttpRequest();
            xhr.open((options.method || "get").toUpperCase(), options.url, Base.pick(options.async, true));
            if (options.mimeType)
              xhr.overrideMimeType(options.mimeType);
            xhr.onload = function() {
              var status = xhr.status;
              if (status === 0 || status === 200) {
                if (options.onLoad) {
                  options.onLoad.call(xhr, xhr.responseText);
                }
              } else {
                xhr.onerror();
              }
            };
            xhr.onerror = function() {
              var status = xhr.status, message = 'Could not load "' + options.url + '" (Status: ' + status + ")";
              if (options.onError) {
                options.onError(message, status);
              } else {
                throw new Error(message);
              }
            };
            return xhr.send(null);
          }
        };
        var CanvasProvider = Base.exports.CanvasProvider = {
          canvases: [],
          getCanvas: function(width, height) {
            if (!window2)
              return null;
            var canvas2, clear = true;
            if (typeof width === "object") {
              height = width.height;
              width = width.width;
            }
            if (this.canvases.length) {
              canvas2 = this.canvases.pop();
            } else {
              canvas2 = document2.createElement("canvas");
              clear = false;
            }
            var ctx = canvas2.getContext("2d");
            if (!ctx) {
              throw new Error("Canvas " + canvas2 + " is unable to provide a 2D context.");
            }
            if (canvas2.width === width && canvas2.height === height) {
              if (clear)
                ctx.clearRect(0, 0, width + 1, height + 1);
            } else {
              canvas2.width = width;
              canvas2.height = height;
            }
            ctx.save();
            return canvas2;
          },
          getContext: function(width, height) {
            var canvas2 = this.getCanvas(width, height);
            return canvas2 ? canvas2.getContext("2d") : null;
          },
          release: function(obj) {
            var canvas2 = obj && obj.canvas ? obj.canvas : obj;
            if (canvas2 && canvas2.getContext) {
              canvas2.getContext("2d").restore();
              this.canvases.push(canvas2);
            }
          }
        };
        var BlendMode = new function() {
          var min = Math.min, max = Math.max, abs = Math.abs, sr2, sg, sb, sa2, br2, bg, bb, ba, dr2, dg, db;
          function getLum(r2, g2, b2) {
            return 0.2989 * r2 + 0.587 * g2 + 0.114 * b2;
          }
          function setLum(r2, g2, b2, l2) {
            var d = l2 - getLum(r2, g2, b2);
            dr2 = r2 + d;
            dg = g2 + d;
            db = b2 + d;
            var l2 = getLum(dr2, dg, db), mn2 = min(dr2, dg, db), mx = max(dr2, dg, db);
            if (mn2 < 0) {
              var lmn = l2 - mn2;
              dr2 = l2 + (dr2 - l2) * l2 / lmn;
              dg = l2 + (dg - l2) * l2 / lmn;
              db = l2 + (db - l2) * l2 / lmn;
            }
            if (mx > 255) {
              var ln2 = 255 - l2, mxl = mx - l2;
              dr2 = l2 + (dr2 - l2) * ln2 / mxl;
              dg = l2 + (dg - l2) * ln2 / mxl;
              db = l2 + (db - l2) * ln2 / mxl;
            }
          }
          function getSat(r2, g2, b2) {
            return max(r2, g2, b2) - min(r2, g2, b2);
          }
          function setSat(r2, g2, b2, s2) {
            var col = [r2, g2, b2], mx = max(r2, g2, b2), mn2 = min(r2, g2, b2), md2;
            mn2 = mn2 === r2 ? 0 : mn2 === g2 ? 1 : 2;
            mx = mx === r2 ? 0 : mx === g2 ? 1 : 2;
            md2 = min(mn2, mx) === 0 ? max(mn2, mx) === 1 ? 2 : 1 : 0;
            if (col[mx] > col[mn2]) {
              col[md2] = (col[md2] - col[mn2]) * s2 / (col[mx] - col[mn2]);
              col[mx] = s2;
            } else {
              col[md2] = col[mx] = 0;
            }
            col[mn2] = 0;
            dr2 = col[0];
            dg = col[1];
            db = col[2];
          }
          var modes = {
            multiply: function() {
              dr2 = br2 * sr2 / 255;
              dg = bg * sg / 255;
              db = bb * sb / 255;
            },
            screen: function() {
              dr2 = br2 + sr2 - br2 * sr2 / 255;
              dg = bg + sg - bg * sg / 255;
              db = bb + sb - bb * sb / 255;
            },
            overlay: function() {
              dr2 = br2 < 128 ? 2 * br2 * sr2 / 255 : 255 - 2 * (255 - br2) * (255 - sr2) / 255;
              dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
              db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
            },
            "soft-light": function() {
              var t2 = sr2 * br2 / 255;
              dr2 = t2 + br2 * (255 - (255 - br2) * (255 - sr2) / 255 - t2) / 255;
              t2 = sg * bg / 255;
              dg = t2 + bg * (255 - (255 - bg) * (255 - sg) / 255 - t2) / 255;
              t2 = sb * bb / 255;
              db = t2 + bb * (255 - (255 - bb) * (255 - sb) / 255 - t2) / 255;
            },
            "hard-light": function() {
              dr2 = sr2 < 128 ? 2 * sr2 * br2 / 255 : 255 - 2 * (255 - sr2) * (255 - br2) / 255;
              dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
              db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
            },
            "color-dodge": function() {
              dr2 = br2 === 0 ? 0 : sr2 === 255 ? 255 : min(255, 255 * br2 / (255 - sr2));
              dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
              db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
            },
            "color-burn": function() {
              dr2 = br2 === 255 ? 255 : sr2 === 0 ? 0 : max(0, 255 - (255 - br2) * 255 / sr2);
              dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
              db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
            },
            darken: function() {
              dr2 = br2 < sr2 ? br2 : sr2;
              dg = bg < sg ? bg : sg;
              db = bb < sb ? bb : sb;
            },
            lighten: function() {
              dr2 = br2 > sr2 ? br2 : sr2;
              dg = bg > sg ? bg : sg;
              db = bb > sb ? bb : sb;
            },
            difference: function() {
              dr2 = br2 - sr2;
              if (dr2 < 0)
                dr2 = -dr2;
              dg = bg - sg;
              if (dg < 0)
                dg = -dg;
              db = bb - sb;
              if (db < 0)
                db = -db;
            },
            exclusion: function() {
              dr2 = br2 + sr2 * (255 - br2 - br2) / 255;
              dg = bg + sg * (255 - bg - bg) / 255;
              db = bb + sb * (255 - bb - bb) / 255;
            },
            hue: function() {
              setSat(sr2, sg, sb, getSat(br2, bg, bb));
              setLum(dr2, dg, db, getLum(br2, bg, bb));
            },
            saturation: function() {
              setSat(br2, bg, bb, getSat(sr2, sg, sb));
              setLum(dr2, dg, db, getLum(br2, bg, bb));
            },
            luminosity: function() {
              setLum(br2, bg, bb, getLum(sr2, sg, sb));
            },
            color: function() {
              setLum(sr2, sg, sb, getLum(br2, bg, bb));
            },
            add: function() {
              dr2 = min(br2 + sr2, 255);
              dg = min(bg + sg, 255);
              db = min(bb + sb, 255);
            },
            subtract: function() {
              dr2 = max(br2 - sr2, 0);
              dg = max(bg - sg, 0);
              db = max(bb - sb, 0);
            },
            average: function() {
              dr2 = (br2 + sr2) / 2;
              dg = (bg + sg) / 2;
              db = (bb + sb) / 2;
            },
            negation: function() {
              dr2 = 255 - abs(255 - sr2 - br2);
              dg = 255 - abs(255 - sg - bg);
              db = 255 - abs(255 - sb - bb);
            }
          };
          var nativeModes = this.nativeModes = Base.each([
            "source-over",
            "source-in",
            "source-out",
            "source-atop",
            "destination-over",
            "destination-in",
            "destination-out",
            "destination-atop",
            "lighter",
            "darker",
            "copy",
            "xor"
          ], function(mode) {
            this[mode] = true;
          }, {});
          var ctx = CanvasProvider.getContext(1, 1);
          if (ctx) {
            Base.each(modes, function(func, mode) {
              var darken = mode === "darken", ok = false;
              ctx.save();
              try {
                ctx.fillStyle = darken ? "#300" : "#a00";
                ctx.fillRect(0, 0, 1, 1);
                ctx.globalCompositeOperation = mode;
                if (ctx.globalCompositeOperation === mode) {
                  ctx.fillStyle = darken ? "#a00" : "#300";
                  ctx.fillRect(0, 0, 1, 1);
                  ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
                }
              } catch (e4) {
              }
              ctx.restore();
              nativeModes[mode] = ok;
            });
            CanvasProvider.release(ctx);
          }
          this.process = function(mode, srcContext, dstContext, alpha, offset) {
            var srcCanvas = srcContext.canvas, normal = mode === "normal";
            if (normal || nativeModes[mode]) {
              dstContext.save();
              dstContext.setTransform(1, 0, 0, 1, 0, 0);
              dstContext.globalAlpha = alpha;
              if (!normal)
                dstContext.globalCompositeOperation = mode;
              dstContext.drawImage(srcCanvas, offset.x, offset.y);
              dstContext.restore();
            } else {
              var process2 = modes[mode];
              if (!process2)
                return;
              var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height), dst = dstData.data, src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;
              for (var i2 = 0, l2 = dst.length; i2 < l2; i2 += 4) {
                sr2 = src[i2];
                br2 = dst[i2];
                sg = src[i2 + 1];
                bg = dst[i2 + 1];
                sb = src[i2 + 2];
                bb = dst[i2 + 2];
                sa2 = src[i2 + 3];
                ba = dst[i2 + 3];
                process2();
                var a1 = sa2 * alpha / 255, a2 = 1 - a1;
                dst[i2] = a1 * dr2 + a2 * br2;
                dst[i2 + 1] = a1 * dg + a2 * bg;
                dst[i2 + 2] = a1 * db + a2 * bb;
                dst[i2 + 3] = sa2 * alpha + a2 * ba;
              }
              dstContext.putImageData(dstData, offset.x, offset.y);
            }
          };
        }();
        var SvgElement = new function() {
          var svg = "http://www.w3.org/2000/svg", xmlns = "http://www.w3.org/2000/xmlns", xlink = "http://www.w3.org/1999/xlink", attributeNamespace = {
            href: xlink,
            xlink: xmlns,
            xmlns: xmlns + "/",
            "xmlns:xlink": xmlns + "/"
          };
          function create(tag, attributes, formatter) {
            return set(document2.createElementNS(svg, tag), attributes, formatter);
          }
          function get(node, name) {
            var namespace = attributeNamespace[name], value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
            return value === "null" ? null : value;
          }
          function set(node, attributes, formatter) {
            for (var name in attributes) {
              var value = attributes[name], namespace = attributeNamespace[name];
              if (typeof value === "number" && formatter)
                value = formatter.number(value);
              if (namespace) {
                node.setAttributeNS(namespace, name, value);
              } else {
                node.setAttribute(name, value);
              }
            }
            return node;
          }
          return {
            svg,
            xmlns,
            xlink,
            create,
            get,
            set
          };
        }();
        var SvgStyles = Base.each({
          fillColor: ["fill", "color"],
          fillRule: ["fill-rule", "string"],
          strokeColor: ["stroke", "color"],
          strokeWidth: ["stroke-width", "number"],
          strokeCap: ["stroke-linecap", "string"],
          strokeJoin: ["stroke-linejoin", "string"],
          strokeScaling: ["vector-effect", "lookup", {
            true: "none",
            false: "non-scaling-stroke"
          }, function(item, value) {
            return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
          }],
          miterLimit: ["stroke-miterlimit", "number"],
          dashArray: ["stroke-dasharray", "array"],
          dashOffset: ["stroke-dashoffset", "number"],
          fontFamily: ["font-family", "string"],
          fontWeight: ["font-weight", "string"],
          fontSize: ["font-size", "number"],
          justification: ["text-anchor", "lookup", {
            left: "start",
            center: "middle",
            right: "end"
          }],
          opacity: ["opacity", "number"],
          blendMode: ["mix-blend-mode", "style"]
        }, function(entry, key) {
          var part = Base.capitalize(key), lookup = entry[2];
          this[key] = {
            type: entry[1],
            property: key,
            attribute: entry[0],
            toSVG: lookup,
            fromSVG: lookup && Base.each(lookup, function(value, name) {
              this[value] = name;
            }, {}),
            exportFilter: entry[3],
            get: "get" + part,
            set: "set" + part
          };
        }, {});
        new function() {
          var formatter;
          function getTransform(matrix, coordinates, center) {
            var attrs = new Base(), trans = matrix.getTranslation();
            if (coordinates) {
              var point;
              if (matrix.isInvertible()) {
                matrix = matrix._shiftless();
                point = matrix._inverseTransform(trans);
                trans = null;
              } else {
                point = new Point();
              }
              attrs[center ? "cx" : "x"] = point.x;
              attrs[center ? "cy" : "y"] = point.y;
            }
            if (!matrix.isIdentity()) {
              var decomposed = matrix.decompose();
              if (decomposed) {
                var parts = [], angle = decomposed.rotation, scale = decomposed.scaling, skew = decomposed.skewing;
                if (trans && !trans.isZero())
                  parts.push("translate(" + formatter.point(trans) + ")");
                if (angle)
                  parts.push("rotate(" + formatter.number(angle) + ")");
                if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1))
                  parts.push("scale(" + formatter.point(scale) + ")");
                if (skew.x)
                  parts.push("skewX(" + formatter.number(skew.x) + ")");
                if (skew.y)
                  parts.push("skewY(" + formatter.number(skew.y) + ")");
                attrs.transform = parts.join(" ");
              } else {
                attrs.transform = "matrix(" + matrix.getValues().join(",") + ")";
              }
            }
            return attrs;
          }
          function exportGroup(item, options) {
            var attrs = getTransform(item._matrix), children = item._children;
            var node = SvgElement.create("g", attrs, formatter);
            for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
              var child = children[i2];
              var childNode = exportSVG(child, options);
              if (childNode) {
                if (child.isClipMask()) {
                  var clip = SvgElement.create("clipPath");
                  clip.appendChild(childNode);
                  setDefinition(child, clip, "clip");
                  SvgElement.set(node, {
                    "clip-path": "url(#" + clip.id + ")"
                  });
                } else {
                  node.appendChild(childNode);
                }
              }
            }
            return node;
          }
          function exportRaster(item, options) {
            var attrs = getTransform(item._matrix, true), size = item.getSize(), image = item.getImage();
            attrs.x -= size.width / 2;
            attrs.y -= size.height / 2;
            attrs.width = size.width;
            attrs.height = size.height;
            attrs.href = options.embedImages == false && image && image.src || item.toDataURL();
            return SvgElement.create("image", attrs, formatter);
          }
          function exportPath(item, options) {
            var matchShapes = options.matchShapes;
            if (matchShapes) {
              var shape = item.toShape(false);
              if (shape)
                return exportShape(shape, options);
            }
            var segments = item._segments, length = segments.length, type, attrs = getTransform(item._matrix);
            if (matchShapes && length >= 2 && !item.hasHandles()) {
              if (length > 2) {
                type = item._closed ? "polygon" : "polyline";
                var parts = [];
                for (var i2 = 0; i2 < length; i2++) {
                  parts.push(formatter.point(segments[i2]._point));
                }
                attrs.points = parts.join(" ");
              } else {
                type = "line";
                var start = segments[0]._point, end = segments[1]._point;
                attrs.set({
                  x1: start.x,
                  y1: start.y,
                  x2: end.x,
                  y2: end.y
                });
              }
            } else {
              type = "path";
              attrs.d = item.getPathData(null, options.precision);
            }
            return SvgElement.create(type, attrs, formatter);
          }
          function exportShape(item) {
            var type = item._type, radius = item._radius, attrs = getTransform(item._matrix, true, type !== "rectangle");
            if (type === "rectangle") {
              type = "rect";
              var size = item._size, width = size.width, height = size.height;
              attrs.x -= width / 2;
              attrs.y -= height / 2;
              attrs.width = width;
              attrs.height = height;
              if (radius.isZero())
                radius = null;
            }
            if (radius) {
              if (type === "circle") {
                attrs.r = radius;
              } else {
                attrs.rx = radius.width;
                attrs.ry = radius.height;
              }
            }
            return SvgElement.create(type, attrs, formatter);
          }
          function exportCompoundPath(item, options) {
            var attrs = getTransform(item._matrix);
            var data = item.getPathData(null, options.precision);
            if (data)
              attrs.d = data;
            return SvgElement.create("path", attrs, formatter);
          }
          function exportSymbolItem(item, options) {
            var attrs = getTransform(item._matrix, true), definition = item._definition, node = getDefinition(definition, "symbol"), definitionItem = definition._item, bounds = definitionItem.getStrokeBounds();
            if (!node) {
              node = SvgElement.create("symbol", {
                viewBox: formatter.rectangle(bounds)
              });
              node.appendChild(exportSVG(definitionItem, options));
              setDefinition(definition, node, "symbol");
            }
            attrs.href = "#" + node.id;
            attrs.x += bounds.x;
            attrs.y += bounds.y;
            attrs.width = bounds.width;
            attrs.height = bounds.height;
            attrs.overflow = "visible";
            return SvgElement.create("use", attrs, formatter);
          }
          function exportGradient(color) {
            var gradientNode = getDefinition(color, "color");
            if (!gradientNode) {
              var gradient = color.getGradient(), radial = gradient._radial, origin = color.getOrigin(), destination = color.getDestination(), attrs;
              if (radial) {
                attrs = {
                  cx: origin.x,
                  cy: origin.y,
                  r: origin.getDistance(destination)
                };
                var highlight = color.getHighlight();
                if (highlight) {
                  attrs.fx = highlight.x;
                  attrs.fy = highlight.y;
                }
              } else {
                attrs = {
                  x1: origin.x,
                  y1: origin.y,
                  x2: destination.x,
                  y2: destination.y
                };
              }
              attrs.gradientUnits = "userSpaceOnUse";
              gradientNode = SvgElement.create((radial ? "radial" : "linear") + "Gradient", attrs, formatter);
              var stops = gradient._stops;
              for (var i2 = 0, l2 = stops.length; i2 < l2; i2++) {
                var stop = stops[i2], stopColor = stop._color, alpha = stopColor.getAlpha(), offset = stop._offset;
                attrs = {
                  offset: offset == null ? i2 / (l2 - 1) : offset
                };
                if (stopColor)
                  attrs["stop-color"] = stopColor.toCSS(true);
                if (alpha < 1)
                  attrs["stop-opacity"] = alpha;
                gradientNode.appendChild(SvgElement.create("stop", attrs, formatter));
              }
              setDefinition(color, gradientNode, "color");
            }
            return "url(#" + gradientNode.id + ")";
          }
          function exportText(item) {
            var node = SvgElement.create("text", getTransform(item._matrix, true), formatter);
            node.textContent = item._content;
            return node;
          }
          var exporters = {
            Group: exportGroup,
            Layer: exportGroup,
            Raster: exportRaster,
            Path: exportPath,
            Shape: exportShape,
            CompoundPath: exportCompoundPath,
            SymbolItem: exportSymbolItem,
            PointText: exportText
          };
          function applyStyle(item, node, isRoot) {
            var attrs = {}, parent = !isRoot && item.getParent(), style = [];
            if (item._name != null)
              attrs.id = item._name;
            Base.each(SvgStyles, function(entry) {
              var get = entry.get, type = entry.type, value = item[get]();
              if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
                if (type === "color" && value != null) {
                  var alpha = value.getAlpha();
                  if (alpha < 1)
                    attrs[entry.attribute + "-opacity"] = alpha;
                }
                if (type === "style") {
                  style.push(entry.attribute + ": " + value);
                } else {
                  attrs[entry.attribute] = value == null ? "none" : type === "color" ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === "array" ? value.join(",") : type === "lookup" ? entry.toSVG[value] : value;
                }
              }
            });
            if (style.length)
              attrs.style = style.join(";");
            if (attrs.opacity === 1)
              delete attrs.opacity;
            if (!item._visible)
              attrs.visibility = "hidden";
            return SvgElement.set(node, attrs, formatter);
          }
          var definitions;
          function getDefinition(item, type) {
            if (!definitions)
              definitions = { ids: {}, svgs: {} };
            return item && definitions.svgs[type + "-" + (item._id || item.__id || (item.__id = UID.get("svg")))];
          }
          function setDefinition(item, node, type) {
            if (!definitions)
              getDefinition();
            var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
            node.id = type + "-" + typeId;
            definitions.svgs[type + "-" + (item._id || item.__id)] = node;
          }
          function exportDefinitions(node, options) {
            var svg = node, defs = null;
            if (definitions) {
              svg = node.nodeName.toLowerCase() === "svg" && node;
              for (var i2 in definitions.svgs) {
                if (!defs) {
                  if (!svg) {
                    svg = SvgElement.create("svg");
                    svg.appendChild(node);
                  }
                  defs = svg.insertBefore(SvgElement.create("defs"), svg.firstChild);
                }
                defs.appendChild(definitions.svgs[i2]);
              }
              definitions = null;
            }
            return options.asString ? new self2.XMLSerializer().serializeToString(svg) : svg;
          }
          function exportSVG(item, options, isRoot) {
            var exporter = exporters[item._class], node = exporter && exporter(item, options);
            if (node) {
              var onExport = options.onExport;
              if (onExport)
                node = onExport(item, node, options) || node;
              var data = JSON.stringify(item._data);
              if (data && data !== "{}" && data !== "null")
                node.setAttribute("data-paper-data", data);
            }
            return node && applyStyle(item, node, isRoot);
          }
          function setOptions(options) {
            if (!options)
              options = {};
            formatter = new Formatter(options.precision);
            return options;
          }
          Item.inject({
            exportSVG: function(options) {
              options = setOptions(options);
              return exportDefinitions(exportSVG(this, options, true), options);
            }
          });
          Project.inject({
            exportSVG: function(options) {
              options = setOptions(options);
              var children = this._children, view = this.getView(), bounds = Base.pick(options.bounds, "view"), mx = options.matrix || bounds === "view" && view._matrix, matrix = mx && Matrix.read([mx]), rect = bounds === "view" ? new Rectangle([0, 0], view.getViewSize()) : bounds === "content" ? Item._getBounds(children, matrix, { stroke: true }).rect : Rectangle.read([bounds], 0, { readNull: true }), attrs = {
                version: "1.1",
                xmlns: SvgElement.svg,
                "xmlns:xlink": SvgElement.xlink
              };
              if (rect) {
                attrs.width = rect.width;
                attrs.height = rect.height;
                if (rect.x || rect.x === 0 || rect.y || rect.y === 0)
                  attrs.viewBox = formatter.rectangle(rect);
              }
              var node = SvgElement.create("svg", attrs, formatter), parent = node;
              if (matrix && !matrix.isIdentity()) {
                parent = node.appendChild(SvgElement.create("g", getTransform(matrix), formatter));
              }
              for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
                parent.appendChild(exportSVG(children[i2], options, true));
              }
              return exportDefinitions(node, options);
            }
          });
        }();
        new function() {
          var definitions = {}, rootSize;
          function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {
            var value = SvgElement.get(node, name) || defaultValue, res = value == null ? allowNull ? null : isString ? "" : 0 : isString ? value : parseFloat(value);
            return /%\s*$/.test(value) ? res / 100 * (allowPercent ? 1 : rootSize[/x|^width/.test(name) ? "width" : "height"]) : res;
          }
          function getPoint(node, x2, y2, allowNull, allowPercent, defaultX, defaultY) {
            x2 = getValue(node, x2 || "x", false, allowNull, allowPercent, defaultX);
            y2 = getValue(node, y2 || "y", false, allowNull, allowPercent, defaultY);
            return allowNull && (x2 == null || y2 == null) ? null : new Point(x2, y2);
          }
          function getSize(node, w2, h2, allowNull, allowPercent) {
            w2 = getValue(node, w2 || "width", false, allowNull, allowPercent);
            h2 = getValue(node, h2 || "height", false, allowNull, allowPercent);
            return allowNull && (w2 == null || h2 == null) ? null : new Size(w2, h2);
          }
          function convertValue(value, type, lookup) {
            return value === "none" ? null : type === "number" ? parseFloat(value) : type === "array" ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === "color" ? getDefinition(value) || value : type === "lookup" ? lookup[value] : value;
          }
          function importGroup(node, type, options, isRoot) {
            var nodes = node.childNodes, isClip = type === "clippath", isDefs = type === "defs", item = new Group(), project = item._project, currentStyle = project._currentStyle, children = [];
            if (!isClip && !isDefs) {
              item = applyAttributes(item, node, isRoot);
              project._currentStyle = item._style.clone();
            }
            if (isRoot) {
              var defs = node.querySelectorAll("defs");
              for (var i2 = 0, l2 = defs.length; i2 < l2; i2++) {
                importNode(defs[i2], options, false);
              }
            }
            for (var i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
              var childNode = nodes[i2], child;
              if (childNode.nodeType === 1 && !/^defs$/i.test(childNode.nodeName) && (child = importNode(childNode, options, false)) && !(child instanceof SymbolDefinition))
                children.push(child);
            }
            item.addChildren(children);
            if (isClip)
              item = applyAttributes(item.reduce(), node, isRoot);
            project._currentStyle = currentStyle;
            if (isClip || isDefs) {
              item.remove();
              item = null;
            }
            return item;
          }
          function importPoly(node, type) {
            var coords = node.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), points = [];
            for (var i2 = 0, l2 = coords.length; i2 < l2; i2 += 2)
              points.push(new Point(parseFloat(coords[i2]), parseFloat(coords[i2 + 1])));
            var path = new Path(points);
            if (type === "polygon")
              path.closePath();
            return path;
          }
          function importPath(node) {
            return PathItem.create(node.getAttribute("d"));
          }
          function importGradient(node, type) {
            var id2 = (getValue(node, "href", true) || "").substring(1), radial = type === "radialgradient", gradient;
            if (id2) {
              gradient = definitions[id2].getGradient();
              if (gradient._radial ^ radial) {
                gradient = gradient.clone();
                gradient._radial = radial;
              }
            } else {
              var nodes = node.childNodes, stops = [];
              for (var i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
                var child = nodes[i2];
                if (child.nodeType === 1)
                  stops.push(applyAttributes(new GradientStop(), child));
              }
              gradient = new Gradient(stops, radial);
            }
            var origin, destination, highlight, scaleToBounds = getValue(node, "gradientUnits", true) !== "userSpaceOnUse";
            if (radial) {
              origin = getPoint(node, "cx", "cy", false, scaleToBounds, "50%", "50%");
              destination = origin.add(getValue(node, "r", false, false, scaleToBounds, "50%"), 0);
              highlight = getPoint(node, "fx", "fy", true, scaleToBounds);
            } else {
              origin = getPoint(node, "x1", "y1", false, scaleToBounds, "0%", "0%");
              destination = getPoint(node, "x2", "y2", false, scaleToBounds, "100%", "0%");
            }
            var color = applyAttributes(new Color(gradient, origin, destination, highlight), node);
            color._scaleToBounds = scaleToBounds;
            return null;
          }
          var importers = {
            "#document": function(node, type, options, isRoot) {
              var nodes = node.childNodes;
              for (var i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
                var child = nodes[i2];
                if (child.nodeType === 1)
                  return importNode(child, options, isRoot);
              }
            },
            g: importGroup,
            svg: importGroup,
            clippath: importGroup,
            polygon: importPoly,
            polyline: importPoly,
            path: importPath,
            lineargradient: importGradient,
            radialgradient: importGradient,
            image: function(node) {
              var raster = new Raster(getValue(node, "href", true));
              raster.on("load", function() {
                var size = getSize(node);
                this.setSize(size);
                var center = getPoint(node).add(size.divide(2));
                this._matrix.append(new Matrix().translate(center));
              });
              return raster;
            },
            symbol: function(node, type, options, isRoot) {
              return new SymbolDefinition(importGroup(node, type, options, isRoot), true);
            },
            defs: importGroup,
            use: function(node) {
              var id2 = (getValue(node, "href", true) || "").substring(1), definition = definitions[id2], point = getPoint(node);
              return definition ? definition instanceof SymbolDefinition ? definition.place(point) : definition.clone().translate(point) : null;
            },
            circle: function(node) {
              return new Shape.Circle(getPoint(node, "cx", "cy"), getValue(node, "r"));
            },
            ellipse: function(node) {
              return new Shape.Ellipse({
                center: getPoint(node, "cx", "cy"),
                radius: getSize(node, "rx", "ry")
              });
            },
            rect: function(node) {
              return new Shape.Rectangle(new Rectangle(getPoint(node), getSize(node)), getSize(node, "rx", "ry"));
            },
            line: function(node) {
              return new Path.Line(getPoint(node, "x1", "y1"), getPoint(node, "x2", "y2"));
            },
            text: function(node) {
              var text = new PointText(getPoint(node).add(getPoint(node, "dx", "dy")));
              text.setContent(node.textContent.trim() || "");
              return text;
            },
            switch: importGroup
          };
          function applyTransform(item, value, name, node) {
            if (item.transform) {
              var transforms = (node.getAttribute(name) || "").split(/\)\s*/g), matrix = new Matrix();
              for (var i2 = 0, l2 = transforms.length; i2 < l2; i2++) {
                var transform = transforms[i2];
                if (!transform)
                  break;
                var parts = transform.split(/\(\s*/), command = parts[0], v2 = parts[1].split(/[\s,]+/g);
                for (var j2 = 0, m2 = v2.length; j2 < m2; j2++)
                  v2[j2] = parseFloat(v2[j2]);
                switch (command) {
                  case "matrix":
                    matrix.append(new Matrix(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]));
                    break;
                  case "rotate":
                    matrix.rotate(v2[0], v2[1] || 0, v2[2] || 0);
                    break;
                  case "translate":
                    matrix.translate(v2[0], v2[1] || 0);
                    break;
                  case "scale":
                    matrix.scale(v2);
                    break;
                  case "skewX":
                    matrix.skew(v2[0], 0);
                    break;
                  case "skewY":
                    matrix.skew(0, v2[0]);
                    break;
                }
              }
              item.transform(matrix);
            }
          }
          function applyOpacity(item, value, name) {
            var key = name === "fill-opacity" ? "getFillColor" : "getStrokeColor", color = item[key] && item[key]();
            if (color)
              color.setAlpha(parseFloat(value));
          }
          var attributes = Base.set(Base.each(SvgStyles, function(entry) {
            this[entry.attribute] = function(item, value) {
              if (item[entry.set]) {
                item[entry.set](convertValue(value, entry.type, entry.fromSVG));
                if (entry.type === "color") {
                  var color = item[entry.get]();
                  if (color) {
                    if (color._scaleToBounds) {
                      var bounds = item.getBounds();
                      color.transform(new Matrix().translate(bounds.getPoint()).scale(bounds.getSize()));
                    }
                  }
                }
              }
            };
          }, {}), {
            id: function(item, value) {
              definitions[value] = item;
              if (item.setName)
                item.setName(value);
            },
            "clip-path": function(item, value) {
              var clip = getDefinition(value);
              if (clip) {
                clip = clip.clone();
                clip.setClipMask(true);
                if (item instanceof Group) {
                  item.insertChild(0, clip);
                } else {
                  return new Group(clip, item);
                }
              }
            },
            gradientTransform: applyTransform,
            transform: applyTransform,
            "fill-opacity": applyOpacity,
            "stroke-opacity": applyOpacity,
            visibility: function(item, value) {
              if (item.setVisible)
                item.setVisible(value === "visible");
            },
            display: function(item, value) {
              if (item.setVisible)
                item.setVisible(value !== null);
            },
            "stop-color": function(item, value) {
              if (item.setColor)
                item.setColor(value);
            },
            "stop-opacity": function(item, value) {
              if (item._color)
                item._color.setAlpha(parseFloat(value));
            },
            offset: function(item, value) {
              if (item.setOffset) {
                var percent = value.match(/(.*)%$/);
                item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
              }
            },
            viewBox: function(item, value, name, node, styles) {
              var rect = new Rectangle(convertValue(value, "array")), size = getSize(node, null, null, true), group, matrix;
              if (item instanceof Group) {
                var scale = size ? size.divide(rect.getSize()) : 1, matrix = new Matrix().scale(scale).translate(rect.getPoint().negate());
                group = item;
              } else if (item instanceof SymbolDefinition) {
                if (size)
                  rect.setSize(size);
                group = item._item;
              }
              if (group) {
                if (getAttribute(node, "overflow", styles) !== "visible") {
                  var clip = new Shape.Rectangle(rect);
                  clip.setClipMask(true);
                  group.addChild(clip);
                }
                if (matrix)
                  group.transform(matrix);
              }
            }
          });
          function getAttribute(node, name, styles) {
            var attr = node.attributes[name], value = attr && attr.value;
            if (!value && node.style) {
              var style = Base.camelize(name);
              value = node.style[style];
              if (!value && styles.node[style] !== styles.parent[style])
                value = styles.node[style];
            }
            return !value ? undefined2 : value === "none" ? null : value;
          }
          function applyAttributes(item, node, isRoot) {
            var parent = node.parentNode, styles = {
              node: DomElement.getStyles(node) || {},
              parent: !isRoot && !/^defs$/i.test(parent.tagName) && DomElement.getStyles(parent) || {}
            };
            Base.each(attributes, function(apply, name) {
              var value = getAttribute(node, name, styles);
              item = value !== undefined2 && apply(item, value, name, node, styles) || item;
            });
            return item;
          }
          function getDefinition(value) {
            var match = value && value.match(/\((?:["'#]*)([^"')]+)/), name = match && match[1], res = name && definitions[window2 ? name.replace(window2.location.href.split("#")[0] + "#", "") : name];
            if (res && res._scaleToBounds) {
              res = res.clone();
              res._scaleToBounds = true;
            }
            return res;
          }
          function importNode(node, options, isRoot) {
            var type = node.nodeName.toLowerCase(), isElement = type !== "#document", body = document2.body, container, parent, next;
            if (isRoot && isElement) {
              rootSize = paper2.getView().getSize();
              rootSize = getSize(node, null, null, true) || rootSize;
              container = SvgElement.create("svg", {
                style: "stroke-width: 1px; stroke-miterlimit: 10"
              });
              parent = node.parentNode;
              next = node.nextSibling;
              container.appendChild(node);
              body.appendChild(container);
            }
            var settings = paper2.settings, applyMatrix = settings.applyMatrix, insertItems = settings.insertItems;
            settings.applyMatrix = false;
            settings.insertItems = false;
            var importer = importers[type], item = importer && importer(node, type, options, isRoot) || null;
            settings.insertItems = insertItems;
            settings.applyMatrix = applyMatrix;
            if (item) {
              if (isElement && !(item instanceof Group))
                item = applyAttributes(item, node, isRoot);
              var onImport = options.onImport, data = isElement && node.getAttribute("data-paper-data");
              if (onImport)
                item = onImport(node, item, options) || item;
              if (options.expandShapes && item instanceof Shape) {
                item.remove();
                item = item.toPath();
              }
              if (data)
                item._data = JSON.parse(data);
            }
            if (container) {
              body.removeChild(container);
              if (parent) {
                if (next) {
                  parent.insertBefore(node, next);
                } else {
                  parent.appendChild(node);
                }
              }
            }
            if (isRoot) {
              definitions = {};
              if (item && Base.pick(options.applyMatrix, applyMatrix))
                item.matrix.apply(true, true);
            }
            return item;
          }
          function importSVG(source, options, owner) {
            if (!source)
              return null;
            options = typeof options === "function" ? { onLoad: options } : options || {};
            var scope = paper2, item = null;
            function onLoad(svg) {
              try {
                var node2 = typeof svg === "object" ? svg : new self2.DOMParser().parseFromString(svg.trim(), "image/svg+xml");
                if (!node2.nodeName) {
                  node2 = null;
                  throw new Error("Unsupported SVG source: " + source);
                }
                paper2 = scope;
                item = importNode(node2, options, true);
                if (!options || options.insert !== false) {
                  owner._insertItem(undefined2, item);
                }
                var onLoad2 = options.onLoad;
                if (onLoad2)
                  onLoad2(item, svg);
              } catch (e4) {
                onError(e4);
              }
            }
            function onError(message, status) {
              var onError2 = options.onError;
              if (onError2) {
                onError2(message, status);
              } else {
                throw new Error(message);
              }
            }
            if (typeof source === "string" && !/^[\s\S]*</.test(source)) {
              var node = document2.getElementById(source);
              if (node) {
                onLoad(node);
              } else {
                Http.request({
                  url: source,
                  async: true,
                  onLoad,
                  onError
                });
              }
            } else if (typeof File !== "undefined" && source instanceof File) {
              var reader = new FileReader();
              reader.onload = function() {
                onLoad(reader.result);
              };
              reader.onerror = function() {
                onError(reader.error);
              };
              return reader.readAsText(source);
            } else {
              onLoad(source);
            }
            return item;
          }
          Item.inject({
            importSVG: function(node, options) {
              return importSVG(node, options, this);
            }
          });
          Project.inject({
            importSVG: function(node, options) {
              this.activate();
              return importSVG(node, options, this);
            }
          });
        }();
        Base.exports.PaperScript = function() {
          var global2 = this, acorn = global2.acorn;
          if (!acorn && typeof __require !== "undefined") {
            try {
              acorn = require_acorn();
            } catch (e4) {
            }
          }
          if (!acorn) {
            var exports2, module2;
            acorn = exports2 = module2 = {};
            (function(root, mod) {
              if (typeof exports2 == "object" && typeof module2 == "object")
                return mod(exports2);
              if (typeof define == "function" && define.amd)
                return define(["exports"], mod);
              mod(root.acorn || (root.acorn = {}));
            })(this, function(exports3) {
              "use strict";
              exports3.version = "0.5.0";
              var options, input, inputLen, sourceFile;
              exports3.parse = function(inpt, opts) {
                input = String(inpt);
                inputLen = input.length;
                setOptions(opts);
                initTokenState();
                return parseTopLevel(options.program);
              };
              var defaultOptions = exports3.defaultOptions = {
                ecmaVersion: 5,
                strictSemicolons: false,
                allowTrailingCommas: true,
                forbidReserved: false,
                allowReturnOutsideFunction: false,
                locations: false,
                onComment: null,
                ranges: false,
                program: null,
                sourceFile: null,
                directSourceFile: null
              };
              function setOptions(opts) {
                options = opts || {};
                for (var opt in defaultOptions)
                  if (!Object.prototype.hasOwnProperty.call(options, opt))
                    options[opt] = defaultOptions[opt];
                sourceFile = options.sourceFile || null;
              }
              var getLineInfo = exports3.getLineInfo = function(input2, offset) {
                for (var line = 1, cur = 0; ; ) {
                  lineBreak.lastIndex = cur;
                  var match = lineBreak.exec(input2);
                  if (match && match.index < offset) {
                    ++line;
                    cur = match.index + match[0].length;
                  } else
                    break;
                }
                return { line, column: offset - cur };
              };
              exports3.tokenize = function(inpt, opts) {
                input = String(inpt);
                inputLen = input.length;
                setOptions(opts);
                initTokenState();
                var t2 = {};
                function getToken(forceRegexp) {
                  lastEnd = tokEnd;
                  readToken(forceRegexp);
                  t2.start = tokStart;
                  t2.end = tokEnd;
                  t2.startLoc = tokStartLoc;
                  t2.endLoc = tokEndLoc;
                  t2.type = tokType;
                  t2.value = tokVal;
                  return t2;
                }
                getToken.jumpTo = function(pos, reAllowed) {
                  tokPos = pos;
                  if (options.locations) {
                    tokCurLine = 1;
                    tokLineStart = lineBreak.lastIndex = 0;
                    var match;
                    while ((match = lineBreak.exec(input)) && match.index < pos) {
                      ++tokCurLine;
                      tokLineStart = match.index + match[0].length;
                    }
                  }
                  tokRegexpAllowed = reAllowed;
                  skipSpace();
                };
                return getToken;
              };
              var tokPos;
              var tokStart, tokEnd;
              var tokStartLoc, tokEndLoc;
              var tokType, tokVal;
              var tokRegexpAllowed;
              var tokCurLine, tokLineStart;
              var lastStart, lastEnd, lastEndLoc;
              var inFunction, labels, strict;
              function raise(pos, message) {
                var loc = getLineInfo(input, pos);
                message += " (" + loc.line + ":" + loc.column + ")";
                var err = new SyntaxError(message);
                err.pos = pos;
                err.loc = loc;
                err.raisedAt = tokPos;
                throw err;
              }
              var empty = [];
              var _num = { type: "num" }, _regexp = { type: "regexp" }, _string = { type: "string" };
              var _name = { type: "name" }, _eof = { type: "eof" };
              var _break = { keyword: "break" }, _case = { keyword: "case", beforeExpr: true }, _catch = { keyword: "catch" };
              var _continue = { keyword: "continue" }, _debugger = { keyword: "debugger" }, _default = { keyword: "default" };
              var _do = { keyword: "do", isLoop: true }, _else = { keyword: "else", beforeExpr: true };
              var _finally = { keyword: "finally" }, _for = { keyword: "for", isLoop: true }, _function = { keyword: "function" };
              var _if = { keyword: "if" }, _return = { keyword: "return", beforeExpr: true }, _switch = { keyword: "switch" };
              var _throw = { keyword: "throw", beforeExpr: true }, _try = { keyword: "try" }, _var = { keyword: "var" };
              var _while = { keyword: "while", isLoop: true }, _with = { keyword: "with" }, _new = { keyword: "new", beforeExpr: true };
              var _this = { keyword: "this" };
              var _null = { keyword: "null", atomValue: null }, _true = { keyword: "true", atomValue: true };
              var _false = { keyword: "false", atomValue: false };
              var _in = { keyword: "in", binop: 7, beforeExpr: true };
              var keywordTypes = {
                "break": _break,
                "case": _case,
                "catch": _catch,
                "continue": _continue,
                "debugger": _debugger,
                "default": _default,
                "do": _do,
                "else": _else,
                "finally": _finally,
                "for": _for,
                "function": _function,
                "if": _if,
                "return": _return,
                "switch": _switch,
                "throw": _throw,
                "try": _try,
                "var": _var,
                "while": _while,
                "with": _with,
                "null": _null,
                "true": _true,
                "false": _false,
                "new": _new,
                "in": _in,
                "instanceof": { keyword: "instanceof", binop: 7, beforeExpr: true },
                "this": _this,
                "typeof": { keyword: "typeof", prefix: true, beforeExpr: true },
                "void": { keyword: "void", prefix: true, beforeExpr: true },
                "delete": { keyword: "delete", prefix: true, beforeExpr: true }
              };
              var _bracketL = { type: "[", beforeExpr: true }, _bracketR = { type: "]" }, _braceL = { type: "{", beforeExpr: true };
              var _braceR = { type: "}" }, _parenL = { type: "(", beforeExpr: true }, _parenR = { type: ")" };
              var _comma = { type: ",", beforeExpr: true }, _semi = { type: ";", beforeExpr: true };
              var _colon = { type: ":", beforeExpr: true }, _dot = { type: "." }, _question = { type: "?", beforeExpr: true };
              var _slash = { binop: 10, beforeExpr: true }, _eq = { isAssign: true, beforeExpr: true };
              var _assign = { isAssign: true, beforeExpr: true };
              var _incDec = { postfix: true, prefix: true, isUpdate: true }, _prefix = { prefix: true, beforeExpr: true };
              var _logicalOR = { binop: 1, beforeExpr: true };
              var _logicalAND = { binop: 2, beforeExpr: true };
              var _bitwiseOR = { binop: 3, beforeExpr: true };
              var _bitwiseXOR = { binop: 4, beforeExpr: true };
              var _bitwiseAND = { binop: 5, beforeExpr: true };
              var _equality = { binop: 6, beforeExpr: true };
              var _relational = { binop: 7, beforeExpr: true };
              var _bitShift = { binop: 8, beforeExpr: true };
              var _plusMin = { binop: 9, prefix: true, beforeExpr: true };
              var _multiplyModulo = { binop: 10, beforeExpr: true };
              exports3.tokTypes = {
                bracketL: _bracketL,
                bracketR: _bracketR,
                braceL: _braceL,
                braceR: _braceR,
                parenL: _parenL,
                parenR: _parenR,
                comma: _comma,
                semi: _semi,
                colon: _colon,
                dot: _dot,
                question: _question,
                slash: _slash,
                eq: _eq,
                name: _name,
                eof: _eof,
                num: _num,
                regexp: _regexp,
                string: _string
              };
              for (var kw in keywordTypes)
                exports3.tokTypes["_" + kw] = keywordTypes[kw];
              function makePredicate(words) {
                words = words.split(" ");
                var f = "", cats = [];
                out:
                  for (var i2 = 0; i2 < words.length; ++i2) {
                    for (var j2 = 0; j2 < cats.length; ++j2)
                      if (cats[j2][0].length == words[i2].length) {
                        cats[j2].push(words[i2]);
                        continue out;
                      }
                    cats.push([words[i2]]);
                  }
                function compareTo(arr) {
                  if (arr.length == 1)
                    return f += "return str === " + JSON.stringify(arr[0]) + ";";
                  f += "switch(str){";
                  for (var i3 = 0; i3 < arr.length; ++i3)
                    f += "case " + JSON.stringify(arr[i3]) + ":";
                  f += "return true}return false;";
                }
                if (cats.length > 3) {
                  cats.sort(function(a2, b2) {
                    return b2.length - a2.length;
                  });
                  f += "switch(str.length){";
                  for (var i2 = 0; i2 < cats.length; ++i2) {
                    var cat = cats[i2];
                    f += "case " + cat[0].length + ":";
                    compareTo(cat);
                  }
                  f += "}";
                } else {
                  compareTo(words);
                }
                return new Function("str", f);
              }
              var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
              var isReservedWord5 = makePredicate("class enum extends super const export import");
              var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
              var isStrictBadIdWord = makePredicate("eval arguments");
              var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
              var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
              var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
              var nonASCIIidentifierChars = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u0620-\u0649\u0672-\u06D3\u06E7-\u06E8\u06FB-\u06FC\u0730-\u074A\u0800-\u0814\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0840-\u0857\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09D7\u09DF-\u09E0\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5F-\u0B60\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2-\u0CE3\u0CE6-\u0CEF\u0D02\u0D03\u0D46-\u0D48\u0D57\u0D62-\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E34-\u0E3A\u0E40-\u0E45\u0E50-\u0E59\u0EB4-\u0EB9\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F41-\u0F47\u0F71-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1029\u1040-\u1049\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u170E-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17B2\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1920-\u192B\u1930-\u193B\u1951-\u196D\u19B0-\u19C0\u19C8-\u19C9\u19D0-\u19D9\u1A00-\u1A15\u1A20-\u1A53\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1B46-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C00-\u1C22\u1C40-\u1C49\u1C5B-\u1C7D\u1CD0-\u1CD2\u1D00-\u1DBE\u1E01-\u1F15\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2D81-\u2D96\u2DE0-\u2DFF\u3021-\u3028\u3099\u309A\uA640-\uA66D\uA674-\uA67D\uA69F\uA6F0-\uA6F1\uA7F8-\uA800\uA806\uA80B\uA823-\uA827\uA880-\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8F3-\uA8F7\uA900-\uA909\uA926-\uA92D\uA930-\uA945\uA980-\uA983\uA9B3-\uA9C0\uAA00-\uAA27\uAA40-\uAA41\uAA4C-\uAA4D\uAA50-\uAA59\uAA7B\uAAE0-\uAAE9\uAAF2-\uAAF3\uABC0-\uABE1\uABEC\uABED\uABF0-\uABF9\uFB20-\uFB28\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
              var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
              var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
              var newline = /[\n\r\u2028\u2029]/;
              var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
              var isIdentifierStart = exports3.isIdentifierStart = function(code) {
                if (code < 65)
                  return code === 36;
                if (code < 91)
                  return true;
                if (code < 97)
                  return code === 95;
                if (code < 123)
                  return true;
                return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
              };
              var isIdentifierChar = exports3.isIdentifierChar = function(code) {
                if (code < 48)
                  return code === 36;
                if (code < 58)
                  return true;
                if (code < 65)
                  return false;
                if (code < 91)
                  return true;
                if (code < 97)
                  return code === 95;
                if (code < 123)
                  return true;
                return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
              };
              function line_loc_t() {
                this.line = tokCurLine;
                this.column = tokPos - tokLineStart;
              }
              function initTokenState() {
                tokCurLine = 1;
                tokPos = tokLineStart = 0;
                tokRegexpAllowed = true;
                skipSpace();
              }
              function finishToken(type, val) {
                tokEnd = tokPos;
                if (options.locations)
                  tokEndLoc = new line_loc_t();
                tokType = type;
                skipSpace();
                tokVal = val;
                tokRegexpAllowed = type.beforeExpr;
              }
              function skipBlockComment() {
                var startLoc = options.onComment && options.locations && new line_loc_t();
                var start = tokPos, end = input.indexOf("*/", tokPos += 2);
                if (end === -1)
                  raise(tokPos - 2, "Unterminated comment");
                tokPos = end + 2;
                if (options.locations) {
                  lineBreak.lastIndex = start;
                  var match;
                  while ((match = lineBreak.exec(input)) && match.index < tokPos) {
                    ++tokCurLine;
                    tokLineStart = match.index + match[0].length;
                  }
                }
                if (options.onComment)
                  options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
              }
              function skipLineComment() {
                var start = tokPos;
                var startLoc = options.onComment && options.locations && new line_loc_t();
                var ch2 = input.charCodeAt(tokPos += 2);
                while (tokPos < inputLen && ch2 !== 10 && ch2 !== 13 && ch2 !== 8232 && ch2 !== 8233) {
                  ++tokPos;
                  ch2 = input.charCodeAt(tokPos);
                }
                if (options.onComment)
                  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
              }
              function skipSpace() {
                while (tokPos < inputLen) {
                  var ch2 = input.charCodeAt(tokPos);
                  if (ch2 === 32) {
                    ++tokPos;
                  } else if (ch2 === 13) {
                    ++tokPos;
                    var next2 = input.charCodeAt(tokPos);
                    if (next2 === 10) {
                      ++tokPos;
                    }
                    if (options.locations) {
                      ++tokCurLine;
                      tokLineStart = tokPos;
                    }
                  } else if (ch2 === 10 || ch2 === 8232 || ch2 === 8233) {
                    ++tokPos;
                    if (options.locations) {
                      ++tokCurLine;
                      tokLineStart = tokPos;
                    }
                  } else if (ch2 > 8 && ch2 < 14) {
                    ++tokPos;
                  } else if (ch2 === 47) {
                    var next2 = input.charCodeAt(tokPos + 1);
                    if (next2 === 42) {
                      skipBlockComment();
                    } else if (next2 === 47) {
                      skipLineComment();
                    } else
                      break;
                  } else if (ch2 === 160) {
                    ++tokPos;
                  } else if (ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
                    ++tokPos;
                  } else {
                    break;
                  }
                }
              }
              function readToken_dot() {
                var next2 = input.charCodeAt(tokPos + 1);
                if (next2 >= 48 && next2 <= 57)
                  return readNumber(true);
                ++tokPos;
                return finishToken(_dot);
              }
              function readToken_slash() {
                var next2 = input.charCodeAt(tokPos + 1);
                if (tokRegexpAllowed) {
                  ++tokPos;
                  return readRegexp();
                }
                if (next2 === 61)
                  return finishOp(_assign, 2);
                return finishOp(_slash, 1);
              }
              function readToken_mult_modulo() {
                var next2 = input.charCodeAt(tokPos + 1);
                if (next2 === 61)
                  return finishOp(_assign, 2);
                return finishOp(_multiplyModulo, 1);
              }
              function readToken_pipe_amp(code) {
                var next2 = input.charCodeAt(tokPos + 1);
                if (next2 === code)
                  return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
                if (next2 === 61)
                  return finishOp(_assign, 2);
                return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
              }
              function readToken_caret() {
                var next2 = input.charCodeAt(tokPos + 1);
                if (next2 === 61)
                  return finishOp(_assign, 2);
                return finishOp(_bitwiseXOR, 1);
              }
              function readToken_plus_min(code) {
                var next2 = input.charCodeAt(tokPos + 1);
                if (next2 === code) {
                  if (next2 == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
                    tokPos += 3;
                    skipLineComment();
                    skipSpace();
                    return readToken();
                  }
                  return finishOp(_incDec, 2);
                }
                if (next2 === 61)
                  return finishOp(_assign, 2);
                return finishOp(_plusMin, 1);
              }
              function readToken_lt_gt(code) {
                var next2 = input.charCodeAt(tokPos + 1);
                var size = 1;
                if (next2 === code) {
                  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
                  if (input.charCodeAt(tokPos + size) === 61)
                    return finishOp(_assign, size + 1);
                  return finishOp(_bitShift, size);
                }
                if (next2 == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
                  tokPos += 4;
                  skipLineComment();
                  skipSpace();
                  return readToken();
                }
                if (next2 === 61)
                  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
                return finishOp(_relational, size);
              }
              function readToken_eq_excl(code) {
                var next2 = input.charCodeAt(tokPos + 1);
                if (next2 === 61)
                  return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
                return finishOp(code === 61 ? _eq : _prefix, 1);
              }
              function getTokenFromCode(code) {
                switch (code) {
                  case 46:
                    return readToken_dot();
                  case 40:
                    ++tokPos;
                    return finishToken(_parenL);
                  case 41:
                    ++tokPos;
                    return finishToken(_parenR);
                  case 59:
                    ++tokPos;
                    return finishToken(_semi);
                  case 44:
                    ++tokPos;
                    return finishToken(_comma);
                  case 91:
                    ++tokPos;
                    return finishToken(_bracketL);
                  case 93:
                    ++tokPos;
                    return finishToken(_bracketR);
                  case 123:
                    ++tokPos;
                    return finishToken(_braceL);
                  case 125:
                    ++tokPos;
                    return finishToken(_braceR);
                  case 58:
                    ++tokPos;
                    return finishToken(_colon);
                  case 63:
                    ++tokPos;
                    return finishToken(_question);
                  case 48:
                    var next2 = input.charCodeAt(tokPos + 1);
                    if (next2 === 120 || next2 === 88)
                      return readHexNumber();
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return readNumber(false);
                  case 34:
                  case 39:
                    return readString(code);
                  case 47:
                    return readToken_slash(code);
                  case 37:
                  case 42:
                    return readToken_mult_modulo();
                  case 124:
                  case 38:
                    return readToken_pipe_amp(code);
                  case 94:
                    return readToken_caret();
                  case 43:
                  case 45:
                    return readToken_plus_min(code);
                  case 60:
                  case 62:
                    return readToken_lt_gt(code);
                  case 61:
                  case 33:
                    return readToken_eq_excl(code);
                  case 126:
                    return finishOp(_prefix, 1);
                }
                return false;
              }
              function readToken(forceRegexp) {
                if (!forceRegexp)
                  tokStart = tokPos;
                else
                  tokPos = tokStart + 1;
                if (options.locations)
                  tokStartLoc = new line_loc_t();
                if (forceRegexp)
                  return readRegexp();
                if (tokPos >= inputLen)
                  return finishToken(_eof);
                var code = input.charCodeAt(tokPos);
                if (isIdentifierStart(code) || code === 92)
                  return readWord();
                var tok = getTokenFromCode(code);
                if (tok === false) {
                  var ch2 = String.fromCharCode(code);
                  if (ch2 === "\\" || nonASCIIidentifierStart.test(ch2))
                    return readWord();
                  raise(tokPos, "Unexpected character '" + ch2 + "'");
                }
                return tok;
              }
              function finishOp(type, size) {
                var str = input.slice(tokPos, tokPos + size);
                tokPos += size;
                finishToken(type, str);
              }
              function readRegexp() {
                var content = "", escaped, inClass, start = tokPos;
                for (; ; ) {
                  if (tokPos >= inputLen)
                    raise(start, "Unterminated regular expression");
                  var ch2 = input.charAt(tokPos);
                  if (newline.test(ch2))
                    raise(start, "Unterminated regular expression");
                  if (!escaped) {
                    if (ch2 === "[")
                      inClass = true;
                    else if (ch2 === "]" && inClass)
                      inClass = false;
                    else if (ch2 === "/" && !inClass)
                      break;
                    escaped = ch2 === "\\";
                  } else
                    escaped = false;
                  ++tokPos;
                }
                var content = input.slice(start, tokPos);
                ++tokPos;
                var mods = readWord1();
                if (mods && !/^[gmsiy]*$/.test(mods))
                  raise(start, "Invalid regexp flag");
                try {
                  var value = new RegExp(content, mods);
                } catch (e4) {
                  if (e4 instanceof SyntaxError)
                    raise(start, e4.message);
                  raise(e4);
                }
                return finishToken(_regexp, value);
              }
              function readInt(radix, len) {
                var start = tokPos, total = 0;
                for (var i2 = 0, e4 = len == null ? Infinity : len; i2 < e4; ++i2) {
                  var code = input.charCodeAt(tokPos), val;
                  if (code >= 97)
                    val = code - 97 + 10;
                  else if (code >= 65)
                    val = code - 65 + 10;
                  else if (code >= 48 && code <= 57)
                    val = code - 48;
                  else
                    val = Infinity;
                  if (val >= radix)
                    break;
                  ++tokPos;
                  total = total * radix + val;
                }
                if (tokPos === start || len != null && tokPos - start !== len)
                  return null;
                return total;
              }
              function readHexNumber() {
                tokPos += 2;
                var val = readInt(16);
                if (val == null)
                  raise(tokStart + 2, "Expected hexadecimal number");
                if (isIdentifierStart(input.charCodeAt(tokPos)))
                  raise(tokPos, "Identifier directly after number");
                return finishToken(_num, val);
              }
              function readNumber(startsWithDot) {
                var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
                if (!startsWithDot && readInt(10) === null)
                  raise(start, "Invalid number");
                if (input.charCodeAt(tokPos) === 46) {
                  ++tokPos;
                  readInt(10);
                  isFloat = true;
                }
                var next2 = input.charCodeAt(tokPos);
                if (next2 === 69 || next2 === 101) {
                  next2 = input.charCodeAt(++tokPos);
                  if (next2 === 43 || next2 === 45)
                    ++tokPos;
                  if (readInt(10) === null)
                    raise(start, "Invalid number");
                  isFloat = true;
                }
                if (isIdentifierStart(input.charCodeAt(tokPos)))
                  raise(tokPos, "Identifier directly after number");
                var str = input.slice(start, tokPos), val;
                if (isFloat)
                  val = parseFloat(str);
                else if (!octal || str.length === 1)
                  val = parseInt(str, 10);
                else if (/[89]/.test(str) || strict)
                  raise(start, "Invalid number");
                else
                  val = parseInt(str, 8);
                return finishToken(_num, val);
              }
              function readString(quote) {
                tokPos++;
                var out = "";
                for (; ; ) {
                  if (tokPos >= inputLen)
                    raise(tokStart, "Unterminated string constant");
                  var ch2 = input.charCodeAt(tokPos);
                  if (ch2 === quote) {
                    ++tokPos;
                    return finishToken(_string, out);
                  }
                  if (ch2 === 92) {
                    ch2 = input.charCodeAt(++tokPos);
                    var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
                    if (octal)
                      octal = octal[0];
                    while (octal && parseInt(octal, 8) > 255)
                      octal = octal.slice(0, -1);
                    if (octal === "0")
                      octal = null;
                    ++tokPos;
                    if (octal) {
                      if (strict)
                        raise(tokPos - 2, "Octal literal in strict mode");
                      out += String.fromCharCode(parseInt(octal, 8));
                      tokPos += octal.length - 1;
                    } else {
                      switch (ch2) {
                        case 110:
                          out += "\n";
                          break;
                        case 114:
                          out += "\r";
                          break;
                        case 120:
                          out += String.fromCharCode(readHexChar(2));
                          break;
                        case 117:
                          out += String.fromCharCode(readHexChar(4));
                          break;
                        case 85:
                          out += String.fromCharCode(readHexChar(8));
                          break;
                        case 116:
                          out += "	";
                          break;
                        case 98:
                          out += "\b";
                          break;
                        case 118:
                          out += "\v";
                          break;
                        case 102:
                          out += "\f";
                          break;
                        case 48:
                          out += "\0";
                          break;
                        case 13:
                          if (input.charCodeAt(tokPos) === 10)
                            ++tokPos;
                        case 10:
                          if (options.locations) {
                            tokLineStart = tokPos;
                            ++tokCurLine;
                          }
                          break;
                        default:
                          out += String.fromCharCode(ch2);
                          break;
                      }
                    }
                  } else {
                    if (ch2 === 13 || ch2 === 10 || ch2 === 8232 || ch2 === 8233)
                      raise(tokStart, "Unterminated string constant");
                    out += String.fromCharCode(ch2);
                    ++tokPos;
                  }
                }
              }
              function readHexChar(len) {
                var n2 = readInt(16, len);
                if (n2 === null)
                  raise(tokStart, "Bad character escape sequence");
                return n2;
              }
              var containsEsc;
              function readWord1() {
                containsEsc = false;
                var word, first = true, start = tokPos;
                for (; ; ) {
                  var ch2 = input.charCodeAt(tokPos);
                  if (isIdentifierChar(ch2)) {
                    if (containsEsc)
                      word += input.charAt(tokPos);
                    ++tokPos;
                  } else if (ch2 === 92) {
                    if (!containsEsc)
                      word = input.slice(start, tokPos);
                    containsEsc = true;
                    if (input.charCodeAt(++tokPos) != 117)
                      raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
                    ++tokPos;
                    var esc = readHexChar(4);
                    var escStr = String.fromCharCode(esc);
                    if (!escStr)
                      raise(tokPos - 1, "Invalid Unicode escape");
                    if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
                      raise(tokPos - 4, "Invalid Unicode escape");
                    word += escStr;
                  } else {
                    break;
                  }
                  first = false;
                }
                return containsEsc ? word : input.slice(start, tokPos);
              }
              function readWord() {
                var word = readWord1();
                var type = _name;
                if (!containsEsc && isKeyword(word))
                  type = keywordTypes[word];
                return finishToken(type, word);
              }
              function next() {
                lastStart = tokStart;
                lastEnd = tokEnd;
                lastEndLoc = tokEndLoc;
                readToken();
              }
              function setStrict(strct) {
                strict = strct;
                tokPos = tokStart;
                if (options.locations) {
                  while (tokPos < tokLineStart) {
                    tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
                    --tokCurLine;
                  }
                }
                skipSpace();
                readToken();
              }
              function node_t() {
                this.type = null;
                this.start = tokStart;
                this.end = null;
              }
              function node_loc_t() {
                this.start = tokStartLoc;
                this.end = null;
                if (sourceFile !== null)
                  this.source = sourceFile;
              }
              function startNode() {
                var node = new node_t();
                if (options.locations)
                  node.loc = new node_loc_t();
                if (options.directSourceFile)
                  node.sourceFile = options.directSourceFile;
                if (options.ranges)
                  node.range = [tokStart, 0];
                return node;
              }
              function startNodeFrom(other) {
                var node = new node_t();
                node.start = other.start;
                if (options.locations) {
                  node.loc = new node_loc_t();
                  node.loc.start = other.loc.start;
                }
                if (options.ranges)
                  node.range = [other.range[0], 0];
                return node;
              }
              function finishNode(node, type) {
                node.type = type;
                node.end = lastEnd;
                if (options.locations)
                  node.loc.end = lastEndLoc;
                if (options.ranges)
                  node.range[1] = lastEnd;
                return node;
              }
              function isUseStrict(stmt) {
                return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
              }
              function eat(type) {
                if (tokType === type) {
                  next();
                  return true;
                }
              }
              function canInsertSemicolon() {
                return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
              }
              function semicolon() {
                if (!eat(_semi) && !canInsertSemicolon())
                  unexpected();
              }
              function expect(type) {
                if (tokType === type)
                  next();
                else
                  unexpected();
              }
              function unexpected() {
                raise(tokStart, "Unexpected token");
              }
              function checkLVal(expr) {
                if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
                  raise(expr.start, "Assigning to rvalue");
                if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
                  raise(expr.start, "Assigning to " + expr.name + " in strict mode");
              }
              function parseTopLevel(program) {
                lastStart = lastEnd = tokPos;
                if (options.locations)
                  lastEndLoc = new line_loc_t();
                inFunction = strict = null;
                labels = [];
                readToken();
                var node = program || startNode(), first = true;
                if (!program)
                  node.body = [];
                while (tokType !== _eof) {
                  var stmt = parseStatement();
                  node.body.push(stmt);
                  if (first && isUseStrict(stmt))
                    setStrict(true);
                  first = false;
                }
                return finishNode(node, "Program");
              }
              var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
              function parseStatement() {
                if (tokType === _slash || tokType === _assign && tokVal == "/=")
                  readToken(true);
                var starttype = tokType, node = startNode();
                switch (starttype) {
                  case _break:
                  case _continue:
                    next();
                    var isBreak = starttype === _break;
                    if (eat(_semi) || canInsertSemicolon())
                      node.label = null;
                    else if (tokType !== _name)
                      unexpected();
                    else {
                      node.label = parseIdent();
                      semicolon();
                    }
                    for (var i2 = 0; i2 < labels.length; ++i2) {
                      var lab = labels[i2];
                      if (node.label == null || lab.name === node.label.name) {
                        if (lab.kind != null && (isBreak || lab.kind === "loop"))
                          break;
                        if (node.label && isBreak)
                          break;
                      }
                    }
                    if (i2 === labels.length)
                      raise(node.start, "Unsyntactic " + starttype.keyword);
                    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
                  case _debugger:
                    next();
                    semicolon();
                    return finishNode(node, "DebuggerStatement");
                  case _do:
                    next();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    expect(_while);
                    node.test = parseParenExpression();
                    semicolon();
                    return finishNode(node, "DoWhileStatement");
                  case _for:
                    next();
                    labels.push(loopLabel);
                    expect(_parenL);
                    if (tokType === _semi)
                      return parseFor(node, null);
                    if (tokType === _var) {
                      var init = startNode();
                      next();
                      parseVar(init, true);
                      finishNode(init, "VariableDeclaration");
                      if (init.declarations.length === 1 && eat(_in))
                        return parseForIn(node, init);
                      return parseFor(node, init);
                    }
                    var init = parseExpression(false, true);
                    if (eat(_in)) {
                      checkLVal(init);
                      return parseForIn(node, init);
                    }
                    return parseFor(node, init);
                  case _function:
                    next();
                    return parseFunction(node, true);
                  case _if:
                    next();
                    node.test = parseParenExpression();
                    node.consequent = parseStatement();
                    node.alternate = eat(_else) ? parseStatement() : null;
                    return finishNode(node, "IfStatement");
                  case _return:
                    if (!inFunction && !options.allowReturnOutsideFunction)
                      raise(tokStart, "'return' outside of function");
                    next();
                    if (eat(_semi) || canInsertSemicolon())
                      node.argument = null;
                    else {
                      node.argument = parseExpression();
                      semicolon();
                    }
                    return finishNode(node, "ReturnStatement");
                  case _switch:
                    next();
                    node.discriminant = parseParenExpression();
                    node.cases = [];
                    expect(_braceL);
                    labels.push(switchLabel);
                    for (var cur, sawDefault; tokType != _braceR; ) {
                      if (tokType === _case || tokType === _default) {
                        var isCase = tokType === _case;
                        if (cur)
                          finishNode(cur, "SwitchCase");
                        node.cases.push(cur = startNode());
                        cur.consequent = [];
                        next();
                        if (isCase)
                          cur.test = parseExpression();
                        else {
                          if (sawDefault)
                            raise(lastStart, "Multiple default clauses");
                          sawDefault = true;
                          cur.test = null;
                        }
                        expect(_colon);
                      } else {
                        if (!cur)
                          unexpected();
                        cur.consequent.push(parseStatement());
                      }
                    }
                    if (cur)
                      finishNode(cur, "SwitchCase");
                    next();
                    labels.pop();
                    return finishNode(node, "SwitchStatement");
                  case _throw:
                    next();
                    if (newline.test(input.slice(lastEnd, tokStart)))
                      raise(lastEnd, "Illegal newline after throw");
                    node.argument = parseExpression();
                    semicolon();
                    return finishNode(node, "ThrowStatement");
                  case _try:
                    next();
                    node.block = parseBlock();
                    node.handler = null;
                    if (tokType === _catch) {
                      var clause = startNode();
                      next();
                      expect(_parenL);
                      clause.param = parseIdent();
                      if (strict && isStrictBadIdWord(clause.param.name))
                        raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                      expect(_parenR);
                      clause.guard = null;
                      clause.body = parseBlock();
                      node.handler = finishNode(clause, "CatchClause");
                    }
                    node.guardedHandlers = empty;
                    node.finalizer = eat(_finally) ? parseBlock() : null;
                    if (!node.handler && !node.finalizer)
                      raise(node.start, "Missing catch or finally clause");
                    return finishNode(node, "TryStatement");
                  case _var:
                    next();
                    parseVar(node);
                    semicolon();
                    return finishNode(node, "VariableDeclaration");
                  case _while:
                    next();
                    node.test = parseParenExpression();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    return finishNode(node, "WhileStatement");
                  case _with:
                    if (strict)
                      raise(tokStart, "'with' in strict mode");
                    next();
                    node.object = parseParenExpression();
                    node.body = parseStatement();
                    return finishNode(node, "WithStatement");
                  case _braceL:
                    return parseBlock();
                  case _semi:
                    next();
                    return finishNode(node, "EmptyStatement");
                  default:
                    var maybeName = tokVal, expr = parseExpression();
                    if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                      for (var i2 = 0; i2 < labels.length; ++i2)
                        if (labels[i2].name === maybeName)
                          raise(expr.start, "Label '" + maybeName + "' is already declared");
                      var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                      labels.push({ name: maybeName, kind });
                      node.body = parseStatement();
                      labels.pop();
                      node.label = expr;
                      return finishNode(node, "LabeledStatement");
                    } else {
                      node.expression = expr;
                      semicolon();
                      return finishNode(node, "ExpressionStatement");
                    }
                }
              }
              function parseParenExpression() {
                expect(_parenL);
                var val = parseExpression();
                expect(_parenR);
                return val;
              }
              function parseBlock(allowStrict) {
                var node = startNode(), first = true, strict2 = false, oldStrict;
                node.body = [];
                expect(_braceL);
                while (!eat(_braceR)) {
                  var stmt = parseStatement();
                  node.body.push(stmt);
                  if (first && allowStrict && isUseStrict(stmt)) {
                    oldStrict = strict2;
                    setStrict(strict2 = true);
                  }
                  first = false;
                }
                if (strict2 && !oldStrict)
                  setStrict(false);
                return finishNode(node, "BlockStatement");
              }
              function parseFor(node, init) {
                node.init = init;
                expect(_semi);
                node.test = tokType === _semi ? null : parseExpression();
                expect(_semi);
                node.update = tokType === _parenR ? null : parseExpression();
                expect(_parenR);
                node.body = parseStatement();
                labels.pop();
                return finishNode(node, "ForStatement");
              }
              function parseForIn(node, init) {
                node.left = init;
                node.right = parseExpression();
                expect(_parenR);
                node.body = parseStatement();
                labels.pop();
                return finishNode(node, "ForInStatement");
              }
              function parseVar(node, noIn) {
                node.declarations = [];
                node.kind = "var";
                for (; ; ) {
                  var decl = startNode();
                  decl.id = parseIdent();
                  if (strict && isStrictBadIdWord(decl.id.name))
                    raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
                  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
                  node.declarations.push(finishNode(decl, "VariableDeclarator"));
                  if (!eat(_comma))
                    break;
                }
                return node;
              }
              function parseExpression(noComma, noIn) {
                var expr = parseMaybeAssign(noIn);
                if (!noComma && tokType === _comma) {
                  var node = startNodeFrom(expr);
                  node.expressions = [expr];
                  while (eat(_comma))
                    node.expressions.push(parseMaybeAssign(noIn));
                  return finishNode(node, "SequenceExpression");
                }
                return expr;
              }
              function parseMaybeAssign(noIn) {
                var left = parseMaybeConditional(noIn);
                if (tokType.isAssign) {
                  var node = startNodeFrom(left);
                  node.operator = tokVal;
                  node.left = left;
                  next();
                  node.right = parseMaybeAssign(noIn);
                  checkLVal(left);
                  return finishNode(node, "AssignmentExpression");
                }
                return left;
              }
              function parseMaybeConditional(noIn) {
                var expr = parseExprOps(noIn);
                if (eat(_question)) {
                  var node = startNodeFrom(expr);
                  node.test = expr;
                  node.consequent = parseExpression(true);
                  expect(_colon);
                  node.alternate = parseExpression(true, noIn);
                  return finishNode(node, "ConditionalExpression");
                }
                return expr;
              }
              function parseExprOps(noIn) {
                return parseExprOp(parseMaybeUnary(), -1, noIn);
              }
              function parseExprOp(left, minPrec, noIn) {
                var prec = tokType.binop;
                if (prec != null && (!noIn || tokType !== _in)) {
                  if (prec > minPrec) {
                    var node = startNodeFrom(left);
                    node.left = left;
                    node.operator = tokVal;
                    var op2 = tokType;
                    next();
                    node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
                    var exprNode = finishNode(node, op2 === _logicalOR || op2 === _logicalAND ? "LogicalExpression" : "BinaryExpression");
                    return parseExprOp(exprNode, minPrec, noIn);
                  }
                }
                return left;
              }
              function parseMaybeUnary() {
                if (tokType.prefix) {
                  var node = startNode(), update = tokType.isUpdate;
                  node.operator = tokVal;
                  node.prefix = true;
                  tokRegexpAllowed = true;
                  next();
                  node.argument = parseMaybeUnary();
                  if (update)
                    checkLVal(node.argument);
                  else if (strict && node.operator === "delete" && node.argument.type === "Identifier")
                    raise(node.start, "Deleting local variable in strict mode");
                  return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
                }
                var expr = parseExprSubscripts();
                while (tokType.postfix && !canInsertSemicolon()) {
                  var node = startNodeFrom(expr);
                  node.operator = tokVal;
                  node.prefix = false;
                  node.argument = expr;
                  checkLVal(expr);
                  next();
                  expr = finishNode(node, "UpdateExpression");
                }
                return expr;
              }
              function parseExprSubscripts() {
                return parseSubscripts(parseExprAtom());
              }
              function parseSubscripts(base, noCalls) {
                if (eat(_dot)) {
                  var node = startNodeFrom(base);
                  node.object = base;
                  node.property = parseIdent(true);
                  node.computed = false;
                  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
                } else if (eat(_bracketL)) {
                  var node = startNodeFrom(base);
                  node.object = base;
                  node.property = parseExpression();
                  node.computed = true;
                  expect(_bracketR);
                  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
                } else if (!noCalls && eat(_parenL)) {
                  var node = startNodeFrom(base);
                  node.callee = base;
                  node.arguments = parseExprList(_parenR, false);
                  return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
                } else
                  return base;
              }
              function parseExprAtom() {
                switch (tokType) {
                  case _this:
                    var node = startNode();
                    next();
                    return finishNode(node, "ThisExpression");
                  case _name:
                    return parseIdent();
                  case _num:
                  case _string:
                  case _regexp:
                    var node = startNode();
                    node.value = tokVal;
                    node.raw = input.slice(tokStart, tokEnd);
                    next();
                    return finishNode(node, "Literal");
                  case _null:
                  case _true:
                  case _false:
                    var node = startNode();
                    node.value = tokType.atomValue;
                    node.raw = tokType.keyword;
                    next();
                    return finishNode(node, "Literal");
                  case _parenL:
                    var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
                    next();
                    var val = parseExpression();
                    val.start = tokStart1;
                    val.end = tokEnd;
                    if (options.locations) {
                      val.loc.start = tokStartLoc1;
                      val.loc.end = tokEndLoc;
                    }
                    if (options.ranges)
                      val.range = [tokStart1, tokEnd];
                    expect(_parenR);
                    return val;
                  case _bracketL:
                    var node = startNode();
                    next();
                    node.elements = parseExprList(_bracketR, true, true);
                    return finishNode(node, "ArrayExpression");
                  case _braceL:
                    return parseObj();
                  case _function:
                    var node = startNode();
                    next();
                    return parseFunction(node, false);
                  case _new:
                    return parseNew();
                  default:
                    unexpected();
                }
              }
              function parseNew() {
                var node = startNode();
                next();
                node.callee = parseSubscripts(parseExprAtom(), true);
                if (eat(_parenL))
                  node.arguments = parseExprList(_parenR, false);
                else
                  node.arguments = empty;
                return finishNode(node, "NewExpression");
              }
              function parseObj() {
                var node = startNode(), first = true, sawGetSet = false;
                node.properties = [];
                next();
                while (!eat(_braceR)) {
                  if (!first) {
                    expect(_comma);
                    if (options.allowTrailingCommas && eat(_braceR))
                      break;
                  } else
                    first = false;
                  var prop = { key: parsePropertyName() }, isGetSet = false, kind;
                  if (eat(_colon)) {
                    prop.value = parseExpression(true);
                    kind = prop.kind = "init";
                  } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
                    isGetSet = sawGetSet = true;
                    kind = prop.kind = prop.key.name;
                    prop.key = parsePropertyName();
                    if (tokType !== _parenL)
                      unexpected();
                    prop.value = parseFunction(startNode(), false);
                  } else
                    unexpected();
                  if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
                    for (var i2 = 0; i2 < node.properties.length; ++i2) {
                      var other = node.properties[i2];
                      if (other.key.name === prop.key.name) {
                        var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                        if (conflict && !strict && kind === "init" && other.kind === "init")
                          conflict = false;
                        if (conflict)
                          raise(prop.key.start, "Redefinition of property");
                      }
                    }
                  }
                  node.properties.push(prop);
                }
                return finishNode(node, "ObjectExpression");
              }
              function parsePropertyName() {
                if (tokType === _num || tokType === _string)
                  return parseExprAtom();
                return parseIdent(true);
              }
              function parseFunction(node, isStatement) {
                if (tokType === _name)
                  node.id = parseIdent();
                else if (isStatement)
                  unexpected();
                else
                  node.id = null;
                node.params = [];
                var first = true;
                expect(_parenL);
                while (!eat(_parenR)) {
                  if (!first)
                    expect(_comma);
                  else
                    first = false;
                  node.params.push(parseIdent());
                }
                var oldInFunc = inFunction, oldLabels = labels;
                inFunction = true;
                labels = [];
                node.body = parseBlock(true);
                inFunction = oldInFunc;
                labels = oldLabels;
                if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
                  for (var i2 = node.id ? -1 : 0; i2 < node.params.length; ++i2) {
                    var id2 = i2 < 0 ? node.id : node.params[i2];
                    if (isStrictReservedWord(id2.name) || isStrictBadIdWord(id2.name))
                      raise(id2.start, "Defining '" + id2.name + "' in strict mode");
                    if (i2 >= 0) {
                      for (var j2 = 0; j2 < i2; ++j2)
                        if (id2.name === node.params[j2].name)
                          raise(id2.start, "Argument name clash in strict mode");
                    }
                  }
                }
                return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
              }
              function parseExprList(close, allowTrailingComma, allowEmpty) {
                var elts = [], first = true;
                while (!eat(close)) {
                  if (!first) {
                    expect(_comma);
                    if (allowTrailingComma && options.allowTrailingCommas && eat(close))
                      break;
                  } else
                    first = false;
                  if (allowEmpty && tokType === _comma)
                    elts.push(null);
                  else
                    elts.push(parseExpression(true));
                }
                return elts;
              }
              function parseIdent(liberal) {
                var node = startNode();
                if (liberal && options.forbidReserved == "everywhere")
                  liberal = false;
                if (tokType === _name) {
                  if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf("\\") == -1)
                    raise(tokStart, "The keyword '" + tokVal + "' is reserved");
                  node.name = tokVal;
                } else if (liberal && tokType.keyword) {
                  node.name = tokType.keyword;
                } else {
                  unexpected();
                }
                tokRegexpAllowed = false;
                next();
                return finishNode(node, "Identifier");
              }
            });
            if (!acorn.version)
              acorn = null;
          }
          function parse(code, options) {
            return (global2.acorn || acorn).parse(code, options);
          }
          var binaryOperators = {
            "+": "__add",
            "-": "__subtract",
            "*": "__multiply",
            "/": "__divide",
            "%": "__modulo",
            "==": "__equals",
            "!=": "__equals"
          };
          var unaryOperators = {
            "-": "__negate",
            "+": "__self"
          };
          var fields = Base.each(["add", "subtract", "multiply", "divide", "modulo", "equals", "negate"], function(name) {
            this["__" + name] = "#" + name;
          }, {
            __self: function() {
              return this;
            }
          });
          Point.inject(fields);
          Size.inject(fields);
          Color.inject(fields);
          function __$__(left, operator, right) {
            var handler = binaryOperators[operator];
            if (left && left[handler]) {
              var res = left[handler](right);
              return operator === "!=" ? !res : res;
            }
            switch (operator) {
              case "+":
                return left + right;
              case "-":
                return left - right;
              case "*":
                return left * right;
              case "/":
                return left / right;
              case "%":
                return left % right;
              case "==":
                return left == right;
              case "!=":
                return left != right;
            }
          }
          function $__(operator, value) {
            var handler = unaryOperators[operator];
            if (value && value[handler])
              return value[handler]();
            switch (operator) {
              case "+":
                return +value;
              case "-":
                return -value;
            }
          }
          function compile(code, options) {
            if (!code)
              return "";
            options = options || {};
            var insertions = [];
            function getOffset(offset2) {
              for (var i2 = 0, l2 = insertions.length; i2 < l2; i2++) {
                var insertion = insertions[i2];
                if (insertion[0] >= offset2)
                  break;
                offset2 += insertion[1];
              }
              return offset2;
            }
            function getCode(node) {
              return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
            }
            function getBetween(left, right) {
              return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
            }
            function replaceCode(node, str) {
              var start = getOffset(node.range[0]), end = getOffset(node.range[1]), insert = 0;
              for (var i2 = insertions.length - 1; i2 >= 0; i2--) {
                if (start > insertions[i2][0]) {
                  insert = i2 + 1;
                  break;
                }
              }
              insertions.splice(insert, 0, [start, str.length - end + start]);
              code = code.substring(0, start) + str + code.substring(end);
            }
            function handleOverloading(node, parent) {
              switch (node.type) {
                case "UnaryExpression":
                  if (node.operator in unaryOperators && node.argument.type !== "Literal") {
                    var arg = getCode(node.argument);
                    replaceCode(node, '$__("' + node.operator + '", ' + arg + ")");
                  }
                  break;
                case "BinaryExpression":
                  if (node.operator in binaryOperators && node.left.type !== "Literal") {
                    var left = getCode(node.left), right = getCode(node.right), between = getBetween(node.left, node.right), operator = node.operator;
                    replaceCode(node, "__$__(" + left + "," + between.replace(new RegExp("\\" + operator), '"' + operator + '"') + ", " + right + ")");
                  }
                  break;
                case "UpdateExpression":
                case "AssignmentExpression":
                  var parentType = parent && parent.type;
                  if (!(parentType === "ForStatement" || parentType === "BinaryExpression" && /^[=!<>]/.test(parent.operator) || parentType === "MemberExpression" && parent.computed)) {
                    if (node.type === "UpdateExpression") {
                      var arg = getCode(node.argument), exp = "__$__(" + arg + ', "' + node.operator[0] + '", 1)', str = arg + " = " + exp;
                      if (node.prefix) {
                        str = "(" + str + ")";
                      } else if (parentType === "AssignmentExpression" || parentType === "VariableDeclarator" || parentType === "BinaryExpression") {
                        if (getCode(parent.left || parent.id) === arg)
                          str = exp;
                        str = arg + "; " + str;
                      }
                      replaceCode(node, str);
                    } else {
                      if (/^.=$/.test(node.operator) && node.left.type !== "Literal") {
                        var left = getCode(node.left), right = getCode(node.right), exp = left + " = __$__(" + left + ', "' + node.operator[0] + '", ' + right + ")";
                        replaceCode(node, /^\(.*\)$/.test(getCode(node)) ? "(" + exp + ")" : exp);
                      }
                    }
                  }
                  break;
              }
            }
            function handleExports(node) {
              switch (node.type) {
                case "ExportDefaultDeclaration":
                  replaceCode({
                    range: [node.start, node.declaration.start]
                  }, "module.exports = ");
                  break;
                case "ExportNamedDeclaration":
                  var declaration = node.declaration;
                  var specifiers = node.specifiers;
                  if (declaration) {
                    var declarations = declaration.declarations;
                    if (declarations) {
                      declarations.forEach(function(dec) {
                        replaceCode(dec, "module.exports." + getCode(dec));
                      });
                      replaceCode({
                        range: [
                          node.start,
                          declaration.start + declaration.kind.length
                        ]
                      }, "");
                    }
                  } else if (specifiers) {
                    var exports3 = specifiers.map(function(specifier) {
                      var name = getCode(specifier);
                      return "module.exports." + name + " = " + name + "; ";
                    }).join("");
                    if (exports3) {
                      replaceCode(node, exports3);
                    }
                  }
                  break;
              }
            }
            function walkAST(node, parent, paperFeatures2) {
              if (node) {
                for (var key in node) {
                  if (key !== "range" && key !== "loc") {
                    var value = node[key];
                    if (Array.isArray(value)) {
                      for (var i2 = 0, l2 = value.length; i2 < l2; i2++) {
                        walkAST(value[i2], node, paperFeatures2);
                      }
                    } else if (value && typeof value === "object") {
                      walkAST(value, node, paperFeatures2);
                    }
                  }
                }
                if (paperFeatures2.operatorOverloading !== false) {
                  handleOverloading(node, parent);
                }
                if (paperFeatures2.moduleExports !== false) {
                  handleExports(node);
                }
              }
            }
            function encodeVLQ(value) {
              var res = "", base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);
              while (value || !res) {
                var next = value & 32 - 1;
                value >>= 5;
                if (value)
                  next |= 32;
                res += base64[next];
              }
              return res;
            }
            var url = options.url || "", sourceMaps = options.sourceMaps, paperFeatures = options.paperFeatures || {}, source = options.source || code, offset = options.offset || 0, agent = paper2.agent, version = agent.versionNumber, offsetCode = false, lineBreaks = /\r\n|\n|\r/mg, map;
            if (sourceMaps && (agent.chrome && version >= 30 || agent.webkit && version >= 537.76 || agent.firefox && version >= 23 || agent.node)) {
              if (agent.node) {
                offset -= 2;
              } else if (window2 && url && !window2.location.href.indexOf(url)) {
                var html = document2.getElementsByTagName("html")[0].innerHTML;
                offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
              }
              offsetCode = offset > 0 && !(agent.chrome && version >= 36 || agent.safari && version >= 600 || agent.firefox && version >= 40 || agent.node);
              var mappings = ["AA" + encodeVLQ(offsetCode ? 0 : offset) + "A"];
              mappings.length = (code.match(lineBreaks) || []).length + 1 + (offsetCode ? offset : 0);
              map = {
                version: 3,
                file: url,
                names: [],
                mappings: mappings.join(";AACA"),
                sourceRoot: "",
                sources: [url],
                sourcesContent: [source]
              };
            }
            if (paperFeatures.operatorOverloading !== false || paperFeatures.moduleExports !== false) {
              walkAST(parse(code, {
                ranges: true,
                preserveParens: true,
                sourceType: "module"
              }), null, paperFeatures);
            }
            if (map) {
              if (offsetCode) {
                code = new Array(offset + 1).join("\n") + code;
              }
              if (/^(inline|both)$/.test(sourceMaps)) {
                code += "\n//# sourceMappingURL=data:application/json;base64," + self2.btoa(unescape(encodeURIComponent(JSON.stringify(map))));
              }
              code += "\n//# sourceURL=" + (url || "paperscript");
            }
            return {
              url,
              source,
              code,
              map
            };
          }
          function execute(code, scope, options) {
            paper2 = scope;
            var view = scope.getView(), tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) && !/\bnew\s+Tool\b/.test(code) ? new Tool() : null, toolHandlers = tool ? tool._events : [], handlers = ["onFrame", "onResize"].concat(toolHandlers), params = [], args = [], func, compiled = typeof code === "object" ? code : compile(code, options);
            code = compiled.code;
            function expose(scope2, hidden) {
              for (var key in scope2) {
                if ((hidden || !/^_/.test(key)) && new RegExp("([\\b\\s\\W]|^)" + key.replace(/\$/g, "\\$") + "\\b").test(code)) {
                  params.push(key);
                  args.push(scope2[key]);
                }
              }
            }
            expose({ __$__, $__, paper: scope, tool }, true);
            expose(scope);
            code = "var module = { exports: {} }; " + code;
            var exports3 = Base.each(handlers, function(key) {
              if (new RegExp("\\s+" + key + "\\b").test(code)) {
                params.push(key);
                this.push("module.exports." + key + " = " + key + ";");
              }
            }, []).join("\n");
            if (exports3) {
              code += "\n" + exports3;
            }
            code += "\nreturn module.exports;";
            var agent = paper2.agent;
            if (document2 && (agent.chrome || agent.firefox && agent.versionNumber < 40)) {
              var script = document2.createElement("script"), head = document2.head || document2.getElementsByTagName("head")[0];
              if (agent.firefox)
                code = "\n" + code;
              script.appendChild(document2.createTextNode("document.__paperscript__ = function(" + params + ") {" + code + "\n}"));
              head.appendChild(script);
              func = document2.__paperscript__;
              delete document2.__paperscript__;
              head.removeChild(script);
            } else {
              func = Function(params, code);
            }
            var exports3 = func && func.apply(scope, args);
            var obj = exports3 || {};
            Base.each(toolHandlers, function(key) {
              var value = obj[key];
              if (value)
                tool[key] = value;
            });
            if (view) {
              if (obj.onResize)
                view.setOnResize(obj.onResize);
              view.emit("resize", {
                size: view.size,
                delta: new Point()
              });
              if (obj.onFrame)
                view.setOnFrame(obj.onFrame);
              view.requestUpdate();
            }
            return exports3;
          }
          function loadScript(script) {
            if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, "ignore") !== "true") {
              var canvasId = PaperScope.getAttribute(script, "canvas"), canvas2 = document2.getElementById(canvasId), src = script.src || script.getAttribute("data-src"), async = PaperScope.hasAttribute(script, "async"), scopeAttribute = "data-paper-scope";
              if (!canvas2)
                throw new Error('Unable to find canvas with id "' + canvasId + '"');
              var scope = PaperScope.get(canvas2.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas2);
              canvas2.setAttribute(scopeAttribute, scope._id);
              if (src) {
                Http.request({
                  url: src,
                  async,
                  mimeType: "text/plain",
                  onLoad: function(code) {
                    execute(code, scope, src);
                  }
                });
              } else {
                execute(script.innerHTML, scope, script.baseURI);
              }
              script.setAttribute("data-paper-ignore", "true");
              return scope;
            }
          }
          function loadAll() {
            Base.each(document2 && document2.getElementsByTagName("script"), loadScript);
          }
          function load(script) {
            return script ? loadScript(script) : loadAll();
          }
          if (window2) {
            if (document2.readyState === "complete") {
              setTimeout(loadAll);
            } else {
              DomEvent.add(window2, { load: loadAll });
            }
          }
          return {
            compile,
            execute,
            load,
            parse,
            calculateBinary: __$__,
            calculateUnary: $__
          };
        }.call(this);
        var paper2 = new (PaperScope.inject(Base.exports, {
          Base,
          Numerical,
          Key,
          DomEvent,
          DomElement,
          document: document2,
          window: window2,
          Symbol: SymbolDefinition,
          PlacedSymbol: SymbolItem
        }))();
        if (paper2.agent.node) {
          require_extend()(paper2);
        }
        if (typeof define === "function" && define.amd) {
          define("paper", paper2);
        } else if (typeof module === "object" && module) {
          module.exports = paper2;
        }
        return paper2;
      }.call(exports, typeof self === "object" ? self : null);
    }
  });

  // ../../node_modules/alloyfinger/alloy_finger.js
  var require_alloy_finger = __commonJS({
    "../../node_modules/alloyfinger/alloy_finger.js"(exports, module) {
      (function() {
        function getLen(v2) {
          return Math.sqrt(v2.x * v2.x + v2.y * v2.y);
        }
        function dot(v1, v2) {
          return v1.x * v2.x + v1.y * v2.y;
        }
        function getAngle(v1, v2) {
          var mr2 = getLen(v1) * getLen(v2);
          if (mr2 === 0)
            return 0;
          var r2 = dot(v1, v2) / mr2;
          if (r2 > 1)
            r2 = 1;
          return Math.acos(r2);
        }
        function cross(v1, v2) {
          return v1.x * v2.y - v2.x * v1.y;
        }
        function getRotateAngle(v1, v2) {
          var angle = getAngle(v1, v2);
          if (cross(v1, v2) > 0) {
            angle *= -1;
          }
          return angle * 180 / Math.PI;
        }
        var HandlerAdmin = function(el2) {
          this.handlers = [];
          this.el = el2;
        };
        HandlerAdmin.prototype.add = function(handler) {
          this.handlers.push(handler);
        };
        HandlerAdmin.prototype.del = function(handler) {
          if (!handler)
            this.handlers = [];
          for (var i2 = this.handlers.length; i2 >= 0; i2--) {
            if (this.handlers[i2] === handler) {
              this.handlers.splice(i2, 1);
            }
          }
        };
        HandlerAdmin.prototype.dispatch = function() {
          for (var i2 = 0, len = this.handlers.length; i2 < len; i2++) {
            var handler = this.handlers[i2];
            if (typeof handler === "function")
              handler.apply(this.el, arguments);
          }
        };
        function wrapFunc(el2, handler) {
          var handlerAdmin = new HandlerAdmin(el2);
          handlerAdmin.add(handler);
          return handlerAdmin;
        }
        var AlloyFinger2 = function(el2, option) {
          this.element = typeof el2 == "string" ? document.querySelector(el2) : el2;
          this.start = this.start.bind(this);
          this.move = this.move.bind(this);
          this.end = this.end.bind(this);
          this.cancel = this.cancel.bind(this);
          this.element.addEventListener("touchstart", this.start, false);
          this.element.addEventListener("touchmove", this.move, false);
          this.element.addEventListener("touchend", this.end, false);
          this.element.addEventListener("touchcancel", this.cancel, false);
          this.preV = { x: null, y: null };
          this.pinchStartLen = null;
          this.zoom = 1;
          this.isDoubleTap = false;
          var noop = function() {
          };
          this.rotate = wrapFunc(this.element, option.rotate || noop);
          this.touchStart = wrapFunc(this.element, option.touchStart || noop);
          this.multipointStart = wrapFunc(this.element, option.multipointStart || noop);
          this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop);
          this.pinch = wrapFunc(this.element, option.pinch || noop);
          this.swipe = wrapFunc(this.element, option.swipe || noop);
          this.tap = wrapFunc(this.element, option.tap || noop);
          this.doubleTap = wrapFunc(this.element, option.doubleTap || noop);
          this.longTap = wrapFunc(this.element, option.longTap || noop);
          this.singleTap = wrapFunc(this.element, option.singleTap || noop);
          this.pressMove = wrapFunc(this.element, option.pressMove || noop);
          this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop);
          this.touchMove = wrapFunc(this.element, option.touchMove || noop);
          this.touchEnd = wrapFunc(this.element, option.touchEnd || noop);
          this.touchCancel = wrapFunc(this.element, option.touchCancel || noop);
          this._cancelAllHandler = this.cancelAll.bind(this);
          window.addEventListener("scroll", this._cancelAllHandler);
          this.delta = null;
          this.last = null;
          this.now = null;
          this.tapTimeout = null;
          this.singleTapTimeout = null;
          this.longTapTimeout = null;
          this.swipeTimeout = null;
          this.x1 = this.x2 = this.y1 = this.y2 = null;
          this.preTapPosition = { x: null, y: null };
        };
        AlloyFinger2.prototype = {
          start: function(evt) {
            if (!evt.touches)
              return;
            this.now = Date.now();
            this.x1 = evt.touches[0].pageX;
            this.y1 = evt.touches[0].pageY;
            this.delta = this.now - (this.last || this.now);
            this.touchStart.dispatch(evt, this.element);
            if (this.preTapPosition.x !== null) {
              this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30;
              if (this.isDoubleTap)
                clearTimeout(this.singleTapTimeout);
            }
            this.preTapPosition.x = this.x1;
            this.preTapPosition.y = this.y1;
            this.last = this.now;
            var preV = this.preV, len = evt.touches.length;
            if (len > 1) {
              this._cancelLongTap();
              this._cancelSingleTap();
              var v2 = { x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 };
              preV.x = v2.x;
              preV.y = v2.y;
              this.pinchStartLen = getLen(preV);
              this.multipointStart.dispatch(evt, this.element);
            }
            this._preventTap = false;
            this.longTapTimeout = setTimeout(function() {
              this.longTap.dispatch(evt, this.element);
              this._preventTap = true;
            }.bind(this), 750);
          },
          move: function(evt) {
            if (!evt.touches)
              return;
            var preV = this.preV, len = evt.touches.length, currentX = evt.touches[0].pageX, currentY = evt.touches[0].pageY;
            this.isDoubleTap = false;
            if (len > 1) {
              var sCurrentX = evt.touches[1].pageX, sCurrentY = evt.touches[1].pageY;
              var v2 = { x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY };
              if (preV.x !== null) {
                if (this.pinchStartLen > 0) {
                  evt.zoom = getLen(v2) / this.pinchStartLen;
                  this.pinch.dispatch(evt, this.element);
                }
                evt.angle = getRotateAngle(v2, preV);
                this.rotate.dispatch(evt, this.element);
              }
              preV.x = v2.x;
              preV.y = v2.y;
              if (this.x2 !== null && this.sx2 !== null) {
                evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;
                evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;
              } else {
                evt.deltaX = 0;
                evt.deltaY = 0;
              }
              this.twoFingerPressMove.dispatch(evt, this.element);
              this.sx2 = sCurrentX;
              this.sy2 = sCurrentY;
            } else {
              if (this.x2 !== null) {
                evt.deltaX = currentX - this.x2;
                evt.deltaY = currentY - this.y2;
                var movedX = Math.abs(this.x1 - this.x2), movedY = Math.abs(this.y1 - this.y2);
                if (movedX > 10 || movedY > 10) {
                  this._preventTap = true;
                }
              } else {
                evt.deltaX = 0;
                evt.deltaY = 0;
              }
              this.pressMove.dispatch(evt, this.element);
            }
            this.touchMove.dispatch(evt, this.element);
            this._cancelLongTap();
            this.x2 = currentX;
            this.y2 = currentY;
            if (len > 1) {
              evt.preventDefault();
            }
          },
          end: function(evt) {
            if (!evt.changedTouches)
              return;
            this._cancelLongTap();
            var self2 = this;
            if (evt.touches.length < 2) {
              this.multipointEnd.dispatch(evt, this.element);
              this.sx2 = this.sy2 = null;
            }
            if (this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.y1 - this.y2) > 30) {
              evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);
              this.swipeTimeout = setTimeout(function() {
                self2.swipe.dispatch(evt, self2.element);
              }, 0);
            } else {
              this.tapTimeout = setTimeout(function() {
                if (!self2._preventTap) {
                  self2.tap.dispatch(evt, self2.element);
                }
                if (self2.isDoubleTap) {
                  self2.doubleTap.dispatch(evt, self2.element);
                  self2.isDoubleTap = false;
                }
              }, 0);
              if (!self2.isDoubleTap) {
                self2.singleTapTimeout = setTimeout(function() {
                  self2.singleTap.dispatch(evt, self2.element);
                }, 250);
              }
            }
            this.touchEnd.dispatch(evt, this.element);
            this.preV.x = 0;
            this.preV.y = 0;
            this.zoom = 1;
            this.pinchStartLen = null;
            this.x1 = this.x2 = this.y1 = this.y2 = null;
          },
          cancelAll: function() {
            this._preventTap = true;
            clearTimeout(this.singleTapTimeout);
            clearTimeout(this.tapTimeout);
            clearTimeout(this.longTapTimeout);
            clearTimeout(this.swipeTimeout);
          },
          cancel: function(evt) {
            this.cancelAll();
            this.touchCancel.dispatch(evt, this.element);
          },
          _cancelLongTap: function() {
            clearTimeout(this.longTapTimeout);
          },
          _cancelSingleTap: function() {
            clearTimeout(this.singleTapTimeout);
          },
          _swipeDirection: function(x1, x2, y1, y2) {
            return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? "Left" : "Right" : y1 - y2 > 0 ? "Up" : "Down";
          },
          on: function(evt, handler) {
            if (this[evt]) {
              this[evt].add(handler);
            }
          },
          off: function(evt, handler) {
            if (this[evt]) {
              this[evt].del(handler);
            }
          },
          destroy: function() {
            if (this.singleTapTimeout)
              clearTimeout(this.singleTapTimeout);
            if (this.tapTimeout)
              clearTimeout(this.tapTimeout);
            if (this.longTapTimeout)
              clearTimeout(this.longTapTimeout);
            if (this.swipeTimeout)
              clearTimeout(this.swipeTimeout);
            this.element.removeEventListener("touchstart", this.start);
            this.element.removeEventListener("touchmove", this.move);
            this.element.removeEventListener("touchend", this.end);
            this.element.removeEventListener("touchcancel", this.cancel);
            this.rotate.del();
            this.touchStart.del();
            this.multipointStart.del();
            this.multipointEnd.del();
            this.pinch.del();
            this.swipe.del();
            this.tap.del();
            this.doubleTap.del();
            this.longTap.del();
            this.singleTap.del();
            this.pressMove.del();
            this.twoFingerPressMove.del();
            this.touchMove.del();
            this.touchEnd.del();
            this.touchCancel.del();
            this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;
            window.removeEventListener("scroll", this._cancelAllHandler);
            return null;
          }
        };
        if (typeof module !== "undefined" && typeof exports === "object") {
          module.exports = AlloyFinger2;
        } else {
          window.AlloyFinger = AlloyFinger2;
        }
      })();
    }
  });

  // external/artificer.min.mjs
  var import_three = __toESM(require_three(), 1);
  var u = class {
    constructor(e4, t2) {
      Object.assign(this, {}, t2), this.name = e4;
    }
    useTool(e4) {
      return e4.bind(this)();
    }
  };
  var c = class {
    constructor() {
      this.pantheon = {};
    }
    assignGod(e4) {
      e4.world = this, this.pantheon[e4.name] = { act: (t2) => {
        e4.world = this, t2(e4);
      }, god: e4 };
    }
  };
  function h(e4) {
    return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
  }
  function m(e4) {
    if (e4.__esModule)
      return e4;
    var t2 = Object.defineProperty({}, "__esModule", { value: true });
    return Object.keys(e4).forEach(function(n2) {
      var r2 = Object.getOwnPropertyDescriptor(e4, n2);
      Object.defineProperty(t2, n2, r2.get ? r2 : { enumerable: true, get: function() {
        return e4[n2];
      } });
    }), t2;
  }
  var v = {};
  var g = {};
  var y = Array.isArray;
  var b = typeof global == "object" && global && global.Object === Object && global;
  var w = typeof self == "object" && self && self.Object === Object && self;
  var k = b || w || Function("return this")();
  var x = k.Symbol;
  var S = Object.prototype;
  var _ = S.hasOwnProperty;
  var E = S.toString;
  var P = x ? x.toStringTag : void 0;
  var C = Object.prototype.toString;
  var j = x ? x.toStringTag : void 0;
  function O(e4) {
    return e4 == null ? e4 === void 0 ? "[object Undefined]" : "[object Null]" : j && j in Object(e4) ? function(e5) {
      var t2 = _.call(e5, P), n2 = e5[P];
      try {
        e5[P] = void 0;
        var r2 = true;
      } catch (e6) {
      }
      var o2 = E.call(e5);
      return r2 && (t2 ? e5[P] = n2 : delete e5[P]), o2;
    }(e4) : function(e5) {
      return C.call(e5);
    }(e4);
  }
  function T(e4) {
    return e4 != null && typeof e4 == "object";
  }
  function I(e4) {
    return typeof e4 == "symbol" || T(e4) && O(e4) == "[object Symbol]";
  }
  var D = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var R = /^\w*$/;
  function N(e4) {
    var t2 = typeof e4;
    return e4 != null && (t2 == "object" || t2 == "function");
  }
  var A;
  var z = k["__core-js_shared__"];
  var M = (A = /[^.]+$/.exec(z && z.keys && z.keys.IE_PROTO || "")) ? "Symbol(src)_1." + A : "";
  var L = Function.prototype.toString;
  var F = /^\[object .+?Constructor\]$/;
  var $ = Function.prototype;
  var B = Object.prototype;
  var V = $.toString;
  var U = B.hasOwnProperty;
  var H = RegExp("^" + V.call(U).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function W(e4) {
    if (!N(e4) || (t2 = e4, M && M in t2))
      return false;
    var t2, n2 = function(e5) {
      if (!N(e5))
        return false;
      var t3 = O(e5);
      return t3 == "[object Function]" || t3 == "[object GeneratorFunction]" || t3 == "[object AsyncFunction]" || t3 == "[object Proxy]";
    }(e4) ? H : F;
    return n2.test(function(e5) {
      if (e5 != null) {
        try {
          return L.call(e5);
        } catch (e6) {
        }
        try {
          return e5 + "";
        } catch (e6) {
        }
      }
      return "";
    }(e4));
  }
  function q(e4, t2) {
    var n2 = function(e5, t3) {
      return e5 == null ? void 0 : e5[t3];
    }(e4, t2);
    return W(n2) ? n2 : void 0;
  }
  var K = q(Object, "create");
  var Y = Object.prototype.hasOwnProperty;
  var X = Object.prototype.hasOwnProperty;
  function G(e4) {
    var t2 = -1, n2 = e4 == null ? 0 : e4.length;
    for (this.clear(); ++t2 < n2; ) {
      var r2 = e4[t2];
      this.set(r2[0], r2[1]);
    }
  }
  function Q(e4, t2) {
    for (var n2, r2, o2 = e4.length; o2--; )
      if ((n2 = e4[o2][0]) === (r2 = t2) || n2 != n2 && r2 != r2)
        return o2;
    return -1;
  }
  G.prototype.clear = function() {
    this.__data__ = K ? K(null) : {}, this.size = 0;
  }, G.prototype.delete = function(e4) {
    var t2 = this.has(e4) && delete this.__data__[e4];
    return this.size -= t2 ? 1 : 0, t2;
  }, G.prototype.get = function(e4) {
    var t2 = this.__data__;
    if (K) {
      var n2 = t2[e4];
      return n2 === "__lodash_hash_undefined__" ? void 0 : n2;
    }
    return Y.call(t2, e4) ? t2[e4] : void 0;
  }, G.prototype.has = function(e4) {
    var t2 = this.__data__;
    return K ? t2[e4] !== void 0 : X.call(t2, e4);
  }, G.prototype.set = function(e4, t2) {
    var n2 = this.__data__;
    return this.size += this.has(e4) ? 0 : 1, n2[e4] = K && t2 === void 0 ? "__lodash_hash_undefined__" : t2, this;
  };
  var J = Array.prototype.splice;
  function Z(e4) {
    var t2 = -1, n2 = e4 == null ? 0 : e4.length;
    for (this.clear(); ++t2 < n2; ) {
      var r2 = e4[t2];
      this.set(r2[0], r2[1]);
    }
  }
  Z.prototype.clear = function() {
    this.__data__ = [], this.size = 0;
  }, Z.prototype.delete = function(e4) {
    var t2 = this.__data__, n2 = Q(t2, e4);
    return !(n2 < 0) && (n2 == t2.length - 1 ? t2.pop() : J.call(t2, n2, 1), --this.size, true);
  }, Z.prototype.get = function(e4) {
    var t2 = this.__data__, n2 = Q(t2, e4);
    return n2 < 0 ? void 0 : t2[n2][1];
  }, Z.prototype.has = function(e4) {
    return Q(this.__data__, e4) > -1;
  }, Z.prototype.set = function(e4, t2) {
    var n2 = this.__data__, r2 = Q(n2, e4);
    return r2 < 0 ? (++this.size, n2.push([e4, t2])) : n2[r2][1] = t2, this;
  };
  var ee = q(k, "Map");
  function te(e4, t2) {
    var n2, r2, o2 = e4.__data__;
    return ((r2 = typeof (n2 = t2)) == "string" || r2 == "number" || r2 == "symbol" || r2 == "boolean" ? n2 !== "__proto__" : n2 === null) ? o2[typeof t2 == "string" ? "string" : "hash"] : o2.map;
  }
  function ne(e4) {
    var t2 = -1, n2 = e4 == null ? 0 : e4.length;
    for (this.clear(); ++t2 < n2; ) {
      var r2 = e4[t2];
      this.set(r2[0], r2[1]);
    }
  }
  ne.prototype.clear = function() {
    this.size = 0, this.__data__ = { hash: new G(), map: new (ee || Z)(), string: new G() };
  }, ne.prototype.delete = function(e4) {
    var t2 = te(this, e4).delete(e4);
    return this.size -= t2 ? 1 : 0, t2;
  }, ne.prototype.get = function(e4) {
    return te(this, e4).get(e4);
  }, ne.prototype.has = function(e4) {
    return te(this, e4).has(e4);
  }, ne.prototype.set = function(e4, t2) {
    var n2 = te(this, e4), r2 = n2.size;
    return n2.set(e4, t2), this.size += n2.size == r2 ? 0 : 1, this;
  };
  function re(e4, t2) {
    if (typeof e4 != "function" || t2 != null && typeof t2 != "function")
      throw new TypeError("Expected a function");
    var n2 = function() {
      var r2 = arguments, o2 = t2 ? t2.apply(this, r2) : r2[0], a2 = n2.cache;
      if (a2.has(o2))
        return a2.get(o2);
      var i2 = e4.apply(this, r2);
      return n2.cache = a2.set(o2, i2) || a2, i2;
    };
    return n2.cache = new (re.Cache || ne)(), n2;
  }
  re.Cache = ne;
  var oe;
  var ae;
  var ie;
  var se = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var le = /\\(\\)?/g;
  var ue = (oe = function(e4) {
    var t2 = [];
    return e4.charCodeAt(0) === 46 && t2.push(""), e4.replace(se, function(e5, n2, r2, o2) {
      t2.push(r2 ? o2.replace(le, "$1") : n2 || e5);
    }), t2;
  }, ae = re(oe, function(e4) {
    return ie.size === 500 && ie.clear(), e4;
  }), ie = ae.cache, ae);
  var ce = ue;
  var de = x ? x.prototype : void 0;
  var fe = de ? de.toString : void 0;
  function pe(e4) {
    if (typeof e4 == "string")
      return e4;
    if (y(e4))
      return function(e5, t3) {
        for (var n2 = -1, r2 = e5 == null ? 0 : e5.length, o2 = Array(r2); ++n2 < r2; )
          o2[n2] = t3(e5[n2], n2, e5);
        return o2;
      }(e4, pe) + "";
    if (I(e4))
      return fe ? fe.call(e4) : "";
    var t2 = e4 + "";
    return t2 == "0" && 1 / e4 == -Infinity ? "-0" : t2;
  }
  function he(e4, t2) {
    return y(e4) ? e4 : function(e5, t3) {
      if (y(e5))
        return false;
      var n2 = typeof e5;
      return !(n2 != "number" && n2 != "symbol" && n2 != "boolean" && e5 != null && !I(e5)) || R.test(e5) || !D.test(e5) || t3 != null && e5 in Object(t3);
    }(e4, t2) ? [e4] : ce(function(e5) {
      return e5 == null ? "" : pe(e5);
    }(e4));
  }
  function me(e4) {
    if (typeof e4 == "string" || I(e4))
      return e4;
    var t2 = e4 + "";
    return t2 == "0" && 1 / e4 == -Infinity ? "-0" : t2;
  }
  var ve = Object.freeze({ __proto__: null, default: function(e4, t2, n2) {
    var r2 = e4 == null ? void 0 : function(e5, t3) {
      for (var n3 = 0, r3 = (t3 = he(t3, e5)).length; e5 != null && n3 < r3; )
        e5 = e5[me(t3[n3++])];
      return n3 && n3 == r3 ? e5 : void 0;
    }(e4, t2);
    return r2 === void 0 ? n2 : r2;
  } });
  var ge = m(ve);
  var ye = function(e4, t2) {
    return function(n2) {
      return e4(t2(n2));
    };
  }(Object.getPrototypeOf, Object);
  var be = ye;
  var we = Function.prototype;
  var ke = Object.prototype;
  var xe = we.toString;
  var Se = ke.hasOwnProperty;
  var _e = xe.call(Object);
  var Ee = m(Object.freeze({ __proto__: null, default: function(e4) {
    if (!T(e4) || O(e4) != "[object Object]")
      return false;
    var t2 = be(e4);
    if (t2 === null)
      return true;
    var n2 = Se.call(t2, "constructor") && t2.constructor;
    return typeof n2 == "function" && n2 instanceof n2 && xe.call(n2) == _e;
  } }));
  var Pe = m(Object.freeze({ __proto__: null, default: function(e4) {
    var t2 = e4 == null ? 0 : e4.length;
    return t2 ? e4[t2 - 1] : void 0;
  } }));
  !function(e4) {
    var t2 = Object.create, n2 = Object.defineProperty, r2 = Object.defineProperties, o2 = Object.getOwnPropertyDescriptor, a2 = Object.getOwnPropertyDescriptors, i2 = Object.getOwnPropertyNames, s2 = Object.getOwnPropertySymbols, l2 = Object.getPrototypeOf, u2 = Object.prototype.hasOwnProperty, c2 = Object.prototype.propertyIsEnumerable, d = (e5, t3, r3) => t3 in e5 ? n2(e5, t3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e5[t3] = r3, f = (e5) => n2(e5, "__esModule", { value: true }), p = (e5) => ((e6, t3, r3) => {
      if (t3 && typeof t3 == "object" || typeof t3 == "function")
        for (let a3 of i2(t3))
          u2.call(e6, a3) || a3 === "default" || n2(e6, a3, { get: () => t3[a3], enumerable: !(r3 = o2(t3, a3)) || r3.enumerable });
      return e6;
    })(f(n2(e5 != null ? t2(l2(e5)) : {}, "default", e5 && e5.__esModule && "default" in e5 ? { get: () => e5.default, enumerable: true } : { value: e5, enumerable: true })), e5);
    ((e5, t3) => {
      for (var r3 in f(e5), t3)
        n2(e5, r3, { get: t3[r3], enumerable: true });
    })(e4, { AbstractDerivation: () => R2, Atom: () => J2, Box: () => ne2, ConstantDerivation: () => re2, DerivationFromSource: () => A2, PointerProxy: () => ke2, Ticker: () => ae2, getPointerParts: () => B2, isDerivation: () => w2, isPointer: () => H2, iterateAndCountTicks: () => oe2, iterateOver: () => ie2, pointer: () => U2, prism: () => we2, val: () => te2, valueDerivation: () => ee2 });
    var h2, m2, v2 = p(ge), g2 = p(Ee), y2 = p(Pe), b2 = class {
      constructor() {
        this._lastTapperId = 0, this._tappers = /* @__PURE__ */ new Map(), this.tappable = new class {
          constructor(e5) {
            this._untapFromSourceTimeout = null, this._cb = (e6) => {
              this._tappers.forEach((t3) => {
                t3(e6);
              });
            }, this._lastTapperId = 0, this._untapFromSource = null, this._props = e5, this._tappers = /* @__PURE__ */ new Map();
          }
          _check() {
            this._untapFromSource ? this._tappers.size === 0 && this._scheduleToUntapFromSource() : this._tappers.size !== 0 && (this._untapFromSource = this._props.tapToSource(this._cb));
          }
          _scheduleToUntapFromSource() {
            this._untapFromSourceTimeout === null && (this._untapFromSourceTimeout = setTimeout(() => {
              this._untapFromSourceTimeout = null, this._tappers.size === 0 && (this._untapFromSource(), this._untapFromSource = null);
            }, 0));
          }
          tap(e5) {
            const t3 = this._lastTapperId++;
            return this._tappers.set(t3, e5), this._check(), () => {
              this._removeTapperById(t3);
            };
          }
          _removeTapperById(e5) {
            this._tappers.delete(e5), this._check();
          }
        }({ tapToSource: (e5) => this._tap(e5) });
      }
      _tap(e5) {
        const t3 = this._lastTapperId++;
        return this._tappers.set(t3, e5), this._onNumberOfTappersChangeListener && this._onNumberOfTappersChangeListener(this._tappers.size), () => {
          this._removeTapperById(t3);
        };
      }
      _removeTapperById(e5) {
        const t3 = this._tappers.size;
        this._tappers.delete(e5);
        t3 !== this._tappers.size && this._onNumberOfTappersChangeListener && this._onNumberOfTappersChangeListener(this._tappers.size);
      }
      emit(e5) {
        this._tappers.forEach((t3) => {
          t3(e5);
        });
      }
      hasTappers() {
        return this._tappers.size !== 0;
      }
      onNumberOfTappersChange(e5) {
        this._onNumberOfTappersChangeListener = e5;
      }
    };
    function w2(e5) {
      return e5 && e5.isDerivation && e5.isDerivation === true;
    }
    (m2 = h2 || (h2 = {}))[m2.none = 0] = "none", m2[m2.dep = 1] = "dep", m2[m2.inner = 2] = "inner";
    var k2 = () => {
      class e5 extends R2 {
        constructor(e6, t3) {
          return super(), this._depDerivation = e6, this._fn = t3, this._innerDerivation = void 0, this._staleDependency = 1, this._addDependency(e6), this;
        }
        _recalculateHot() {
          const e6 = this._staleDependency;
          if (this._staleDependency = 0, e6 === 2)
            return this._innerDerivation.getValue();
          const t3 = this._fn(this._depDerivation.getValue());
          return w2(t3) ? (this._innerDerivation = t3, this._addDependency(t3), t3.getValue()) : t3;
        }
        _recalculateCold() {
          const e6 = this._fn(this._depDerivation.getValue());
          return w2(e6) ? e6.getValue() : e6;
        }
        _recalculate() {
          return this.isHot ? this._recalculateHot() : this._recalculateCold();
        }
        _reactToDependencyBecomingStale(e6) {
          const t3 = e6 === this._depDerivation ? 1 : 2;
          if (t3 === 2 && e6 !== this._innerDerivation)
            throw Error("got a _reactToDependencyBecomingStale() from neither the dep nor the inner derivation");
          this._staleDependency === 0 ? (this._staleDependency = t3, t3 === 1 && this._removeInnerDerivation()) : this._staleDependency === 1 || t3 === 1 && (this._staleDependency = 1, this._removeInnerDerivation());
        }
        _removeInnerDerivation() {
          this._innerDerivation && (this._removeDependency(this._innerDerivation), this._innerDerivation = void 0);
        }
        _keepHot() {
          this._staleDependency = 1, this.getValue();
        }
        _becomeCold() {
          this._staleDependency = 1, this._removeInnerDerivation();
        }
      }
      return e5.displayName = "flatMap", e5;
    }, x2 = void 0;
    var S2 = () => class extends R2 {
      constructor(e5, t3) {
        super(), this._dep = e5, this._fn = t3, this._addDependency(e5);
      }
      _recalculate() {
        return this._fn(this._dep.getValue());
      }
      _reactToDependencyBecomingStale() {
      }
    }, _2 = void 0;
    var E2 = class {
      constructor() {
        this._head = void 0;
      }
      peek() {
        return this._head && this._head.data;
      }
      pop() {
        const e5 = this._head;
        if (e5)
          return this._head = e5.next, e5.data;
      }
      push(e5) {
        const t3 = { next: this._head, data: e5 };
        this._head = t3;
      }
    };
    function P2() {
      const e5 = new E2(), t3 = () => {
      };
      return { type: "Dataverse_discoveryMechanism", startIgnoringDependencies: () => {
        e5.push(t3);
      }, stopIgnoringDependencies: () => {
        e5.peek() !== t3 ? console.warn("This should never happen") : e5.pop();
      }, reportResolutionStart: (n3) => {
        const r3 = e5.peek();
        r3 && r3(n3), e5.push(t3);
      }, reportResolutionEnd: (t4) => {
        e5.pop();
      }, pushCollector: (t4) => {
        e5.push(t4);
      }, popCollector: (t4) => {
        if (e5.peek() !== t4)
          throw new Error("Popped collector is not on top of the stack");
        e5.pop();
      } };
    }
    var { startIgnoringDependencies: C2, stopIgnoringDependencies: j2, reportResolutionEnd: O2, reportResolutionStart: T2, pushCollector: I2, popCollector: D2 } = function() {
      const e5 = "__dataverse_discoveryMechanism_sharedStack";
      if (window) {
        const t3 = window[e5];
        if (t3 && typeof t3 == "object" && t3.type === "Dataverse_discoveryMechanism")
          return t3;
        {
          const t4 = P2();
          return window[e5] = t4, t4;
        }
      }
      return P2();
    }(), R2 = class {
      constructor() {
        this.isDerivation = true, this._didMarkDependentsAsStale = false, this._isHot = false, this._isFresh = false, this._lastValue = void 0, this._dependents = /* @__PURE__ */ new Set(), this._dependencies = /* @__PURE__ */ new Set(), this._internal_markAsStale = (e5) => {
          this._reactToDependencyBecomingStale(e5), this._didMarkDependentsAsStale || (this._didMarkDependentsAsStale = true, this._isFresh = false, this._dependents.forEach((e6) => {
            e6(this);
          }));
        };
      }
      get isHot() {
        return this._isHot;
      }
      _addDependency(e5) {
        this._dependencies.has(e5) || (this._dependencies.add(e5), this._isHot && e5.addDependent(this._internal_markAsStale));
      }
      _removeDependency(e5) {
        this._dependencies.has(e5) && (this._dependencies.delete(e5), this._isHot && e5.removeDependent(this._internal_markAsStale));
      }
      changes(e5) {
        return new class {
          constructor(e6, t3) {
            return this._possiblyMarkAsStale = () => {
              this._ticker.onThisOrNextTick(this._refresh);
            }, this._refresh = () => {
              const e7 = this._derivation.getValue();
              e7 === this._lastValue && this._lastValueRecorded === true || (this._lastValue = e7, this._lastValueRecorded = true, this._emitter.emit(e7));
            }, this._derivation = e6, this._ticker = t3, this._emitter = new b2(), this._emitter.onNumberOfTappersChange(() => {
              this._reactToNumberOfTappersChange();
            }), this._hadTappers = false, this._lastValueRecorded = false, this._lastValue = void 0, this;
          }
          _reactToNumberOfTappersChange() {
            const e6 = this._emitter.hasTappers();
            e6 !== this._hadTappers && (this._hadTappers = e6, e6 ? this._derivation.addDependent(this._possiblyMarkAsStale) : this._derivation.removeDependent(this._possiblyMarkAsStale));
          }
          tappable() {
            return this._emitter.tappable;
          }
        }(this, e5).tappable();
      }
      changesWithoutValues() {
        return new class {
          constructor(e5, t3 = false) {
            return this.dontEmitValues = t3, this._possiblyMarkAsStale = () => {
              this._emitter.emit(void 0);
            }, this._derivation = e5, this._emitter = new b2(), this._emitter.onNumberOfTappersChange(() => {
              this._reactToNumberOfTappersChange();
            }), this._hadTappers = false, this;
          }
          _reactToNumberOfTappersChange() {
            const e5 = this._emitter.hasTappers();
            e5 !== this._hadTappers && (this._hadTappers = e5, e5 ? this._derivation.addDependent(this._possiblyMarkAsStale) : this._derivation.removeDependent(this._possiblyMarkAsStale));
          }
          tappable() {
            return this._emitter.tappable;
          }
        }(this).tappable();
      }
      keepHot() {
        return this.changesWithoutValues().tap(() => {
        });
      }
      tapImmediate(e5, t3) {
        const n3 = this.changes(e5).tap(t3);
        return t3(this.getValue()), n3;
      }
      addDependent(e5) {
        const t3 = this._dependents.size > 0;
        this._dependents.add(e5);
        t3 !== this._dependents.size > 0 && this._reactToNumberOfDependentsChange();
      }
      removeDependent(e5) {
        const t3 = this._dependents.size > 0;
        this._dependents.delete(e5);
        t3 !== this._dependents.size > 0 && this._reactToNumberOfDependentsChange();
      }
      _markAsStale(e5) {
        this._internal_markAsStale(e5);
      }
      getValue() {
        if (T2(this), !this._isFresh) {
          const e5 = this._recalculate();
          this._lastValue = e5, this._isHot && (this._isFresh = true, this._didMarkDependentsAsStale = false);
        }
        return O2(this), this._lastValue;
      }
      _reactToNumberOfDependentsChange() {
        const e5 = this._dependents.size > 0;
        e5 !== this._isHot && (this._isHot = e5, this._didMarkDependentsAsStale = false, this._isFresh = false, e5 ? (this._dependencies.forEach((e6) => {
          e6.addDependent(this._internal_markAsStale);
        }), this._keepHot()) : (this._dependencies.forEach((e6) => {
          e6.removeDependent(this._internal_markAsStale);
        }), this._becomeCold()));
      }
      _keepHot() {
      }
      _becomeCold() {
      }
      map(e5) {
        return function(e6, t3) {
          return _2 || (_2 = S2()), new _2(e6, t3);
        }(this, e5);
      }
      flatMap(e5) {
        return function(e6, t3) {
          return x2 || (x2 = k2()), new x2(e6, t3);
        }(this, e5);
      }
    }, N2 = () => {
    }, A2 = class extends R2 {
      constructor(e5, t3) {
        super(), this._tapToSource = e5, this._getValueFromSource = t3, this._untapFromChanges = N2, this._cachedValue = void 0, this._hasCachedValue = false;
      }
      _recalculate() {
        return this.isHot ? (this._hasCachedValue || (this._cachedValue = this._getValueFromSource(), this._hasCachedValue = true), this._cachedValue) : this._getValueFromSource();
      }
      _keepHot() {
        this._hasCachedValue = false, this._cachedValue = void 0, this._untapFromChanges = this._tapToSource((e5) => {
          this._hasCachedValue = true, this._cachedValue = e5, this._markAsStale(this);
        });
      }
      _becomeCold() {
        this._untapFromChanges(), this._untapFromChanges = N2, this._hasCachedValue = false, this._cachedValue = void 0;
      }
      _reactToDependencyBecomingStale() {
      }
    }, z2 = /* @__PURE__ */ new WeakMap(), M2 = Symbol("pointerMeta"), L2 = /* @__PURE__ */ new WeakMap(), F2 = { get(e5, t3) {
      if (t3 === M2)
        return z2.get(e5);
      let n3 = L2.get(e5);
      if (n3 || (n3 = {}, L2.set(e5, n3)), n3[t3])
        return n3[t3];
      const r3 = z2.get(e5), o3 = V2({ root: r3.root, path: [...r3.path, t3] });
      return n3[t3] = o3, o3;
    } }, $2 = (e5) => e5[M2], B2 = (e5) => {
      const { root: t3, path: n3 } = $2(e5);
      return { root: t3, path: n3 };
    };
    function V2(e5) {
      var t3;
      const n3 = { root: e5.root, path: (t3 = e5.path) != null ? t3 : [] }, r3 = {};
      return z2.set(r3, n3), new Proxy(r3, F2);
    }
    var U2 = V2, H2 = (e5) => e5 && !!$2(e5);
    var W2, q2, K2 = (e5, t3, n3) => {
      if (t3.length === 0)
        return n3(e5);
      if (Array.isArray(e5)) {
        let [r3, ...o3] = t3;
        r3 = parseInt(String(r3), 10), isNaN(r3) && (r3 = 0);
        const a3 = e5[r3], i3 = K2(a3, o3, n3);
        if (a3 === i3)
          return e5;
        const s3 = [...e5];
        return s3.splice(r3, 1, i3), s3;
      }
      if (typeof e5 == "object" && e5 !== null) {
        const [o3, ...i3] = t3, l3 = e5[o3], f2 = K2(l3, i3, n3);
        if (l3 === f2)
          return e5;
        const p2 = ((e6, t4) => r2(e6, a2(t4)))(((e6, t4) => {
          for (var n4 in t4 || (t4 = {}))
            u2.call(t4, n4) && d(e6, n4, t4[n4]);
          if (s2)
            for (var n4 of s2(t4))
              c2.call(t4, n4) && d(e6, n4, t4[n4]);
          return e6;
        })({}, e5), { [o3]: f2 });
        return p2;
      }
      {
        const [e6, ...r3] = t3;
        return { [e6]: K2(void 0, r3, n3) };
      }
    };
    (q2 = W2 || (W2 = {}))[q2.Dict = 0] = "Dict", q2[q2.Array = 1] = "Array", q2[q2.Other = 2] = "Other";
    var Y2 = (e5) => Array.isArray(e5) ? 1 : (0, g2.default)(e5) ? 0 : 2, X2 = (e5, t3, n3 = Y2(e5)) => n3 === 0 && typeof t3 == "string" || n3 === 1 && G2(t3) ? e5[t3] : void 0, G2 = (e5) => {
      const t3 = typeof e5 == "number" ? e5 : parseInt(e5, 10);
      return !isNaN(t3) && t3 >= 0 && t3 < 1 / 0 && (0 | t3) === t3;
    }, Q2 = class {
      constructor(e5, t3) {
        this._parent = e5, this._path = t3, this.children = /* @__PURE__ */ new Map(), this.identityChangeListeners = /* @__PURE__ */ new Set();
      }
      addIdentityChangeListener(e5) {
        this.identityChangeListeners.add(e5);
      }
      removeIdentityChangeListener(e5) {
        this.identityChangeListeners.delete(e5), this._checkForGC();
      }
      removeChild(e5) {
        this.children.delete(e5), this._checkForGC();
      }
      getChild(e5) {
        return this.children.get(e5);
      }
      getOrCreateChild(e5) {
        let t3 = this.children.get(e5);
        return t3 || (t3 = t3 = new Q2(this, this._path.concat([e5])), this.children.set(e5, t3)), t3;
      }
      _checkForGC() {
        this.identityChangeListeners.size > 0 || this.children.size > 0 || this._parent && this._parent.removeChild((0, y2.default)(this._path));
      }
    }, J2 = class {
      constructor(e5) {
        this.$$isIdentityDerivationProvider = true, this.reduceState = (e6, t3) => {
          const n3 = function(e7, t4, n4) {
            return t4.length === 0 ? n4(e7) : K2(e7, t4, n4);
          }(this.getState(), e6, t3);
          return this.setState(n3), n3;
        }, this._onPathValueChange = (e6, t3) => {
          const n3 = this._getOrCreateScopeForPath(e6);
          n3.identityChangeListeners.add(t3);
          return () => {
            n3.identityChangeListeners.delete(t3);
          };
        }, this._currentState = e5, this._rootScope = new Q2(void 0, []), this.pointer = U2({ root: this, path: [] });
      }
      setState(e5) {
        const t3 = this._currentState;
        this._currentState = e5, this._checkUpdates(this._rootScope, t3, e5);
      }
      getState() {
        return this._currentState;
      }
      getIn(e5) {
        return e5.length === 0 ? this.getState() : (0, v2.default)(this.getState(), e5);
      }
      setIn(e5, t3) {
        return this.reduceState(e5, () => t3);
      }
      _checkUpdates(e5, t3, n3) {
        if (t3 === n3)
          return;
        if (e5.identityChangeListeners.forEach((e6) => e6(n3)), e5.children.size === 0)
          return;
        const r3 = Y2(t3), o3 = Y2(n3);
        r3 === 2 && r3 === o3 || e5.children.forEach((e6, a3) => {
          const i3 = X2(t3, a3, r3), s3 = X2(n3, a3, o3);
          this._checkUpdates(e6, i3, s3);
        });
      }
      _getOrCreateScopeForPath(e5) {
        let t3 = this._rootScope;
        for (const n3 of e5)
          t3 = t3.getOrCreateChild(n3);
        return t3;
      }
      getIdentityDerivation(e5) {
        return new A2((t3) => this._onPathValueChange(e5, t3), () => this.getIn(e5));
      }
    }, Z2 = /* @__PURE__ */ new WeakMap(), ee2 = (e5) => {
      const t3 = $2(e5);
      let n3 = Z2.get(t3);
      if (!n3) {
        const e6 = t3.root;
        if (typeof (r3 = e6) != "object" || r3 === null || r3.$$isIdentityDerivationProvider !== true)
          throw new Error("Cannot run valueDerivation() on a pointer whose root is not an IdentityChangeProvider");
        const { path: o3 } = t3;
        n3 = e6.getIdentityDerivation(o3), Z2.set(t3, n3);
      }
      var r3;
      return n3;
    };
    var te2 = (e5) => H2(e5) ? ee2(e5).getValue() : w2(e5) ? e5.getValue() : e5, ne2 = class {
      constructor(e5) {
        this._value = e5, this._emitter = new b2(), this._publicDerivation = new A2((e6) => this._emitter.tappable.tap(e6), this.get.bind(this));
      }
      set(e5) {
        e5 !== this._value && (this._value = e5, this._emitter.emit(e5));
      }
      get() {
        return this._value;
      }
      get derivation() {
        return this._publicDerivation;
      }
    }, re2 = class extends R2 {
      constructor(e5) {
        return super(), this._v = e5, this;
      }
      _recalculate() {
        return this._v;
      }
      _reactToDependencyBecomingStale() {
      }
    };
    function* oe2(e5) {
      let t3;
      if (H2(e5))
        t3 = ee2(e5);
      else {
        if (!w2(e5))
          throw new Error("Only pointers and derivations are supported");
        t3 = e5;
      }
      let n3 = 0;
      const r3 = t3.changesWithoutValues().tap(() => {
        n3++;
      });
      try {
        for (; ; ) {
          const e6 = n3;
          n3 = 0, yield { value: t3.getValue(), ticks: e6 };
        }
      } finally {
        r3();
      }
    }
    var ae2 = class {
      constructor() {
        this._ticking = false, this._scheduledForThisOrNextTick = /* @__PURE__ */ new Set(), this._scheduledForNextTick = /* @__PURE__ */ new Set(), this._timeAtCurrentTick = 0;
      }
      onThisOrNextTick(e5) {
        this._scheduledForThisOrNextTick.add(e5);
      }
      onNextTick(e5) {
        this._scheduledForNextTick.add(e5);
      }
      offThisOrNextTick(e5) {
        this._scheduledForThisOrNextTick.delete(e5);
      }
      offNextTick(e5) {
        this._scheduledForNextTick.delete(e5);
      }
      get time() {
        return this._ticking ? this._timeAtCurrentTick : performance.now();
      }
      tick(e5 = performance.now()) {
        this._ticking = true, this._timeAtCurrentTick = e5, this._scheduledForNextTick.forEach((e6) => this._scheduledForThisOrNextTick.add(e6)), this._scheduledForNextTick.clear(), this._tick(0), this._ticking = false;
      }
      _tick(e5) {
        const t3 = this.time;
        if (e5 > 10 && console.warn("_tick() recursing for 10 times"), e5 > 100)
          throw new Error("Maximum recursion limit for _tick()");
        const n3 = this._scheduledForThisOrNextTick;
        if (this._scheduledForThisOrNextTick = /* @__PURE__ */ new Set(), n3.forEach((e6) => {
          e6(t3);
        }), this._scheduledForThisOrNextTick.size > 0)
          return this._tick(e5 + 1);
      }
    };
    function* ie2(e5) {
      let t3;
      if (H2(e5))
        t3 = ee2(e5);
      else {
        if (!w2(e5))
          throw new Error("Only pointers and derivations are supported");
        t3 = e5;
      }
      const n3 = new ae2(), r3 = t3.changes(n3).tap((e6) => {
      });
      try {
        for (; ; )
          n3.tick(), yield t3.getValue();
      } finally {
        r3();
      }
    }
    var se2 = () => {
    }, le2 = class extends R2 {
      constructor(e5) {
        super(), this._fn = e5, this._cacheOfDendencyValues = /* @__PURE__ */ new Map(), this._possiblyStaleDeps = /* @__PURE__ */ new Set(), this._prismScope = new ue2();
      }
      _recalculate() {
        let e5;
        if (this._possiblyStaleDeps.size > 0) {
          let e6 = false;
          C2();
          for (const t4 of this._possiblyStaleDeps)
            if (this._cacheOfDendencyValues.get(t4) !== t4.getValue()) {
              e6 = true;
              break;
            }
          if (j2(), this._possiblyStaleDeps.clear(), !e6)
            return this._lastValue;
        }
        const t3 = /* @__PURE__ */ new Set();
        this._cacheOfDendencyValues.clear();
        const n3 = (e6) => {
          t3.add(e6), this._addDependency(e6);
        };
        I2(n3), fe2.push(this._prismScope);
        try {
          e5 = this._fn();
        } catch (e6) {
          console.error(e6);
        } finally {
          fe2.pop() !== this._prismScope && console.warn("The Prism hook stack has slipped. This is a bug.");
        }
        return D2(n3), this._dependencies.forEach((e6) => {
          t3.has(e6) || this._removeDependency(e6);
        }), this._dependencies = t3, C2(), t3.forEach((e6) => {
          this._cacheOfDendencyValues.set(e6, e6.getValue());
        }), j2(), e5;
      }
      _reactToDependencyBecomingStale(e5) {
        this._possiblyStaleDeps.add(e5);
      }
      _keepHot() {
        this._prismScope = new ue2(), C2(), this.getValue(), j2();
      }
      _becomeCold() {
        ce2(this._prismScope), this._prismScope = new ue2();
      }
    }, ue2 = class {
      constructor() {
        this.isPrismScope = true, this._subs = {};
      }
      sub(e5) {
        return this._subs[e5] || (this._subs[e5] = new ue2()), this._subs[e5];
      }
      get subs() {
        return this._subs;
      }
    };
    function ce2(e5) {
      for (const [t3, n3] of Object.entries(e5.subs))
        ce2(n3);
      !function(e6) {
        const t3 = he2.get(e6);
        if (t3)
          for (const e7 of Object.keys(t3)) {
            de2(t3[e7].cleanup, void 0);
          }
        he2.delete(e6);
      }(e5);
    }
    function de2(e5, t3) {
      let n3 = t3, r3 = false;
      try {
        n3 = e5(), r3 = true;
      } catch (e6) {
        setTimeout(() => {
          throw e6;
        });
      }
      return { success: r3, returnValue: n3 };
    }
    var fe2 = new E2(), pe2 = /* @__PURE__ */ new WeakMap(), he2 = /* @__PURE__ */ new WeakMap(), me2 = /* @__PURE__ */ new WeakMap();
    function ve2(e5, t3) {
      return e5 === void 0 || t3 === void 0 || (e5.length !== t3.length || e5.some((e6, n3) => e6 !== t3[n3]));
    }
    function ye2(e5, t3, n3) {
      const r3 = fe2.peek();
      if (!r3)
        throw new Error("prism.memo() is called outside of a prism() call.");
      let o3 = me2.get(r3);
      o3 || (o3 = {}, me2.set(r3, o3)), o3[e5] || (o3[e5] = { cachedValue: null, deps: [{}] });
      const a3 = o3[e5];
      return ve2(a3.deps, n3) && (C2(), a3.cachedValue = de2(t3, void 0).returnValue, j2(), a3.deps = n3), a3.cachedValue;
    }
    var be2 = (e5) => new le2(e5);
    be2.ref = function(e5, t3) {
      const n3 = fe2.peek();
      if (!n3)
        throw new Error("prism.ref() is called outside of a prism() call.");
      let r3 = pe2.get(n3);
      if (r3 || (r3 = {}, pe2.set(n3, r3)), r3[e5])
        return r3[e5];
      {
        const n4 = { current: t3 };
        return r3[e5] = n4, n4;
      }
    }, be2.effect = function(e5, t3, n3) {
      const r3 = fe2.peek();
      if (!r3)
        throw new Error("prism.effect() is called outside of a prism() call.");
      let o3 = he2.get(r3);
      o3 || (o3 = {}, he2.set(r3, o3)), o3[e5] || (o3[e5] = { cleanup: se2, deps: [{}] });
      const a3 = o3[e5];
      ve2(a3.deps, n3) && (a3.cleanup(), C2(), a3.cleanup = de2(t3, se2).returnValue, j2(), a3.deps = n3);
    }, be2.memo = ye2, be2.ensurePrism = function() {
      if (!fe2.peek())
        throw new Error("The parent function is called outside of a prism() call.");
    }, be2.state = function(e5, t3) {
      const { b: n3, setValue: r3 } = be2.memo("state/" + e5, () => {
        const e6 = new ne2(t3);
        return { b: e6, setValue: (t4) => e6.set(t4) };
      }, []);
      return [n3.derivation.getValue(), r3];
    }, be2.scope = function(e5, t3) {
      const n3 = fe2.peek();
      if (!n3)
        throw new Error("prism.scope() is called outside of a prism() call.");
      const r3 = n3.sub(e5);
      fe2.push(r3);
      const o3 = de2(t3, void 0).returnValue;
      return fe2.pop(), o3;
    }, be2.sub = function(e5, t3, n3) {
      return ye2(e5, () => be2(t3), n3).getValue();
    }, be2.inPrism = function() {
      return !!fe2.peek();
    };
    var we2 = be2, ke2 = class {
      constructor(e5) {
        this.$$isIdentityDerivationProvider = true, this._currentPointerBox = new ne2(e5), this.pointer = U2({ root: this, path: [] });
      }
      setPointer(e5) {
        this._currentPointerBox.set(e5);
      }
      getIdentityDerivation(e5) {
        return this._currentPointerBox.derivation.flatMap((t3) => {
          const n3 = e5.reduce((e6, t4) => e6[t4], t3);
          return ee2(n3);
        });
      }
    };
  }(g), function(e4) {
    var t2 = Object.create, n2 = Object.defineProperty, r2 = Object.defineProperties, o2 = Object.getOwnPropertyDescriptor, a2 = Object.getOwnPropertyDescriptors, i2 = Object.getOwnPropertyNames, s2 = Object.getOwnPropertySymbols, l2 = Object.getPrototypeOf, u2 = Object.prototype.hasOwnProperty, c2 = Object.prototype.propertyIsEnumerable, d = (e5, t3, r3) => t3 in e5 ? n2(e5, t3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e5[t3] = r3, f = (e5, t3) => {
      for (var n3 in t3 || (t3 = {}))
        u2.call(t3, n3) && d(e5, n3, t3[n3]);
      if (s2)
        for (var n3 of s2(t3))
          c2.call(t3, n3) && d(e5, n3, t3[n3]);
      return e5;
    }, p = (e5, t3) => r2(e5, a2(t3)), h2 = (e5) => n2(e5, "__esModule", { value: true }), m2 = (e5, t3) => function() {
      return t3 || (0, e5[Object.keys(e5)[0]])((t3 = { exports: {} }).exports, t3), t3.exports;
    }, v2 = (e5, t3) => {
      for (var r3 in h2(e5), t3)
        n2(e5, r3, { get: t3[r3], enumerable: true });
    }, y2 = (e5) => ((e6, t3, r3) => {
      if (t3 && typeof t3 == "object" || typeof t3 == "function")
        for (let a3 of i2(t3))
          u2.call(e6, a3) || a3 === "default" || n2(e6, a3, { get: () => t3[a3], enumerable: !(r3 = o2(t3, a3)) || r3.enumerable });
      return e6;
    })(h2(n2(e5 != null ? t2(l2(e5)) : {}, "default", e5 && e5.__esModule && "default" in e5 ? { get: () => e5.default, enumerable: true } : { value: e5, enumerable: true })), e5), b2 = (e5, t3, n3) => (d(e5, typeof t3 != "symbol" ? t3 + "" : t3, n3), n3), w2 = m2({ "../node_modules/timing-function/lib/UnitBezier.js"(e5, t3) {
      t3.exports = function() {
        function e6(e7, t4, n3, r3) {
          this.set(e7, t4, n3, r3);
        }
        return e6.prototype.set = function(e7, t4, n3, r3) {
          this._cx = 3 * e7, this._bx = 3 * (n3 - e7) - this._cx, this._ax = 1 - this._cx - this._bx, this._cy = 3 * t4, this._by = 3 * (r3 - t4) - this._cy, this._ay = 1 - this._cy - this._by;
        }, e6.epsilon = 1e-6, e6.prototype._sampleCurveX = function(e7) {
          return ((this._ax * e7 + this._bx) * e7 + this._cx) * e7;
        }, e6.prototype._sampleCurveY = function(e7) {
          return ((this._ay * e7 + this._by) * e7 + this._cy) * e7;
        }, e6.prototype._sampleCurveDerivativeX = function(e7) {
          return (3 * this._ax * e7 + 2 * this._bx) * e7 + this._cx;
        }, e6.prototype._solveCurveX = function(e7, t4) {
          var n3, r3, o3, a3, i3, s3;
          for (o3 = void 0, a3 = void 0, i3 = void 0, s3 = void 0, n3 = void 0, r3 = void 0, i3 = e7, r3 = 0; r3 < 8; ) {
            if (s3 = this._sampleCurveX(i3) - e7, Math.abs(s3) < t4)
              return i3;
            if (n3 = this._sampleCurveDerivativeX(i3), Math.abs(n3) < t4)
              break;
            i3 -= s3 / n3, r3++;
          }
          if ((i3 = e7) < (o3 = 0))
            return o3;
          if (i3 > (a3 = 1))
            return a3;
          for (; o3 < a3; ) {
            if (s3 = this._sampleCurveX(i3), Math.abs(s3 - e7) < t4)
              return i3;
            e7 > s3 ? o3 = i3 : a3 = i3, i3 = 0.5 * (a3 - o3) + o3;
          }
          return i3;
        }, e6.prototype.solve = function(e7, t4) {
          return this._sampleCurveY(this._solveCurveX(e7, t4));
        }, e6.prototype.solveSimple = function(e7) {
          return this._sampleCurveY(this._solveCurveX(e7, 1e-6));
        }, e6;
      }();
    } }), k2 = m2({ "../node_modules/levenshtein-edit-distance/index.js"(e5, t3) {
      var n3, r3;
      n3 = [], r3 = [], t3.exports = function(e6, t4, o3) {
        var a3, i3, s3, l3, u3, c3, d2, f2;
        if (e6 === t4)
          return 0;
        if (a3 = e6.length, i3 = t4.length, a3 === 0)
          return i3;
        if (i3 === 0)
          return a3;
        for (o3 && (e6 = e6.toLowerCase(), t4 = t4.toLowerCase()), d2 = 0; d2 < a3; )
          r3[d2] = e6.charCodeAt(d2), n3[d2] = ++d2;
        for (f2 = 0; f2 < i3; )
          for (s3 = t4.charCodeAt(f2), l3 = u3 = f2++, d2 = -1; ++d2 < a3; )
            c3 = s3 === r3[d2] ? u3 : u3 + 1, u3 = n3[d2], n3[d2] = l3 = u3 > l3 ? c3 > l3 ? l3 + 1 : c3 : c3 > u3 ? u3 + 1 : c3;
        return l3;
      };
    } }), x2 = m2({ "../node_modules/propose/propose.js"(e5, t3) {
      var n3 = k2();
      t3.exports = function() {
        var e6, t4, r3, o3, a3, i3 = 0, s3 = arguments[0], l3 = arguments[1], u3 = l3.length, c3 = arguments[2];
        c3 && (o3 = c3.threshold, a3 = c3.ignoreCase), o3 === void 0 && (o3 = 0);
        for (var d2 = 0; d2 < u3; ++d2)
          (e6 = (t4 = a3 ? n3(s3, l3[d2], true) : n3(s3, l3[d2])) > s3.length ? 1 - t4 / l3[d2].length : 1 - t4 / s3.length) > i3 && (i3 = e6, r3 = l3[d2]);
        return i3 >= o3 ? r3 : null;
      };
    } }), S2 = m2({ "../node_modules/fast-deep-equal/index.js"(e5, t3) {
      t3.exports = function e6(t4, n3) {
        if (t4 === n3)
          return true;
        if (t4 && n3 && typeof t4 == "object" && typeof n3 == "object") {
          if (t4.constructor !== n3.constructor)
            return false;
          var r3, o3, a3;
          if (Array.isArray(t4)) {
            if ((r3 = t4.length) != n3.length)
              return false;
            for (o3 = r3; o3-- != 0; )
              if (!e6(t4[o3], n3[o3]))
                return false;
            return true;
          }
          if (t4.constructor === RegExp)
            return t4.source === n3.source && t4.flags === n3.flags;
          if (t4.valueOf !== Object.prototype.valueOf)
            return t4.valueOf() === n3.valueOf();
          if (t4.toString !== Object.prototype.toString)
            return t4.toString() === n3.toString();
          if ((r3 = (a3 = Object.keys(t4)).length) !== Object.keys(n3).length)
            return false;
          for (o3 = r3; o3-- != 0; )
            if (!Object.prototype.hasOwnProperty.call(n3, a3[o3]))
              return false;
          for (o3 = r3; o3-- != 0; ) {
            var i3 = a3[o3];
            if (!e6(t4[i3], n3[i3]))
              return false;
          }
          return true;
        }
        return t4 != t4 && n3 != n3;
      };
    } });
    v2(e4, { getProject: () => So2, onChange: () => Co2, types: () => Zn2, val: () => jo2 });
    var _2 = {};
    v2(_2, { getProject: () => So2, onChange: () => Co2, types: () => Zn2, val: () => jo2 });
    var E2 = y2(g), P2 = new class {
      constructor() {
        b2(this, "atom", new E2.Atom({ projects: {} }));
      }
      add(e5, t3) {
        this.atom.reduceState(["projects", e5], () => t3);
      }
      get(e5) {
        return this.atom.getState().projects[e5];
      }
      has(e5) {
        return !!this.get(e5);
      }
    }(), C2 = P2, j2 = /* @__PURE__ */ new WeakMap();
    function O2(e5) {
      return j2.get(e5);
    }
    function T2(e5, t3) {
      j2.set(e5, t3);
    }
    var I2 = [], D2 = Array.isArray, R2 = typeof window == "object" && window && window.Object === Object && window, N2 = typeof self == "object" && self && self.Object === Object && self, A2 = R2 || N2 || Function("return this")(), z2 = A2.Symbol, M2 = Object.prototype, L2 = M2.hasOwnProperty, F2 = M2.toString, $2 = z2 ? z2.toStringTag : void 0;
    var B2 = function(e5) {
      var t3 = L2.call(e5, $2), n3 = e5[$2];
      try {
        e5[$2] = void 0;
        var r3 = true;
      } catch (e6) {
      }
      var o3 = F2.call(e5);
      return r3 && (t3 ? e5[$2] = n3 : delete e5[$2]), o3;
    }, V2 = Object.prototype.toString;
    var U2 = function(e5) {
      return V2.call(e5);
    }, H2 = z2 ? z2.toStringTag : void 0;
    var W2 = function(e5) {
      return e5 == null ? e5 === void 0 ? "[object Undefined]" : "[object Null]" : H2 && H2 in Object(e5) ? B2(e5) : U2(e5);
    };
    var q2 = function(e5) {
      return e5 != null && typeof e5 == "object";
    };
    var K2 = function(e5) {
      return typeof e5 == "symbol" || q2(e5) && W2(e5) == "[object Symbol]";
    }, Y2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, X2 = /^\w*$/;
    var G2 = function(e5, t3) {
      if (D2(e5))
        return false;
      var n3 = typeof e5;
      return !(n3 != "number" && n3 != "symbol" && n3 != "boolean" && e5 != null && !K2(e5)) || (X2.test(e5) || !Y2.test(e5) || t3 != null && e5 in Object(t3));
    };
    var Q2 = function(e5) {
      var t3 = typeof e5;
      return e5 != null && (t3 == "object" || t3 == "function");
    };
    var J2 = function(e5) {
      if (!Q2(e5))
        return false;
      var t3 = W2(e5);
      return t3 == "[object Function]" || t3 == "[object GeneratorFunction]" || t3 == "[object AsyncFunction]" || t3 == "[object Proxy]";
    }, Z2 = A2["__core-js_shared__"], ee2 = function() {
      var e5 = /[^.]+$/.exec(Z2 && Z2.keys && Z2.keys.IE_PROTO || "");
      return e5 ? "Symbol(src)_1." + e5 : "";
    }();
    var te2 = function(e5) {
      return !!ee2 && ee2 in e5;
    }, ne2 = Function.prototype.toString;
    var re2 = function(e5) {
      if (e5 != null) {
        try {
          return ne2.call(e5);
        } catch (e6) {
        }
        try {
          return e5 + "";
        } catch (e6) {
        }
      }
      return "";
    }, oe2 = /^\[object .+?Constructor\]$/, ae2 = Function.prototype, ie2 = Object.prototype, se2 = ae2.toString, le2 = ie2.hasOwnProperty, ue2 = RegExp("^" + se2.call(le2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var ce2 = function(e5) {
      return !(!Q2(e5) || te2(e5)) && (J2(e5) ? ue2 : oe2).test(re2(e5));
    };
    var de2 = function(e5, t3) {
      return e5 == null ? void 0 : e5[t3];
    };
    var fe2 = function(e5, t3) {
      var n3 = de2(e5, t3);
      return ce2(n3) ? n3 : void 0;
    }, pe2 = fe2(Object, "create");
    var he2 = function() {
      this.__data__ = pe2 ? pe2(null) : {}, this.size = 0;
    };
    var me2 = function(e5) {
      var t3 = this.has(e5) && delete this.__data__[e5];
      return this.size -= t3 ? 1 : 0, t3;
    }, ve2 = Object.prototype.hasOwnProperty;
    var ge2 = function(e5) {
      var t3 = this.__data__;
      if (pe2) {
        var n3 = t3[e5];
        return n3 === "__lodash_hash_undefined__" ? void 0 : n3;
      }
      return ve2.call(t3, e5) ? t3[e5] : void 0;
    }, ye2 = Object.prototype.hasOwnProperty;
    var be2 = function(e5) {
      var t3 = this.__data__;
      return pe2 ? t3[e5] !== void 0 : ye2.call(t3, e5);
    };
    var we2 = function(e5, t3) {
      var n3 = this.__data__;
      return this.size += this.has(e5) ? 0 : 1, n3[e5] = pe2 && t3 === void 0 ? "__lodash_hash_undefined__" : t3, this;
    };
    function ke2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.clear(); ++t3 < n3; ) {
        var r3 = e5[t3];
        this.set(r3[0], r3[1]);
      }
    }
    ke2.prototype.clear = he2, ke2.prototype.delete = me2, ke2.prototype.get = ge2, ke2.prototype.has = be2, ke2.prototype.set = we2;
    var xe2 = ke2;
    var Se2 = function() {
      this.__data__ = [], this.size = 0;
    };
    var _e2 = function(e5, t3) {
      return e5 === t3 || e5 != e5 && t3 != t3;
    };
    var Ee2 = function(e5, t3) {
      for (var n3 = e5.length; n3--; )
        if (_e2(e5[n3][0], t3))
          return n3;
      return -1;
    }, Pe2 = Array.prototype.splice;
    var Ce2 = function(e5) {
      var t3 = this.__data__, n3 = Ee2(t3, e5);
      return !(n3 < 0) && (n3 == t3.length - 1 ? t3.pop() : Pe2.call(t3, n3, 1), --this.size, true);
    };
    var je2 = function(e5) {
      var t3 = this.__data__, n3 = Ee2(t3, e5);
      return n3 < 0 ? void 0 : t3[n3][1];
    };
    var Oe2 = function(e5) {
      return Ee2(this.__data__, e5) > -1;
    };
    var Te2 = function(e5, t3) {
      var n3 = this.__data__, r3 = Ee2(n3, e5);
      return r3 < 0 ? (++this.size, n3.push([e5, t3])) : n3[r3][1] = t3, this;
    };
    function Ie2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.clear(); ++t3 < n3; ) {
        var r3 = e5[t3];
        this.set(r3[0], r3[1]);
      }
    }
    Ie2.prototype.clear = Se2, Ie2.prototype.delete = Ce2, Ie2.prototype.get = je2, Ie2.prototype.has = Oe2, Ie2.prototype.set = Te2;
    var De2 = Ie2, Re2 = fe2(A2, "Map");
    var Ne2 = function() {
      this.size = 0, this.__data__ = { hash: new xe2(), map: new (Re2 || De2)(), string: new xe2() };
    };
    var Ae2 = function(e5) {
      var t3 = typeof e5;
      return t3 == "string" || t3 == "number" || t3 == "symbol" || t3 == "boolean" ? e5 !== "__proto__" : e5 === null;
    };
    var ze2 = function(e5, t3) {
      var n3 = e5.__data__;
      return Ae2(t3) ? n3[typeof t3 == "string" ? "string" : "hash"] : n3.map;
    };
    var Me2 = function(e5) {
      var t3 = ze2(this, e5).delete(e5);
      return this.size -= t3 ? 1 : 0, t3;
    };
    var Le2 = function(e5) {
      return ze2(this, e5).get(e5);
    };
    var Fe2 = function(e5) {
      return ze2(this, e5).has(e5);
    };
    var $e2 = function(e5, t3) {
      var n3 = ze2(this, e5), r3 = n3.size;
      return n3.set(e5, t3), this.size += n3.size == r3 ? 0 : 1, this;
    };
    function Be2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.clear(); ++t3 < n3; ) {
        var r3 = e5[t3];
        this.set(r3[0], r3[1]);
      }
    }
    Be2.prototype.clear = Ne2, Be2.prototype.delete = Me2, Be2.prototype.get = Le2, Be2.prototype.has = Fe2, Be2.prototype.set = $e2;
    var Ve2 = Be2;
    function Ue(e5, t3) {
      if (typeof e5 != "function" || t3 != null && typeof t3 != "function")
        throw new TypeError("Expected a function");
      var n3 = function() {
        var r3 = arguments, o3 = t3 ? t3.apply(this, r3) : r3[0], a3 = n3.cache;
        if (a3.has(o3))
          return a3.get(o3);
        var i3 = e5.apply(this, r3);
        return n3.cache = a3.set(o3, i3) || a3, i3;
      };
      return n3.cache = new (Ue.Cache || Ve2)(), n3;
    }
    Ue.Cache = Ve2;
    var He2 = Ue;
    var We2 = function(e5) {
      var t3 = He2(e5, function(e6) {
        return n3.size === 500 && n3.clear(), e6;
      }), n3 = t3.cache;
      return t3;
    }, qe2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ke2 = /\\(\\)?/g, Ye2 = We2(function(e5) {
      var t3 = [];
      return e5.charCodeAt(0) === 46 && t3.push(""), e5.replace(qe2, function(e6, n3, r3, o3) {
        t3.push(r3 ? o3.replace(Ke2, "$1") : n3 || e6);
      }), t3;
    }), Xe2 = Ye2;
    var Ge2 = function(e5, t3) {
      for (var n3 = -1, r3 = e5 == null ? 0 : e5.length, o3 = Array(r3); ++n3 < r3; )
        o3[n3] = t3(e5[n3], n3, e5);
      return o3;
    }, Qe2 = z2 ? z2.prototype : void 0, Je2 = Qe2 ? Qe2.toString : void 0;
    var Ze2 = function e5(t3) {
      if (typeof t3 == "string")
        return t3;
      if (D2(t3))
        return Ge2(t3, e5) + "";
      if (K2(t3))
        return Je2 ? Je2.call(t3) : "";
      var n3 = t3 + "";
      return n3 == "0" && 1 / t3 == -Infinity ? "-0" : n3;
    };
    var et2 = function(e5) {
      return e5 == null ? "" : Ze2(e5);
    };
    var tt2 = function(e5, t3) {
      return D2(e5) ? e5 : G2(e5, t3) ? [e5] : Xe2(et2(e5));
    };
    var nt2 = function(e5) {
      if (typeof e5 == "string" || K2(e5))
        return e5;
      var t3 = e5 + "";
      return t3 == "0" && 1 / e5 == -Infinity ? "-0" : t3;
    };
    var rt2 = function(e5, t3) {
      for (var n3 = 0, r3 = (t3 = tt2(t3, e5)).length; e5 != null && n3 < r3; )
        e5 = e5[nt2(t3[n3++])];
      return n3 && n3 == r3 ? e5 : void 0;
    };
    var ot2 = function(e5, t3, n3) {
      var r3 = e5 == null ? void 0 : rt2(e5, t3);
      return r3 === void 0 ? n3 : r3;
    };
    var at2 = class {
      constructor() {
        b2(this, "_values", {});
      }
      get(e5, t3) {
        if (this.has(e5))
          return this._values[e5];
        {
          const n3 = t3();
          return this._values[e5] = n3, n3;
        }
      }
      has(e5) {
        return this._values.hasOwnProperty(e5);
      }
    }, it2 = y2(g), st2 = function() {
      try {
        var e5 = fe2(Object, "defineProperty");
        return e5({}, "", {}), e5;
      } catch (e6) {
      }
    }(), lt2 = st2;
    var ut2 = function(e5, t3, n3) {
      t3 == "__proto__" && lt2 ? lt2(e5, t3, { configurable: true, enumerable: true, value: n3, writable: true }) : e5[t3] = n3;
    }, ct2 = Object.prototype.hasOwnProperty;
    var dt2 = function(e5, t3, n3) {
      var r3 = e5[t3];
      ct2.call(e5, t3) && _e2(r3, n3) && (n3 !== void 0 || t3 in e5) || ut2(e5, t3, n3);
    }, ft2 = /^(?:0|[1-9]\d*)$/;
    var pt2 = function(e5, t3) {
      var n3 = typeof e5;
      return !!(t3 = t3 == null ? 9007199254740991 : t3) && (n3 == "number" || n3 != "symbol" && ft2.test(e5)) && e5 > -1 && e5 % 1 == 0 && e5 < t3;
    };
    var ht2 = function(e5, t3, n3, r3) {
      if (!Q2(e5))
        return e5;
      for (var o3 = -1, a3 = (t3 = tt2(t3, e5)).length, i3 = a3 - 1, s3 = e5; s3 != null && ++o3 < a3; ) {
        var l3 = nt2(t3[o3]), u3 = n3;
        if (l3 === "__proto__" || l3 === "constructor" || l3 === "prototype")
          return e5;
        if (o3 != i3) {
          var c3 = s3[l3];
          (u3 = r3 ? r3(c3, l3, s3) : void 0) === void 0 && (u3 = Q2(c3) ? c3 : pt2(t3[o3 + 1]) ? [] : {});
        }
        dt2(s3, l3, u3), s3 = s3[l3];
      }
      return e5;
    };
    var mt2 = function(e5, t3, n3) {
      return e5 == null ? e5 : ht2(e5, t3, n3);
    }, vt2 = /* @__PURE__ */ new WeakMap();
    function gt2(e5) {
      if (vt2.has(e5))
        return vt2.get(e5);
      const t3 = e5.type === "compound" ? function(e6) {
        const t4 = {};
        for (const [n3, r3] of Object.entries(e6.props))
          t4[n3] = gt2(r3);
        return t4;
      }(e5) : e5.type === "enum" ? function(e6) {
        const t4 = { $case: e6.defaultCase };
        for (const [n3, r3] of Object.entries(e6.cases))
          t4[n3] = gt2(r3);
        return t4;
      }(e5) : e5.default;
      return vt2.set(e5, t3), t3;
    }
    var yt2 = y2(g), bt2 = { log: console.log, warn: console.warn, error: console.error, trace: console.trace }, wt2 = y2(w2());
    function kt2(e5, t3) {
      return (0, yt2.prism)(() => {
        const n3 = (0, yt2.val)(e5), r3 = yt2.prism.memo("driver", () => n3 ? n3.type === "BasicKeyframedTrack" ? function(e6, t4) {
          return (0, yt2.prism)(() => {
            let n4 = yt2.prism.ref("state", { started: false }), r4 = n4.current;
            const o3 = t4.getValue();
            return (!r4.started || o3 < r4.validFrom || r4.validTo <= o3) && (n4.current = r4 = St2(t4, e6)), r4.der.getValue();
          });
        }(n3, t3) : (bt2.error("Track type not yet supported."), new yt2.ConstantDerivation(void 0)) : new yt2.ConstantDerivation(void 0), [n3]);
        return r3.getValue();
      });
    }
    var xt2 = new yt2.ConstantDerivation(void 0), St2 = (e5, t3) => {
      const n3 = e5.getValue();
      if (t3.keyframes.length === 0)
        return { started: true, validFrom: -1 / 0, validTo: 1 / 0, der: xt2 };
      let r3 = 0;
      for (; ; ) {
        const o3 = t3.keyframes[r3];
        if (!o3)
          return bt2.error("Bug here"), _t2.error;
        const a3 = r3 === t3.keyframes.length - 1;
        if (n3 < o3.position)
          return r3 === 0 ? _t2.beforeFirstKeyframe(o3) : (bt2.error("Bug here"), _t2.error);
        if (o3.position === n3)
          return a3 ? _t2.lastKeyframe(o3) : _t2.between(o3, t3.keyframes[r3 + 1], e5);
        if (r3 === t3.keyframes.length - 1)
          return _t2.lastKeyframe(o3);
        {
          const a4 = r3 + 1;
          if (t3.keyframes[a4].position <= n3) {
            r3 = a4;
            continue;
          }
          return _t2.between(o3, t3.keyframes[r3 + 1], e5);
        }
      }
    }, _t2 = { beforeFirstKeyframe: (e5) => ({ started: true, validFrom: -1 / 0, validTo: e5.position, der: new yt2.ConstantDerivation(e5.value) }), lastKeyframe: (e5) => ({ started: true, validFrom: e5.position, validTo: 1 / 0, der: new yt2.ConstantDerivation(e5.value) }), between(e5, t3, n3) {
      if (!e5.connectedRight)
        return { started: true, validFrom: e5.position, validTo: t3.position, der: new yt2.ConstantDerivation(e5.value) };
      const r3 = new wt2.default(e5.handles[2], e5.handles[3], t3.handles[0], t3.handles[1]), o3 = (0, yt2.prism)(() => {
        const o4 = (n3.getValue() - e5.position) / (t3.position - e5.position);
        const a3 = r3.solveSimple(o4);
        return e5.value + a3 * (t3.value - e5.value);
      });
      return { started: true, validFrom: e5.position, validTo: t3.position, der: o3 };
    }, error: { started: true, validFrom: -1 / 0, validTo: 1 / 0, der: xt2 } };
    function Et2(e5, t3, n3) {
      const r3 = n3.get(e5);
      if (r3 && r3.override === t3)
        return r3.merged;
      const o3 = f({}, e5);
      for (const r4 of Object.keys(t3)) {
        const a3 = t3[r4], i3 = e5[r4];
        o3[r4] = typeof a3 == "object" && typeof i3 == "object" ? Et2(i3, a3, n3) : a3 === void 0 ? i3 : a3;
      }
      return n3.set(e5, { override: t3, merged: o3 }), o3;
    }
    function Pt2(e5, t3) {
      let n3 = e5;
      for (const e6 of t3)
        n3 = n3[e6];
      return n3;
    }
    var Ct2 = y2(g), jt2 = y2(g), Ot2 = new (y2(g)).Ticker(), Tt2 = Ot2, It2 = (e5) => {
      Ot2.tick(e5), window.requestAnimationFrame(It2);
    };
    window.requestAnimationFrame(It2);
    var Dt2 = y2(g), Rt2 = y2(g), Nt2 = y2(x2());
    var At2 = class extends Error {
    }, zt2 = class extends At2 {
    }, Mt2 = y2(g), Lt2 = y2(g), Ft2 = /\s/;
    var $t2 = function(e5) {
      for (var t3 = e5.length; t3-- && Ft2.test(e5.charAt(t3)); )
        ;
      return t3;
    }, Bt2 = /^\s+/;
    var Vt2 = function(e5) {
      return e5 ? e5.slice(0, $t2(e5) + 1).replace(Bt2, "") : e5;
    }, Ut2 = /^[-+]0x[0-9a-f]+$/i, Ht2 = /^0b[01]+$/i, Wt2 = /^0o[0-7]+$/i, qt2 = parseInt;
    var Kt2 = function(e5) {
      if (typeof e5 == "number")
        return e5;
      if (K2(e5))
        return NaN;
      if (Q2(e5)) {
        var t3 = typeof e5.valueOf == "function" ? e5.valueOf() : e5;
        e5 = Q2(t3) ? t3 + "" : t3;
      }
      if (typeof e5 != "string")
        return e5 === 0 ? e5 : +e5;
      e5 = Vt2(e5);
      var n3 = Ht2.test(e5);
      return n3 || Wt2.test(e5) ? qt2(e5.slice(2), n3 ? 2 : 8) : Ut2.test(e5) ? NaN : +e5;
    }, Yt2 = 1 / 0;
    var Xt2 = function(e5) {
      return e5 ? (e5 = Kt2(e5)) === Yt2 || e5 === -1 / 0 ? 17976931348623157e292 * (e5 < 0 ? -1 : 1) : e5 == e5 ? e5 : 0 : e5 === 0 ? e5 : 0;
    };
    var Gt2 = function(e5) {
      var t3 = Xt2(e5), n3 = t3 % 1;
      return t3 == t3 ? n3 ? t3 - n3 : t3 : 0;
    };
    var Qt2 = function(e5, t3) {
      return function(n3) {
        return e5(t3(n3));
      };
    }, Jt2 = Qt2(Object.getPrototypeOf, Object), Zt2 = Function.prototype, en2 = Object.prototype, tn = Zt2.toString, nn2 = en2.hasOwnProperty, rn2 = tn.call(Object);
    var on2 = function(e5) {
      if (!q2(e5) || W2(e5) != "[object Object]")
        return false;
      var t3 = Jt2(e5);
      if (t3 === null)
        return true;
      var n3 = nn2.call(t3, "constructor") && t3.constructor;
      return typeof n3 == "function" && n3 instanceof n3 && tn.call(n3) == rn2;
    };
    var an2 = function(e5, t3, n3) {
      var r3 = -1, o3 = e5.length;
      t3 < 0 && (t3 = -t3 > o3 ? 0 : o3 + t3), (n3 = n3 > o3 ? o3 : n3) < 0 && (n3 += o3), o3 = t3 > n3 ? 0 : n3 - t3 >>> 0, t3 >>>= 0;
      for (var a3 = Array(o3); ++r3 < o3; )
        a3[r3] = e5[r3 + t3];
      return a3;
    };
    var sn2 = function(e5, t3, n3) {
      var r3 = e5.length;
      return n3 = n3 === void 0 ? r3 : n3, !t3 && n3 >= r3 ? e5 : an2(e5, t3, n3);
    }, ln2 = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
    var un2 = function(e5) {
      return ln2.test(e5);
    };
    var cn2 = function(e5) {
      return e5.split("");
    }, dn2 = "[\\ud800-\\udfff]", fn2 = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", pn2 = "\\ud83c[\\udffb-\\udfff]", hn2 = "[^\\ud800-\\udfff]", mn2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", vn2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", gn2 = "(?:" + fn2 + "|" + pn2 + ")?", yn2 = "[\\ufe0e\\ufe0f]?", bn2 = yn2 + gn2 + ("(?:\\u200d(?:" + [hn2, mn2, vn2].join("|") + ")" + yn2 + gn2 + ")*"), wn2 = "(?:" + [hn2 + fn2 + "?", fn2, mn2, vn2, dn2].join("|") + ")", kn2 = RegExp(pn2 + "(?=" + pn2 + ")|" + wn2 + bn2, "g");
    var xn2 = function(e5) {
      return e5.match(kn2) || [];
    };
    var Sn2 = function(e5) {
      return un2(e5) ? xn2(e5) : cn2(e5);
    };
    var _n2 = function(e5) {
      return function(t3) {
        return t3 == null ? void 0 : t3[e5];
      };
    }, En2 = Math.floor;
    var Pn2 = function(e5, t3) {
      var n3 = "";
      if (!e5 || t3 < 1 || t3 > 9007199254740991)
        return n3;
      do {
        t3 % 2 && (n3 += e5), (t3 = En2(t3 / 2)) && (e5 += e5);
      } while (t3);
      return n3;
    }, Cn2 = _n2("length"), jn2 = "[\\ud800-\\udfff]", On2 = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", Tn2 = "\\ud83c[\\udffb-\\udfff]", In2 = "[^\\ud800-\\udfff]", Dn2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rn2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Nn2 = "(?:" + On2 + "|" + Tn2 + ")?", An2 = "[\\ufe0e\\ufe0f]?", zn2 = An2 + Nn2 + ("(?:\\u200d(?:" + [In2, Dn2, Rn2].join("|") + ")" + An2 + Nn2 + ")*"), Mn2 = "(?:" + [In2 + On2 + "?", On2, Dn2, Rn2, jn2].join("|") + ")", Ln2 = RegExp(Tn2 + "(?=" + Tn2 + ")|" + Mn2 + zn2, "g");
    var Fn2 = function(e5) {
      for (var t3 = Ln2.lastIndex = 0; Ln2.test(e5); )
        ++t3;
      return t3;
    };
    var $n2 = function(e5) {
      return un2(e5) ? Fn2(e5) : Cn2(e5);
    }, Bn2 = Math.ceil;
    var Vn2 = function(e5, t3) {
      var n3 = (t3 = t3 === void 0 ? " " : Ze2(t3)).length;
      if (n3 < 2)
        return n3 ? Pn2(t3, e5) : t3;
      var r3 = Pn2(t3, Bn2(e5 / $n2(t3)));
      return un2(t3) ? sn2(Sn2(r3), 0, e5).join("") : r3.slice(0, e5);
    };
    var Un2 = function(e5, t3, n3) {
      e5 = et2(e5);
      var r3 = (t3 = Gt2(t3)) ? $n2(e5) : 0;
      return t3 && r3 < t3 ? Vn2(t3 - r3, n3) + e5 : e5;
    };
    function Hn2() {
      let e5, t3;
      const n3 = new Promise((n4, o3) => {
        e5 = (e6) => {
          n4(e6), r3.status = "resolved";
        }, t3 = (e6) => {
          o3(e6), r3.status = "rejected";
        };
      }), r3 = { resolve: e5, reject: t3, promise: n3, status: "pending" };
      return r3;
    }
    var Wn2 = () => {
    }, qn2 = y2(g), Kn2 = y2(g);
    var Yn2 = ["normal", "reverse", "alternate", "alternateReverse"], Xn2 = class {
      constructor(e5) {
        this._fps = e5;
      }
      formatSubUnitForGrid(e5) {
        const t3 = e5 % 1, n3 = 1 / this._fps;
        return Math.round(t3 / n3) + "f";
      }
      formatFullUnitForGrid(e5) {
        let t3 = e5, n3 = "";
        if (t3 >= Jn2) {
          n3 += Math.floor(t3 / Jn2) + "h", t3 %= Jn2;
        }
        if (t3 >= Qn2) {
          n3 += Math.floor(t3 / Qn2) + "m", t3 %= Qn2;
        }
        if (t3 >= Gn2) {
          n3 += Math.floor(t3 / Gn2) + "s", t3 %= Gn2;
        }
        const r3 = 1 / this._fps;
        if (t3 >= r3) {
          n3 += Math.floor(t3 / r3) + "f", t3 %= r3;
        }
        return n3.length === 0 ? "0s" : n3;
      }
      formatForPlayhead(e5) {
        let t3 = e5, n3 = "";
        if (t3 >= Jn2) {
          const e6 = Math.floor(t3 / Jn2);
          n3 += Un2(e6.toString(), 2, "0") + "h", t3 %= Jn2;
        }
        if (t3 >= Qn2) {
          const e6 = Math.floor(t3 / Qn2);
          n3 += Un2(e6.toString(), 2, "0") + "m", t3 %= Qn2;
        } else
          n3.length > 0 && (n3 += "00m");
        if (t3 >= Gn2) {
          const e6 = Math.floor(t3 / Gn2);
          n3 += Un2(e6.toString(), 2, "0") + "s", t3 %= Gn2;
        } else
          n3 += "00s";
        const r3 = 1 / this._fps;
        if (t3 >= r3) {
          const e6 = Math.round(t3 / r3);
          n3 += Un2(e6.toString(), 2, "0") + "f", t3 %= r3;
        } else if (t3 / r3 > 0.98) {
          n3 += Un2(1 .toString(), 2, "0") + "f", t3 %= r3;
        } else
          n3 += "00f";
        return n3.length === 0 ? "00s00f" : n3;
      }
      formatBasic(e5) {
        return e5.toFixed(2) + "s";
      }
    }, Gn2 = 1, Qn2 = 60 * Gn2, Jn2 = 60 * Qn2, Zn2 = {};
    function er2(e5, t3) {
      return e5.length <= t3 ? e5 : e5.substr(0, t3 - 3) + "...";
    }
    v2(Zn2, { boolean: () => ur2, compound: () => sr2, number: () => lr2, string: () => cr2, stringLiteral: () => dr2 });
    var tr2 = (e5) => typeof e5 == "string" ? `string("${er2(e5, 10)}")` : typeof e5 == "number" ? `number(${er2(String(e5), 10)})` : e5 === null ? "null" : e5 === void 0 ? "undefined" : typeof e5 == "boolean" ? String(e5) : Array.isArray(e5) ? "array" : typeof e5 == "object" ? "object" : "unknown", nr2 = Symbol("TheatrePropType_Basic");
    function rr2(e5) {
      return typeof e5 == "object" && !!e5 && e5[nr2] === "TheatrePropType";
    }
    function or2(e5) {
      if (typeof e5 == "number")
        return lr2(e5);
      if (typeof e5 == "boolean")
        return ur2(e5);
      if (typeof e5 == "string")
        return cr2(e5);
      if (typeof e5 == "object" && e5) {
        if (rr2(e5))
          return e5;
        if (on2(e5))
          return sr2(e5);
        throw new zt2(`This value is not a valid prop type: ${tr2(e5)}`);
      }
      throw new zt2(`This value is not a valid prop type: ${tr2(e5)}`);
    }
    function ar(e5) {
      const t3 = {};
      if (typeof e5 != "object" || !e5)
        throw new zt2(`t.compound() expects an object, like: {x: 10}. ${tr2(e5)} given.`);
      for (const n3 of Object.keys(e5)) {
        if (true) {
          if (typeof n3 != "string")
            throw new zt2(`t.compound()'s keys must be all strings. ${tr2(n3)} given.`);
          if (n3.length === 0 || !n3.match(/^\w+$/))
            throw new zt2(`compound key ${tr2(n3)} is invalid. The keys must be alphanumeric and start with a letter.`);
          if (n3.length > 64)
            throw new zt2(`compound key ${tr2(n3)} is too long.`);
        }
        const r3 = e5[n3];
        rr2(r3) ? t3[n3] = r3 : t3[n3] = or2(r3);
      }
      return t3;
    }
    var ir2 = (e5, t3) => {
      if (true) {
        if (t3 === void 0)
          return;
        if (typeof t3 != "object" || t3 === null)
          throw new Error(`opts in ${e5} must either be undefined or an object.`);
        if (Object.prototype.hasOwnProperty.call(t3, "label")) {
          const { label: n3 } = t3;
          if (typeof n3 != "string")
            throw new Error(`opts.label in ${e5} should be a string. ${tr2(n3)} given.`);
          if (n3.trim().length !== n3.length)
            throw new Error(`opts.label in ${e5} should not start/end with whitespace. "${n3}" given.`);
          if (n3.length === 0)
            throw new Error(`opts.label in ${e5} should not be an empty string. If you wish to have no label, remove opts.label from opts.`);
        }
      }
    }, sr2 = (e5, t3) => (ir2("t.compound(props, opts)", t3), { type: "compound", props: ar(e5), valueType: null, [nr2]: "TheatrePropType", label: t3 == null ? void 0 : t3.label }), lr2 = (e5, t3) => {
      var n3;
      if (true) {
        if (ir2("t.number(defaultValue, opts)", t3), typeof e5 != "number" || !isFinite(e5))
          throw new Error(`Argument defaultValue in t.number(defaultValue) must be a number. ${tr2(e5)} given.`);
        if (typeof t3 == "object" && t3 !== null) {
          if (Object.prototype.hasOwnProperty.call(t3, "range")) {
            if (!Array.isArray(t3.range))
              throw new Error(`opts.range in t.number(defaultValue, opts) must be a tuple of two numbers. ${tr2(t3.range)} given.`);
            if (t3.range.length !== 2)
              throw new Error(`opts.range in t.number(defaultValue, opts) must have two elements. ${t3.range.length} given.`);
            if (!t3.range.every((e6) => typeof e6 == "number" && !isNaN(e6)))
              throw new Error("opts.range in t.number(defaultValue, opts) must be a tuple of two numbers.");
            if (t3.range[0] >= t3.range[1])
              throw new Error(`opts.range[0] in t.number(defaultValue, opts) must be smaller than opts.range[1]. Given: ${JSON.stringify(t3.range)}`);
          }
          if (Object.prototype.hasOwnProperty.call(t3, "nudgeMultiplier") && (typeof t3.nudgeMultiplier != "number" || !isFinite(t3.nudgeMultiplier)))
            throw new Error(`opts.nudgeMultiplier in t.number(defaultValue, opts) must be a finite number. ${tr2(t3.nudgeMultiplier)} given.`);
          if (Object.prototype.hasOwnProperty.call(t3, "nudgeFn") && typeof (t3 == null ? void 0 : t3.nudgeFn) != "function")
            throw new Error(`opts.nudgeFn in t.number(defaultValue, opts) must be a function. ${tr2(t3.nudgeFn)} given.`);
        }
      }
      return p(f({ type: "number", valueType: 0, default: e5, [nr2]: "TheatrePropType" }, t3 || {}), { label: t3 == null ? void 0 : t3.label, nudgeFn: (n3 = t3 == null ? void 0 : t3.nudgeFn) != null ? n3 : fr2, nudgeMultiplier: typeof (t3 == null ? void 0 : t3.nudgeMultiplier) == "number" ? t3.nudgeMultiplier : 1 });
    }, ur2 = (e5, t3) => {
      if (ir2("t.boolean(defaultValue, opts)", t3), typeof e5 != "boolean")
        throw new Error(`defaultValue in t.boolean(defaultValue) must be a boolean. ${tr2(e5)} given.`);
      return { type: "boolean", default: e5, valueType: null, [nr2]: "TheatrePropType", label: t3 == null ? void 0 : t3.label };
    }, cr2 = (e5, t3) => {
      if (ir2("t.string(defaultValue, opts)", t3), typeof e5 != "string")
        throw new Error(`defaultValue in t.string(defaultValue) must be a string. ${tr2(e5)} given.`);
      return { type: "string", default: e5, valueType: null, [nr2]: "TheatrePropType", label: t3 == null ? void 0 : t3.label };
    };
    function dr2(e5, t3, n3) {
      var r3;
      return { type: "stringLiteral", default: e5, options: f({}, t3), [nr2]: "TheatrePropType", valueType: null, as: (r3 = n3 == null ? void 0 : n3.as) != null ? r3 : "menu", label: n3 == null ? void 0 : n3.label };
    }
    var fr2 = ({ config: e5, deltaX: t3, deltaFraction: n3, magnitude: r3 }) => {
      const { range: o3 } = e5;
      return o3 ? n3 * (o3[1] - o3[0]) * r3 * e5.nudgeMultiplier : t3 * r3 * e5.nudgeMultiplier;
    };
    function pr2(e5, t3) {
      const n3 = e5.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/, " / ");
      if (false)
        return n3;
      const r3 = ((e6) => {
        if (typeof e6 != "string")
          return `it is not a string. (it is a ${typeof e6})`;
        const t4 = e6.split(/\//);
        if (t4.length === 0)
          return "it is empty.";
        for (let e7 = 0; e7 < t4.length; e7++) {
          const n4 = t4[e7].trim();
          if (n4.length === 0)
            return `the component #${e7 + 1} is empty.`;
          if (n4.length > 32)
            return `the component '${n4}' must have 32 characters or less.`;
        }
      })(n3);
      if (r3)
        throw new zt2(`The path in ${t3}(${typeof e5 == "string" ? `"${e5}"` : ""}) is invalid because ${r3}`);
      return e5 !== n3 && bt2.warn(`The path in ${t3}("${e5}") was sanitised to "${n3}".`), n3;
    }
    var hr2, mr2, vr2 = y2(S2()), gr2 = /* @__PURE__ */ new WeakMap(), yr2 = y2(g), br2 = y2(g), wr2 = y2(g), kr2 = (e5) => new Promise((t3) => setTimeout(t3, e5));
    function xr2(e5) {
      for (var t3 = arguments.length, n3 = Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      if (true) {
        var o3 = so2[e5], a3 = o3 ? typeof o3 == "function" ? o3.apply(null, n3) : o3 : "unknown error nr: " + e5;
        throw Error("[Immer] " + a3);
      }
      throw Error("[Immer] minified error nr: " + e5 + (n3.length ? " " + n3.map(function(e6) {
        return "'" + e6 + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function Sr2(e5) {
      return !!e5 && !!e5[io2];
    }
    function _r2(e5) {
      return !!e5 && (function(e6) {
        if (!e6 || typeof e6 != "object")
          return false;
        var t3 = Object.getPrototypeOf(e6);
        if (t3 === null)
          return true;
        var n3 = Object.hasOwnProperty.call(t3, "constructor") && t3.constructor;
        return n3 === Object || typeof n3 == "function" && Function.toString.call(n3) === lo2;
      }(e5) || Array.isArray(e5) || !!e5[ao2] || !!e5.constructor[ao2] || Or2(e5) || Tr2(e5));
    }
    function Er2(e5, t3, n3) {
      n3 === void 0 && (n3 = false), Pr2(e5) === 0 ? (n3 ? Object.keys : uo2)(e5).forEach(function(r3) {
        n3 && typeof r3 == "symbol" || t3(r3, e5[r3], e5);
      }) : e5.forEach(function(n4, r3) {
        return t3(r3, n4, e5);
      });
    }
    function Pr2(e5) {
      var t3 = e5[io2];
      return t3 ? t3.i > 3 ? t3.i - 4 : t3.i : Array.isArray(e5) ? 1 : Or2(e5) ? 2 : Tr2(e5) ? 3 : 0;
    }
    function Cr2(e5, t3) {
      return Pr2(e5) === 2 ? e5.has(t3) : Object.prototype.hasOwnProperty.call(e5, t3);
    }
    function jr2(e5, t3, n3) {
      var r3 = Pr2(e5);
      r3 === 2 ? e5.set(t3, n3) : r3 === 3 ? (e5.delete(t3), e5.add(n3)) : e5[t3] = n3;
    }
    function Or2(e5) {
      return to2 && e5 instanceof Map;
    }
    function Tr2(e5) {
      return no2 && e5 instanceof Set;
    }
    function Ir2(e5) {
      return e5.o || e5.t;
    }
    function Dr2(e5) {
      if (Array.isArray(e5))
        return Array.prototype.slice.call(e5);
      var t3 = co2(e5);
      delete t3[io2];
      for (var n3 = uo2(t3), r3 = 0; r3 < n3.length; r3++) {
        var o3 = n3[r3], a3 = t3[o3];
        a3.writable === false && (a3.writable = true, a3.configurable = true), (a3.get || a3.set) && (t3[o3] = { configurable: true, writable: true, enumerable: a3.enumerable, value: e5[o3] });
      }
      return Object.create(Object.getPrototypeOf(e5), t3);
    }
    function Rr2(e5, t3) {
      return t3 === void 0 && (t3 = false), Ar2(e5) || Sr2(e5) || !_r2(e5) || (Pr2(e5) > 1 && (e5.set = e5.add = e5.clear = e5.delete = Nr2), Object.freeze(e5), t3 && Er2(e5, function(e6, t4) {
        return Rr2(t4, true);
      }, true)), e5;
    }
    function Nr2() {
      xr2(2);
    }
    function Ar2(e5) {
      return e5 == null || typeof e5 != "object" || Object.isFrozen(e5);
    }
    function zr2(e5) {
      var t3 = fo2[e5];
      return t3 || xr2(18, e5), t3;
    }
    function Mr2() {
      return mr2 || xr2(0), mr2;
    }
    function Lr2(e5, t3) {
      t3 && (zr2("Patches"), e5.u = [], e5.s = [], e5.v = t3);
    }
    function Fr2(e5) {
      $r2(e5), e5.p.forEach(Vr2), e5.p = null;
    }
    function $r2(e5) {
      e5 === mr2 && (mr2 = e5.l);
    }
    function Br2(e5) {
      return mr2 = { p: [], l: mr2, h: e5, m: true, _: 0 };
    }
    function Vr2(e5) {
      var t3 = e5[io2];
      t3.i === 0 || t3.i === 1 ? t3.j() : t3.O = true;
    }
    function Ur2(e5, t3) {
      t3._ = t3.p.length;
      var n3 = t3.p[0], r3 = e5 !== void 0 && e5 !== n3;
      return t3.h.g || zr2("ES5").S(t3, e5, r3), r3 ? (n3[io2].P && (Fr2(t3), xr2(4)), _r2(e5) && (e5 = Hr2(t3, e5), t3.l || qr2(t3, e5)), t3.u && zr2("Patches").M(n3[io2], e5, t3.u, t3.s)) : e5 = Hr2(t3, n3, []), Fr2(t3), t3.u && t3.v(t3.u, t3.s), e5 !== oo2 ? e5 : void 0;
    }
    function Hr2(e5, t3, n3) {
      if (Ar2(t3))
        return t3;
      var r3 = t3[io2];
      if (!r3)
        return Er2(t3, function(o4, a3) {
          return Wr2(e5, r3, t3, o4, a3, n3);
        }, true), t3;
      if (r3.A !== e5)
        return t3;
      if (!r3.P)
        return qr2(e5, r3.t, true), r3.t;
      if (!r3.I) {
        r3.I = true, r3.A._--;
        var o3 = r3.i === 4 || r3.i === 5 ? r3.o = Dr2(r3.k) : r3.o;
        Er2(r3.i === 3 ? new Set(o3) : o3, function(t4, a3) {
          return Wr2(e5, r3, o3, t4, a3, n3);
        }), qr2(e5, o3, false), n3 && e5.u && zr2("Patches").R(r3, n3, e5.u, e5.s);
      }
      return r3.o;
    }
    function Wr2(e5, t3, n3, r3, o3, a3) {
      if (o3 === n3 && xr2(5), Sr2(o3)) {
        var i3 = Hr2(e5, o3, a3 && t3 && t3.i !== 3 && !Cr2(t3.D, r3) ? a3.concat(r3) : void 0);
        if (jr2(n3, r3, i3), !Sr2(i3))
          return;
        e5.m = false;
      }
      if (_r2(o3) && !Ar2(o3)) {
        if (!e5.h.F && e5._ < 1)
          return;
        Hr2(e5, o3), t3 && t3.A.l || qr2(e5, o3);
      }
    }
    function qr2(e5, t3, n3) {
      n3 === void 0 && (n3 = false), e5.h.F && e5.m && Rr2(t3, n3);
    }
    function Kr2(e5, t3) {
      var n3 = e5[io2];
      return (n3 ? Ir2(n3) : e5)[t3];
    }
    function Yr2(e5, t3) {
      if (t3 in e5)
        for (var n3 = Object.getPrototypeOf(e5); n3; ) {
          var r3 = Object.getOwnPropertyDescriptor(n3, t3);
          if (r3)
            return r3;
          n3 = Object.getPrototypeOf(n3);
        }
    }
    function Xr2(e5) {
      e5.P || (e5.P = true, e5.l && Xr2(e5.l));
    }
    function Gr2(e5) {
      e5.o || (e5.o = Dr2(e5.t));
    }
    function Qr2(e5, t3, n3) {
      var r3 = Or2(t3) ? zr2("MapSet").N(t3, n3) : Tr2(t3) ? zr2("MapSet").T(t3, n3) : e5.g ? function(e6, t4) {
        var n4 = Array.isArray(e6), r4 = { i: n4 ? 1 : 0, A: t4 ? t4.A : Mr2(), P: false, I: false, D: {}, l: t4, t: e6, k: null, o: null, j: null, C: false }, o3 = r4, a3 = po2;
        n4 && (o3 = [r4], a3 = ho2);
        var i3 = Proxy.revocable(o3, a3), s3 = i3.revoke, l3 = i3.proxy;
        return r4.k = l3, r4.j = s3, l3;
      }(t3, n3) : zr2("ES5").J(t3, n3);
      return (n3 ? n3.A : Mr2()).p.push(r3), r3;
    }
    function Jr2(e5) {
      return Sr2(e5) || xr2(22, e5), function e6(t3) {
        if (!_r2(t3))
          return t3;
        var n3, r3 = t3[io2], o3 = Pr2(t3);
        if (r3) {
          if (!r3.P && (r3.i < 4 || !zr2("ES5").K(r3)))
            return r3.t;
          r3.I = true, n3 = Zr2(t3, o3), r3.I = false;
        } else
          n3 = Zr2(t3, o3);
        return Er2(n3, function(t4, o4) {
          r3 && function(e7, t5) {
            return Pr2(e7) === 2 ? e7.get(t5) : e7[t5];
          }(r3.t, t4) === o4 || jr2(n3, t4, e6(o4));
        }), o3 === 3 ? new Set(n3) : n3;
      }(e5);
    }
    function Zr2(e5, t3) {
      switch (t3) {
        case 2:
          return new Map(e5);
        case 3:
          return Array.from(e5);
      }
      return Dr2(e5);
    }
    var eo2 = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol", to2 = typeof Map != "undefined", no2 = typeof Set != "undefined", ro2 = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined", oo2 = eo2 ? Symbol.for("immer-nothing") : ((hr2 = {})["immer-nothing"] = true, hr2), ao2 = eo2 ? Symbol.for("immer-draftable") : "__$immer_draftable", io2 = eo2 ? Symbol.for("immer-state") : "__$immer_state", so2 = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(e5) {
      return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e5;
    }, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(e5) {
      return "Cannot apply patch, path doesn't resolve: " + e5;
    }, 16: 'Sets cannot have "replace" patches.', 17: function(e5) {
      return "Unsupported patch operation: " + e5;
    }, 18: function(e5) {
      return "The plugin for '" + e5 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + e5 + "()` when initializing your application.";
    }, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(e5) {
      return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + e5 + "'";
    }, 22: function(e5) {
      return "'current' expects a draft, got: " + e5;
    }, 23: function(e5) {
      return "'original' expects a draft, got: " + e5;
    }, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, lo2 = "" + Object.prototype.constructor, uo2 = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e5) {
      return Object.getOwnPropertyNames(e5).concat(Object.getOwnPropertySymbols(e5));
    } : Object.getOwnPropertyNames, co2 = Object.getOwnPropertyDescriptors || function(e5) {
      var t3 = {};
      return uo2(e5).forEach(function(n3) {
        t3[n3] = Object.getOwnPropertyDescriptor(e5, n3);
      }), t3;
    }, fo2 = {}, po2 = { get: function(e5, t3) {
      if (t3 === io2)
        return e5;
      var n3, r3, o3, a3 = Ir2(e5);
      if (!Cr2(a3, t3))
        return n3 = e5, (o3 = Yr2(a3, t3)) ? "value" in o3 ? o3.value : (r3 = o3.get) === null || r3 === void 0 ? void 0 : r3.call(n3.k) : void 0;
      var i3 = a3[t3];
      return e5.I || !_r2(i3) ? i3 : i3 === Kr2(e5.t, t3) ? (Gr2(e5), e5.o[t3] = Qr2(e5.A.h, i3, e5)) : i3;
    }, has: function(e5, t3) {
      return t3 in Ir2(e5);
    }, ownKeys: function(e5) {
      return Reflect.ownKeys(Ir2(e5));
    }, set: function(e5, t3, n3) {
      var r3 = Yr2(Ir2(e5), t3);
      if (r3 == null ? void 0 : r3.set)
        return r3.set.call(e5.k, n3), true;
      if (!e5.P) {
        var o3 = Kr2(Ir2(e5), t3), a3 = o3 == null ? void 0 : o3[io2];
        if (a3 && a3.t === n3)
          return e5.o[t3] = n3, e5.D[t3] = false, true;
        if (function(e6, t4) {
          return e6 === t4 ? e6 !== 0 || 1 / e6 == 1 / t4 : e6 != e6 && t4 != t4;
        }(n3, o3) && (n3 !== void 0 || Cr2(e5.t, t3)))
          return true;
        Gr2(e5), Xr2(e5);
      }
      return e5.o[t3] === n3 && typeof n3 != "number" && (n3 !== void 0 || t3 in e5.o) || (e5.o[t3] = n3, e5.D[t3] = true, true);
    }, deleteProperty: function(e5, t3) {
      return Kr2(e5.t, t3) !== void 0 || t3 in e5.t ? (e5.D[t3] = false, Gr2(e5), Xr2(e5)) : delete e5.D[t3], e5.o && delete e5.o[t3], true;
    }, getOwnPropertyDescriptor: function(e5, t3) {
      var n3 = Ir2(e5), r3 = Reflect.getOwnPropertyDescriptor(n3, t3);
      return r3 ? { writable: true, configurable: e5.i !== 1 || t3 !== "length", enumerable: r3.enumerable, value: n3[t3] } : r3;
    }, defineProperty: function() {
      xr2(11);
    }, getPrototypeOf: function(e5) {
      return Object.getPrototypeOf(e5.t);
    }, setPrototypeOf: function() {
      xr2(12);
    } }, ho2 = {};
    Er2(po2, function(e5, t3) {
      ho2[e5] = function() {
        return arguments[0] = arguments[0][0], t3.apply(this, arguments);
      };
    }), ho2.deleteProperty = function(e5, t3) {
      return isNaN(parseInt(t3)) && xr2(13), po2.deleteProperty.call(this, e5[0], t3);
    }, ho2.set = function(e5, t3, n3) {
      return t3 !== "length" && isNaN(parseInt(t3)) && xr2(14), po2.set.call(this, e5[0], t3, n3, e5[0]);
    };
    var mo2 = function() {
      function e5(e6) {
        var t4 = this;
        this.g = ro2, this.F = true, this.produce = function(e7, n3, r3) {
          if (typeof e7 == "function" && typeof n3 != "function") {
            var o3 = n3;
            n3 = e7;
            var a3 = t4;
            return function(e8) {
              var t5 = this;
              e8 === void 0 && (e8 = o3);
              for (var r4 = arguments.length, i4 = Array(r4 > 1 ? r4 - 1 : 0), s4 = 1; s4 < r4; s4++)
                i4[s4 - 1] = arguments[s4];
              return a3.produce(e8, function(e9) {
                var r5;
                return (r5 = n3).call.apply(r5, [t5, e9].concat(i4));
              });
            };
          }
          var i3;
          if (typeof n3 != "function" && xr2(6), r3 !== void 0 && typeof r3 != "function" && xr2(7), _r2(e7)) {
            var s3 = Br2(t4), l3 = Qr2(t4, e7, void 0), u3 = true;
            try {
              i3 = n3(l3), u3 = false;
            } finally {
              u3 ? Fr2(s3) : $r2(s3);
            }
            return typeof Promise != "undefined" && i3 instanceof Promise ? i3.then(function(e8) {
              return Lr2(s3, r3), Ur2(e8, s3);
            }, function(e8) {
              throw Fr2(s3), e8;
            }) : (Lr2(s3, r3), Ur2(i3, s3));
          }
          if (!e7 || typeof e7 != "object") {
            if ((i3 = n3(e7)) === oo2)
              return;
            return i3 === void 0 && (i3 = e7), t4.F && Rr2(i3, true), i3;
          }
          xr2(21, e7);
        }, this.produceWithPatches = function(e7, n3) {
          return typeof e7 == "function" ? function(n4) {
            for (var r4 = arguments.length, o4 = Array(r4 > 1 ? r4 - 1 : 0), a3 = 1; a3 < r4; a3++)
              o4[a3 - 1] = arguments[a3];
            return t4.produceWithPatches(n4, function(t5) {
              return e7.apply(void 0, [t5].concat(o4));
            });
          } : [t4.produce(e7, n3, function(e8, t5) {
            r3 = e8, o3 = t5;
          }), r3, o3];
          var r3, o3;
        }, typeof (e6 == null ? void 0 : e6.useProxies) == "boolean" && this.setUseProxies(e6.useProxies), typeof (e6 == null ? void 0 : e6.autoFreeze) == "boolean" && this.setAutoFreeze(e6.autoFreeze);
      }
      var t3 = e5.prototype;
      return t3.createDraft = function(e6) {
        _r2(e6) || xr2(8), Sr2(e6) && (e6 = Jr2(e6));
        var t4 = Br2(this), n3 = Qr2(this, e6, void 0);
        return n3[io2].C = true, $r2(t4), n3;
      }, t3.finishDraft = function(e6, t4) {
        var n3 = e6 && e6[io2];
        n3 && n3.C || xr2(9), n3.I && xr2(10);
        var r3 = n3.A;
        return Lr2(r3, t4), Ur2(void 0, r3);
      }, t3.setAutoFreeze = function(e6) {
        this.F = e6;
      }, t3.setUseProxies = function(e6) {
        e6 && !ro2 && xr2(20), this.g = e6;
      }, t3.applyPatches = function(e6, t4) {
        var n3;
        for (n3 = t4.length - 1; n3 >= 0; n3--) {
          var r3 = t4[n3];
          if (r3.path.length === 0 && r3.op === "replace") {
            e6 = r3.value;
            break;
          }
        }
        var o3 = zr2("Patches").$;
        return Sr2(e6) ? o3(e6, t4) : this.produce(e6, function(e7) {
          return o3(e7, t4.slice(n3 + 1));
        });
      }, e5;
    }(), vo2 = new mo2();
    vo2.produce, vo2.produceWithPatches.bind(vo2), vo2.setAutoFreeze.bind(vo2), vo2.setUseProxies.bind(vo2), vo2.applyPatches.bind(vo2), vo2.createDraft.bind(vo2), vo2.finishDraft.bind(vo2);
    var go2 = { currentProjectStateDefinitionVersion: "0.4.0" };
    async function yo2(e5, t3, n3) {
      await kr2(0), e5.transaction(({ drafts: e6 }) => {
        var r3;
        const o3 = t3.address.projectId;
        function a3() {
          e6.ephemeral.coreByProject[o3].loadingState = { type: "loaded" };
        }
        e6.ephemeral.coreByProject[o3] = { lastExportedObject: null, loadingState: { type: "loading" } }, e6.ahistoric.coreByProject[o3] = { ahistoricStuff: "" };
        const i3 = (Sr2(s3 = e6.historic) || xr2(23, s3), r3 = s3[io2].t) == null ? void 0 : r3.coreByProject[t3.address.projectId];
        var s3, l3, u3;
        i3 ? n3 && i3.revisionHistory.indexOf(n3.revisionHistory[0]) == -1 ? (l3 = n3, e6.ephemeral.coreByProject[o3].loadingState = { type: "browserStateIsNotBasedOnDiskState", onDiskState: l3 }) : a3() : n3 ? (u3 = n3, e6.ephemeral.coreByProject[o3].loadingState = { type: "loaded" }, e6.historic.coreByProject[o3] = u3) : (e6.ephemeral.coreByProject[o3].loadingState = { type: "loaded" }, e6.historic.coreByProject[o3] = { sheetsById: {}, definitionVersion: go2.currentProjectStateDefinitionVersion, revisionHistory: [] });
      });
    }
    var bo2 = (e5, t3, n3) => typeof e5 != "string" ? `${t3} must be a string. ${tr2(e5)} given.` : e5.trim().length !== e5.length ? `${t3} must not have leading or trailing spaces. '${e5}' given.` : e5.length < n3[0] || e5.length > n3[1] ? `${t3} must have between ${n3[0]} and ${n3[1]} characters. '${e5}' given.` : void 0, wo2 = y2(S2()), ko2 = y2(g), xo2 = y2(g);
    function So2(e5, t3 = {}) {
      const n3 = ((e6, t4) => {
        var n4 = {};
        for (var r4 in e6)
          u2.call(e6, r4) && t4.indexOf(r4) < 0 && (n4[r4] = e6[r4]);
        if (e6 != null && s2)
          for (var r4 of s2(e6))
            t4.indexOf(r4) < 0 && c2.call(e6, r4) && (n4[r4] = e6[r4]);
        return n4;
      })(t3, []), r3 = C2.get(e5);
      if (r3) {
        if (!(0, wo2.default)(t3, r3.config))
          throw new Error(`You seem to have called Theatre.getProject("${e5}", config) twice, with different config objects. This is disallowed because changing the config of a project on the fly can lead to hard-to-debug issues.

You can fix this by either calling Theatre.getProject() once per projectId, or calling it multiple times but with the exact same config.`);
        return r3.publicApi;
      }
      return ((e6, t4, n4 = false) => {
        const r4 = bo2(e6, t4, [3, 32]);
        if (typeof r4 == "string" && n4)
          throw new zt2(r4);
      })(e5, "projectName in Theatre.getProject(projectName)", true), Po2(e5), t3.state && (true ? _o2(e5, t3.state) : Eo2(e5, t3.state)), new class {
        get type() {
          return "Theatre_Project_PublicAPI";
        }
        constructor(e6, t4 = {}) {
          T2(this, new class {
            constructor(e7, t5 = {}, n4) {
              var r4;
              this.config = t5, this.publicApi = n4, b2(this, "pointers"), b2(this, "_pointerProxies"), b2(this, "address"), b2(this, "_readyDeferred"), b2(this, "_sheetTemplates", new wr2.Atom({})), b2(this, "sheetTemplatesP", this._sheetTemplates.pointer), b2(this, "_studio"), b2(this, "type", "Theatre_Project"), this.address = { projectId: e7 };
              const o3 = new wr2.Atom({ ahistoric: { ahistoricStuff: "" }, historic: (r4 = t5.state) != null ? r4 : { sheetsById: {}, definitionVersion: go2.currentProjectStateDefinitionVersion, revisionHistory: [] }, ephemeral: { loadingState: { type: "loaded" }, lastExportedObject: null } });
              this._pointerProxies = { historic: new br2.PointerProxy(o3.pointer.historic), ahistoric: new br2.PointerProxy(o3.pointer.ahistoric), ephemeral: new br2.PointerProxy(o3.pointer.ephemeral) }, this.pointers = { historic: this._pointerProxies.historic.pointer, ahistoric: this._pointerProxies.ahistoric.pointer, ephemeral: this._pointerProxies.ephemeral.pointer }, C2.add(e7, this), this._readyDeferred = Hn2(), t5.state ? setTimeout(() => {
                this._studio || this._readyDeferred.resolve(void 0);
              }, 0) : setTimeout(() => {
                if (!this._studio)
                  throw new Error(`Argument config.state in Theatre.getProject("${e7}", config) is empty. This is fine while you are using @theatre/core along with @theatre/sutdio. But since @theatre/studio is not loaded, the state of project "${e7}" will be empty.

To fix this, you need to add @theatre/studio into the bundle and export the projet's state. Learn how to do that at https://docs.theatrejs.com/in-depth/#exporting`);
              }, 1e3);
            }
            attachToStudio(e7) {
              if (this._studio) {
                if (this._studio !== e7)
                  throw new Error(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);
                console.warn(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);
              } else
                this._studio = e7, e7.initialized.then(async () => {
                  await yo2(e7, this, this.config.state), this._pointerProxies.historic.setPointer(e7.atomP.historic.coreByProject[this.address.projectId]), this._pointerProxies.ahistoric.setPointer(e7.atomP.ahistoric.coreByProject[this.address.projectId]), this._pointerProxies.ephemeral.setPointer(e7.atomP.ephemeral.coreByProject[this.address.projectId]), this._readyDeferred.resolve(void 0);
                });
            }
            get isAttachedToStudio() {
              return !!this._studio;
            }
            get ready() {
              return this._readyDeferred.promise;
            }
            isReady() {
              return this._readyDeferred.status === "resolved";
            }
            getOrCreateSheet(e7, t5 = "default") {
              let n4 = this._sheetTemplates.getState()[e7];
              return n4 || (n4 = new class {
                constructor(e8, t6) {
                  this.project = e8, b2(this, "type", "Theatre_SheetTemplate"), b2(this, "address"), b2(this, "_instances", new Rt2.Atom({})), b2(this, "instancesP", this._instances.pointer), b2(this, "_objectTemplates", new Rt2.Atom({})), b2(this, "objectTemplatesP", this._objectTemplates.pointer), this.address = p(f({}, e8.address), { sheetId: t6 });
                }
                getInstance(e8) {
                  let t6 = this._instances.getState()[e8];
                  return t6 || (t6 = new class {
                    constructor(e9, t7) {
                      this.template = e9, this.instanceId = t7, b2(this, "_objects", new yr2.Atom({})), b2(this, "_sequence"), b2(this, "address"), b2(this, "publicApi"), b2(this, "project"), b2(this, "objectsP", this._objects.pointer), b2(this, "type", "Theatre_Sheet"), this.project = e9.project, this.address = p(f({}, e9.address), { sheetInstanceId: this.instanceId }), this.publicApi = new class {
                        get type() {
                          return "Theatre_Sheet_PublicAPI";
                        }
                        constructor(e10) {
                          T2(this, e10);
                        }
                        object(e10, t8) {
                          const n5 = O2(this), r4 = pr2(e10, `sheet.object("${e10}", ...)`), o3 = n5.getObject(r4);
                          if (o3) {
                            if (true) {
                              const n6 = gr2.get(o3);
                              if (n6 && !(0, vr2.default)(t8, n6))
                                throw new Error(`You seem to have called sheet.object("${e10}", config) twice, with different values for \`config\`. This is disallowed because changing the config of an object on the fly would make it difficult to reason about.

You can fix this by either re-using the existing object, or calling sheet.object("${e10}", config) with the same config.`);
                            }
                            return o3.publicApi;
                          }
                          {
                            const e11 = sr2(t8), o4 = n5.createObject(r4, null, e11);
                            return gr2.set(o4, t8), o4.publicApi;
                          }
                        }
                        get sequence() {
                          return O2(this).getSequence().publicApi;
                        }
                        get project() {
                          return O2(this).project.publicApi;
                        }
                        get address() {
                          return f({}, O2(this).address);
                        }
                      }(this);
                    }
                    createObject(e9, t7, n5) {
                      const r4 = this.template.getObjectTemplate(e9, t7, n5).createInstance(this, t7, n5);
                      return this._objects.setIn([e9], r4), r4;
                    }
                    getObject(e9) {
                      return this._objects.getState()[e9];
                    }
                    getSequence() {
                      if (!this._sequence) {
                        const e9 = (0, yr2.valueDerivation)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length).map((e10) => typeof e10 == "number" ? e10 : 10), t7 = (0, yr2.valueDerivation)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit).map((e10) => typeof e10 == "number" ? e10 : 30);
                        this._sequence = new class {
                          constructor(e10, t8, n5, r4, o3) {
                            this._project = e10, this._sheet = t8, this._lengthD = n5, this._subUnitsPerUnitD = r4, b2(this, "address"), b2(this, "publicApi"), b2(this, "_playbackControllerBox"), b2(this, "_statePointerDerivation"), b2(this, "_positionD"), b2(this, "_positionFormatterD"), b2(this, "_playableRangeD"), b2(this, "pointer", (0, Mt2.pointer)({ root: this, path: [] })), b2(this, "$$isIdentityDerivationProvider", true), b2(this, "closestGridPosition", (e11) => {
                              const t9 = 1 / this.subUnitsPerUnit;
                              return parseFloat((Math.round(e11 / t9) * t9).toFixed(3));
                            }), this.address = p(f({}, this._sheet.address), { sequenceName: "default" }), this.publicApi = new class {
                              get type() {
                                return "Theatre_Sequence_PublicAPI";
                              }
                              constructor(e11) {
                                T2(this, e11);
                              }
                              play(e11) {
                                if (O2(this)._project.isReady())
                                  return O2(this).play(e11);
                                {
                                  bt2.warn("You seem to have called sequence.play() before the project has finished loading.\nThis would **not** a problem in production when using '@theatre/core', since Theatre loads instantly in core mode. However, when using '@theatre/studio', it takes a few milliseconds for it to load your project's state, before which your sequences cannot start playing.\n\nTo fix this, simply defer calling sequence.play() until after the project is loaded, like this:\nproject.ready.then(() => {\n  sequence.play()\n})");
                                  const e12 = Hn2();
                                  return e12.resolve(true), e12.promise;
                                }
                              }
                              pause() {
                                O2(this).pause();
                              }
                              get position() {
                                return O2(this).position;
                              }
                              set position(e11) {
                                O2(this).position = e11;
                              }
                              async attachAudio(e11) {
                                const { audioContext: t9, destinationNode: n6, decodedBuffer: r5, gainNode: o4 } = await async function(e12) {
                                  function t10() {
                                    if (e12.audioContext)
                                      return Promise.resolve(e12.audioContext);
                                    const t11 = new AudioContext();
                                    return t11.state === "running" ? Promise.resolve(t11) : new Promise((e13) => {
                                      const n8 = () => {
                                        t11.resume();
                                      }, r7 = ["mousedown", "keydown", "touchstart"], o6 = { capture: true, passive: false };
                                      r7.forEach((e14) => {
                                        window.addEventListener(e14, n8, o6);
                                      }), t11.addEventListener("statechange", () => {
                                        t11.state === "running" && (r7.forEach((e14) => {
                                          window.removeEventListener(e14, n8, o6);
                                        }), e13(t11));
                                      });
                                    });
                                  }
                                  async function n7() {
                                    if (e12.source instanceof AudioBuffer)
                                      return e12.source;
                                    const t11 = Hn2();
                                    if (typeof e12.source != "string")
                                      throw new Error("Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.");
                                    let n8, o6, a5;
                                    try {
                                      n8 = await fetch(e12.source);
                                    } catch (t12) {
                                      throw console.error(t12), new Error(`Could not fetch '${e12.source}'. Network error logged above.`);
                                    }
                                    try {
                                      o6 = await n8.arrayBuffer();
                                    } catch (t12) {
                                      throw console.error(t12), new Error(`Could not read '${e12.source}' as an arrayBuffer.`);
                                    }
                                    (await r6).decodeAudioData(o6, t11.resolve, t11.reject);
                                    try {
                                      a5 = await t11.promise;
                                    } catch (t12) {
                                      throw console.error(t12), new Error(`Could not decode ${e12.source} as an audio file.`);
                                    }
                                    return a5;
                                  }
                                  const r6 = t10(), o5 = n7(), [a4, i3] = await Promise.all([r6, o5]), s3 = e12.destinationNode || a4.destination, l3 = a4.createGain();
                                  return l3.connect(s3), { audioContext: a4, decodedBuffer: i3, gainNode: l3, destinationNode: s3 };
                                }(e11), a3 = new class {
                                  constructor(e12, t10, n7, r6) {
                                    this._ticker = e12, this._decodedBuffer = t10, this._audioContext = n7, this._nodeDestination = r6, b2(this, "_mainGain"), b2(this, "_state", new Kn2.Atom({ position: 0, playing: false })), b2(this, "statePointer"), b2(this, "_stopPlayCallback", Wn2), this.statePointer = this._state.pointer, this._mainGain = this._audioContext.createGain(), this._mainGain.connect(this._nodeDestination);
                                  }
                                  get _playing() {
                                    return this._state.getState().playing;
                                  }
                                  set _playing(e12) {
                                    this._state.setIn(["playing"], e12);
                                  }
                                  destroy() {
                                  }
                                  pause() {
                                    this._stopPlayCallback(), this._playing = false, this._stopPlayCallback = Wn2;
                                  }
                                  gotoPosition(e12) {
                                    this._updatePositionInState(e12);
                                  }
                                  _updatePositionInState(e12) {
                                    this._state.reduceState(["position"], () => e12);
                                  }
                                  getCurrentPosition() {
                                    return this._state.getState().position;
                                  }
                                  play(e12, t10, n7, r6) {
                                    this._playing && this.pause(), this._playing = true;
                                    const o5 = this._ticker;
                                    let a4 = this.getCurrentPosition();
                                    const i3 = t10[1] - t10[0];
                                    if (r6 !== "normal")
                                      throw new zt2(`Audio-controlled sequences can only be played in the "normal" direction. '${r6}' given.`);
                                    (a4 < t10[0] || a4 > t10[1] || a4 === t10[1]) && this._updatePositionInState(t10[0]), a4 = this.getCurrentPosition();
                                    const s3 = Hn2(), l3 = this._audioContext.createBufferSource();
                                    l3.buffer = this._decodedBuffer, l3.connect(this._mainGain), l3.playbackRate.value = n7, e12 > 1e3 && (console.warn("Audio-controlled sequences cannot have an iterationCount larger than 1000. It has been clamped to 1000."), e12 = 1e3), e12 > 1 && (l3.loop = true, l3.loopStart = t10[0], l3.loopEnd = t10[1]);
                                    const u3 = o5.time;
                                    let c3 = a4 - t10[0];
                                    const d2 = i3 * e12;
                                    l3.start(0, a4, d2 - c3);
                                    const f2 = (e13) => {
                                      const r7 = Math.max(e13 - u3, 0) / 1e3, o6 = Math.min(r7 * n7 + c3, d2);
                                      if (o6 !== d2) {
                                        let e14 = o6 / i3 % 1 * i3;
                                        this._updatePositionInState(e14 + t10[0]), h3();
                                      } else
                                        this._updatePositionInState(t10[1]), this._playing = false, p2(), s3.resolve(true);
                                    }, p2 = () => {
                                      l3.stop(), l3.disconnect();
                                    };
                                    this._stopPlayCallback = () => {
                                      p2(), o5.offThisOrNextTick(f2), o5.offNextTick(f2), this._playing && s3.resolve(false);
                                    };
                                    const h3 = () => o5.onNextTick(f2);
                                    return o5.onThisOrNextTick(f2), s3.promise;
                                  }
                                }(Tt2, r5, t9, o4);
                                return O2(this).replacePlaybackController(a3), { audioContext: t9, destinationNode: n6, decodedBuffer: r5, gainNode: o4 };
                              }
                              get pointer() {
                                return O2(this).pointer;
                              }
                            }(this), this._playbackControllerBox = new Lt2.Box(o3 != null ? o3 : new class {
                              constructor(e11) {
                                this._ticker = e11, b2(this, "_stopPlayCallback", Wn2), b2(this, "_state", new qn2.Atom({ position: 0, playing: false })), b2(this, "statePointer"), this.statePointer = this._state.pointer;
                              }
                              destroy() {
                              }
                              pause() {
                                this._stopPlayCallback(), this.playing = false, this._stopPlayCallback = Wn2;
                              }
                              gotoPosition(e11) {
                                this._updatePositionInState(e11);
                              }
                              _updatePositionInState(e11) {
                                this._state.reduceState(["position"], () => e11);
                              }
                              getCurrentPosition() {
                                return this._state.getState().position;
                              }
                              get playing() {
                                return this._state.getState().playing;
                              }
                              set playing(e11) {
                                this._state.setIn(["playing"], e11);
                              }
                              play(e11, t9, n6, r5) {
                                this.playing && this.pause(), this.playing = true;
                                const o4 = this._ticker, a3 = t9[1] - t9[0];
                                {
                                  const e12 = this.getCurrentPosition();
                                  e12 < t9[0] || e12 > t9[1] ? r5 === "normal" || r5 === "alternate" ? this._updatePositionInState(t9[0]) : r5 !== "reverse" && r5 !== "alternateReverse" || this._updatePositionInState(t9[1]) : r5 === "normal" || r5 === "alternate" ? e12 === t9[1] && this._updatePositionInState(t9[0]) : e12 === t9[0] && this._updatePositionInState(t9[1]);
                                }
                                const i3 = Hn2(), s3 = o4.time, l3 = a3 * e11;
                                let u3 = this.getCurrentPosition() - t9[0];
                                r5 !== "reverse" && r5 !== "alternateReverse" || (u3 = t9[1] - this.getCurrentPosition());
                                const c3 = (o5) => {
                                  const c4 = Math.max(o5 - s3, 0) / 1e3, f2 = Math.min(c4 * n6 + u3, l3);
                                  if (f2 !== l3) {
                                    const e12 = Math.floor(f2 / a3);
                                    let n7 = f2 / a3 % 1 * a3;
                                    if (r5 !== "normal")
                                      if (r5 === "reverse")
                                        n7 = a3 - n7;
                                      else {
                                        const t10 = e12 % 2 == 0;
                                        r5 === "alternate" ? t10 || (n7 = a3 - n7) : t10 && (n7 = a3 - n7);
                                      }
                                    this._updatePositionInState(n7 + t9[0]), d2();
                                  } else {
                                    if (r5 === "normal")
                                      this._updatePositionInState(t9[1]);
                                    else if (r5 === "reverse")
                                      this._updatePositionInState(t9[0]);
                                    else {
                                      const n7 = (e11 - 1) % 2 == 0;
                                      r5 === "alternate" ? n7 ? this._updatePositionInState(t9[1]) : this._updatePositionInState(t9[0]) : n7 ? this._updatePositionInState(t9[0]) : this._updatePositionInState(t9[1]);
                                    }
                                    this.playing = false, i3.resolve(true);
                                  }
                                };
                                this._stopPlayCallback = () => {
                                  o4.offThisOrNextTick(c3), o4.offNextTick(c3), this.playing && i3.resolve(false);
                                };
                                const d2 = () => o4.onNextTick(c3);
                                return o4.onThisOrNextTick(c3), i3.promise;
                              }
                            }(Tt2)), this._statePointerDerivation = this._playbackControllerBox.derivation.map((e11) => e11.statePointer), this._positionD = this._statePointerDerivation.flatMap((e11) => (0, Lt2.valueDerivation)(e11.position)), this._positionFormatterD = this._subUnitsPerUnitD.map((e11) => new Xn2(e11));
                          }
                          getIdentityDerivation(e10) {
                            if (e10.length === 0)
                              return (0, Lt2.prism)(() => ({ length: (0, Lt2.val)(this.pointer.length), playing: (0, Lt2.val)(this.pointer.playing), position: (0, Lt2.val)(this.pointer.position) }));
                            if (e10.length > 1)
                              return (0, Lt2.prism)(() => {
                              });
                            const [t8] = e10;
                            return t8 === "length" ? this._lengthD : t8 === "position" ? this._positionD : t8 === "playing" ? (0, Lt2.prism)(() => (0, Lt2.val)(this._statePointerDerivation.getValue().playing)) : (0, Lt2.prism)(() => {
                            });
                          }
                          get positionFormatter() {
                            return this._positionFormatterD.getValue();
                          }
                          get derivationToStatePointer() {
                            return this._statePointerDerivation;
                          }
                          get length() {
                            return this._lengthD.getValue();
                          }
                          get positionDerivation() {
                            return this._positionD;
                          }
                          get position() {
                            return this._playbackControllerBox.get().getCurrentPosition();
                          }
                          get subUnitsPerUnit() {
                            return this._subUnitsPerUnitD.getValue();
                          }
                          get positionSnappedToGrid() {
                            return this.closestGridPosition(this.position);
                          }
                          set position(e10) {
                            let t8 = e10;
                            this.pause(), typeof t8 != "number" && (bt2.error(`value t in sequence.position = t must be a number. ${typeof t8} given`), t8 = 0), t8 < 0 && (bt2.error(`sequence.position must be a positive number. ${t8} given`), t8 = 0), t8 > this.length && (t8 = this.length);
                            const n5 = this.length;
                            this._playbackControllerBox.get().gotoPosition(t8 > n5 ? n5 : t8);
                          }
                          getDurationCold() {
                            return this._lengthD.getValue();
                          }
                          get playing() {
                            return (0, Lt2.val)(this._playbackControllerBox.get().statePointer.playing);
                          }
                          _makeRangeFromSequenceTemplate() {
                            return (0, Lt2.prism)(() => [0, (0, Lt2.val)(this._lengthD)]);
                          }
                          async play(e10) {
                            const t8 = this.length, n5 = e10 && e10.range ? e10.range : [0, t8];
                            if (true) {
                              if (typeof n5[0] != "number" || n5[0] < 0)
                                throw new zt2(`Argument conf.range[0] in sequence.play(conf) must be a positive number. ${JSON.stringify(n5[0])} given.`);
                              if (n5[0] >= t8)
                                throw new zt2(`Argument conf.range[0] in sequence.play(conf) cannot be longer than the duration of the sequence, which is ${t8}s. ${JSON.stringify(n5[0])} given.`);
                              if (typeof n5[1] != "number" || n5[1] <= 0)
                                throw new zt2(`Argument conf.range[1] in sequence.play(conf) must be a number larger than zero. ${JSON.stringify(n5[1])} given.`);
                              if (n5[1] > t8 && (bt2.warn(`Argument conf.range[1] in sequence.play(conf) cannot be longer than the duration of the sequence, which is ${t8}s. ${JSON.stringify(n5[1])} given.`), n5[1] = t8), n5[1] <= n5[0])
                                throw new zt2(`Argument conf.range[1] in sequence.play(conf) must be larger than conf.range[0]. ${JSON.stringify(n5)} given.`);
                            }
                            const r4 = e10 && typeof e10.iterationCount == "number" ? e10.iterationCount : 1;
                            if (!(Number.isInteger(r4) && r4 > 0) && r4 !== 1 / 0)
                              throw new zt2(`Argument conf.iterationCount in sequence.play(conf) must be an integer larger than 0. ${JSON.stringify(r4)} given.`);
                            const o3 = e10 && e10.rate !== void 0 ? e10.rate : 1;
                            if (true) {
                              if (typeof o3 != "number" || o3 === 0)
                                throw new zt2(`Argument conf.rate in sequence.play(conf) must be a number larger than 0. ${JSON.stringify(o3)} given.`);
                              if (o3 < 0)
                                throw new zt2(`Argument conf.rate in sequence.play(conf) must be a number larger than 0. ${JSON.stringify(o3)} given. If you want the animation to play backwards, try setting conf.direction to 'reverse' or 'alternateReverse'.`);
                            }
                            const a3 = e10 && e10.direction ? e10.direction : "normal";
                            if (Yn2.indexOf(a3) === -1)
                              throw new zt2(`Argument conf.direction in sequence.play(conf) must be one of ${JSON.stringify(Yn2)}. ${JSON.stringify(a3)} given. ${function(e11, t9, n6 = "Did you mean ", r5 = "?") {
                                const o4 = (0, Nt2.default)(e11, t9, { threshold: 0.7 });
                                return o4 ? n6 + JSON.stringify(o4) + r5 : "";
                              }(a3, Yn2)}`);
                            return await this._play(r4, [n5[0], n5[1]], o3, a3);
                          }
                          _play(e10, t8, n5, r4) {
                            return this._playbackControllerBox.get().play(e10, t8, n5, r4);
                          }
                          pause() {
                            this._playbackControllerBox.get().pause();
                          }
                          replacePlaybackController(e10) {
                            this.pause();
                            const t8 = this._playbackControllerBox.get();
                            this._playbackControllerBox.set(e10);
                            const n5 = t8.getCurrentPosition();
                            t8.destroy(), e10.gotoPosition(n5);
                          }
                        }(this.template.project, this, e9, t7);
                      }
                      return this._sequence;
                    }
                  }(this, e8), this._instances.setIn([e8], t6)), t6;
                }
                getObjectTemplate(e8, t6, n5) {
                  let r4 = this._objectTemplates.getState()[e8];
                  return r4 || (r4 = new class {
                    constructor(e9, t7, n6, r5) {
                      this.sheetTemplate = e9, b2(this, "address"), b2(this, "type", "Theatre_SheetObjectTemplate"), b2(this, "_config"), b2(this, "_cache", new at2()), b2(this, "project"), this.address = p(f({}, e9.address), { objectKey: t7 }), this._config = new it2.Atom(r5), this.project = e9.project;
                    }
                    get config() {
                      return this._config.getState();
                    }
                    createInstance(e9, t7, n6) {
                      return this._config.setState(n6), new class {
                        constructor(e10, t8, n7) {
                          this.sheet = e10, this.template = t8, this.nativeObject = n7, b2(this, "$$isIdentityDerivationProvider", true), b2(this, "address"), b2(this, "publicApi"), b2(this, "_initialValue", new jt2.Atom({})), b2(this, "_cache", new at2()), this.address = p(f({}, t8.address), { sheetInstanceId: e10.address.sheetInstanceId }), this.publicApi = new class {
                            constructor(e11) {
                              b2(this, "_cache", new at2()), T2(this, e11);
                            }
                            get type() {
                              return "Theatre_SheetObject_PublicAPI";
                            }
                            get props() {
                              return O2(this).propsP;
                            }
                            get sheet() {
                              return O2(this).sheet.publicApi;
                            }
                            get project() {
                              return O2(this).sheet.project.publicApi;
                            }
                            get address() {
                              return f({}, O2(this).address);
                            }
                            _valuesDerivation() {
                              return this._cache.get("onValuesChangeDerivation", () => {
                                const e11 = O2(this);
                                return (0, Dt2.prism)(() => (0, Dt2.val)(e11.getValues().getValue()));
                              });
                            }
                            onValuesChange(e11) {
                              return this._valuesDerivation().tapImmediate(Tt2, e11);
                            }
                            get value() {
                              return this._valuesDerivation().getValue();
                            }
                            set initialValue(e11) {
                              O2(this).setInitialValue(e11);
                            }
                          }(this);
                        }
                        get type() {
                          return "Theatre_SheetObject";
                        }
                        getValues() {
                          return this._cache.get("getValues()", () => (0, jt2.prism)(() => {
                            const e10 = Et2((0, jt2.val)(this.template.getDefaultValues()), (0, jt2.val)(this._initialValue.pointer), jt2.prism.memo("withInitialCache", () => /* @__PURE__ */ new WeakMap(), []));
                            let t8, n7 = Et2(e10, (0, jt2.val)(this.template.getStaticValues()), jt2.prism.memo("withStatics", () => /* @__PURE__ */ new WeakMap(), []));
                            {
                              const e11 = jt2.prism.memo("seq", () => this.getSequencedValues(), []), r5 = jt2.prism.memo("withSeqsCache", () => /* @__PURE__ */ new WeakMap(), []);
                              t8 = (0, jt2.val)((0, jt2.val)(e11)), n7 = Et2(n7, t8, r5);
                            }
                            return ((e11, t9) => {
                              const n8 = Ct2.prism.memo(e11, () => new Ct2.Atom(t9), []);
                              return n8.setState(t9), n8;
                            })("finalAtom", n7).pointer;
                          }));
                        }
                        getValueByPointer(e10) {
                          const t8 = (0, jt2.val)(this.getValues()), { path: n7 } = (0, jt2.getPointerParts)(e10);
                          return (0, jt2.val)(Pt2(t8, n7));
                        }
                        getIdentityDerivation(e10) {
                          return (0, jt2.prism)(() => {
                            const t8 = (0, jt2.val)(this.getValues());
                            return (0, jt2.val)(Pt2(t8, e10));
                          });
                        }
                        getSequencedValues() {
                          return (0, jt2.prism)(() => {
                            const e10 = jt2.prism.memo("tracksToProcess", () => this.template.getArrayOfValidSequenceTracks(), []), t8 = (0, jt2.val)(e10), n7 = new jt2.Atom({});
                            return jt2.prism.effect("processTracks", () => {
                              const e11 = [];
                              for (const { trackId: r5, pathToProp: o3 } of t8) {
                                const t9 = this._trackIdToDerivation(r5), a3 = () => {
                                  n7.setIn(o3, t9.getValue());
                                }, i3 = t9.changesWithoutValues().tap(a3);
                                a3(), e11.push(i3);
                              }
                              return () => {
                                for (const t9 of e11)
                                  t9();
                              };
                            }, t8), n7.pointer;
                          });
                        }
                        _trackIdToDerivation(e10) {
                          return kt2(this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[e10], this.sheet.getSequence().positionDerivation);
                        }
                        get propsP() {
                          return this._cache.get("propsP", () => (0, jt2.pointer)({ root: this, path: [] }));
                        }
                        validateValue(e10, t8) {
                        }
                        setInitialValue(e10) {
                          this.validateValue(this.propsP, e10), this._initialValue.setState(e10);
                        }
                      }(e9, this, t7);
                    }
                    overrideConfig(e9) {
                      this._config.setState(e9);
                    }
                    getDefaultValues() {
                      return this._cache.get("getDefaultValues()", () => (0, it2.prism)(() => function(e9) {
                        return gt2(e9);
                      }((0, it2.val)(this._config.pointer))));
                    }
                    getStaticValues() {
                      return this._cache.get("getDerivationOfStatics", () => (0, it2.prism)(() => {
                        const e9 = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId];
                        return (0, it2.val)(e9.staticOverrides.byObject[this.address.objectKey]) || {};
                      }));
                    }
                    getArrayOfValidSequenceTracks() {
                      return this._cache.get("getArrayOfValidSequenceTracks", () => (0, it2.prism)(() => {
                        const e9 = (0, it2.val)(this.getDefaultValues()), t7 = this.project.pointers.historic.sheetsById[this.address.sheetId], n6 = (0, it2.val)(t7.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath), r5 = [];
                        if (!n6)
                          return I2;
                        for (const [t8, o3] of Object.entries(n6)) {
                          let n7;
                          try {
                            n7 = JSON.parse(t8);
                          } catch (e10) {
                            bt2.warn(`property ${JSON.stringify(t8)} cannot be parsed. Skipping.`);
                            continue;
                          }
                          typeof ot2(e9, n7) == "number" && r5.push({ pathToProp: n7, trackId: o3 });
                        }
                        return r5.length === 0 ? I2 : r5;
                      }));
                    }
                    getMapOfValidSequenceTracks_forStudio() {
                      return this._cache.get("getMapOfValidSequenceTracks_forStudio", () => this.getArrayOfValidSequenceTracks().map((e9) => {
                        let t7 = {};
                        for (const { pathToProp: n6, trackId: r5 } of e9)
                          mt2(t7, n6, r5);
                        return t7;
                      }));
                    }
                    getDefaultsAtPointer(e9) {
                      const { path: t7 } = (0, it2.getPointerParts)(e9), n6 = function(e10, t8) {
                        return t8.length === 0 ? e10 : ot2(e10, t8);
                      }(this.getDefaultValues().getValue(), t7);
                      return n6;
                    }
                  }(this, e8, t6, n5), this._objectTemplates.setIn([e8], r4)), r4;
                }
              }(this, e7), this._sheetTemplates.setIn([e7], n4)), n4.getInstance(t5);
            }
          }(e6, t4, this));
        }
        get ready() {
          return O2(this).ready;
        }
        get isReady() {
          return O2(this).isReady();
        }
        get address() {
          return f({}, O2(this).address);
        }
        sheet(e6, t4 = "default") {
          const n4 = pr2(e6, "project.sheet");
          return ((e7, t5, n5 = false) => {
            const r4 = bo2(e7, "instanceId in project.sheet(sheetId, instanceId)", [1, 32]);
            if (typeof r4 == "string" && n5)
              throw new zt2(r4);
          })(t4, 0, true), O2(this).getOrCreateSheet(n4, t4).publicApi;
        }
      }(e5, n3);
    }
    var _o2 = (e5, t3) => {
      if (Array.isArray(t3) || t3 == null || t3.definitionVersion !== go2.currentProjectStateDefinitionVersion)
        throw new zt2(`Error validating conf.state in Theatre.getProject(${JSON.stringify(e5)}, conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://docs.theatrejs.com`);
    }, Eo2 = (e5, t3) => {
      _o2(e5, t3);
    }, Po2 = (e5) => {
      if (typeof e5 != "string")
        throw new zt2(`Argument 'projectId' in \`Theatre.getProject(projectId, ...)\` must be a string. Instead, it was ${tr2(e5)}.`);
      const t3 = e5.trim();
      if (t3.length !== e5.length)
        throw new zt2(`Argument 'projectId' in \`Theatre.getProject("${e5}", ...)\` should not have surrounding whitespace.`);
      if (t3.length < 3)
        throw new zt2(`Argument 'projectId' in \`Theatre.getProject("${e5}", ...)\` should be at least 3 characters long.`);
    };
    function Co2(e5, t3) {
      if ((0, ko2.isPointer)(e5)) {
        return (0, xo2.valueDerivation)(e5).tapImmediate(Tt2, t3);
      }
      if ((0, xo2.isDerivation)(e5))
        return e5.tapImmediate(Tt2, t3);
      throw new Error("Called onChange(p) where p is neither a pointer nor a derivation.");
    }
    function jo2(e5) {
      if ((0, ko2.isPointer)(e5))
        return (0, xo2.valueDerivation)(e5).getValue();
      throw new Error("Called val(p) where p is not a pointer.");
    }
    var Oo2 = "__TheatreJS_CoreBundle";
    !function() {
      if (typeof window == "undefined")
        return;
      const e5 = window[Oo2];
      if (e5 !== void 0)
        throw typeof e5 == "object" && e5 && typeof e5.version == "string" ? new Error("It seems that the module '@theatre/core' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of theatre in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre/core' multiple times. But those imports should point to the same module.") : new Error(`The variable window.${Oo2} seems to be already set by a module other than @theatre/core.`);
      const t3 = new class {
        constructor() {
          b2(this, "_studio");
        }
        get type() {
          return "Theatre_CoreBundle";
        }
        get version() {
          return "0.4.7";
        }
        getBitsForStudio(e6, t4) {
          if (this._studio)
            throw new Error("@theatre/core is already attached to @theatre/studio");
          this._studio = e6, t4({ projectsP: C2.atom.pointer.projects, privateAPI: O2, coreExports: _2 });
        }
      }();
      window[Oo2] = t3;
      const n3 = window.__TheatreJS_StudioBundle;
      n3 && n3 !== null && n3.type === "Theatre_StudioBundle" && n3.registerCoreBundle(t3);
    }();
  }(v);
  var Ce = { exports: {} };
  var je = { exports: {} };
  var Oe = {};
  var Te = Object.getOwnPropertySymbols;
  var Ie = Object.prototype.hasOwnProperty;
  var De = Object.prototype.propertyIsEnumerable;
  function Re(e4) {
    if (e4 == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(e4);
  }
  var Ne = function() {
    try {
      if (!Object.assign)
        return false;
      var e4 = new String("abc");
      if (e4[5] = "de", Object.getOwnPropertyNames(e4)[0] === "5")
        return false;
      for (var t2 = {}, n2 = 0; n2 < 10; n2++)
        t2["_" + String.fromCharCode(n2)] = n2;
      var r2 = Object.getOwnPropertyNames(t2).map(function(e5) {
        return t2[e5];
      });
      if (r2.join("") !== "0123456789")
        return false;
      var o2 = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(e5) {
        o2[e5] = e5;
      }), Object.keys(Object.assign({}, o2)).join("") === "abcdefghijklmnopqrst";
    } catch (e5) {
      return false;
    }
  }() ? Object.assign : function(e4, t2) {
    for (var n2, r2, o2 = Re(e4), a2 = 1; a2 < arguments.length; a2++) {
      for (var i2 in n2 = Object(arguments[a2]))
        Ie.call(n2, i2) && (o2[i2] = n2[i2]);
      if (Te) {
        r2 = Te(n2);
        for (var s2 = 0; s2 < r2.length; s2++)
          De.call(n2, r2[s2]) && (o2[r2[s2]] = n2[r2[s2]]);
      }
    }
    return o2;
  };
  var Ae = Ne;
  var ze = 60103;
  var Me = 60106;
  Oe.Fragment = 60107, Oe.StrictMode = 60108, Oe.Profiler = 60114;
  var Le = 60109;
  var Fe = 60110;
  var $e = 60112;
  Oe.Suspense = 60113;
  var Be = 60115;
  var Ve = 60116;
  if (typeof Symbol == "function" && Symbol.for) {
    Ue = Symbol.for;
    ze = Ue("react.element"), Me = Ue("react.portal"), Oe.Fragment = Ue("react.fragment"), Oe.StrictMode = Ue("react.strict_mode"), Oe.Profiler = Ue("react.profiler"), Le = Ue("react.provider"), Fe = Ue("react.context"), $e = Ue("react.forward_ref"), Oe.Suspense = Ue("react.suspense"), Be = Ue("react.memo"), Ve = Ue("react.lazy");
  }
  var Ue;
  var He = typeof Symbol == "function" && Symbol.iterator;
  function We(e4) {
    for (var t2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e4, n2 = 1; n2 < arguments.length; n2++)
      t2 += "&args[]=" + encodeURIComponent(arguments[n2]);
    return "Minified React error #" + e4 + "; visit " + t2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var qe = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } };
  var Ke = {};
  function Ye(e4, t2, n2) {
    this.props = e4, this.context = t2, this.refs = Ke, this.updater = n2 || qe;
  }
  function Xe() {
  }
  function Ge(e4, t2, n2) {
    this.props = e4, this.context = t2, this.refs = Ke, this.updater = n2 || qe;
  }
  Ye.prototype.isReactComponent = {}, Ye.prototype.setState = function(e4, t2) {
    if (typeof e4 != "object" && typeof e4 != "function" && e4 != null)
      throw Error(We(85));
    this.updater.enqueueSetState(this, e4, t2, "setState");
  }, Ye.prototype.forceUpdate = function(e4) {
    this.updater.enqueueForceUpdate(this, e4, "forceUpdate");
  }, Xe.prototype = Ye.prototype;
  var Qe = Ge.prototype = new Xe();
  Qe.constructor = Ge, Ae(Qe, Ye.prototype), Qe.isPureReactComponent = true;
  var Je = { current: null };
  var Ze = Object.prototype.hasOwnProperty;
  var et = { key: true, ref: true, __self: true, __source: true };
  function tt(e4, t2, n2) {
    var r2, o2 = {}, a2 = null, i2 = null;
    if (t2 != null)
      for (r2 in t2.ref !== void 0 && (i2 = t2.ref), t2.key !== void 0 && (a2 = "" + t2.key), t2)
        Ze.call(t2, r2) && !et.hasOwnProperty(r2) && (o2[r2] = t2[r2]);
    var s2 = arguments.length - 2;
    if (s2 === 1)
      o2.children = n2;
    else if (1 < s2) {
      for (var l2 = Array(s2), u2 = 0; u2 < s2; u2++)
        l2[u2] = arguments[u2 + 2];
      o2.children = l2;
    }
    if (e4 && e4.defaultProps)
      for (r2 in s2 = e4.defaultProps)
        o2[r2] === void 0 && (o2[r2] = s2[r2]);
    return { $$typeof: ze, type: e4, key: a2, ref: i2, props: o2, _owner: Je.current };
  }
  function nt(e4) {
    return typeof e4 == "object" && e4 !== null && e4.$$typeof === ze;
  }
  var rt = /\/+/g;
  function ot(e4, t2) {
    return typeof e4 == "object" && e4 !== null && e4.key != null ? function(e5) {
      var t3 = { "=": "=0", ":": "=2" };
      return "$" + e5.replace(/[=:]/g, function(e6) {
        return t3[e6];
      });
    }("" + e4.key) : t2.toString(36);
  }
  function at(e4, t2, n2, r2, o2) {
    var a2 = typeof e4;
    a2 !== "undefined" && a2 !== "boolean" || (e4 = null);
    var i2 = false;
    if (e4 === null)
      i2 = true;
    else
      switch (a2) {
        case "string":
        case "number":
          i2 = true;
          break;
        case "object":
          switch (e4.$$typeof) {
            case ze:
            case Me:
              i2 = true;
          }
      }
    if (i2)
      return o2 = o2(i2 = e4), e4 = r2 === "" ? "." + ot(i2, 0) : r2, Array.isArray(o2) ? (n2 = "", e4 != null && (n2 = e4.replace(rt, "$&/") + "/"), at(o2, t2, n2, "", function(e5) {
        return e5;
      })) : o2 != null && (nt(o2) && (o2 = function(e5, t3) {
        return { $$typeof: ze, type: e5.type, key: t3, ref: e5.ref, props: e5.props, _owner: e5._owner };
      }(o2, n2 + (!o2.key || i2 && i2.key === o2.key ? "" : ("" + o2.key).replace(rt, "$&/") + "/") + e4)), t2.push(o2)), 1;
    if (i2 = 0, r2 = r2 === "" ? "." : r2 + ":", Array.isArray(e4))
      for (var s2 = 0; s2 < e4.length; s2++) {
        var l2 = r2 + ot(a2 = e4[s2], s2);
        i2 += at(a2, t2, n2, l2, o2);
      }
    else if (l2 = function(e5) {
      return e5 === null || typeof e5 != "object" ? null : typeof (e5 = He && e5[He] || e5["@@iterator"]) == "function" ? e5 : null;
    }(e4), typeof l2 == "function")
      for (e4 = l2.call(e4), s2 = 0; !(a2 = e4.next()).done; )
        i2 += at(a2 = a2.value, t2, n2, l2 = r2 + ot(a2, s2++), o2);
    else if (a2 === "object")
      throw t2 = "" + e4, Error(We(31, t2 === "[object Object]" ? "object with keys {" + Object.keys(e4).join(", ") + "}" : t2));
    return i2;
  }
  function it(e4, t2, n2) {
    if (e4 == null)
      return e4;
    var r2 = [], o2 = 0;
    return at(e4, r2, "", "", function(e5) {
      return t2.call(n2, e5, o2++);
    }), r2;
  }
  function st(e4) {
    if (e4._status === -1) {
      var t2 = e4._result;
      t2 = t2(), e4._status = 0, e4._result = t2, t2.then(function(t3) {
        e4._status === 0 && (t3 = t3.default, e4._status = 1, e4._result = t3);
      }, function(t3) {
        e4._status === 0 && (e4._status = 2, e4._result = t3);
      });
    }
    if (e4._status === 1)
      return e4._result;
    throw e4._result;
  }
  var lt = { current: null };
  function ut() {
    var e4 = lt.current;
    if (e4 === null)
      throw Error(We(321));
    return e4;
  }
  var ct = { ReactCurrentDispatcher: lt, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: Je, IsSomeRendererActing: { current: false }, assign: Ae };
  Oe.Children = { map: it, forEach: function(e4, t2, n2) {
    it(e4, function() {
      t2.apply(this, arguments);
    }, n2);
  }, count: function(e4) {
    var t2 = 0;
    return it(e4, function() {
      t2++;
    }), t2;
  }, toArray: function(e4) {
    return it(e4, function(e5) {
      return e5;
    }) || [];
  }, only: function(e4) {
    if (!nt(e4))
      throw Error(We(143));
    return e4;
  } }, Oe.Component = Ye, Oe.PureComponent = Ge, Oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ct, Oe.cloneElement = function(e4, t2, n2) {
    if (e4 == null)
      throw Error(We(267, e4));
    var r2 = Ae({}, e4.props), o2 = e4.key, a2 = e4.ref, i2 = e4._owner;
    if (t2 != null) {
      if (t2.ref !== void 0 && (a2 = t2.ref, i2 = Je.current), t2.key !== void 0 && (o2 = "" + t2.key), e4.type && e4.type.defaultProps)
        var s2 = e4.type.defaultProps;
      for (l2 in t2)
        Ze.call(t2, l2) && !et.hasOwnProperty(l2) && (r2[l2] = t2[l2] === void 0 && s2 !== void 0 ? s2[l2] : t2[l2]);
    }
    var l2 = arguments.length - 2;
    if (l2 === 1)
      r2.children = n2;
    else if (1 < l2) {
      s2 = Array(l2);
      for (var u2 = 0; u2 < l2; u2++)
        s2[u2] = arguments[u2 + 2];
      r2.children = s2;
    }
    return { $$typeof: ze, type: e4.type, key: o2, ref: a2, props: r2, _owner: i2 };
  }, Oe.createContext = function(e4, t2) {
    return t2 === void 0 && (t2 = null), (e4 = { $$typeof: Fe, _calculateChangedBits: t2, _currentValue: e4, _currentValue2: e4, _threadCount: 0, Provider: null, Consumer: null }).Provider = { $$typeof: Le, _context: e4 }, e4.Consumer = e4;
  }, Oe.createElement = tt, Oe.createFactory = function(e4) {
    var t2 = tt.bind(null, e4);
    return t2.type = e4, t2;
  }, Oe.createRef = function() {
    return { current: null };
  }, Oe.forwardRef = function(e4) {
    return { $$typeof: $e, render: e4 };
  }, Oe.isValidElement = nt, Oe.lazy = function(e4) {
    return { $$typeof: Ve, _payload: { _status: -1, _result: e4 }, _init: st };
  }, Oe.memo = function(e4, t2) {
    return { $$typeof: Be, type: e4, compare: t2 === void 0 ? null : t2 };
  }, Oe.useCallback = function(e4, t2) {
    return ut().useCallback(e4, t2);
  }, Oe.useContext = function(e4, t2) {
    return ut().useContext(e4, t2);
  }, Oe.useDebugValue = function() {
  }, Oe.useEffect = function(e4, t2) {
    return ut().useEffect(e4, t2);
  }, Oe.useImperativeHandle = function(e4, t2, n2) {
    return ut().useImperativeHandle(e4, t2, n2);
  }, Oe.useLayoutEffect = function(e4, t2) {
    return ut().useLayoutEffect(e4, t2);
  }, Oe.useMemo = function(e4, t2) {
    return ut().useMemo(e4, t2);
  }, Oe.useReducer = function(e4, t2, n2) {
    return ut().useReducer(e4, t2, n2);
  }, Oe.useRef = function(e4) {
    return ut().useRef(e4);
  }, Oe.useState = function(e4) {
    return ut().useState(e4);
  }, Oe.version = "17.0.2";
  var dt;
  var ft = {};
  dt = ft, function() {
    var e4 = Ne, t2 = 60103, n2 = 60106;
    dt.Fragment = 60107, dt.StrictMode = 60108, dt.Profiler = 60114;
    var r2 = 60109, o2 = 60110, a2 = 60112;
    dt.Suspense = 60113;
    var i2 = 60120, s2 = 60115, l2 = 60116, u2 = 60121, c2 = 60122, d = 60117, f = 60129, p = 60131;
    if (typeof Symbol == "function" && Symbol.for) {
      var h2 = Symbol.for;
      t2 = h2("react.element"), n2 = h2("react.portal"), dt.Fragment = h2("react.fragment"), dt.StrictMode = h2("react.strict_mode"), dt.Profiler = h2("react.profiler"), r2 = h2("react.provider"), o2 = h2("react.context"), a2 = h2("react.forward_ref"), dt.Suspense = h2("react.suspense"), i2 = h2("react.suspense_list"), s2 = h2("react.memo"), l2 = h2("react.lazy"), u2 = h2("react.block"), c2 = h2("react.server.block"), d = h2("react.fundamental"), h2("react.scope"), h2("react.opaque.id"), f = h2("react.debug_trace_mode"), h2("react.offscreen"), p = h2("react.legacy_hidden");
    }
    var m2 = typeof Symbol == "function" && Symbol.iterator;
    function v2(e5) {
      if (e5 === null || typeof e5 != "object")
        return null;
      var t3 = m2 && e5[m2] || e5["@@iterator"];
      return typeof t3 == "function" ? t3 : null;
    }
    var g2 = { current: null }, y2 = { current: null }, b2 = {}, w2 = null;
    function k2(e5) {
      w2 = e5;
    }
    b2.setExtraStackFrame = function(e5) {
      w2 = e5;
    }, b2.getCurrentStack = null, b2.getStackAddendum = function() {
      var e5 = "";
      w2 && (e5 += w2);
      var t3 = b2.getCurrentStack;
      return t3 && (e5 += t3() || ""), e5;
    };
    var x2 = { ReactCurrentDispatcher: g2, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: y2, IsSomeRendererActing: { current: false }, assign: e4 };
    function S2(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      E2("warn", e5, n3);
    }
    function _2(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      E2("error", e5, n3);
    }
    function E2(e5, t3, n3) {
      var r3 = x2.ReactDebugCurrentFrame.getStackAddendum();
      r3 !== "" && (t3 += "%s", n3 = n3.concat([r3]));
      var o3 = n3.map(function(e6) {
        return "" + e6;
      });
      o3.unshift("Warning: " + t3), Function.prototype.apply.call(console[e5], console, o3);
    }
    x2.ReactDebugCurrentFrame = b2;
    var P2 = {};
    function C2(e5, t3) {
      var n3 = e5.constructor, r3 = n3 && (n3.displayName || n3.name) || "ReactClass", o3 = r3 + "." + t3;
      P2[o3] || (_2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", t3, r3), P2[o3] = true);
    }
    var j2 = { isMounted: function(e5) {
      return false;
    }, enqueueForceUpdate: function(e5, t3, n3) {
      C2(e5, "forceUpdate");
    }, enqueueReplaceState: function(e5, t3, n3, r3) {
      C2(e5, "replaceState");
    }, enqueueSetState: function(e5, t3, n3, r3) {
      C2(e5, "setState");
    } }, O2 = {};
    function T2(e5, t3, n3) {
      this.props = e5, this.context = t3, this.refs = O2, this.updater = n3 || j2;
    }
    Object.freeze(O2), T2.prototype.isReactComponent = {}, T2.prototype.setState = function(e5, t3) {
      if (typeof e5 != "object" && typeof e5 != "function" && e5 != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, e5, t3, "setState");
    }, T2.prototype.forceUpdate = function(e5) {
      this.updater.enqueueForceUpdate(this, e5, "forceUpdate");
    };
    var I2 = { isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."], replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."] }, D2 = function(e5, t3) {
      Object.defineProperty(T2.prototype, e5, { get: function() {
        S2("%s(...) is deprecated in plain JavaScript React classes. %s", t3[0], t3[1]);
      } });
    };
    for (var R2 in I2)
      I2.hasOwnProperty(R2) && D2(R2, I2[R2]);
    function N2() {
    }
    function A2(e5, t3, n3) {
      this.props = e5, this.context = t3, this.refs = O2, this.updater = n3 || j2;
    }
    N2.prototype = T2.prototype;
    var z2 = A2.prototype = new N2();
    function M2(e5) {
      return e5.displayName || "Context";
    }
    function L2(e5) {
      if (e5 == null)
        return null;
      if (typeof e5.tag == "number" && _2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof e5 == "function")
        return e5.displayName || e5.name || null;
      if (typeof e5 == "string")
        return e5;
      switch (e5) {
        case dt.Fragment:
          return "Fragment";
        case n2:
          return "Portal";
        case dt.Profiler:
          return "Profiler";
        case dt.StrictMode:
          return "StrictMode";
        case dt.Suspense:
          return "Suspense";
        case i2:
          return "SuspenseList";
      }
      if (typeof e5 == "object")
        switch (e5.$$typeof) {
          case o2:
            return M2(e5) + ".Consumer";
          case r2:
            return M2(e5._context) + ".Provider";
          case a2:
            return f2 = e5, p2 = e5.render, h3 = "ForwardRef", m3 = p2.displayName || p2.name || "", f2.displayName || (m3 !== "" ? h3 + "(" + m3 + ")" : h3);
          case s2:
            return L2(e5.type);
          case u2:
            return L2(e5._render);
          case l2:
            var t3 = e5, c3 = t3._payload, d2 = t3._init;
            try {
              return L2(d2(c3));
            } catch (e6) {
              return null;
            }
        }
      var f2, p2, h3, m3;
      return null;
    }
    z2.constructor = A2, e4(z2, T2.prototype), z2.isPureReactComponent = true;
    var F2, $2, B2, V2 = Object.prototype.hasOwnProperty, U2 = { key: true, ref: true, __self: true, __source: true };
    function H2(e5) {
      if (V2.call(e5, "ref")) {
        var t3 = Object.getOwnPropertyDescriptor(e5, "ref").get;
        if (t3 && t3.isReactWarning)
          return false;
      }
      return e5.ref !== void 0;
    }
    function W2(e5) {
      if (V2.call(e5, "key")) {
        var t3 = Object.getOwnPropertyDescriptor(e5, "key").get;
        if (t3 && t3.isReactWarning)
          return false;
      }
      return e5.key !== void 0;
    }
    function q2(e5, t3) {
      var n3 = function() {
        F2 || (F2 = true, _2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", t3));
      };
      n3.isReactWarning = true, Object.defineProperty(e5, "key", { get: n3, configurable: true });
    }
    function K2(e5, t3) {
      var n3 = function() {
        $2 || ($2 = true, _2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", t3));
      };
      n3.isReactWarning = true, Object.defineProperty(e5, "ref", { get: n3, configurable: true });
    }
    function Y2(e5) {
      if (typeof e5.ref == "string" && y2.current && e5.__self && y2.current.stateNode !== e5.__self) {
        var t3 = L2(y2.current.type);
        B2[t3] || (_2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', t3, e5.ref), B2[t3] = true);
      }
    }
    B2 = {};
    var X2 = function(e5, n3, r3, o3, a3, i3, s3) {
      var l3 = { $$typeof: t2, type: e5, key: n3, ref: r3, props: s3, _owner: i3, _store: {} };
      return Object.defineProperty(l3._store, "validated", { configurable: false, enumerable: false, writable: true, value: false }), Object.defineProperty(l3, "_self", { configurable: false, enumerable: false, writable: false, value: o3 }), Object.defineProperty(l3, "_source", { configurable: false, enumerable: false, writable: false, value: a3 }), Object.freeze && (Object.freeze(l3.props), Object.freeze(l3)), l3;
    };
    function G2(e5, t3, n3) {
      var r3, o3 = {}, a3 = null, i3 = null, s3 = null, l3 = null;
      if (t3 != null)
        for (r3 in H2(t3) && (i3 = t3.ref, Y2(t3)), W2(t3) && (a3 = "" + t3.key), s3 = t3.__self === void 0 ? null : t3.__self, l3 = t3.__source === void 0 ? null : t3.__source, t3)
          V2.call(t3, r3) && !U2.hasOwnProperty(r3) && (o3[r3] = t3[r3]);
      var u3 = arguments.length - 2;
      if (u3 === 1)
        o3.children = n3;
      else if (u3 > 1) {
        for (var c3 = Array(u3), d2 = 0; d2 < u3; d2++)
          c3[d2] = arguments[d2 + 2];
        Object.freeze && Object.freeze(c3), o3.children = c3;
      }
      if (e5 && e5.defaultProps) {
        var f2 = e5.defaultProps;
        for (r3 in f2)
          o3[r3] === void 0 && (o3[r3] = f2[r3]);
      }
      if (a3 || i3) {
        var p2 = typeof e5 == "function" ? e5.displayName || e5.name || "Unknown" : e5;
        a3 && q2(o3, p2), i3 && K2(o3, p2);
      }
      return X2(e5, a3, i3, s3, l3, y2.current, o3);
    }
    function Q2(t3, n3, r3) {
      if (t3 == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t3 + ".");
      var o3, a3, i3 = e4({}, t3.props), s3 = t3.key, l3 = t3.ref, u3 = t3._self, c3 = t3._source, d2 = t3._owner;
      if (n3 != null)
        for (o3 in H2(n3) && (l3 = n3.ref, d2 = y2.current), W2(n3) && (s3 = "" + n3.key), t3.type && t3.type.defaultProps && (a3 = t3.type.defaultProps), n3)
          V2.call(n3, o3) && !U2.hasOwnProperty(o3) && (n3[o3] === void 0 && a3 !== void 0 ? i3[o3] = a3[o3] : i3[o3] = n3[o3]);
      var f2 = arguments.length - 2;
      if (f2 === 1)
        i3.children = r3;
      else if (f2 > 1) {
        for (var p2 = Array(f2), h3 = 0; h3 < f2; h3++)
          p2[h3] = arguments[h3 + 2];
        i3.children = p2;
      }
      return X2(t3.type, s3, l3, u3, c3, d2, i3);
    }
    function J2(e5) {
      return typeof e5 == "object" && e5 !== null && e5.$$typeof === t2;
    }
    var Z2 = false, ee2 = /\/+/g;
    function te2(e5) {
      return e5.replace(ee2, "$&/");
    }
    function ne2(e5, t3) {
      return typeof e5 == "object" && e5 !== null && e5.key != null ? (n3 = "" + e5.key, r3 = { "=": "=0", ":": "=2" }, "$" + n3.replace(/[=:]/g, function(e6) {
        return r3[e6];
      })) : t3.toString(36);
      var n3, r3;
    }
    function re2(e5, r3, o3, a3, i3) {
      var s3 = typeof e5;
      s3 !== "undefined" && s3 !== "boolean" || (e5 = null);
      var l3, u3, c3, d2 = false;
      if (e5 === null)
        d2 = true;
      else
        switch (s3) {
          case "string":
          case "number":
            d2 = true;
            break;
          case "object":
            switch (e5.$$typeof) {
              case t2:
              case n2:
                d2 = true;
            }
        }
      if (d2) {
        var f2 = e5, p2 = i3(f2), h3 = a3 === "" ? "." + ne2(f2, 0) : a3;
        if (Array.isArray(p2)) {
          var m3 = "";
          h3 != null && (m3 = te2(h3) + "/"), re2(p2, r3, m3, "", function(e6) {
            return e6;
          });
        } else
          p2 != null && (J2(p2) && (l3 = p2, u3 = o3 + (!p2.key || f2 && f2.key === p2.key ? "" : te2("" + p2.key) + "/") + h3, p2 = X2(l3.type, u3, l3.ref, l3._self, l3._source, l3._owner, l3.props)), r3.push(p2));
        return 1;
      }
      var g3 = 0, y3 = a3 === "" ? "." : a3 + ":";
      if (Array.isArray(e5))
        for (var b3 = 0; b3 < e5.length; b3++)
          g3 += re2(c3 = e5[b3], r3, o3, y3 + ne2(c3, b3), i3);
      else {
        var w3 = v2(e5);
        if (typeof w3 == "function") {
          var k3 = e5;
          w3 === k3.entries && (Z2 || S2("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Z2 = true);
          for (var x3, _3 = w3.call(k3), E3 = 0; !(x3 = _3.next()).done; )
            g3 += re2(c3 = x3.value, r3, o3, y3 + ne2(c3, E3++), i3);
        } else if (s3 === "object") {
          var P3 = "" + e5;
          throw Error("Objects are not valid as a React child (found: " + (P3 === "[object Object]" ? "object with keys {" + Object.keys(e5).join(", ") + "}" : P3) + "). If you meant to render a collection of children, use an array instead.");
        }
      }
      return g3;
    }
    function oe2(e5, t3, n3) {
      if (e5 == null)
        return e5;
      var r3 = [], o3 = 0;
      return re2(e5, r3, "", "", function(e6) {
        return t3.call(n3, e6, o3++);
      }), r3;
    }
    function ae2(e5) {
      if (e5._status === -1) {
        var t3 = (0, e5._result)(), n3 = e5;
        n3._status = 0, n3._result = t3, t3.then(function(t4) {
          if (e5._status === 0) {
            var n4 = t4.default;
            n4 === void 0 && _2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", t4);
            var r3 = e5;
            r3._status = 1, r3._result = n4;
          }
        }, function(t4) {
          if (e5._status === 0) {
            var n4 = e5;
            n4._status = 2, n4._result = t4;
          }
        });
      }
      if (e5._status === 1)
        return e5._result;
      throw e5._result;
    }
    function ie2(e5) {
      return typeof e5 == "string" || typeof e5 == "function" || e5 === dt.Fragment || e5 === dt.Profiler || e5 === f || e5 === dt.StrictMode || e5 === dt.Suspense || e5 === i2 || e5 === p || typeof e5 == "object" && e5 !== null && (e5.$$typeof === l2 || e5.$$typeof === s2 || e5.$$typeof === r2 || e5.$$typeof === o2 || e5.$$typeof === a2 || e5.$$typeof === d || e5.$$typeof === u2 || e5[0] === c2);
    }
    function se2() {
      var e5 = g2.current;
      if (e5 === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return e5;
    }
    var le2, ue2, ce2, de2, fe2, pe2, he2, me2 = 0;
    function ve2() {
    }
    ve2.__reactDisabledLog = true;
    var ge2, ye2 = x2.ReactCurrentDispatcher;
    function be2(e5, t3, n3) {
      if (ge2 === void 0)
        try {
          throw Error();
        } catch (e6) {
          var r3 = e6.stack.trim().match(/\n( *(at )?)/);
          ge2 = r3 && r3[1] || "";
        }
      return "\n" + ge2 + e5;
    }
    var we2, ke2 = false, xe2 = typeof WeakMap == "function" ? WeakMap : Map;
    function Se2(t3, n3) {
      if (!t3 || ke2)
        return "";
      var r3, o3 = we2.get(t3);
      if (o3 !== void 0)
        return o3;
      ke2 = true;
      var a3, i3 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0, a3 = ye2.current, ye2.current = null, function() {
        if (me2 === 0) {
          le2 = console.log, ue2 = console.info, ce2 = console.warn, de2 = console.error, fe2 = console.group, pe2 = console.groupCollapsed, he2 = console.groupEnd;
          var e5 = { configurable: true, enumerable: true, value: ve2, writable: true };
          Object.defineProperties(console, { info: e5, log: e5, warn: e5, error: e5, group: e5, groupCollapsed: e5, groupEnd: e5 });
        }
        me2++;
      }();
      try {
        if (n3) {
          var s3 = function() {
            throw Error();
          };
          if (Object.defineProperty(s3.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(s3, []);
            } catch (e5) {
              r3 = e5;
            }
            Reflect.construct(t3, [], s3);
          } else {
            try {
              s3.call();
            } catch (e5) {
              r3 = e5;
            }
            t3.call(s3.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (e5) {
            r3 = e5;
          }
          t3();
        }
      } catch (e5) {
        if (e5 && r3 && typeof e5.stack == "string") {
          for (var l3 = e5.stack.split("\n"), u3 = r3.stack.split("\n"), c3 = l3.length - 1, d2 = u3.length - 1; c3 >= 1 && d2 >= 0 && l3[c3] !== u3[d2]; )
            d2--;
          for (; c3 >= 1 && d2 >= 0; c3--, d2--)
            if (l3[c3] !== u3[d2]) {
              if (c3 !== 1 || d2 !== 1)
                do {
                  if (c3--, --d2 < 0 || l3[c3] !== u3[d2]) {
                    var f2 = "\n" + l3[c3].replace(" at new ", " at ");
                    return typeof t3 == "function" && we2.set(t3, f2), f2;
                  }
                } while (c3 >= 1 && d2 >= 0);
              break;
            }
        }
      } finally {
        ke2 = false, ye2.current = a3, function() {
          if (--me2 == 0) {
            var t4 = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, { log: e4({}, t4, { value: le2 }), info: e4({}, t4, { value: ue2 }), warn: e4({}, t4, { value: ce2 }), error: e4({}, t4, { value: de2 }), group: e4({}, t4, { value: fe2 }), groupCollapsed: e4({}, t4, { value: pe2 }), groupEnd: e4({}, t4, { value: he2 }) });
          }
          me2 < 0 && _2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }(), Error.prepareStackTrace = i3;
      }
      var p2 = t3 ? t3.displayName || t3.name : "", h3 = p2 ? be2(p2) : "";
      return typeof t3 == "function" && we2.set(t3, h3), h3;
    }
    function _e2(e5, t3, n3) {
      return Se2(e5, false);
    }
    function Ee2(e5, t3, n3) {
      if (e5 == null)
        return "";
      if (typeof e5 == "function")
        return Se2(e5, function(e6) {
          var t4 = e6.prototype;
          return !(!t4 || !t4.isReactComponent);
        }(e5));
      if (typeof e5 == "string")
        return be2(e5);
      switch (e5) {
        case dt.Suspense:
          return be2("Suspense");
        case i2:
          return be2("SuspenseList");
      }
      if (typeof e5 == "object")
        switch (e5.$$typeof) {
          case a2:
            return _e2(e5.render);
          case s2:
            return Ee2(e5.type, t3, n3);
          case u2:
            return _e2(e5._render);
          case l2:
            var r3 = e5, o3 = r3._payload, c3 = r3._init;
            try {
              return Ee2(c3(o3), t3, n3);
            } catch (e6) {
            }
        }
      return "";
    }
    we2 = new xe2();
    var Pe2, Ce2 = {}, je2 = x2.ReactDebugCurrentFrame;
    function Oe2(e5) {
      if (e5) {
        var t3 = e5._owner, n3 = Ee2(e5.type, e5._source, t3 ? t3.type : null);
        je2.setExtraStackFrame(n3);
      } else
        je2.setExtraStackFrame(null);
    }
    function Te2(e5) {
      if (e5) {
        var t3 = e5._owner;
        k2(Ee2(e5.type, e5._source, t3 ? t3.type : null));
      } else
        k2(null);
    }
    function Ie2() {
      if (y2.current) {
        var e5 = L2(y2.current.type);
        if (e5)
          return "\n\nCheck the render method of `" + e5 + "`.";
      }
      return "";
    }
    function De2(e5) {
      return e5 != null && (t3 = e5.__source) !== void 0 ? "\n\nCheck your code at " + t3.fileName.replace(/^.*[\\\/]/, "") + ":" + t3.lineNumber + "." : "";
      var t3;
    }
    Pe2 = false;
    var Re2 = {};
    function Ae2(e5, t3) {
      if (e5._store && !e5._store.validated && e5.key == null) {
        e5._store.validated = true;
        var n3 = function(e6) {
          var t4 = Ie2();
          if (!t4) {
            var n4 = typeof e6 == "string" ? e6 : e6.displayName || e6.name;
            n4 && (t4 = "\n\nCheck the top-level render call using <" + n4 + ">.");
          }
          return t4;
        }(t3);
        if (!Re2[n3]) {
          Re2[n3] = true;
          var r3 = "";
          e5 && e5._owner && e5._owner !== y2.current && (r3 = " It was passed a child from " + L2(e5._owner.type) + "."), Te2(e5), _2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', n3, r3), Te2(null);
        }
      }
    }
    function ze2(e5, t3) {
      if (typeof e5 == "object") {
        if (Array.isArray(e5))
          for (var n3 = 0; n3 < e5.length; n3++) {
            var r3 = e5[n3];
            J2(r3) && Ae2(r3, t3);
          }
        else if (J2(e5))
          e5._store && (e5._store.validated = true);
        else if (e5) {
          var o3 = v2(e5);
          if (typeof o3 == "function" && o3 !== e5.entries)
            for (var a3, i3 = o3.call(e5); !(a3 = i3.next()).done; )
              J2(a3.value) && Ae2(a3.value, t3);
        }
      }
    }
    function Me2(e5) {
      var t3, n3 = e5.type;
      if (n3 != null && typeof n3 != "string") {
        if (typeof n3 == "function")
          t3 = n3.propTypes;
        else {
          if (typeof n3 != "object" || n3.$$typeof !== a2 && n3.$$typeof !== s2)
            return;
          t3 = n3.propTypes;
        }
        if (t3) {
          var r3 = L2(n3);
          !function(e6, t4, n4, r4, o3) {
            var a3 = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var i3 in e6)
              if (a3(e6, i3)) {
                var s3 = void 0;
                try {
                  if (typeof e6[i3] != "function") {
                    var l3 = Error((r4 || "React class") + ": " + n4 + " type `" + i3 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e6[i3] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    throw l3.name = "Invariant Violation", l3;
                  }
                  s3 = e6[i3](t4, i3, r4, n4, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (e7) {
                  s3 = e7;
                }
                !s3 || s3 instanceof Error || (Oe2(o3), _2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", r4 || "React class", n4, i3, typeof s3), Oe2(null)), s3 instanceof Error && !(s3.message in Ce2) && (Ce2[s3.message] = true, Oe2(o3), _2("Failed %s type: %s", n4, s3.message), Oe2(null));
              }
          }(t3, e5.props, "prop", r3, e5);
        } else
          n3.PropTypes === void 0 || Pe2 || (Pe2 = true, _2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", L2(n3) || "Unknown"));
        typeof n3.getDefaultProps != "function" || n3.getDefaultProps.isReactClassApproved || _2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Le2(e5) {
      for (var t3 = Object.keys(e5.props), n3 = 0; n3 < t3.length; n3++) {
        var r3 = t3[n3];
        if (r3 !== "children" && r3 !== "key") {
          Te2(e5), _2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", r3), Te2(null);
          break;
        }
      }
      e5.ref !== null && (Te2(e5), _2("Invalid attribute `ref` supplied to `React.Fragment`."), Te2(null));
    }
    function Fe2(e5, n3, r3) {
      var o3 = ie2(e5);
      if (!o3) {
        var a3 = "";
        (e5 === void 0 || typeof e5 == "object" && e5 !== null && Object.keys(e5).length === 0) && (a3 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var i3, s3 = De2(n3);
        a3 += s3 || Ie2(), e5 === null ? i3 = "null" : Array.isArray(e5) ? i3 = "array" : e5 !== void 0 && e5.$$typeof === t2 ? (i3 = "<" + (L2(e5.type) || "Unknown") + " />", a3 = " Did you accidentally export a JSX literal instead of a component?") : i3 = typeof e5, _2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", i3, a3);
      }
      var l3 = G2.apply(this, arguments);
      if (l3 == null)
        return l3;
      if (o3)
        for (var u3 = 2; u3 < arguments.length; u3++)
          ze2(arguments[u3], e5);
      return e5 === dt.Fragment ? Le2(l3) : Me2(l3), l3;
    }
    var $e2 = false;
    try {
      var Be2 = Object.freeze({});
      /* @__PURE__ */ new Map([[Be2, null]]), /* @__PURE__ */ new Set([Be2]);
    } catch (e5) {
    }
    var Ve2 = Fe2, Ue = function(e5, t3, n3) {
      for (var r3 = Q2.apply(this, arguments), o3 = 2; o3 < arguments.length; o3++)
        ze2(arguments[o3], r3.type);
      return Me2(r3), r3;
    }, He2 = function(e5) {
      var t3 = Fe2.bind(null, e5);
      return t3.type = e5, $e2 || ($e2 = true, S2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(t3, "type", { enumerable: false, get: function() {
        return S2("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", { value: e5 }), e5;
      } }), t3;
    }, We2 = { map: oe2, forEach: function(e5, t3, n3) {
      oe2(e5, function() {
        t3.apply(this, arguments);
      }, n3);
    }, count: function(e5) {
      var t3 = 0;
      return oe2(e5, function() {
        t3++;
      }), t3;
    }, toArray: function(e5) {
      return oe2(e5, function(e6) {
        return e6;
      }) || [];
    }, only: function(e5) {
      if (!J2(e5))
        throw Error("React.Children.only expected to receive a single React element child.");
      return e5;
    } };
    dt.Children = We2, dt.Component = T2, dt.PureComponent = A2, dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = x2, dt.cloneElement = Ue, dt.createContext = function(e5, t3) {
      t3 === void 0 ? t3 = null : t3 !== null && typeof t3 != "function" && _2("createContext: Expected the optional second argument to be a function. Instead received: %s", t3);
      var n3 = { $$typeof: o2, _calculateChangedBits: t3, _currentValue: e5, _currentValue2: e5, _threadCount: 0, Provider: null, Consumer: null };
      n3.Provider = { $$typeof: r2, _context: n3 };
      var a3 = false, i3 = false, s3 = false, l3 = { $$typeof: o2, _context: n3, _calculateChangedBits: n3._calculateChangedBits };
      return Object.defineProperties(l3, { Provider: { get: function() {
        return i3 || (i3 = true, _2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), n3.Provider;
      }, set: function(e6) {
        n3.Provider = e6;
      } }, _currentValue: { get: function() {
        return n3._currentValue;
      }, set: function(e6) {
        n3._currentValue = e6;
      } }, _currentValue2: { get: function() {
        return n3._currentValue2;
      }, set: function(e6) {
        n3._currentValue2 = e6;
      } }, _threadCount: { get: function() {
        return n3._threadCount;
      }, set: function(e6) {
        n3._threadCount = e6;
      } }, Consumer: { get: function() {
        return a3 || (a3 = true, _2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), n3.Consumer;
      } }, displayName: { get: function() {
        return n3.displayName;
      }, set: function(e6) {
        s3 || (S2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", e6), s3 = true);
      } } }), n3.Consumer = l3, n3._currentRenderer = null, n3._currentRenderer2 = null, n3;
    }, dt.createElement = Ve2, dt.createFactory = He2, dt.createRef = function() {
      var e5 = { current: null };
      return Object.seal(e5), e5;
    }, dt.forwardRef = function(e5) {
      e5 != null && e5.$$typeof === s2 ? _2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof e5 != "function" ? _2("forwardRef requires a render function but was given %s.", e5 === null ? "null" : typeof e5) : e5.length !== 0 && e5.length !== 2 && _2("forwardRef render functions accept exactly two parameters: props and ref. %s", e5.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), e5 != null && (e5.defaultProps == null && e5.propTypes == null || _2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?"));
      var t3, n3 = { $$typeof: a2, render: e5 };
      return Object.defineProperty(n3, "displayName", { enumerable: false, configurable: true, get: function() {
        return t3;
      }, set: function(n4) {
        t3 = n4, e5.displayName == null && (e5.displayName = n4);
      } }), n3;
    }, dt.isValidElement = J2, dt.lazy = function(e5) {
      var t3, n3, r3 = { $$typeof: l2, _payload: { _status: -1, _result: e5 }, _init: ae2 };
      return Object.defineProperties(r3, { defaultProps: { configurable: true, get: function() {
        return t3;
      }, set: function(e6) {
        _2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), t3 = e6, Object.defineProperty(r3, "defaultProps", { enumerable: true });
      } }, propTypes: { configurable: true, get: function() {
        return n3;
      }, set: function(e6) {
        _2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), n3 = e6, Object.defineProperty(r3, "propTypes", { enumerable: true });
      } } }), r3;
    }, dt.memo = function(e5, t3) {
      ie2(e5) || _2("memo: The first argument must be a component. Instead received: %s", e5 === null ? "null" : typeof e5);
      var n3, r3 = { $$typeof: s2, type: e5, compare: t3 === void 0 ? null : t3 };
      return Object.defineProperty(r3, "displayName", { enumerable: false, configurable: true, get: function() {
        return n3;
      }, set: function(t4) {
        n3 = t4, e5.displayName == null && (e5.displayName = t4);
      } }), r3;
    }, dt.useCallback = function(e5, t3) {
      return se2().useCallback(e5, t3);
    }, dt.useContext = function(e5, t3) {
      var n3 = se2();
      if (t3 !== void 0 && _2("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", t3, typeof t3 == "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : ""), e5._context !== void 0) {
        var r3 = e5._context;
        r3.Consumer === e5 ? _2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : r3.Provider === e5 && _2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
      }
      return n3.useContext(e5, t3);
    }, dt.useDebugValue = function(e5, t3) {
      return se2().useDebugValue(e5, t3);
    }, dt.useEffect = function(e5, t3) {
      return se2().useEffect(e5, t3);
    }, dt.useImperativeHandle = function(e5, t3, n3) {
      return se2().useImperativeHandle(e5, t3, n3);
    }, dt.useLayoutEffect = function(e5, t3) {
      return se2().useLayoutEffect(e5, t3);
    }, dt.useMemo = function(e5, t3) {
      return se2().useMemo(e5, t3);
    }, dt.useReducer = function(e5, t3, n3) {
      return se2().useReducer(e5, t3, n3);
    }, dt.useRef = function(e5) {
      return se2().useRef(e5);
    }, dt.useState = function(e5) {
      return se2().useState(e5);
    }, dt.version = "17.0.2";
  }(), false ? je.exports = Oe : je.exports = ft;
  var pt = je.exports;
  var ht = { exports: {} };
  var mt = {};
  var vt = { exports: {} };
  var gt = {};
  !function(e4) {
    var t2, n2, r2, o2;
    if (typeof performance == "object" && typeof performance.now == "function") {
      var a2 = performance;
      e4.unstable_now = function() {
        return a2.now();
      };
    } else {
      var i2 = Date, s2 = i2.now();
      e4.unstable_now = function() {
        return i2.now() - s2;
      };
    }
    if (typeof window == "undefined" || typeof MessageChannel != "function") {
      var l2 = null, u2 = null, c2 = function() {
        if (l2 !== null)
          try {
            var t3 = e4.unstable_now();
            l2(true, t3), l2 = null;
          } catch (e5) {
            throw setTimeout(c2, 0), e5;
          }
      };
      t2 = function(e5) {
        l2 !== null ? setTimeout(t2, 0, e5) : (l2 = e5, setTimeout(c2, 0));
      }, n2 = function(e5, t3) {
        u2 = setTimeout(e5, t3);
      }, r2 = function() {
        clearTimeout(u2);
      }, e4.unstable_shouldYield = function() {
        return false;
      }, o2 = e4.unstable_forceFrameRate = function() {
      };
    } else {
      var d = window.setTimeout, f = window.clearTimeout;
      if (typeof console != "undefined") {
        var p = window.cancelAnimationFrame;
        typeof window.requestAnimationFrame != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof p != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      }
      var h2 = false, m2 = null, v2 = -1, g2 = 5, y2 = 0;
      e4.unstable_shouldYield = function() {
        return e4.unstable_now() >= y2;
      }, o2 = function() {
      }, e4.unstable_forceFrameRate = function(e5) {
        0 > e5 || 125 < e5 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : g2 = 0 < e5 ? Math.floor(1e3 / e5) : 5;
      };
      var b2 = new MessageChannel(), w2 = b2.port2;
      b2.port1.onmessage = function() {
        if (m2 !== null) {
          var t3 = e4.unstable_now();
          y2 = t3 + g2;
          try {
            m2(true, t3) ? w2.postMessage(null) : (h2 = false, m2 = null);
          } catch (e5) {
            throw w2.postMessage(null), e5;
          }
        } else
          h2 = false;
      }, t2 = function(e5) {
        m2 = e5, h2 || (h2 = true, w2.postMessage(null));
      }, n2 = function(t3, n3) {
        v2 = d(function() {
          t3(e4.unstable_now());
        }, n3);
      }, r2 = function() {
        f(v2), v2 = -1;
      };
    }
    function k2(e5, t3) {
      var n3 = e5.length;
      e5.push(t3);
      e:
        for (; ; ) {
          var r3 = n3 - 1 >>> 1, o3 = e5[r3];
          if (!(o3 !== void 0 && 0 < _2(o3, t3)))
            break e;
          e5[r3] = t3, e5[n3] = o3, n3 = r3;
        }
    }
    function x2(e5) {
      return (e5 = e5[0]) === void 0 ? null : e5;
    }
    function S2(e5) {
      var t3 = e5[0];
      if (t3 !== void 0) {
        var n3 = e5.pop();
        if (n3 !== t3) {
          e5[0] = n3;
          e:
            for (var r3 = 0, o3 = e5.length; r3 < o3; ) {
              var a3 = 2 * (r3 + 1) - 1, i3 = e5[a3], s3 = a3 + 1, l3 = e5[s3];
              if (i3 !== void 0 && 0 > _2(i3, n3))
                l3 !== void 0 && 0 > _2(l3, i3) ? (e5[r3] = l3, e5[s3] = n3, r3 = s3) : (e5[r3] = i3, e5[a3] = n3, r3 = a3);
              else {
                if (!(l3 !== void 0 && 0 > _2(l3, n3)))
                  break e;
                e5[r3] = l3, e5[s3] = n3, r3 = s3;
              }
            }
        }
        return t3;
      }
      return null;
    }
    function _2(e5, t3) {
      var n3 = e5.sortIndex - t3.sortIndex;
      return n3 !== 0 ? n3 : e5.id - t3.id;
    }
    var E2 = [], P2 = [], C2 = 1, j2 = null, O2 = 3, T2 = false, I2 = false, D2 = false;
    function R2(e5) {
      for (var t3 = x2(P2); t3 !== null; ) {
        if (t3.callback === null)
          S2(P2);
        else {
          if (!(t3.startTime <= e5))
            break;
          S2(P2), t3.sortIndex = t3.expirationTime, k2(E2, t3);
        }
        t3 = x2(P2);
      }
    }
    function N2(e5) {
      if (D2 = false, R2(e5), !I2)
        if (x2(E2) !== null)
          I2 = true, t2(A2);
        else {
          var r3 = x2(P2);
          r3 !== null && n2(N2, r3.startTime - e5);
        }
    }
    function A2(t3, o3) {
      I2 = false, D2 && (D2 = false, r2()), T2 = true;
      var a3 = O2;
      try {
        for (R2(o3), j2 = x2(E2); j2 !== null && (!(j2.expirationTime > o3) || t3 && !e4.unstable_shouldYield()); ) {
          var i3 = j2.callback;
          if (typeof i3 == "function") {
            j2.callback = null, O2 = j2.priorityLevel;
            var s3 = i3(j2.expirationTime <= o3);
            o3 = e4.unstable_now(), typeof s3 == "function" ? j2.callback = s3 : j2 === x2(E2) && S2(E2), R2(o3);
          } else
            S2(E2);
          j2 = x2(E2);
        }
        if (j2 !== null)
          var l3 = true;
        else {
          var u3 = x2(P2);
          u3 !== null && n2(N2, u3.startTime - o3), l3 = false;
        }
        return l3;
      } finally {
        j2 = null, O2 = a3, T2 = false;
      }
    }
    var z2 = o2;
    e4.unstable_IdlePriority = 5, e4.unstable_ImmediatePriority = 1, e4.unstable_LowPriority = 4, e4.unstable_NormalPriority = 3, e4.unstable_Profiling = null, e4.unstable_UserBlockingPriority = 2, e4.unstable_cancelCallback = function(e5) {
      e5.callback = null;
    }, e4.unstable_continueExecution = function() {
      I2 || T2 || (I2 = true, t2(A2));
    }, e4.unstable_getCurrentPriorityLevel = function() {
      return O2;
    }, e4.unstable_getFirstCallbackNode = function() {
      return x2(E2);
    }, e4.unstable_next = function(e5) {
      switch (O2) {
        case 1:
        case 2:
        case 3:
          var t3 = 3;
          break;
        default:
          t3 = O2;
      }
      var n3 = O2;
      O2 = t3;
      try {
        return e5();
      } finally {
        O2 = n3;
      }
    }, e4.unstable_pauseExecution = function() {
    }, e4.unstable_requestPaint = z2, e4.unstable_runWithPriority = function(e5, t3) {
      switch (e5) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          e5 = 3;
      }
      var n3 = O2;
      O2 = e5;
      try {
        return t3();
      } finally {
        O2 = n3;
      }
    }, e4.unstable_scheduleCallback = function(o3, a3, i3) {
      var s3 = e4.unstable_now();
      switch (typeof i3 == "object" && i3 !== null ? i3 = typeof (i3 = i3.delay) == "number" && 0 < i3 ? s3 + i3 : s3 : i3 = s3, o3) {
        case 1:
          var l3 = -1;
          break;
        case 2:
          l3 = 250;
          break;
        case 5:
          l3 = 1073741823;
          break;
        case 4:
          l3 = 1e4;
          break;
        default:
          l3 = 5e3;
      }
      return o3 = { id: C2++, callback: a3, priorityLevel: o3, startTime: i3, expirationTime: l3 = i3 + l3, sortIndex: -1 }, i3 > s3 ? (o3.sortIndex = i3, k2(P2, o3), x2(E2) === null && o3 === x2(P2) && (D2 ? r2() : D2 = true, n2(N2, i3 - s3))) : (o3.sortIndex = l3, k2(E2, o3), I2 || T2 || (I2 = true, t2(A2))), o3;
    }, e4.unstable_wrapCallback = function(e5) {
      var t3 = O2;
      return function() {
        var n3 = O2;
        O2 = t3;
        try {
          return e5.apply(this, arguments);
        } finally {
          O2 = n3;
        }
      };
    };
  }(gt);
  var yt = {};
  !function(e4) {
    (function() {
      var t2, n2, r2, o2;
      if (typeof performance == "object" && typeof performance.now == "function") {
        var a2 = performance;
        e4.unstable_now = function() {
          return a2.now();
        };
      } else {
        var i2 = Date, s2 = i2.now();
        e4.unstable_now = function() {
          return i2.now() - s2;
        };
      }
      if (typeof window == "undefined" || typeof MessageChannel != "function") {
        var l2 = null, u2 = null, c2 = function() {
          if (l2 !== null)
            try {
              var t3 = e4.unstable_now();
              l2(true, t3), l2 = null;
            } catch (e5) {
              throw setTimeout(c2, 0), e5;
            }
        };
        t2 = function(e5) {
          l2 !== null ? setTimeout(t2, 0, e5) : (l2 = e5, setTimeout(c2, 0));
        }, n2 = function(e5, t3) {
          u2 = setTimeout(e5, t3);
        }, r2 = function() {
          clearTimeout(u2);
        }, e4.unstable_shouldYield = function() {
          return false;
        }, o2 = e4.unstable_forceFrameRate = function() {
        };
      } else {
        var d = window.setTimeout, f = window.clearTimeout;
        if (typeof console != "undefined") {
          var p = window.requestAnimationFrame, h2 = window.cancelAnimationFrame;
          typeof p != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof h2 != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        var m2 = false, v2 = null, g2 = -1, y2 = 5, b2 = 0;
        e4.unstable_shouldYield = function() {
          return e4.unstable_now() >= b2;
        }, o2 = function() {
        }, e4.unstable_forceFrameRate = function(e5) {
          e5 < 0 || e5 > 125 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : y2 = e5 > 0 ? Math.floor(1e3 / e5) : 5;
        };
        var w2 = new MessageChannel(), k2 = w2.port2;
        w2.port1.onmessage = function() {
          if (v2 !== null) {
            var t3 = e4.unstable_now();
            b2 = t3 + y2;
            try {
              v2(true, t3) ? k2.postMessage(null) : (m2 = false, v2 = null);
            } catch (e5) {
              throw k2.postMessage(null), e5;
            }
          } else
            m2 = false;
        }, t2 = function(e5) {
          v2 = e5, m2 || (m2 = true, k2.postMessage(null));
        }, n2 = function(t3, n3) {
          g2 = d(function() {
            t3(e4.unstable_now());
          }, n3);
        }, r2 = function() {
          f(g2), g2 = -1;
        };
      }
      function x2(e5, t3) {
        var n3 = e5.length;
        e5.push(t3), function(e6, t4, n4) {
          var r3 = n4;
          for (; ; ) {
            var o3 = r3 - 1 >>> 1, a3 = e6[o3];
            if (!(a3 !== void 0 && E2(a3, t4) > 0))
              return;
            e6[o3] = t4, e6[r3] = a3, r3 = o3;
          }
        }(e5, t3, n3);
      }
      function S2(e5) {
        var t3 = e5[0];
        return t3 === void 0 ? null : t3;
      }
      function _2(e5) {
        var t3 = e5[0];
        if (t3 !== void 0) {
          var n3 = e5.pop();
          return n3 !== t3 && (e5[0] = n3, function(e6, t4, n4) {
            var r3 = n4, o3 = e6.length;
            for (; r3 < o3; ) {
              var a3 = 2 * (r3 + 1) - 1, i3 = e6[a3], s3 = a3 + 1, l3 = e6[s3];
              if (i3 !== void 0 && E2(i3, t4) < 0)
                l3 !== void 0 && E2(l3, i3) < 0 ? (e6[r3] = l3, e6[s3] = t4, r3 = s3) : (e6[r3] = i3, e6[a3] = t4, r3 = a3);
              else {
                if (!(l3 !== void 0 && E2(l3, t4) < 0))
                  return;
                e6[r3] = l3, e6[s3] = t4, r3 = s3;
              }
            }
          }(e5, n3, 0)), t3;
        }
        return null;
      }
      function E2(e5, t3) {
        var n3 = e5.sortIndex - t3.sortIndex;
        return n3 !== 0 ? n3 : e5.id - t3.id;
      }
      var P2 = [], C2 = [], j2 = 1, O2 = null, T2 = 3, I2 = false, D2 = false, R2 = false;
      function N2(e5) {
        for (var t3 = S2(C2); t3 !== null; ) {
          if (t3.callback === null)
            _2(C2);
          else {
            if (!(t3.startTime <= e5))
              return;
            _2(C2), t3.sortIndex = t3.expirationTime, x2(P2, t3);
          }
          t3 = S2(C2);
        }
      }
      function A2(e5) {
        if (R2 = false, N2(e5), !D2)
          if (S2(P2) !== null)
            D2 = true, t2(z2);
          else {
            var r3 = S2(C2);
            r3 !== null && n2(A2, r3.startTime - e5);
          }
      }
      function z2(t3, o3) {
        D2 = false, R2 && (R2 = false, r2()), I2 = true;
        var a3 = T2;
        try {
          return function(t4, r3) {
            var o4 = r3;
            N2(o4), O2 = S2(P2);
            for (; O2 !== null && (!(O2.expirationTime > o4) || t4 && !e4.unstable_shouldYield()); ) {
              var a4 = O2.callback;
              if (typeof a4 == "function") {
                O2.callback = null, T2 = O2.priorityLevel;
                var i3 = a4(O2.expirationTime <= o4);
                o4 = e4.unstable_now(), typeof i3 == "function" ? O2.callback = i3 : O2 === S2(P2) && _2(P2), N2(o4);
              } else
                _2(P2);
              O2 = S2(P2);
            }
            if (O2 !== null)
              return true;
            var s3 = S2(C2);
            return s3 !== null && n2(A2, s3.startTime - o4), false;
          }(t3, o3);
        } finally {
          O2 = null, T2 = a3, I2 = false;
        }
      }
      var M2 = o2;
      e4.unstable_IdlePriority = 5, e4.unstable_ImmediatePriority = 1, e4.unstable_LowPriority = 4, e4.unstable_NormalPriority = 3, e4.unstable_Profiling = null, e4.unstable_UserBlockingPriority = 2, e4.unstable_cancelCallback = function(e5) {
        e5.callback = null;
      }, e4.unstable_continueExecution = function() {
        D2 || I2 || (D2 = true, t2(z2));
      }, e4.unstable_getCurrentPriorityLevel = function() {
        return T2;
      }, e4.unstable_getFirstCallbackNode = function() {
        return S2(P2);
      }, e4.unstable_next = function(e5) {
        var t3;
        switch (T2) {
          case 1:
          case 2:
          case 3:
            t3 = 3;
            break;
          default:
            t3 = T2;
        }
        var n3 = T2;
        T2 = t3;
        try {
          return e5();
        } finally {
          T2 = n3;
        }
      }, e4.unstable_pauseExecution = function() {
      }, e4.unstable_requestPaint = M2, e4.unstable_runWithPriority = function(e5, t3) {
        switch (e5) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            e5 = 3;
        }
        var n3 = T2;
        T2 = e5;
        try {
          return t3();
        } finally {
          T2 = n3;
        }
      }, e4.unstable_scheduleCallback = function(o3, a3, i3) {
        var s3, l3, u3 = e4.unstable_now();
        if (typeof i3 == "object" && i3 !== null) {
          var c3 = i3.delay;
          s3 = typeof c3 == "number" && c3 > 0 ? u3 + c3 : u3;
        } else
          s3 = u3;
        switch (o3) {
          case 1:
            l3 = -1;
            break;
          case 2:
            l3 = 250;
            break;
          case 5:
            l3 = 1073741823;
            break;
          case 4:
            l3 = 1e4;
            break;
          default:
            l3 = 5e3;
        }
        var d2 = s3 + l3, f2 = { id: j2++, callback: a3, priorityLevel: o3, startTime: s3, expirationTime: d2, sortIndex: -1 };
        return s3 > u3 ? (f2.sortIndex = s3, x2(C2, f2), S2(P2) === null && f2 === S2(C2) && (R2 ? r2() : R2 = true, n2(A2, s3 - u3))) : (f2.sortIndex = d2, x2(P2, f2), D2 || I2 || (D2 = true, t2(z2))), f2;
      }, e4.unstable_wrapCallback = function(e5) {
        var t3 = T2;
        return function() {
          var n3 = T2;
          T2 = t3;
          try {
            return e5.apply(this, arguments);
          } finally {
            T2 = n3;
          }
        };
      };
    })();
  }(yt), false ? vt.exports = gt : vt.exports = yt;
  var bt = je.exports;
  var wt = Ne;
  var kt = vt.exports;
  function xt(e4) {
    for (var t2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e4, n2 = 1; n2 < arguments.length; n2++)
      t2 += "&args[]=" + encodeURIComponent(arguments[n2]);
    return "Minified React error #" + e4 + "; visit " + t2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  if (!bt)
    throw Error(xt(227));
  var St = /* @__PURE__ */ new Set();
  var _t = {};
  function Et(e4, t2) {
    Pt(e4, t2), Pt(e4 + "Capture", t2);
  }
  function Pt(e4, t2) {
    for (_t[e4] = t2, e4 = 0; e4 < t2.length; e4++)
      St.add(t2[e4]);
  }
  var Ct = !(typeof window == "undefined" || window.document === void 0 || window.document.createElement === void 0);
  var jt = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
  var Ot = Object.prototype.hasOwnProperty;
  var Tt = {};
  var It = {};
  function Dt(e4, t2, n2, r2, o2, a2, i2) {
    this.acceptsBooleans = t2 === 2 || t2 === 3 || t2 === 4, this.attributeName = r2, this.attributeNamespace = o2, this.mustUseProperty = n2, this.propertyName = e4, this.type = t2, this.sanitizeURL = a2, this.removeEmptyString = i2;
  }
  var Rt = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e4) {
    Rt[e4] = new Dt(e4, 0, false, e4, null, false, false);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e4) {
    var t2 = e4[0];
    Rt[t2] = new Dt(t2, 1, false, e4[1], null, false, false);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 2, false, e4.toLowerCase(), null, false, false);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 2, false, e4, null, false, false);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e4) {
    Rt[e4] = new Dt(e4, 3, false, e4.toLowerCase(), null, false, false);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 3, true, e4, null, false, false);
  }), ["capture", "download"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 4, false, e4, null, false, false);
  }), ["cols", "rows", "size", "span"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 6, false, e4, null, false, false);
  }), ["rowSpan", "start"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 5, false, e4.toLowerCase(), null, false, false);
  });
  var Nt = /[\-:]([a-z])/g;
  function At(e4) {
    return e4[1].toUpperCase();
  }
  function zt(e4, t2, n2, r2) {
    var o2 = Rt.hasOwnProperty(t2) ? Rt[t2] : null;
    (o2 !== null ? o2.type === 0 : !r2 && (2 < t2.length && (t2[0] === "o" || t2[0] === "O") && (t2[1] === "n" || t2[1] === "N"))) || (function(e5, t3, n3, r3) {
      if (t3 == null || function(e6, t4, n4, r4) {
        if (n4 !== null && n4.type === 0)
          return false;
        switch (typeof t4) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            return !r4 && (n4 !== null ? !n4.acceptsBooleans : (e6 = e6.toLowerCase().slice(0, 5)) !== "data-" && e6 !== "aria-");
          default:
            return false;
        }
      }(e5, t3, n3, r3))
        return true;
      if (r3)
        return false;
      if (n3 !== null)
        switch (n3.type) {
          case 3:
            return !t3;
          case 4:
            return t3 === false;
          case 5:
            return isNaN(t3);
          case 6:
            return isNaN(t3) || 1 > t3;
        }
      return false;
    }(t2, n2, o2, r2) && (n2 = null), r2 || o2 === null ? function(e5) {
      return !!Ot.call(It, e5) || !Ot.call(Tt, e5) && (jt.test(e5) ? It[e5] = true : (Tt[e5] = true, false));
    }(t2) && (n2 === null ? e4.removeAttribute(t2) : e4.setAttribute(t2, "" + n2)) : o2.mustUseProperty ? e4[o2.propertyName] = n2 === null ? o2.type !== 3 && "" : n2 : (t2 = o2.attributeName, r2 = o2.attributeNamespace, n2 === null ? e4.removeAttribute(t2) : (n2 = (o2 = o2.type) === 3 || o2 === 4 && n2 === true ? "" : "" + n2, r2 ? e4.setAttributeNS(r2, t2, n2) : e4.setAttribute(t2, n2))));
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e4) {
    var t2 = e4.replace(Nt, At);
    Rt[t2] = new Dt(t2, 1, false, e4, null, false, false);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e4) {
    var t2 = e4.replace(Nt, At);
    Rt[t2] = new Dt(t2, 1, false, e4, "http://www.w3.org/1999/xlink", false, false);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(e4) {
    var t2 = e4.replace(Nt, At);
    Rt[t2] = new Dt(t2, 1, false, e4, "http://www.w3.org/XML/1998/namespace", false, false);
  }), ["tabIndex", "crossOrigin"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 1, false, e4.toLowerCase(), null, false, false);
  }), Rt.xlinkHref = new Dt("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false), ["src", "href", "action", "formAction"].forEach(function(e4) {
    Rt[e4] = new Dt(e4, 1, false, e4.toLowerCase(), null, true, true);
  });
  var Mt = bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  var Lt = 60103;
  var Ft = 60106;
  var $t = 60107;
  var Bt = 60108;
  var Vt = 60114;
  var Ut = 60109;
  var Ht = 60110;
  var Wt = 60112;
  var qt = 60113;
  var Kt = 60120;
  var Yt = 60115;
  var Xt = 60116;
  var Gt = 60121;
  var Qt = 60128;
  var Jt = 60129;
  var Zt = 60130;
  var en = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    tn = Symbol.for;
    Lt = tn("react.element"), Ft = tn("react.portal"), $t = tn("react.fragment"), Bt = tn("react.strict_mode"), Vt = tn("react.profiler"), Ut = tn("react.provider"), Ht = tn("react.context"), Wt = tn("react.forward_ref"), qt = tn("react.suspense"), Kt = tn("react.suspense_list"), Yt = tn("react.memo"), Xt = tn("react.lazy"), Gt = tn("react.block"), tn("react.scope"), Qt = tn("react.opaque.id"), Jt = tn("react.debug_trace_mode"), Zt = tn("react.offscreen"), en = tn("react.legacy_hidden");
  }
  var tn;
  var nn;
  var rn = typeof Symbol == "function" && Symbol.iterator;
  function on(e4) {
    return e4 === null || typeof e4 != "object" ? null : typeof (e4 = rn && e4[rn] || e4["@@iterator"]) == "function" ? e4 : null;
  }
  function an(e4) {
    if (nn === void 0)
      try {
        throw Error();
      } catch (e5) {
        var t2 = e5.stack.trim().match(/\n( *(at )?)/);
        nn = t2 && t2[1] || "";
      }
    return "\n" + nn + e4;
  }
  var sn = false;
  function ln(e4, t2) {
    if (!e4 || sn)
      return "";
    sn = true;
    var n2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (t2)
        if (t2 = function() {
          throw Error();
        }, Object.defineProperty(t2.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(t2, []);
          } catch (e5) {
            var r2 = e5;
          }
          Reflect.construct(e4, [], t2);
        } else {
          try {
            t2.call();
          } catch (e5) {
            r2 = e5;
          }
          e4.call(t2.prototype);
        }
      else {
        try {
          throw Error();
        } catch (e5) {
          r2 = e5;
        }
        e4();
      }
    } catch (e5) {
      if (e5 && r2 && typeof e5.stack == "string") {
        for (var o2 = e5.stack.split("\n"), a2 = r2.stack.split("\n"), i2 = o2.length - 1, s2 = a2.length - 1; 1 <= i2 && 0 <= s2 && o2[i2] !== a2[s2]; )
          s2--;
        for (; 1 <= i2 && 0 <= s2; i2--, s2--)
          if (o2[i2] !== a2[s2]) {
            if (i2 !== 1 || s2 !== 1)
              do {
                if (i2--, 0 > --s2 || o2[i2] !== a2[s2])
                  return "\n" + o2[i2].replace(" at new ", " at ");
              } while (1 <= i2 && 0 <= s2);
            break;
          }
      }
    } finally {
      sn = false, Error.prepareStackTrace = n2;
    }
    return (e4 = e4 ? e4.displayName || e4.name : "") ? an(e4) : "";
  }
  function un(e4) {
    switch (e4.tag) {
      case 5:
        return an(e4.type);
      case 16:
        return an("Lazy");
      case 13:
        return an("Suspense");
      case 19:
        return an("SuspenseList");
      case 0:
      case 2:
      case 15:
        return e4 = ln(e4.type, false);
      case 11:
        return e4 = ln(e4.type.render, false);
      case 22:
        return e4 = ln(e4.type._render, false);
      case 1:
        return e4 = ln(e4.type, true);
      default:
        return "";
    }
  }
  function cn(e4) {
    if (e4 == null)
      return null;
    if (typeof e4 == "function")
      return e4.displayName || e4.name || null;
    if (typeof e4 == "string")
      return e4;
    switch (e4) {
      case $t:
        return "Fragment";
      case Ft:
        return "Portal";
      case Vt:
        return "Profiler";
      case Bt:
        return "StrictMode";
      case qt:
        return "Suspense";
      case Kt:
        return "SuspenseList";
    }
    if (typeof e4 == "object")
      switch (e4.$$typeof) {
        case Ht:
          return (e4.displayName || "Context") + ".Consumer";
        case Ut:
          return (e4._context.displayName || "Context") + ".Provider";
        case Wt:
          var t2 = e4.render;
          return t2 = t2.displayName || t2.name || "", e4.displayName || (t2 !== "" ? "ForwardRef(" + t2 + ")" : "ForwardRef");
        case Yt:
          return cn(e4.type);
        case Gt:
          return cn(e4._render);
        case Xt:
          t2 = e4._payload, e4 = e4._init;
          try {
            return cn(e4(t2));
          } catch (e5) {
          }
      }
    return null;
  }
  function dn(e4) {
    switch (typeof e4) {
      case "boolean":
      case "number":
      case "object":
      case "string":
      case "undefined":
        return e4;
      default:
        return "";
    }
  }
  function fn(e4) {
    var t2 = e4.type;
    return (e4 = e4.nodeName) && e4.toLowerCase() === "input" && (t2 === "checkbox" || t2 === "radio");
  }
  function pn(e4) {
    e4._valueTracker || (e4._valueTracker = function(e5) {
      var t2 = fn(e5) ? "checked" : "value", n2 = Object.getOwnPropertyDescriptor(e5.constructor.prototype, t2), r2 = "" + e5[t2];
      if (!e5.hasOwnProperty(t2) && n2 !== void 0 && typeof n2.get == "function" && typeof n2.set == "function") {
        var o2 = n2.get, a2 = n2.set;
        return Object.defineProperty(e5, t2, { configurable: true, get: function() {
          return o2.call(this);
        }, set: function(e6) {
          r2 = "" + e6, a2.call(this, e6);
        } }), Object.defineProperty(e5, t2, { enumerable: n2.enumerable }), { getValue: function() {
          return r2;
        }, setValue: function(e6) {
          r2 = "" + e6;
        }, stopTracking: function() {
          e5._valueTracker = null, delete e5[t2];
        } };
      }
    }(e4));
  }
  function hn(e4) {
    if (!e4)
      return false;
    var t2 = e4._valueTracker;
    if (!t2)
      return true;
    var n2 = t2.getValue(), r2 = "";
    return e4 && (r2 = fn(e4) ? e4.checked ? "true" : "false" : e4.value), (e4 = r2) !== n2 && (t2.setValue(e4), true);
  }
  function mn(e4) {
    if ((e4 = e4 || (typeof document != "undefined" ? document : void 0)) === void 0)
      return null;
    try {
      return e4.activeElement || e4.body;
    } catch (t2) {
      return e4.body;
    }
  }
  function vn(e4, t2) {
    var n2 = t2.checked;
    return wt({}, t2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n2 != null ? n2 : e4._wrapperState.initialChecked });
  }
  function gn(e4, t2) {
    var n2 = t2.defaultValue == null ? "" : t2.defaultValue, r2 = t2.checked != null ? t2.checked : t2.defaultChecked;
    n2 = dn(t2.value != null ? t2.value : n2), e4._wrapperState = { initialChecked: r2, initialValue: n2, controlled: t2.type === "checkbox" || t2.type === "radio" ? t2.checked != null : t2.value != null };
  }
  function yn(e4, t2) {
    (t2 = t2.checked) != null && zt(e4, "checked", t2, false);
  }
  function bn(e4, t2) {
    yn(e4, t2);
    var n2 = dn(t2.value), r2 = t2.type;
    if (n2 != null)
      r2 === "number" ? (n2 === 0 && e4.value === "" || e4.value != n2) && (e4.value = "" + n2) : e4.value !== "" + n2 && (e4.value = "" + n2);
    else if (r2 === "submit" || r2 === "reset")
      return void e4.removeAttribute("value");
    t2.hasOwnProperty("value") ? kn(e4, t2.type, n2) : t2.hasOwnProperty("defaultValue") && kn(e4, t2.type, dn(t2.defaultValue)), t2.checked == null && t2.defaultChecked != null && (e4.defaultChecked = !!t2.defaultChecked);
  }
  function wn(e4, t2, n2) {
    if (t2.hasOwnProperty("value") || t2.hasOwnProperty("defaultValue")) {
      var r2 = t2.type;
      if (!(r2 !== "submit" && r2 !== "reset" || t2.value !== void 0 && t2.value !== null))
        return;
      t2 = "" + e4._wrapperState.initialValue, n2 || t2 === e4.value || (e4.value = t2), e4.defaultValue = t2;
    }
    (n2 = e4.name) !== "" && (e4.name = ""), e4.defaultChecked = !!e4._wrapperState.initialChecked, n2 !== "" && (e4.name = n2);
  }
  function kn(e4, t2, n2) {
    t2 === "number" && mn(e4.ownerDocument) === e4 || (n2 == null ? e4.defaultValue = "" + e4._wrapperState.initialValue : e4.defaultValue !== "" + n2 && (e4.defaultValue = "" + n2));
  }
  function xn(e4, t2) {
    return e4 = wt({ children: void 0 }, t2), (t2 = function(e5) {
      var t3 = "";
      return bt.Children.forEach(e5, function(e6) {
        e6 != null && (t3 += e6);
      }), t3;
    }(t2.children)) && (e4.children = t2), e4;
  }
  function Sn(e4, t2, n2, r2) {
    if (e4 = e4.options, t2) {
      t2 = {};
      for (var o2 = 0; o2 < n2.length; o2++)
        t2["$" + n2[o2]] = true;
      for (n2 = 0; n2 < e4.length; n2++)
        o2 = t2.hasOwnProperty("$" + e4[n2].value), e4[n2].selected !== o2 && (e4[n2].selected = o2), o2 && r2 && (e4[n2].defaultSelected = true);
    } else {
      for (n2 = "" + dn(n2), t2 = null, o2 = 0; o2 < e4.length; o2++) {
        if (e4[o2].value === n2)
          return e4[o2].selected = true, void (r2 && (e4[o2].defaultSelected = true));
        t2 !== null || e4[o2].disabled || (t2 = e4[o2]);
      }
      t2 !== null && (t2.selected = true);
    }
  }
  function _n(e4, t2) {
    if (t2.dangerouslySetInnerHTML != null)
      throw Error(xt(91));
    return wt({}, t2, { value: void 0, defaultValue: void 0, children: "" + e4._wrapperState.initialValue });
  }
  function En(e4, t2) {
    var n2 = t2.value;
    if (n2 == null) {
      if (n2 = t2.children, t2 = t2.defaultValue, n2 != null) {
        if (t2 != null)
          throw Error(xt(92));
        if (Array.isArray(n2)) {
          if (!(1 >= n2.length))
            throw Error(xt(93));
          n2 = n2[0];
        }
        t2 = n2;
      }
      t2 == null && (t2 = ""), n2 = t2;
    }
    e4._wrapperState = { initialValue: dn(n2) };
  }
  function Pn(e4, t2) {
    var n2 = dn(t2.value), r2 = dn(t2.defaultValue);
    n2 != null && ((n2 = "" + n2) !== e4.value && (e4.value = n2), t2.defaultValue == null && e4.defaultValue !== n2 && (e4.defaultValue = n2)), r2 != null && (e4.defaultValue = "" + r2);
  }
  function Cn(e4) {
    var t2 = e4.textContent;
    t2 === e4._wrapperState.initialValue && t2 !== "" && t2 !== null && (e4.value = t2);
  }
  var jn = "http://www.w3.org/1999/xhtml";
  var On = "http://www.w3.org/2000/svg";
  function Tn(e4) {
    switch (e4) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function In(e4, t2) {
    return e4 == null || e4 === "http://www.w3.org/1999/xhtml" ? Tn(t2) : e4 === "http://www.w3.org/2000/svg" && t2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e4;
  }
  var Dn;
  var Rn;
  var Nn = (Rn = function(e4, t2) {
    if (e4.namespaceURI !== On || "innerHTML" in e4)
      e4.innerHTML = t2;
    else {
      for ((Dn = Dn || document.createElement("div")).innerHTML = "<svg>" + t2.valueOf().toString() + "</svg>", t2 = Dn.firstChild; e4.firstChild; )
        e4.removeChild(e4.firstChild);
      for (; t2.firstChild; )
        e4.appendChild(t2.firstChild);
    }
  }, typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function(e4, t2, n2, r2) {
    MSApp.execUnsafeLocalFunction(function() {
      return Rn(e4, t2);
    });
  } : Rn);
  function An(e4, t2) {
    if (t2) {
      var n2 = e4.firstChild;
      if (n2 && n2 === e4.lastChild && n2.nodeType === 3)
        return void (n2.nodeValue = t2);
    }
    e4.textContent = t2;
  }
  var zn = { animationIterationCount: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridArea: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true };
  var Mn = ["Webkit", "ms", "Moz", "O"];
  function Ln(e4, t2, n2) {
    return t2 == null || typeof t2 == "boolean" || t2 === "" ? "" : n2 || typeof t2 != "number" || t2 === 0 || zn.hasOwnProperty(e4) && zn[e4] ? ("" + t2).trim() : t2 + "px";
  }
  function Fn(e4, t2) {
    for (var n2 in e4 = e4.style, t2)
      if (t2.hasOwnProperty(n2)) {
        var r2 = n2.indexOf("--") === 0, o2 = Ln(n2, t2[n2], r2);
        n2 === "float" && (n2 = "cssFloat"), r2 ? e4.setProperty(n2, o2) : e4[n2] = o2;
      }
  }
  Object.keys(zn).forEach(function(e4) {
    Mn.forEach(function(t2) {
      t2 = t2 + e4.charAt(0).toUpperCase() + e4.substring(1), zn[t2] = zn[e4];
    });
  });
  var $n = wt({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function Bn(e4, t2) {
    if (t2) {
      if ($n[e4] && (t2.children != null || t2.dangerouslySetInnerHTML != null))
        throw Error(xt(137, e4));
      if (t2.dangerouslySetInnerHTML != null) {
        if (t2.children != null)
          throw Error(xt(60));
        if (typeof t2.dangerouslySetInnerHTML != "object" || !("__html" in t2.dangerouslySetInnerHTML))
          throw Error(xt(61));
      }
      if (t2.style != null && typeof t2.style != "object")
        throw Error(xt(62));
    }
  }
  function Vn(e4, t2) {
    if (e4.indexOf("-") === -1)
      return typeof t2.is == "string";
    switch (e4) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  function Un(e4) {
    return (e4 = e4.target || e4.srcElement || window).correspondingUseElement && (e4 = e4.correspondingUseElement), e4.nodeType === 3 ? e4.parentNode : e4;
  }
  var Hn = null;
  var Wn = null;
  var qn = null;
  function Kn(e4) {
    if (e4 = wi(e4)) {
      if (typeof Hn != "function")
        throw Error(xt(280));
      var t2 = e4.stateNode;
      t2 && (t2 = xi(t2), Hn(e4.stateNode, e4.type, t2));
    }
  }
  function Yn(e4) {
    Wn ? qn ? qn.push(e4) : qn = [e4] : Wn = e4;
  }
  function Xn() {
    if (Wn) {
      var e4 = Wn, t2 = qn;
      if (qn = Wn = null, Kn(e4), t2)
        for (e4 = 0; e4 < t2.length; e4++)
          Kn(t2[e4]);
    }
  }
  function Gn(e4, t2) {
    return e4(t2);
  }
  function Qn(e4, t2, n2, r2, o2) {
    return e4(t2, n2, r2, o2);
  }
  function Jn() {
  }
  var Zn = Gn;
  var er = false;
  var tr = false;
  function nr() {
    Wn === null && qn === null || (Jn(), Xn());
  }
  function rr(e4, t2) {
    var n2 = e4.stateNode;
    if (n2 === null)
      return null;
    var r2 = xi(n2);
    if (r2 === null)
      return null;
    n2 = r2[t2];
    e:
      switch (t2) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (r2 = !r2.disabled) || (r2 = !((e4 = e4.type) === "button" || e4 === "input" || e4 === "select" || e4 === "textarea")), e4 = !r2;
          break e;
        default:
          e4 = false;
      }
    if (e4)
      return null;
    if (n2 && typeof n2 != "function")
      throw Error(xt(231, t2, typeof n2));
    return n2;
  }
  var or = false;
  if (Ct)
    try {
      ar = {};
      Object.defineProperty(ar, "passive", { get: function() {
        or = true;
      } }), window.addEventListener("test", ar, ar), window.removeEventListener("test", ar, ar);
    } catch (Rn2) {
      or = false;
    }
  var ar;
  function ir(e4, t2, n2, r2, o2, a2, i2, s2, l2) {
    var u2 = Array.prototype.slice.call(arguments, 3);
    try {
      t2.apply(n2, u2);
    } catch (e5) {
      this.onError(e5);
    }
  }
  var sr = false;
  var lr = null;
  var ur = false;
  var cr = null;
  var dr = { onError: function(e4) {
    sr = true, lr = e4;
  } };
  function fr(e4, t2, n2, r2, o2, a2, i2, s2, l2) {
    sr = false, lr = null, ir.apply(dr, arguments);
  }
  function pr(e4) {
    var t2 = e4, n2 = e4;
    if (e4.alternate)
      for (; t2.return; )
        t2 = t2.return;
    else {
      e4 = t2;
      do {
        (1026 & (t2 = e4).flags) != 0 && (n2 = t2.return), e4 = t2.return;
      } while (e4);
    }
    return t2.tag === 3 ? n2 : null;
  }
  function hr(e4) {
    if (e4.tag === 13) {
      var t2 = e4.memoizedState;
      if (t2 === null && ((e4 = e4.alternate) !== null && (t2 = e4.memoizedState)), t2 !== null)
        return t2.dehydrated;
    }
    return null;
  }
  function mr(e4) {
    if (pr(e4) !== e4)
      throw Error(xt(188));
  }
  function vr(e4) {
    if (e4 = function(e5) {
      var t3 = e5.alternate;
      if (!t3) {
        if ((t3 = pr(e5)) === null)
          throw Error(xt(188));
        return t3 !== e5 ? null : e5;
      }
      for (var n2 = e5, r2 = t3; ; ) {
        var o2 = n2.return;
        if (o2 === null)
          break;
        var a2 = o2.alternate;
        if (a2 === null) {
          if ((r2 = o2.return) !== null) {
            n2 = r2;
            continue;
          }
          break;
        }
        if (o2.child === a2.child) {
          for (a2 = o2.child; a2; ) {
            if (a2 === n2)
              return mr(o2), e5;
            if (a2 === r2)
              return mr(o2), t3;
            a2 = a2.sibling;
          }
          throw Error(xt(188));
        }
        if (n2.return !== r2.return)
          n2 = o2, r2 = a2;
        else {
          for (var i2 = false, s2 = o2.child; s2; ) {
            if (s2 === n2) {
              i2 = true, n2 = o2, r2 = a2;
              break;
            }
            if (s2 === r2) {
              i2 = true, r2 = o2, n2 = a2;
              break;
            }
            s2 = s2.sibling;
          }
          if (!i2) {
            for (s2 = a2.child; s2; ) {
              if (s2 === n2) {
                i2 = true, n2 = a2, r2 = o2;
                break;
              }
              if (s2 === r2) {
                i2 = true, r2 = a2, n2 = o2;
                break;
              }
              s2 = s2.sibling;
            }
            if (!i2)
              throw Error(xt(189));
          }
        }
        if (n2.alternate !== r2)
          throw Error(xt(190));
      }
      if (n2.tag !== 3)
        throw Error(xt(188));
      return n2.stateNode.current === n2 ? e5 : t3;
    }(e4), !e4)
      return null;
    for (var t2 = e4; ; ) {
      if (t2.tag === 5 || t2.tag === 6)
        return t2;
      if (t2.child)
        t2.child.return = t2, t2 = t2.child;
      else {
        if (t2 === e4)
          break;
        for (; !t2.sibling; ) {
          if (!t2.return || t2.return === e4)
            return null;
          t2 = t2.return;
        }
        t2.sibling.return = t2.return, t2 = t2.sibling;
      }
    }
    return null;
  }
  function gr(e4, t2) {
    for (var n2 = e4.alternate; t2 !== null; ) {
      if (t2 === e4 || t2 === n2)
        return true;
      t2 = t2.return;
    }
    return false;
  }
  var yr;
  var br;
  var wr;
  var kr;
  var xr = false;
  var Sr = [];
  var _r = null;
  var Er = null;
  var Pr = null;
  var Cr = /* @__PURE__ */ new Map();
  var jr = /* @__PURE__ */ new Map();
  var Or = [];
  var Tr = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ir(e4, t2, n2, r2, o2) {
    return { blockedOn: e4, domEventName: t2, eventSystemFlags: 16 | n2, nativeEvent: o2, targetContainers: [r2] };
  }
  function Dr(e4, t2) {
    switch (e4) {
      case "focusin":
      case "focusout":
        _r = null;
        break;
      case "dragenter":
      case "dragleave":
        Er = null;
        break;
      case "mouseover":
      case "mouseout":
        Pr = null;
        break;
      case "pointerover":
      case "pointerout":
        Cr.delete(t2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        jr.delete(t2.pointerId);
    }
  }
  function Rr(e4, t2, n2, r2, o2, a2) {
    return e4 === null || e4.nativeEvent !== a2 ? (e4 = Ir(t2, n2, r2, o2, a2), t2 !== null && ((t2 = wi(t2)) !== null && br(t2)), e4) : (e4.eventSystemFlags |= r2, t2 = e4.targetContainers, o2 !== null && t2.indexOf(o2) === -1 && t2.push(o2), e4);
  }
  function Nr(e4) {
    var t2 = bi(e4.target);
    if (t2 !== null) {
      var n2 = pr(t2);
      if (n2 !== null) {
        if ((t2 = n2.tag) === 13) {
          if ((t2 = hr(n2)) !== null)
            return e4.blockedOn = t2, void kr(e4.lanePriority, function() {
              kt.unstable_runWithPriority(e4.priority, function() {
                wr(n2);
              });
            });
        } else if (t2 === 3 && n2.stateNode.hydrate)
          return void (e4.blockedOn = n2.tag === 3 ? n2.stateNode.containerInfo : null);
      }
    }
    e4.blockedOn = null;
  }
  function Ar(e4) {
    if (e4.blockedOn !== null)
      return false;
    for (var t2 = e4.targetContainers; 0 < t2.length; ) {
      var n2 = go(e4.domEventName, e4.eventSystemFlags, t2[0], e4.nativeEvent);
      if (n2 !== null)
        return (t2 = wi(n2)) !== null && br(t2), e4.blockedOn = n2, false;
      t2.shift();
    }
    return true;
  }
  function zr(e4, t2, n2) {
    Ar(e4) && n2.delete(t2);
  }
  function Mr() {
    for (xr = false; 0 < Sr.length; ) {
      var e4 = Sr[0];
      if (e4.blockedOn !== null) {
        (e4 = wi(e4.blockedOn)) !== null && yr(e4);
        break;
      }
      for (var t2 = e4.targetContainers; 0 < t2.length; ) {
        var n2 = go(e4.domEventName, e4.eventSystemFlags, t2[0], e4.nativeEvent);
        if (n2 !== null) {
          e4.blockedOn = n2;
          break;
        }
        t2.shift();
      }
      e4.blockedOn === null && Sr.shift();
    }
    _r !== null && Ar(_r) && (_r = null), Er !== null && Ar(Er) && (Er = null), Pr !== null && Ar(Pr) && (Pr = null), Cr.forEach(zr), jr.forEach(zr);
  }
  function Lr(e4, t2) {
    e4.blockedOn === t2 && (e4.blockedOn = null, xr || (xr = true, kt.unstable_scheduleCallback(kt.unstable_NormalPriority, Mr)));
  }
  function Fr(e4) {
    function t2(t3) {
      return Lr(t3, e4);
    }
    if (0 < Sr.length) {
      Lr(Sr[0], e4);
      for (var n2 = 1; n2 < Sr.length; n2++) {
        var r2 = Sr[n2];
        r2.blockedOn === e4 && (r2.blockedOn = null);
      }
    }
    for (_r !== null && Lr(_r, e4), Er !== null && Lr(Er, e4), Pr !== null && Lr(Pr, e4), Cr.forEach(t2), jr.forEach(t2), n2 = 0; n2 < Or.length; n2++)
      (r2 = Or[n2]).blockedOn === e4 && (r2.blockedOn = null);
    for (; 0 < Or.length && (n2 = Or[0]).blockedOn === null; )
      Nr(n2), n2.blockedOn === null && Or.shift();
  }
  function $r(e4, t2) {
    var n2 = {};
    return n2[e4.toLowerCase()] = t2.toLowerCase(), n2["Webkit" + e4] = "webkit" + t2, n2["Moz" + e4] = "moz" + t2, n2;
  }
  var Br = { animationend: $r("Animation", "AnimationEnd"), animationiteration: $r("Animation", "AnimationIteration"), animationstart: $r("Animation", "AnimationStart"), transitionend: $r("Transition", "TransitionEnd") };
  var Vr = {};
  var Ur = {};
  function Hr(e4) {
    if (Vr[e4])
      return Vr[e4];
    if (!Br[e4])
      return e4;
    var t2, n2 = Br[e4];
    for (t2 in n2)
      if (n2.hasOwnProperty(t2) && t2 in Ur)
        return Vr[e4] = n2[t2];
    return e4;
  }
  Ct && (Ur = document.createElement("div").style, "AnimationEvent" in window || (delete Br.animationend.animation, delete Br.animationiteration.animation, delete Br.animationstart.animation), "TransitionEvent" in window || delete Br.transitionend.transition);
  var Wr = Hr("animationend");
  var qr = Hr("animationiteration");
  var Kr = Hr("animationstart");
  var Yr = Hr("transitionend");
  var Xr = /* @__PURE__ */ new Map();
  var Gr = /* @__PURE__ */ new Map();
  var Qr = ["abort", "abort", Wr, "animationEnd", qr, "animationIteration", Kr, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Yr, "transitionEnd", "waiting", "waiting"];
  function Jr(e4, t2) {
    for (var n2 = 0; n2 < e4.length; n2 += 2) {
      var r2 = e4[n2], o2 = e4[n2 + 1];
      o2 = "on" + (o2[0].toUpperCase() + o2.slice(1)), Gr.set(r2, t2), Xr.set(r2, o2), Et(o2, [r2]);
    }
  }
  (0, kt.unstable_now)();
  var Zr = 8;
  function eo(e4) {
    if ((1 & e4) != 0)
      return Zr = 15, 1;
    if ((2 & e4) != 0)
      return Zr = 14, 2;
    if ((4 & e4) != 0)
      return Zr = 13, 4;
    var t2 = 24 & e4;
    return t2 !== 0 ? (Zr = 12, t2) : (32 & e4) != 0 ? (Zr = 11, 32) : (t2 = 192 & e4) !== 0 ? (Zr = 10, t2) : (256 & e4) != 0 ? (Zr = 9, 256) : (t2 = 3584 & e4) !== 0 ? (Zr = 8, t2) : (4096 & e4) != 0 ? (Zr = 7, 4096) : (t2 = 4186112 & e4) !== 0 ? (Zr = 6, t2) : (t2 = 62914560 & e4) !== 0 ? (Zr = 5, t2) : 67108864 & e4 ? (Zr = 4, 67108864) : (134217728 & e4) != 0 ? (Zr = 3, 134217728) : (t2 = 805306368 & e4) !== 0 ? (Zr = 2, t2) : (1073741824 & e4) != 0 ? (Zr = 1, 1073741824) : (Zr = 8, e4);
  }
  function to(e4, t2) {
    var n2 = e4.pendingLanes;
    if (n2 === 0)
      return Zr = 0;
    var r2 = 0, o2 = 0, a2 = e4.expiredLanes, i2 = e4.suspendedLanes, s2 = e4.pingedLanes;
    if (a2 !== 0)
      r2 = a2, o2 = Zr = 15;
    else if ((a2 = 134217727 & n2) !== 0) {
      var l2 = a2 & ~i2;
      l2 !== 0 ? (r2 = eo(l2), o2 = Zr) : (s2 &= a2) !== 0 && (r2 = eo(s2), o2 = Zr);
    } else
      (a2 = n2 & ~i2) !== 0 ? (r2 = eo(a2), o2 = Zr) : s2 !== 0 && (r2 = eo(s2), o2 = Zr);
    if (r2 === 0)
      return 0;
    if (r2 = n2 & ((0 > (r2 = 31 - so(r2)) ? 0 : 1 << r2) << 1) - 1, t2 !== 0 && t2 !== r2 && (t2 & i2) == 0) {
      if (eo(t2), o2 <= Zr)
        return t2;
      Zr = o2;
    }
    if ((t2 = e4.entangledLanes) !== 0)
      for (e4 = e4.entanglements, t2 &= r2; 0 < t2; )
        o2 = 1 << (n2 = 31 - so(t2)), r2 |= e4[n2], t2 &= ~o2;
    return r2;
  }
  function no(e4) {
    return (e4 = -1073741825 & e4.pendingLanes) !== 0 ? e4 : 1073741824 & e4 ? 1073741824 : 0;
  }
  function ro(e4, t2) {
    switch (e4) {
      case 15:
        return 1;
      case 14:
        return 2;
      case 12:
        return (e4 = oo(24 & ~t2)) === 0 ? ro(10, t2) : e4;
      case 10:
        return (e4 = oo(192 & ~t2)) === 0 ? ro(8, t2) : e4;
      case 8:
        return (e4 = oo(3584 & ~t2)) === 0 && ((e4 = oo(4186112 & ~t2)) === 0 && (e4 = 512)), e4;
      case 2:
        return (t2 = oo(805306368 & ~t2)) === 0 && (t2 = 268435456), t2;
    }
    throw Error(xt(358, e4));
  }
  function oo(e4) {
    return e4 & -e4;
  }
  function ao(e4) {
    for (var t2 = [], n2 = 0; 31 > n2; n2++)
      t2.push(e4);
    return t2;
  }
  function io(e4, t2, n2) {
    e4.pendingLanes |= t2;
    var r2 = t2 - 1;
    e4.suspendedLanes &= r2, e4.pingedLanes &= r2, (e4 = e4.eventTimes)[t2 = 31 - so(t2)] = n2;
  }
  var so = Math.clz32 ? Math.clz32 : function(e4) {
    return e4 === 0 ? 32 : 31 - (lo(e4) / uo | 0) | 0;
  };
  var lo = Math.log;
  var uo = Math.LN2;
  var co = kt.unstable_UserBlockingPriority;
  var fo = kt.unstable_runWithPriority;
  var po = true;
  function ho(e4, t2, n2, r2) {
    er || Jn();
    var o2 = vo, a2 = er;
    er = true;
    try {
      Qn(o2, e4, t2, n2, r2);
    } finally {
      (er = a2) || nr();
    }
  }
  function mo(e4, t2, n2, r2) {
    fo(co, vo.bind(null, e4, t2, n2, r2));
  }
  function vo(e4, t2, n2, r2) {
    var o2;
    if (po)
      if ((o2 = (4 & t2) == 0) && 0 < Sr.length && -1 < Tr.indexOf(e4))
        e4 = Ir(null, e4, t2, n2, r2), Sr.push(e4);
      else {
        var a2 = go(e4, t2, n2, r2);
        if (a2 === null)
          o2 && Dr(e4, r2);
        else {
          if (o2) {
            if (-1 < Tr.indexOf(e4))
              return e4 = Ir(a2, e4, t2, n2, r2), void Sr.push(e4);
            if (function(e5, t3, n3, r3, o3) {
              switch (t3) {
                case "focusin":
                  return _r = Rr(_r, e5, t3, n3, r3, o3), true;
                case "dragenter":
                  return Er = Rr(Er, e5, t3, n3, r3, o3), true;
                case "mouseover":
                  return Pr = Rr(Pr, e5, t3, n3, r3, o3), true;
                case "pointerover":
                  var a3 = o3.pointerId;
                  return Cr.set(a3, Rr(Cr.get(a3) || null, e5, t3, n3, r3, o3)), true;
                case "gotpointercapture":
                  return a3 = o3.pointerId, jr.set(a3, Rr(jr.get(a3) || null, e5, t3, n3, r3, o3)), true;
              }
              return false;
            }(a2, e4, t2, n2, r2))
              return;
            Dr(e4, r2);
          }
          Ja(e4, t2, r2, null, n2);
        }
      }
  }
  function go(e4, t2, n2, r2) {
    var o2 = Un(r2);
    if ((o2 = bi(o2)) !== null) {
      var a2 = pr(o2);
      if (a2 === null)
        o2 = null;
      else {
        var i2 = a2.tag;
        if (i2 === 13) {
          if ((o2 = hr(a2)) !== null)
            return o2;
          o2 = null;
        } else if (i2 === 3) {
          if (a2.stateNode.hydrate)
            return a2.tag === 3 ? a2.stateNode.containerInfo : null;
          o2 = null;
        } else
          a2 !== o2 && (o2 = null);
      }
    }
    return Ja(e4, t2, r2, o2, n2), null;
  }
  var yo = null;
  var bo = null;
  var wo = null;
  function ko() {
    if (wo)
      return wo;
    var e4, t2, n2 = bo, r2 = n2.length, o2 = "value" in yo ? yo.value : yo.textContent, a2 = o2.length;
    for (e4 = 0; e4 < r2 && n2[e4] === o2[e4]; e4++)
      ;
    var i2 = r2 - e4;
    for (t2 = 1; t2 <= i2 && n2[r2 - t2] === o2[a2 - t2]; t2++)
      ;
    return wo = o2.slice(e4, 1 < t2 ? 1 - t2 : void 0);
  }
  function xo(e4) {
    var t2 = e4.keyCode;
    return "charCode" in e4 ? (e4 = e4.charCode) === 0 && t2 === 13 && (e4 = 13) : e4 = t2, e4 === 10 && (e4 = 13), 32 <= e4 || e4 === 13 ? e4 : 0;
  }
  function So() {
    return true;
  }
  function _o() {
    return false;
  }
  function Eo(e4) {
    function t2(t3, n2, r2, o2, a2) {
      for (var i2 in this._reactName = t3, this._targetInst = r2, this.type = n2, this.nativeEvent = o2, this.target = a2, this.currentTarget = null, e4)
        e4.hasOwnProperty(i2) && (t3 = e4[i2], this[i2] = t3 ? t3(o2) : o2[i2]);
      return this.isDefaultPrevented = (o2.defaultPrevented != null ? o2.defaultPrevented : o2.returnValue === false) ? So : _o, this.isPropagationStopped = _o, this;
    }
    return wt(t2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var e5 = this.nativeEvent;
      e5 && (e5.preventDefault ? e5.preventDefault() : typeof e5.returnValue != "unknown" && (e5.returnValue = false), this.isDefaultPrevented = So);
    }, stopPropagation: function() {
      var e5 = this.nativeEvent;
      e5 && (e5.stopPropagation ? e5.stopPropagation() : typeof e5.cancelBubble != "unknown" && (e5.cancelBubble = true), this.isPropagationStopped = So);
    }, persist: function() {
    }, isPersistent: So }), t2;
  }
  var Po;
  var Co;
  var jo;
  var Oo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(e4) {
    return e4.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 };
  var To = Eo(Oo);
  var Io = wt({}, Oo, { view: 0, detail: 0 });
  var Do = Eo(Io);
  var Ro = wt({}, Io, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Wo, button: 0, buttons: 0, relatedTarget: function(e4) {
    return e4.relatedTarget === void 0 ? e4.fromElement === e4.srcElement ? e4.toElement : e4.fromElement : e4.relatedTarget;
  }, movementX: function(e4) {
    return "movementX" in e4 ? e4.movementX : (e4 !== jo && (jo && e4.type === "mousemove" ? (Po = e4.screenX - jo.screenX, Co = e4.screenY - jo.screenY) : Co = Po = 0, jo = e4), Po);
  }, movementY: function(e4) {
    return "movementY" in e4 ? e4.movementY : Co;
  } });
  var No = Eo(Ro);
  var Ao = Eo(wt({}, Ro, { dataTransfer: 0 }));
  var zo = Eo(wt({}, Io, { relatedTarget: 0 }));
  var Mo = Eo(wt({}, Oo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }));
  var Lo = wt({}, Oo, { clipboardData: function(e4) {
    return "clipboardData" in e4 ? e4.clipboardData : window.clipboardData;
  } });
  var Fo = Eo(Lo);
  var $o = Eo(wt({}, Oo, { data: 0 }));
  var Bo = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" };
  var Vo = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };
  var Uo = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ho(e4) {
    var t2 = this.nativeEvent;
    return t2.getModifierState ? t2.getModifierState(e4) : !!(e4 = Uo[e4]) && !!t2[e4];
  }
  function Wo() {
    return Ho;
  }
  var qo = wt({}, Io, { key: function(e4) {
    if (e4.key) {
      var t2 = Bo[e4.key] || e4.key;
      if (t2 !== "Unidentified")
        return t2;
    }
    return e4.type === "keypress" ? (e4 = xo(e4)) === 13 ? "Enter" : String.fromCharCode(e4) : e4.type === "keydown" || e4.type === "keyup" ? Vo[e4.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Wo, charCode: function(e4) {
    return e4.type === "keypress" ? xo(e4) : 0;
  }, keyCode: function(e4) {
    return e4.type === "keydown" || e4.type === "keyup" ? e4.keyCode : 0;
  }, which: function(e4) {
    return e4.type === "keypress" ? xo(e4) : e4.type === "keydown" || e4.type === "keyup" ? e4.keyCode : 0;
  } });
  var Ko = Eo(qo);
  var Yo = Eo(wt({}, Ro, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }));
  var Xo = Eo(wt({}, Io, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Wo }));
  var Go = Eo(wt({}, Oo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }));
  var Qo = wt({}, Ro, { deltaX: function(e4) {
    return "deltaX" in e4 ? e4.deltaX : "wheelDeltaX" in e4 ? -e4.wheelDeltaX : 0;
  }, deltaY: function(e4) {
    return "deltaY" in e4 ? e4.deltaY : "wheelDeltaY" in e4 ? -e4.wheelDeltaY : "wheelDelta" in e4 ? -e4.wheelDelta : 0;
  }, deltaZ: 0, deltaMode: 0 });
  var Jo = Eo(Qo);
  var Zo = [9, 13, 27, 32];
  var ea = Ct && "CompositionEvent" in window;
  var ta = null;
  Ct && "documentMode" in document && (ta = document.documentMode);
  var na = Ct && "TextEvent" in window && !ta;
  var ra = Ct && (!ea || ta && 8 < ta && 11 >= ta);
  var oa = String.fromCharCode(32);
  var aa = false;
  function ia(e4, t2) {
    switch (e4) {
      case "keyup":
        return Zo.indexOf(t2.keyCode) !== -1;
      case "keydown":
        return t2.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function sa(e4) {
    return typeof (e4 = e4.detail) == "object" && "data" in e4 ? e4.data : null;
  }
  var la = false;
  var ua = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function ca(e4) {
    var t2 = e4 && e4.nodeName && e4.nodeName.toLowerCase();
    return t2 === "input" ? !!ua[e4.type] : t2 === "textarea";
  }
  function da(e4, t2, n2, r2) {
    Yn(r2), 0 < (t2 = ei(t2, "onChange")).length && (n2 = new To("onChange", "change", null, n2, r2), e4.push({ event: n2, listeners: t2 }));
  }
  var fa = null;
  var pa = null;
  function ha(e4) {
    qa(e4, 0);
  }
  function ma(e4) {
    if (hn(ki(e4)))
      return e4;
  }
  function va(e4, t2) {
    if (e4 === "change")
      return t2;
  }
  var ga = false;
  if (Ct) {
    if (Ct) {
      ba = "oninput" in document;
      if (!ba) {
        wa = document.createElement("div");
        wa.setAttribute("oninput", "return;"), ba = typeof wa.oninput == "function";
      }
      ya = ba;
    } else
      ya = false;
    ga = ya && (!document.documentMode || 9 < document.documentMode);
  }
  var ya;
  var ba;
  var wa;
  function ka() {
    fa && (fa.detachEvent("onpropertychange", xa), pa = fa = null);
  }
  function xa(e4) {
    if (e4.propertyName === "value" && ma(pa)) {
      var t2 = [];
      if (da(t2, pa, e4, Un(e4)), e4 = ha, er)
        e4(t2);
      else {
        er = true;
        try {
          Gn(e4, t2);
        } finally {
          er = false, nr();
        }
      }
    }
  }
  function Sa(e4, t2, n2) {
    e4 === "focusin" ? (ka(), pa = n2, (fa = t2).attachEvent("onpropertychange", xa)) : e4 === "focusout" && ka();
  }
  function _a(e4) {
    if (e4 === "selectionchange" || e4 === "keyup" || e4 === "keydown")
      return ma(pa);
  }
  function Ea(e4, t2) {
    if (e4 === "click")
      return ma(t2);
  }
  function Pa(e4, t2) {
    if (e4 === "input" || e4 === "change")
      return ma(t2);
  }
  var Ca = typeof Object.is == "function" ? Object.is : function(e4, t2) {
    return e4 === t2 && (e4 !== 0 || 1 / e4 == 1 / t2) || e4 != e4 && t2 != t2;
  };
  var ja = Object.prototype.hasOwnProperty;
  function Oa(e4, t2) {
    if (Ca(e4, t2))
      return true;
    if (typeof e4 != "object" || e4 === null || typeof t2 != "object" || t2 === null)
      return false;
    var n2 = Object.keys(e4), r2 = Object.keys(t2);
    if (n2.length !== r2.length)
      return false;
    for (r2 = 0; r2 < n2.length; r2++)
      if (!ja.call(t2, n2[r2]) || !Ca(e4[n2[r2]], t2[n2[r2]]))
        return false;
    return true;
  }
  function Ta(e4) {
    for (; e4 && e4.firstChild; )
      e4 = e4.firstChild;
    return e4;
  }
  function Ia(e4, t2) {
    var n2, r2 = Ta(e4);
    for (e4 = 0; r2; ) {
      if (r2.nodeType === 3) {
        if (n2 = e4 + r2.textContent.length, e4 <= t2 && n2 >= t2)
          return { node: r2, offset: t2 - e4 };
        e4 = n2;
      }
      e: {
        for (; r2; ) {
          if (r2.nextSibling) {
            r2 = r2.nextSibling;
            break e;
          }
          r2 = r2.parentNode;
        }
        r2 = void 0;
      }
      r2 = Ta(r2);
    }
  }
  function Da(e4, t2) {
    return !(!e4 || !t2) && (e4 === t2 || (!e4 || e4.nodeType !== 3) && (t2 && t2.nodeType === 3 ? Da(e4, t2.parentNode) : "contains" in e4 ? e4.contains(t2) : !!e4.compareDocumentPosition && !!(16 & e4.compareDocumentPosition(t2))));
  }
  function Ra() {
    for (var e4 = window, t2 = mn(); t2 instanceof e4.HTMLIFrameElement; ) {
      try {
        var n2 = typeof t2.contentWindow.location.href == "string";
      } catch (e5) {
        n2 = false;
      }
      if (!n2)
        break;
      t2 = mn((e4 = t2.contentWindow).document);
    }
    return t2;
  }
  function Na(e4) {
    var t2 = e4 && e4.nodeName && e4.nodeName.toLowerCase();
    return t2 && (t2 === "input" && (e4.type === "text" || e4.type === "search" || e4.type === "tel" || e4.type === "url" || e4.type === "password") || t2 === "textarea" || e4.contentEditable === "true");
  }
  var Aa = Ct && "documentMode" in document && 11 >= document.documentMode;
  var za = null;
  var Ma = null;
  var La = null;
  var Fa = false;
  function $a(e4, t2, n2) {
    var r2 = n2.window === n2 ? n2.document : n2.nodeType === 9 ? n2 : n2.ownerDocument;
    Fa || za == null || za !== mn(r2) || ("selectionStart" in (r2 = za) && Na(r2) ? r2 = { start: r2.selectionStart, end: r2.selectionEnd } : r2 = { anchorNode: (r2 = (r2.ownerDocument && r2.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r2.anchorOffset, focusNode: r2.focusNode, focusOffset: r2.focusOffset }, La && Oa(La, r2) || (La = r2, 0 < (r2 = ei(Ma, "onSelect")).length && (t2 = new To("onSelect", "select", null, t2, n2), e4.push({ event: t2, listeners: r2 }), t2.target = za)));
  }
  Jr("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0), Jr("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1), Jr(Qr, 2);
  for (Ba = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), Va = 0; Va < Ba.length; Va++)
    Gr.set(Ba[Va], 0);
  var Ba;
  var Va;
  Pt("onMouseEnter", ["mouseout", "mouseover"]), Pt("onMouseLeave", ["mouseout", "mouseover"]), Pt("onPointerEnter", ["pointerout", "pointerover"]), Pt("onPointerLeave", ["pointerout", "pointerover"]), Et("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Et("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Et("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Et("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Et("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Et("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Ua = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
  var Ha = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ua));
  function Wa(e4, t2, n2) {
    var r2 = e4.type || "unknown-event";
    e4.currentTarget = n2, function(e5, t3, n3, r3, o2, a2, i2, s2, l2) {
      if (fr.apply(this, arguments), sr) {
        if (!sr)
          throw Error(xt(198));
        var u2 = lr;
        sr = false, lr = null, ur || (ur = true, cr = u2);
      }
    }(r2, t2, void 0, e4), e4.currentTarget = null;
  }
  function qa(e4, t2) {
    t2 = (4 & t2) != 0;
    for (var n2 = 0; n2 < e4.length; n2++) {
      var r2 = e4[n2], o2 = r2.event;
      r2 = r2.listeners;
      e: {
        var a2 = void 0;
        if (t2)
          for (var i2 = r2.length - 1; 0 <= i2; i2--) {
            var s2 = r2[i2], l2 = s2.instance, u2 = s2.currentTarget;
            if (s2 = s2.listener, l2 !== a2 && o2.isPropagationStopped())
              break e;
            Wa(o2, s2, u2), a2 = l2;
          }
        else
          for (i2 = 0; i2 < r2.length; i2++) {
            if (l2 = (s2 = r2[i2]).instance, u2 = s2.currentTarget, s2 = s2.listener, l2 !== a2 && o2.isPropagationStopped())
              break e;
            Wa(o2, s2, u2), a2 = l2;
          }
      }
    }
    if (ur)
      throw e4 = cr, ur = false, cr = null, e4;
  }
  function Ka(e4, t2) {
    var n2 = Si(t2), r2 = e4 + "__bubble";
    n2.has(r2) || (Qa(t2, e4, 2, false), n2.add(r2));
  }
  var Ya = "_reactListening" + Math.random().toString(36).slice(2);
  function Xa(e4) {
    e4[Ya] || (e4[Ya] = true, St.forEach(function(t2) {
      Ha.has(t2) || Ga(t2, false, e4, null), Ga(t2, true, e4, null);
    }));
  }
  function Ga(e4, t2, n2, r2) {
    var o2 = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, a2 = n2;
    if (e4 === "selectionchange" && n2.nodeType !== 9 && (a2 = n2.ownerDocument), r2 !== null && !t2 && Ha.has(e4)) {
      if (e4 !== "scroll")
        return;
      o2 |= 2, a2 = r2;
    }
    var i2 = Si(a2), s2 = e4 + "__" + (t2 ? "capture" : "bubble");
    i2.has(s2) || (t2 && (o2 |= 4), Qa(a2, e4, o2, t2), i2.add(s2));
  }
  function Qa(e4, t2, n2, r2) {
    var o2 = Gr.get(t2);
    switch (o2 === void 0 ? 2 : o2) {
      case 0:
        o2 = ho;
        break;
      case 1:
        o2 = mo;
        break;
      default:
        o2 = vo;
    }
    n2 = o2.bind(null, t2, n2, e4), o2 = void 0, !or || t2 !== "touchstart" && t2 !== "touchmove" && t2 !== "wheel" || (o2 = true), r2 ? o2 !== void 0 ? e4.addEventListener(t2, n2, { capture: true, passive: o2 }) : e4.addEventListener(t2, n2, true) : o2 !== void 0 ? e4.addEventListener(t2, n2, { passive: o2 }) : e4.addEventListener(t2, n2, false);
  }
  function Ja(e4, t2, n2, r2, o2) {
    var a2 = r2;
    if ((1 & t2) == 0 && (2 & t2) == 0 && r2 !== null)
      e:
        for (; ; ) {
          if (r2 === null)
            return;
          var i2 = r2.tag;
          if (i2 === 3 || i2 === 4) {
            var s2 = r2.stateNode.containerInfo;
            if (s2 === o2 || s2.nodeType === 8 && s2.parentNode === o2)
              break;
            if (i2 === 4)
              for (i2 = r2.return; i2 !== null; ) {
                var l2 = i2.tag;
                if ((l2 === 3 || l2 === 4) && ((l2 = i2.stateNode.containerInfo) === o2 || l2.nodeType === 8 && l2.parentNode === o2))
                  return;
                i2 = i2.return;
              }
            for (; s2 !== null; ) {
              if ((i2 = bi(s2)) === null)
                return;
              if ((l2 = i2.tag) === 5 || l2 === 6) {
                r2 = a2 = i2;
                continue e;
              }
              s2 = s2.parentNode;
            }
          }
          r2 = r2.return;
        }
    !function(e5, t3, n3) {
      if (tr)
        return e5(t3, n3);
      tr = true;
      try {
        Zn(e5, t3, n3);
      } finally {
        tr = false, nr();
      }
    }(function() {
      var r3 = a2, o3 = Un(n2), i3 = [];
      e: {
        var s3 = Xr.get(e4);
        if (s3 !== void 0) {
          var l3 = To, u2 = e4;
          switch (e4) {
            case "keypress":
              if (xo(n2) === 0)
                break e;
            case "keydown":
            case "keyup":
              l3 = Ko;
              break;
            case "focusin":
              u2 = "focus", l3 = zo;
              break;
            case "focusout":
              u2 = "blur", l3 = zo;
              break;
            case "beforeblur":
            case "afterblur":
              l3 = zo;
              break;
            case "click":
              if (n2.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              l3 = No;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              l3 = Ao;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              l3 = Xo;
              break;
            case Wr:
            case qr:
            case Kr:
              l3 = Mo;
              break;
            case Yr:
              l3 = Go;
              break;
            case "scroll":
              l3 = Do;
              break;
            case "wheel":
              l3 = Jo;
              break;
            case "copy":
            case "cut":
            case "paste":
              l3 = Fo;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              l3 = Yo;
          }
          var c2 = (4 & t2) != 0, d = !c2 && e4 === "scroll", f = c2 ? s3 !== null ? s3 + "Capture" : null : s3;
          c2 = [];
          for (var p, h2 = r3; h2 !== null; ) {
            var m2 = (p = h2).stateNode;
            if (p.tag === 5 && m2 !== null && (p = m2, f !== null && ((m2 = rr(h2, f)) != null && c2.push(Za(h2, m2, p)))), d)
              break;
            h2 = h2.return;
          }
          0 < c2.length && (s3 = new l3(s3, u2, null, n2, o3), i3.push({ event: s3, listeners: c2 }));
        }
      }
      if ((7 & t2) == 0) {
        if (l3 = e4 === "mouseout" || e4 === "pointerout", (!(s3 = e4 === "mouseover" || e4 === "pointerover") || (16 & t2) != 0 || !(u2 = n2.relatedTarget || n2.fromElement) || !bi(u2) && !u2[gi]) && (l3 || s3) && (s3 = o3.window === o3 ? o3 : (s3 = o3.ownerDocument) ? s3.defaultView || s3.parentWindow : window, l3 ? (l3 = r3, (u2 = (u2 = n2.relatedTarget || n2.toElement) ? bi(u2) : null) !== null && (u2 !== (d = pr(u2)) || u2.tag !== 5 && u2.tag !== 6) && (u2 = null)) : (l3 = null, u2 = r3), l3 !== u2)) {
          if (c2 = No, m2 = "onMouseLeave", f = "onMouseEnter", h2 = "mouse", e4 !== "pointerout" && e4 !== "pointerover" || (c2 = Yo, m2 = "onPointerLeave", f = "onPointerEnter", h2 = "pointer"), d = l3 == null ? s3 : ki(l3), p = u2 == null ? s3 : ki(u2), (s3 = new c2(m2, h2 + "leave", l3, n2, o3)).target = d, s3.relatedTarget = p, m2 = null, bi(o3) === r3 && ((c2 = new c2(f, h2 + "enter", u2, n2, o3)).target = p, c2.relatedTarget = d, m2 = c2), d = m2, l3 && u2)
            e: {
              for (f = u2, h2 = 0, p = c2 = l3; p; p = ti(p))
                h2++;
              for (p = 0, m2 = f; m2; m2 = ti(m2))
                p++;
              for (; 0 < h2 - p; )
                c2 = ti(c2), h2--;
              for (; 0 < p - h2; )
                f = ti(f), p--;
              for (; h2--; ) {
                if (c2 === f || f !== null && c2 === f.alternate)
                  break e;
                c2 = ti(c2), f = ti(f);
              }
              c2 = null;
            }
          else
            c2 = null;
          l3 !== null && ni(i3, s3, l3, c2, false), u2 !== null && d !== null && ni(i3, d, u2, c2, true);
        }
        if ((l3 = (s3 = r3 ? ki(r3) : window).nodeName && s3.nodeName.toLowerCase()) === "select" || l3 === "input" && s3.type === "file")
          var v2 = va;
        else if (ca(s3))
          if (ga)
            v2 = Pa;
          else {
            v2 = _a;
            var g2 = Sa;
          }
        else
          (l3 = s3.nodeName) && l3.toLowerCase() === "input" && (s3.type === "checkbox" || s3.type === "radio") && (v2 = Ea);
        switch (v2 && (v2 = v2(e4, r3)) ? da(i3, v2, n2, o3) : (g2 && g2(e4, s3, r3), e4 === "focusout" && (g2 = s3._wrapperState) && g2.controlled && s3.type === "number" && kn(s3, "number", s3.value)), g2 = r3 ? ki(r3) : window, e4) {
          case "focusin":
            (ca(g2) || g2.contentEditable === "true") && (za = g2, Ma = r3, La = null);
            break;
          case "focusout":
            La = Ma = za = null;
            break;
          case "mousedown":
            Fa = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Fa = false, $a(i3, n2, o3);
            break;
          case "selectionchange":
            if (Aa)
              break;
          case "keydown":
          case "keyup":
            $a(i3, n2, o3);
        }
        var y2;
        if (ea)
          e: {
            switch (e4) {
              case "compositionstart":
                var b2 = "onCompositionStart";
                break e;
              case "compositionend":
                b2 = "onCompositionEnd";
                break e;
              case "compositionupdate":
                b2 = "onCompositionUpdate";
                break e;
            }
            b2 = void 0;
          }
        else
          la ? ia(e4, n2) && (b2 = "onCompositionEnd") : e4 === "keydown" && n2.keyCode === 229 && (b2 = "onCompositionStart");
        b2 && (ra && n2.locale !== "ko" && (la || b2 !== "onCompositionStart" ? b2 === "onCompositionEnd" && la && (y2 = ko()) : (bo = "value" in (yo = o3) ? yo.value : yo.textContent, la = true)), 0 < (g2 = ei(r3, b2)).length && (b2 = new $o(b2, e4, null, n2, o3), i3.push({ event: b2, listeners: g2 }), y2 ? b2.data = y2 : (y2 = sa(n2)) !== null && (b2.data = y2))), (y2 = na ? function(e5, t3) {
          switch (e5) {
            case "compositionend":
              return sa(t3);
            case "keypress":
              return t3.which !== 32 ? null : (aa = true, oa);
            case "textInput":
              return (e5 = t3.data) === oa && aa ? null : e5;
            default:
              return null;
          }
        }(e4, n2) : function(e5, t3) {
          if (la)
            return e5 === "compositionend" || !ea && ia(e5, t3) ? (e5 = ko(), wo = bo = yo = null, la = false, e5) : null;
          switch (e5) {
            case "paste":
            default:
              return null;
            case "keypress":
              if (!(t3.ctrlKey || t3.altKey || t3.metaKey) || t3.ctrlKey && t3.altKey) {
                if (t3.char && 1 < t3.char.length)
                  return t3.char;
                if (t3.which)
                  return String.fromCharCode(t3.which);
              }
              return null;
            case "compositionend":
              return ra && t3.locale !== "ko" ? null : t3.data;
          }
        }(e4, n2)) && (0 < (r3 = ei(r3, "onBeforeInput")).length && (o3 = new $o("onBeforeInput", "beforeinput", null, n2, o3), i3.push({ event: o3, listeners: r3 }), o3.data = y2));
      }
      qa(i3, t2);
    });
  }
  function Za(e4, t2, n2) {
    return { instance: e4, listener: t2, currentTarget: n2 };
  }
  function ei(e4, t2) {
    for (var n2 = t2 + "Capture", r2 = []; e4 !== null; ) {
      var o2 = e4, a2 = o2.stateNode;
      o2.tag === 5 && a2 !== null && (o2 = a2, (a2 = rr(e4, n2)) != null && r2.unshift(Za(e4, a2, o2)), (a2 = rr(e4, t2)) != null && r2.push(Za(e4, a2, o2))), e4 = e4.return;
    }
    return r2;
  }
  function ti(e4) {
    if (e4 === null)
      return null;
    do {
      e4 = e4.return;
    } while (e4 && e4.tag !== 5);
    return e4 || null;
  }
  function ni(e4, t2, n2, r2, o2) {
    for (var a2 = t2._reactName, i2 = []; n2 !== null && n2 !== r2; ) {
      var s2 = n2, l2 = s2.alternate, u2 = s2.stateNode;
      if (l2 !== null && l2 === r2)
        break;
      s2.tag === 5 && u2 !== null && (s2 = u2, o2 ? (l2 = rr(n2, a2)) != null && i2.unshift(Za(n2, l2, s2)) : o2 || (l2 = rr(n2, a2)) != null && i2.push(Za(n2, l2, s2))), n2 = n2.return;
    }
    i2.length !== 0 && e4.push({ event: t2, listeners: i2 });
  }
  function ri() {
  }
  var oi = null;
  var ai = null;
  function ii(e4, t2) {
    switch (e4) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        return !!t2.autoFocus;
    }
    return false;
  }
  function si(e4, t2) {
    return e4 === "textarea" || e4 === "option" || e4 === "noscript" || typeof t2.children == "string" || typeof t2.children == "number" || typeof t2.dangerouslySetInnerHTML == "object" && t2.dangerouslySetInnerHTML !== null && t2.dangerouslySetInnerHTML.__html != null;
  }
  var li = typeof setTimeout == "function" ? setTimeout : void 0;
  var ui = typeof clearTimeout == "function" ? clearTimeout : void 0;
  function ci(e4) {
    e4.nodeType === 1 ? e4.textContent = "" : e4.nodeType === 9 && ((e4 = e4.body) != null && (e4.textContent = ""));
  }
  function di(e4) {
    for (; e4 != null; e4 = e4.nextSibling) {
      var t2 = e4.nodeType;
      if (t2 === 1 || t2 === 3)
        break;
    }
    return e4;
  }
  function fi(e4) {
    e4 = e4.previousSibling;
    for (var t2 = 0; e4; ) {
      if (e4.nodeType === 8) {
        var n2 = e4.data;
        if (n2 === "$" || n2 === "$!" || n2 === "$?") {
          if (t2 === 0)
            return e4;
          t2--;
        } else
          n2 === "/$" && t2++;
      }
      e4 = e4.previousSibling;
    }
    return null;
  }
  var pi = 0;
  var hi = Math.random().toString(36).slice(2);
  var mi = "__reactFiber$" + hi;
  var vi = "__reactProps$" + hi;
  var gi = "__reactContainer$" + hi;
  var yi = "__reactEvents$" + hi;
  function bi(e4) {
    var t2 = e4[mi];
    if (t2)
      return t2;
    for (var n2 = e4.parentNode; n2; ) {
      if (t2 = n2[gi] || n2[mi]) {
        if (n2 = t2.alternate, t2.child !== null || n2 !== null && n2.child !== null)
          for (e4 = fi(e4); e4 !== null; ) {
            if (n2 = e4[mi])
              return n2;
            e4 = fi(e4);
          }
        return t2;
      }
      n2 = (e4 = n2).parentNode;
    }
    return null;
  }
  function wi(e4) {
    return !(e4 = e4[mi] || e4[gi]) || e4.tag !== 5 && e4.tag !== 6 && e4.tag !== 13 && e4.tag !== 3 ? null : e4;
  }
  function ki(e4) {
    if (e4.tag === 5 || e4.tag === 6)
      return e4.stateNode;
    throw Error(xt(33));
  }
  function xi(e4) {
    return e4[vi] || null;
  }
  function Si(e4) {
    var t2 = e4[yi];
    return t2 === void 0 && (t2 = e4[yi] = /* @__PURE__ */ new Set()), t2;
  }
  var _i = [];
  var Ei = -1;
  function Pi(e4) {
    return { current: e4 };
  }
  function Ci(e4) {
    0 > Ei || (e4.current = _i[Ei], _i[Ei] = null, Ei--);
  }
  function ji(e4, t2) {
    Ei++, _i[Ei] = e4.current, e4.current = t2;
  }
  var Oi = {};
  var Ti = Pi(Oi);
  var Ii = Pi(false);
  var Di = Oi;
  function Ri(e4, t2) {
    var n2 = e4.type.contextTypes;
    if (!n2)
      return Oi;
    var r2 = e4.stateNode;
    if (r2 && r2.__reactInternalMemoizedUnmaskedChildContext === t2)
      return r2.__reactInternalMemoizedMaskedChildContext;
    var o2, a2 = {};
    for (o2 in n2)
      a2[o2] = t2[o2];
    return r2 && ((e4 = e4.stateNode).__reactInternalMemoizedUnmaskedChildContext = t2, e4.__reactInternalMemoizedMaskedChildContext = a2), a2;
  }
  function Ni(e4) {
    return (e4 = e4.childContextTypes) != null;
  }
  function Ai() {
    Ci(Ii), Ci(Ti);
  }
  function zi(e4, t2, n2) {
    if (Ti.current !== Oi)
      throw Error(xt(168));
    ji(Ti, t2), ji(Ii, n2);
  }
  function Mi(e4, t2, n2) {
    var r2 = e4.stateNode;
    if (e4 = t2.childContextTypes, typeof r2.getChildContext != "function")
      return n2;
    for (var o2 in r2 = r2.getChildContext())
      if (!(o2 in e4))
        throw Error(xt(108, cn(t2) || "Unknown", o2));
    return wt({}, n2, r2);
  }
  function Li(e4) {
    return e4 = (e4 = e4.stateNode) && e4.__reactInternalMemoizedMergedChildContext || Oi, Di = Ti.current, ji(Ti, e4), ji(Ii, Ii.current), true;
  }
  function Fi(e4, t2, n2) {
    var r2 = e4.stateNode;
    if (!r2)
      throw Error(xt(169));
    n2 ? (e4 = Mi(e4, t2, Di), r2.__reactInternalMemoizedMergedChildContext = e4, Ci(Ii), Ci(Ti), ji(Ti, e4)) : Ci(Ii), ji(Ii, n2);
  }
  var $i = null;
  var Bi = null;
  var Vi = kt.unstable_runWithPriority;
  var Ui = kt.unstable_scheduleCallback;
  var Hi = kt.unstable_cancelCallback;
  var Wi = kt.unstable_shouldYield;
  var qi = kt.unstable_requestPaint;
  var Ki = kt.unstable_now;
  var Yi = kt.unstable_getCurrentPriorityLevel;
  var Xi = kt.unstable_ImmediatePriority;
  var Gi = kt.unstable_UserBlockingPriority;
  var Qi = kt.unstable_NormalPriority;
  var Ji = kt.unstable_LowPriority;
  var Zi = kt.unstable_IdlePriority;
  var es = {};
  var ts = qi !== void 0 ? qi : function() {
  };
  var ns = null;
  var rs = null;
  var os = false;
  var as = Ki();
  var is = 1e4 > as ? Ki : function() {
    return Ki() - as;
  };
  function ss() {
    switch (Yi()) {
      case Xi:
        return 99;
      case Gi:
        return 98;
      case Qi:
        return 97;
      case Ji:
        return 96;
      case Zi:
        return 95;
      default:
        throw Error(xt(332));
    }
  }
  function ls(e4) {
    switch (e4) {
      case 99:
        return Xi;
      case 98:
        return Gi;
      case 97:
        return Qi;
      case 96:
        return Ji;
      case 95:
        return Zi;
      default:
        throw Error(xt(332));
    }
  }
  function us(e4, t2) {
    return e4 = ls(e4), Vi(e4, t2);
  }
  function cs(e4, t2, n2) {
    return e4 = ls(e4), Ui(e4, t2, n2);
  }
  function ds() {
    if (rs !== null) {
      var e4 = rs;
      rs = null, Hi(e4);
    }
    fs();
  }
  function fs() {
    if (!os && ns !== null) {
      os = true;
      var e4 = 0;
      try {
        var t2 = ns;
        us(99, function() {
          for (; e4 < t2.length; e4++) {
            var n2 = t2[e4];
            do {
              n2 = n2(true);
            } while (n2 !== null);
          }
        }), ns = null;
      } catch (t3) {
        throw ns !== null && (ns = ns.slice(e4 + 1)), Ui(Xi, ds), t3;
      } finally {
        os = false;
      }
    }
  }
  var ps = Mt.ReactCurrentBatchConfig;
  function hs(e4, t2) {
    if (e4 && e4.defaultProps) {
      for (var n2 in t2 = wt({}, t2), e4 = e4.defaultProps)
        t2[n2] === void 0 && (t2[n2] = e4[n2]);
      return t2;
    }
    return t2;
  }
  var ms = Pi(null);
  var vs = null;
  var gs = null;
  var ys = null;
  function bs() {
    ys = gs = vs = null;
  }
  function ws(e4) {
    var t2 = ms.current;
    Ci(ms), e4.type._context._currentValue = t2;
  }
  function ks(e4, t2) {
    for (; e4 !== null; ) {
      var n2 = e4.alternate;
      if ((e4.childLanes & t2) === t2) {
        if (n2 === null || (n2.childLanes & t2) === t2)
          break;
        n2.childLanes |= t2;
      } else
        e4.childLanes |= t2, n2 !== null && (n2.childLanes |= t2);
      e4 = e4.return;
    }
  }
  function xs(e4, t2) {
    vs = e4, ys = gs = null, (e4 = e4.dependencies) !== null && e4.firstContext !== null && ((e4.lanes & t2) != 0 && (Zl = true), e4.firstContext = null);
  }
  function Ss(e4, t2) {
    if (ys !== e4 && t2 !== false && t2 !== 0)
      if (typeof t2 == "number" && t2 !== 1073741823 || (ys = e4, t2 = 1073741823), t2 = { context: e4, observedBits: t2, next: null }, gs === null) {
        if (vs === null)
          throw Error(xt(308));
        gs = t2, vs.dependencies = { lanes: 0, firstContext: t2, responders: null };
      } else
        gs = gs.next = t2;
    return e4._currentValue;
  }
  var _s = false;
  function Es(e4) {
    e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
  }
  function Ps(e4, t2) {
    e4 = e4.updateQueue, t2.updateQueue === e4 && (t2.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, effects: e4.effects });
  }
  function Cs(e4, t2) {
    return { eventTime: e4, lane: t2, tag: 0, payload: null, callback: null, next: null };
  }
  function js(e4, t2) {
    if ((e4 = e4.updateQueue) !== null) {
      var n2 = (e4 = e4.shared).pending;
      n2 === null ? t2.next = t2 : (t2.next = n2.next, n2.next = t2), e4.pending = t2;
    }
  }
  function Os(e4, t2) {
    var n2 = e4.updateQueue, r2 = e4.alternate;
    if (r2 !== null && n2 === (r2 = r2.updateQueue)) {
      var o2 = null, a2 = null;
      if ((n2 = n2.firstBaseUpdate) !== null) {
        do {
          var i2 = { eventTime: n2.eventTime, lane: n2.lane, tag: n2.tag, payload: n2.payload, callback: n2.callback, next: null };
          a2 === null ? o2 = a2 = i2 : a2 = a2.next = i2, n2 = n2.next;
        } while (n2 !== null);
        a2 === null ? o2 = a2 = t2 : a2 = a2.next = t2;
      } else
        o2 = a2 = t2;
      return n2 = { baseState: r2.baseState, firstBaseUpdate: o2, lastBaseUpdate: a2, shared: r2.shared, effects: r2.effects }, void (e4.updateQueue = n2);
    }
    (e4 = n2.lastBaseUpdate) === null ? n2.firstBaseUpdate = t2 : e4.next = t2, n2.lastBaseUpdate = t2;
  }
  function Ts(e4, t2, n2, r2) {
    var o2 = e4.updateQueue;
    _s = false;
    var a2 = o2.firstBaseUpdate, i2 = o2.lastBaseUpdate, s2 = o2.shared.pending;
    if (s2 !== null) {
      o2.shared.pending = null;
      var l2 = s2, u2 = l2.next;
      l2.next = null, i2 === null ? a2 = u2 : i2.next = u2, i2 = l2;
      var c2 = e4.alternate;
      if (c2 !== null) {
        var d = (c2 = c2.updateQueue).lastBaseUpdate;
        d !== i2 && (d === null ? c2.firstBaseUpdate = u2 : d.next = u2, c2.lastBaseUpdate = l2);
      }
    }
    if (a2 !== null) {
      for (d = o2.baseState, i2 = 0, c2 = u2 = l2 = null; ; ) {
        s2 = a2.lane;
        var f = a2.eventTime;
        if ((r2 & s2) === s2) {
          c2 !== null && (c2 = c2.next = { eventTime: f, lane: 0, tag: a2.tag, payload: a2.payload, callback: a2.callback, next: null });
          e: {
            var p = e4, h2 = a2;
            switch (s2 = t2, f = n2, h2.tag) {
              case 1:
                if (typeof (p = h2.payload) == "function") {
                  d = p.call(f, d, s2);
                  break e;
                }
                d = p;
                break e;
              case 3:
                p.flags = -4097 & p.flags | 64;
              case 0:
                if ((s2 = typeof (p = h2.payload) == "function" ? p.call(f, d, s2) : p) == null)
                  break e;
                d = wt({}, d, s2);
                break e;
              case 2:
                _s = true;
            }
          }
          a2.callback !== null && (e4.flags |= 32, (s2 = o2.effects) === null ? o2.effects = [a2] : s2.push(a2));
        } else
          f = { eventTime: f, lane: s2, tag: a2.tag, payload: a2.payload, callback: a2.callback, next: null }, c2 === null ? (u2 = c2 = f, l2 = d) : c2 = c2.next = f, i2 |= s2;
        if ((a2 = a2.next) === null) {
          if ((s2 = o2.shared.pending) === null)
            break;
          a2 = s2.next, s2.next = null, o2.lastBaseUpdate = s2, o2.shared.pending = null;
        }
      }
      c2 === null && (l2 = d), o2.baseState = l2, o2.firstBaseUpdate = u2, o2.lastBaseUpdate = c2, rc |= i2, e4.lanes = i2, e4.memoizedState = d;
    }
  }
  function Is(e4, t2, n2) {
    if (e4 = t2.effects, t2.effects = null, e4 !== null)
      for (t2 = 0; t2 < e4.length; t2++) {
        var r2 = e4[t2], o2 = r2.callback;
        if (o2 !== null) {
          if (r2.callback = null, r2 = n2, typeof o2 != "function")
            throw Error(xt(191, o2));
          o2.call(r2);
        }
      }
  }
  var Ds = new bt.Component().refs;
  function Rs(e4, t2, n2, r2) {
    n2 = (n2 = n2(r2, t2 = e4.memoizedState)) == null ? t2 : wt({}, t2, n2), e4.memoizedState = n2, e4.lanes === 0 && (e4.updateQueue.baseState = n2);
  }
  var Ns = { isMounted: function(e4) {
    return !!(e4 = e4._reactInternals) && pr(e4) === e4;
  }, enqueueSetState: function(e4, t2, n2) {
    e4 = e4._reactInternals;
    var r2 = jc(), o2 = Oc(e4), a2 = Cs(r2, o2);
    a2.payload = t2, n2 != null && (a2.callback = n2), js(e4, a2), Tc(e4, o2, r2);
  }, enqueueReplaceState: function(e4, t2, n2) {
    e4 = e4._reactInternals;
    var r2 = jc(), o2 = Oc(e4), a2 = Cs(r2, o2);
    a2.tag = 1, a2.payload = t2, n2 != null && (a2.callback = n2), js(e4, a2), Tc(e4, o2, r2);
  }, enqueueForceUpdate: function(e4, t2) {
    e4 = e4._reactInternals;
    var n2 = jc(), r2 = Oc(e4), o2 = Cs(n2, r2);
    o2.tag = 2, t2 != null && (o2.callback = t2), js(e4, o2), Tc(e4, r2, n2);
  } };
  function As(e4, t2, n2, r2, o2, a2, i2) {
    return typeof (e4 = e4.stateNode).shouldComponentUpdate == "function" ? e4.shouldComponentUpdate(r2, a2, i2) : !t2.prototype || !t2.prototype.isPureReactComponent || (!Oa(n2, r2) || !Oa(o2, a2));
  }
  function zs(e4, t2, n2) {
    var r2 = false, o2 = Oi, a2 = t2.contextType;
    return typeof a2 == "object" && a2 !== null ? a2 = Ss(a2) : (o2 = Ni(t2) ? Di : Ti.current, a2 = (r2 = (r2 = t2.contextTypes) != null) ? Ri(e4, o2) : Oi), t2 = new t2(n2, a2), e4.memoizedState = t2.state !== null && t2.state !== void 0 ? t2.state : null, t2.updater = Ns, e4.stateNode = t2, t2._reactInternals = e4, r2 && ((e4 = e4.stateNode).__reactInternalMemoizedUnmaskedChildContext = o2, e4.__reactInternalMemoizedMaskedChildContext = a2), t2;
  }
  function Ms(e4, t2, n2, r2) {
    e4 = t2.state, typeof t2.componentWillReceiveProps == "function" && t2.componentWillReceiveProps(n2, r2), typeof t2.UNSAFE_componentWillReceiveProps == "function" && t2.UNSAFE_componentWillReceiveProps(n2, r2), t2.state !== e4 && Ns.enqueueReplaceState(t2, t2.state, null);
  }
  function Ls(e4, t2, n2, r2) {
    var o2 = e4.stateNode;
    o2.props = n2, o2.state = e4.memoizedState, o2.refs = Ds, Es(e4);
    var a2 = t2.contextType;
    typeof a2 == "object" && a2 !== null ? o2.context = Ss(a2) : (a2 = Ni(t2) ? Di : Ti.current, o2.context = Ri(e4, a2)), Ts(e4, n2, o2, r2), o2.state = e4.memoizedState, typeof (a2 = t2.getDerivedStateFromProps) == "function" && (Rs(e4, t2, a2, n2), o2.state = e4.memoizedState), typeof t2.getDerivedStateFromProps == "function" || typeof o2.getSnapshotBeforeUpdate == "function" || typeof o2.UNSAFE_componentWillMount != "function" && typeof o2.componentWillMount != "function" || (t2 = o2.state, typeof o2.componentWillMount == "function" && o2.componentWillMount(), typeof o2.UNSAFE_componentWillMount == "function" && o2.UNSAFE_componentWillMount(), t2 !== o2.state && Ns.enqueueReplaceState(o2, o2.state, null), Ts(e4, n2, o2, r2), o2.state = e4.memoizedState), typeof o2.componentDidMount == "function" && (e4.flags |= 4);
  }
  var Fs = Array.isArray;
  function $s(e4, t2, n2) {
    if ((e4 = n2.ref) !== null && typeof e4 != "function" && typeof e4 != "object") {
      if (n2._owner) {
        if (n2 = n2._owner) {
          if (n2.tag !== 1)
            throw Error(xt(309));
          var r2 = n2.stateNode;
        }
        if (!r2)
          throw Error(xt(147, e4));
        var o2 = "" + e4;
        return t2 !== null && t2.ref !== null && typeof t2.ref == "function" && t2.ref._stringRef === o2 ? t2.ref : (t2 = function(e5) {
          var t3 = r2.refs;
          t3 === Ds && (t3 = r2.refs = {}), e5 === null ? delete t3[o2] : t3[o2] = e5;
        }, t2._stringRef = o2, t2);
      }
      if (typeof e4 != "string")
        throw Error(xt(284));
      if (!n2._owner)
        throw Error(xt(290, e4));
    }
    return e4;
  }
  function Bs(e4, t2) {
    if (e4.type !== "textarea")
      throw Error(xt(31, Object.prototype.toString.call(t2) === "[object Object]" ? "object with keys {" + Object.keys(t2).join(", ") + "}" : t2));
  }
  function Vs(e4) {
    function t2(t3, n3) {
      if (e4) {
        var r3 = t3.lastEffect;
        r3 !== null ? (r3.nextEffect = n3, t3.lastEffect = n3) : t3.firstEffect = t3.lastEffect = n3, n3.nextEffect = null, n3.flags = 8;
      }
    }
    function n2(n3, r3) {
      if (!e4)
        return null;
      for (; r3 !== null; )
        t2(n3, r3), r3 = r3.sibling;
      return null;
    }
    function r2(e5, t3) {
      for (e5 = /* @__PURE__ */ new Map(); t3 !== null; )
        t3.key !== null ? e5.set(t3.key, t3) : e5.set(t3.index, t3), t3 = t3.sibling;
      return e5;
    }
    function o2(e5, t3) {
      return (e5 = ld(e5, t3)).index = 0, e5.sibling = null, e5;
    }
    function a2(t3, n3, r3) {
      return t3.index = r3, e4 ? (r3 = t3.alternate) !== null ? (r3 = r3.index) < n3 ? (t3.flags = 2, n3) : r3 : (t3.flags = 2, n3) : n3;
    }
    function i2(t3) {
      return e4 && t3.alternate === null && (t3.flags = 2), t3;
    }
    function s2(e5, t3, n3, r3) {
      return t3 === null || t3.tag !== 6 ? ((t3 = fd(n3, e5.mode, r3)).return = e5, t3) : ((t3 = o2(t3, n3)).return = e5, t3);
    }
    function l2(e5, t3, n3, r3) {
      return t3 !== null && t3.elementType === n3.type ? ((r3 = o2(t3, n3.props)).ref = $s(e5, t3, n3), r3.return = e5, r3) : ((r3 = ud(n3.type, n3.key, n3.props, null, e5.mode, r3)).ref = $s(e5, t3, n3), r3.return = e5, r3);
    }
    function u2(e5, t3, n3, r3) {
      return t3 === null || t3.tag !== 4 || t3.stateNode.containerInfo !== n3.containerInfo || t3.stateNode.implementation !== n3.implementation ? ((t3 = pd(n3, e5.mode, r3)).return = e5, t3) : ((t3 = o2(t3, n3.children || [])).return = e5, t3);
    }
    function c2(e5, t3, n3, r3, a3) {
      return t3 === null || t3.tag !== 7 ? ((t3 = cd(n3, e5.mode, r3, a3)).return = e5, t3) : ((t3 = o2(t3, n3)).return = e5, t3);
    }
    function d(e5, t3, n3) {
      if (typeof t3 == "string" || typeof t3 == "number")
        return (t3 = fd("" + t3, e5.mode, n3)).return = e5, t3;
      if (typeof t3 == "object" && t3 !== null) {
        switch (t3.$$typeof) {
          case Lt:
            return (n3 = ud(t3.type, t3.key, t3.props, null, e5.mode, n3)).ref = $s(e5, null, t3), n3.return = e5, n3;
          case Ft:
            return (t3 = pd(t3, e5.mode, n3)).return = e5, t3;
        }
        if (Fs(t3) || on(t3))
          return (t3 = cd(t3, e5.mode, n3, null)).return = e5, t3;
        Bs(e5, t3);
      }
      return null;
    }
    function f(e5, t3, n3, r3) {
      var o3 = t3 !== null ? t3.key : null;
      if (typeof n3 == "string" || typeof n3 == "number")
        return o3 !== null ? null : s2(e5, t3, "" + n3, r3);
      if (typeof n3 == "object" && n3 !== null) {
        switch (n3.$$typeof) {
          case Lt:
            return n3.key === o3 ? n3.type === $t ? c2(e5, t3, n3.props.children, r3, o3) : l2(e5, t3, n3, r3) : null;
          case Ft:
            return n3.key === o3 ? u2(e5, t3, n3, r3) : null;
        }
        if (Fs(n3) || on(n3))
          return o3 !== null ? null : c2(e5, t3, n3, r3, null);
        Bs(e5, n3);
      }
      return null;
    }
    function p(e5, t3, n3, r3, o3) {
      if (typeof r3 == "string" || typeof r3 == "number")
        return s2(t3, e5 = e5.get(n3) || null, "" + r3, o3);
      if (typeof r3 == "object" && r3 !== null) {
        switch (r3.$$typeof) {
          case Lt:
            return e5 = e5.get(r3.key === null ? n3 : r3.key) || null, r3.type === $t ? c2(t3, e5, r3.props.children, o3, r3.key) : l2(t3, e5, r3, o3);
          case Ft:
            return u2(t3, e5 = e5.get(r3.key === null ? n3 : r3.key) || null, r3, o3);
        }
        if (Fs(r3) || on(r3))
          return c2(t3, e5 = e5.get(n3) || null, r3, o3, null);
        Bs(t3, r3);
      }
      return null;
    }
    function h2(o3, i3, s3, l3) {
      for (var u3 = null, c3 = null, h3 = i3, m3 = i3 = 0, v2 = null; h3 !== null && m3 < s3.length; m3++) {
        h3.index > m3 ? (v2 = h3, h3 = null) : v2 = h3.sibling;
        var g2 = f(o3, h3, s3[m3], l3);
        if (g2 === null) {
          h3 === null && (h3 = v2);
          break;
        }
        e4 && h3 && g2.alternate === null && t2(o3, h3), i3 = a2(g2, i3, m3), c3 === null ? u3 = g2 : c3.sibling = g2, c3 = g2, h3 = v2;
      }
      if (m3 === s3.length)
        return n2(o3, h3), u3;
      if (h3 === null) {
        for (; m3 < s3.length; m3++)
          (h3 = d(o3, s3[m3], l3)) !== null && (i3 = a2(h3, i3, m3), c3 === null ? u3 = h3 : c3.sibling = h3, c3 = h3);
        return u3;
      }
      for (h3 = r2(o3, h3); m3 < s3.length; m3++)
        (v2 = p(h3, o3, m3, s3[m3], l3)) !== null && (e4 && v2.alternate !== null && h3.delete(v2.key === null ? m3 : v2.key), i3 = a2(v2, i3, m3), c3 === null ? u3 = v2 : c3.sibling = v2, c3 = v2);
      return e4 && h3.forEach(function(e5) {
        return t2(o3, e5);
      }), u3;
    }
    function m2(o3, i3, s3, l3) {
      var u3 = on(s3);
      if (typeof u3 != "function")
        throw Error(xt(150));
      if ((s3 = u3.call(s3)) == null)
        throw Error(xt(151));
      for (var c3 = u3 = null, h3 = i3, m3 = i3 = 0, v2 = null, g2 = s3.next(); h3 !== null && !g2.done; m3++, g2 = s3.next()) {
        h3.index > m3 ? (v2 = h3, h3 = null) : v2 = h3.sibling;
        var y2 = f(o3, h3, g2.value, l3);
        if (y2 === null) {
          h3 === null && (h3 = v2);
          break;
        }
        e4 && h3 && y2.alternate === null && t2(o3, h3), i3 = a2(y2, i3, m3), c3 === null ? u3 = y2 : c3.sibling = y2, c3 = y2, h3 = v2;
      }
      if (g2.done)
        return n2(o3, h3), u3;
      if (h3 === null) {
        for (; !g2.done; m3++, g2 = s3.next())
          (g2 = d(o3, g2.value, l3)) !== null && (i3 = a2(g2, i3, m3), c3 === null ? u3 = g2 : c3.sibling = g2, c3 = g2);
        return u3;
      }
      for (h3 = r2(o3, h3); !g2.done; m3++, g2 = s3.next())
        (g2 = p(h3, o3, m3, g2.value, l3)) !== null && (e4 && g2.alternate !== null && h3.delete(g2.key === null ? m3 : g2.key), i3 = a2(g2, i3, m3), c3 === null ? u3 = g2 : c3.sibling = g2, c3 = g2);
      return e4 && h3.forEach(function(e5) {
        return t2(o3, e5);
      }), u3;
    }
    return function(e5, r3, a3, s3) {
      var l3 = typeof a3 == "object" && a3 !== null && a3.type === $t && a3.key === null;
      l3 && (a3 = a3.props.children);
      var u3 = typeof a3 == "object" && a3 !== null;
      if (u3)
        switch (a3.$$typeof) {
          case Lt:
            e: {
              for (u3 = a3.key, l3 = r3; l3 !== null; ) {
                if (l3.key === u3) {
                  if (l3.tag === 7) {
                    if (a3.type === $t) {
                      n2(e5, l3.sibling), (r3 = o2(l3, a3.props.children)).return = e5, e5 = r3;
                      break e;
                    }
                  } else if (l3.elementType === a3.type) {
                    n2(e5, l3.sibling), (r3 = o2(l3, a3.props)).ref = $s(e5, l3, a3), r3.return = e5, e5 = r3;
                    break e;
                  }
                  n2(e5, l3);
                  break;
                }
                t2(e5, l3), l3 = l3.sibling;
              }
              a3.type === $t ? ((r3 = cd(a3.props.children, e5.mode, s3, a3.key)).return = e5, e5 = r3) : ((s3 = ud(a3.type, a3.key, a3.props, null, e5.mode, s3)).ref = $s(e5, r3, a3), s3.return = e5, e5 = s3);
            }
            return i2(e5);
          case Ft:
            e: {
              for (l3 = a3.key; r3 !== null; ) {
                if (r3.key === l3) {
                  if (r3.tag === 4 && r3.stateNode.containerInfo === a3.containerInfo && r3.stateNode.implementation === a3.implementation) {
                    n2(e5, r3.sibling), (r3 = o2(r3, a3.children || [])).return = e5, e5 = r3;
                    break e;
                  }
                  n2(e5, r3);
                  break;
                }
                t2(e5, r3), r3 = r3.sibling;
              }
              (r3 = pd(a3, e5.mode, s3)).return = e5, e5 = r3;
            }
            return i2(e5);
        }
      if (typeof a3 == "string" || typeof a3 == "number")
        return a3 = "" + a3, r3 !== null && r3.tag === 6 ? (n2(e5, r3.sibling), (r3 = o2(r3, a3)).return = e5, e5 = r3) : (n2(e5, r3), (r3 = fd(a3, e5.mode, s3)).return = e5, e5 = r3), i2(e5);
      if (Fs(a3))
        return h2(e5, r3, a3, s3);
      if (on(a3))
        return m2(e5, r3, a3, s3);
      if (u3 && Bs(e5, a3), a3 === void 0 && !l3)
        switch (e5.tag) {
          case 1:
          case 22:
          case 0:
          case 11:
          case 15:
            throw Error(xt(152, cn(e5.type) || "Component"));
        }
      return n2(e5, r3);
    };
  }
  var Us = Vs(true);
  var Hs = Vs(false);
  var Ws = {};
  var qs = Pi(Ws);
  var Ks = Pi(Ws);
  var Ys = Pi(Ws);
  function Xs(e4) {
    if (e4 === Ws)
      throw Error(xt(174));
    return e4;
  }
  function Gs(e4, t2) {
    switch (ji(Ys, t2), ji(Ks, e4), ji(qs, Ws), e4 = t2.nodeType) {
      case 9:
      case 11:
        t2 = (t2 = t2.documentElement) ? t2.namespaceURI : In(null, "");
        break;
      default:
        t2 = In(t2 = (e4 = e4 === 8 ? t2.parentNode : t2).namespaceURI || null, e4 = e4.tagName);
    }
    Ci(qs), ji(qs, t2);
  }
  function Qs() {
    Ci(qs), Ci(Ks), Ci(Ys);
  }
  function Js(e4) {
    Xs(Ys.current);
    var t2 = Xs(qs.current), n2 = In(t2, e4.type);
    t2 !== n2 && (ji(Ks, e4), ji(qs, n2));
  }
  function Zs(e4) {
    Ks.current === e4 && (Ci(qs), Ci(Ks));
  }
  var el = Pi(0);
  function tl(e4) {
    for (var t2 = e4; t2 !== null; ) {
      if (t2.tag === 13) {
        var n2 = t2.memoizedState;
        if (n2 !== null && ((n2 = n2.dehydrated) === null || n2.data === "$?" || n2.data === "$!"))
          return t2;
      } else if (t2.tag === 19 && t2.memoizedProps.revealOrder !== void 0) {
        if ((64 & t2.flags) != 0)
          return t2;
      } else if (t2.child !== null) {
        t2.child.return = t2, t2 = t2.child;
        continue;
      }
      if (t2 === e4)
        break;
      for (; t2.sibling === null; ) {
        if (t2.return === null || t2.return === e4)
          return null;
        t2 = t2.return;
      }
      t2.sibling.return = t2.return, t2 = t2.sibling;
    }
    return null;
  }
  var nl = null;
  var rl = null;
  var ol = false;
  function al(e4, t2) {
    var n2 = id(5, null, null, 0);
    n2.elementType = "DELETED", n2.type = "DELETED", n2.stateNode = t2, n2.return = e4, n2.flags = 8, e4.lastEffect !== null ? (e4.lastEffect.nextEffect = n2, e4.lastEffect = n2) : e4.firstEffect = e4.lastEffect = n2;
  }
  function il(e4, t2) {
    switch (e4.tag) {
      case 5:
        var n2 = e4.type;
        return (t2 = t2.nodeType !== 1 || n2.toLowerCase() !== t2.nodeName.toLowerCase() ? null : t2) !== null && (e4.stateNode = t2, true);
      case 6:
        return (t2 = e4.pendingProps === "" || t2.nodeType !== 3 ? null : t2) !== null && (e4.stateNode = t2, true);
      default:
        return false;
    }
  }
  function sl(e4) {
    if (ol) {
      var t2 = rl;
      if (t2) {
        var n2 = t2;
        if (!il(e4, t2)) {
          if (!(t2 = di(n2.nextSibling)) || !il(e4, t2))
            return e4.flags = -1025 & e4.flags | 2, ol = false, void (nl = e4);
          al(nl, n2);
        }
        nl = e4, rl = di(t2.firstChild);
      } else
        e4.flags = -1025 & e4.flags | 2, ol = false, nl = e4;
    }
  }
  function ll(e4) {
    for (e4 = e4.return; e4 !== null && e4.tag !== 5 && e4.tag !== 3 && e4.tag !== 13; )
      e4 = e4.return;
    nl = e4;
  }
  function ul(e4) {
    if (e4 !== nl)
      return false;
    if (!ol)
      return ll(e4), ol = true, false;
    var t2 = e4.type;
    if (e4.tag !== 5 || t2 !== "head" && t2 !== "body" && !si(t2, e4.memoizedProps))
      for (t2 = rl; t2; )
        al(e4, t2), t2 = di(t2.nextSibling);
    if (ll(e4), e4.tag === 13) {
      if (!(e4 = (e4 = e4.memoizedState) !== null ? e4.dehydrated : null))
        throw Error(xt(317));
      e: {
        for (e4 = e4.nextSibling, t2 = 0; e4; ) {
          if (e4.nodeType === 8) {
            var n2 = e4.data;
            if (n2 === "/$") {
              if (t2 === 0) {
                rl = di(e4.nextSibling);
                break e;
              }
              t2--;
            } else
              n2 !== "$" && n2 !== "$!" && n2 !== "$?" || t2++;
          }
          e4 = e4.nextSibling;
        }
        rl = null;
      }
    } else
      rl = nl ? di(e4.stateNode.nextSibling) : null;
    return true;
  }
  function cl() {
    rl = nl = null, ol = false;
  }
  var dl = [];
  function fl() {
    for (var e4 = 0; e4 < dl.length; e4++)
      dl[e4]._workInProgressVersionPrimary = null;
    dl.length = 0;
  }
  var pl = Mt.ReactCurrentDispatcher;
  var hl = Mt.ReactCurrentBatchConfig;
  var ml = 0;
  var vl = null;
  var gl = null;
  var yl = null;
  var bl = false;
  var wl = false;
  function kl() {
    throw Error(xt(321));
  }
  function xl(e4, t2) {
    if (t2 === null)
      return false;
    for (var n2 = 0; n2 < t2.length && n2 < e4.length; n2++)
      if (!Ca(e4[n2], t2[n2]))
        return false;
    return true;
  }
  function Sl(e4, t2, n2, r2, o2, a2) {
    if (ml = a2, vl = t2, t2.memoizedState = null, t2.updateQueue = null, t2.lanes = 0, pl.current = e4 === null || e4.memoizedState === null ? Xl : Gl, e4 = n2(r2, o2), wl) {
      a2 = 0;
      do {
        if (wl = false, !(25 > a2))
          throw Error(xt(301));
        a2 += 1, yl = gl = null, t2.updateQueue = null, pl.current = Ql, e4 = n2(r2, o2);
      } while (wl);
    }
    if (pl.current = Yl, t2 = gl !== null && gl.next !== null, ml = 0, yl = gl = vl = null, bl = false, t2)
      throw Error(xt(300));
    return e4;
  }
  function _l() {
    var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return yl === null ? vl.memoizedState = yl = e4 : yl = yl.next = e4, yl;
  }
  function El() {
    if (gl === null) {
      var e4 = vl.alternate;
      e4 = e4 !== null ? e4.memoizedState : null;
    } else
      e4 = gl.next;
    var t2 = yl === null ? vl.memoizedState : yl.next;
    if (t2 !== null)
      yl = t2, gl = e4;
    else {
      if (e4 === null)
        throw Error(xt(310));
      e4 = { memoizedState: (gl = e4).memoizedState, baseState: gl.baseState, baseQueue: gl.baseQueue, queue: gl.queue, next: null }, yl === null ? vl.memoizedState = yl = e4 : yl = yl.next = e4;
    }
    return yl;
  }
  function Pl(e4, t2) {
    return typeof t2 == "function" ? t2(e4) : t2;
  }
  function Cl(e4) {
    var t2 = El(), n2 = t2.queue;
    if (n2 === null)
      throw Error(xt(311));
    n2.lastRenderedReducer = e4;
    var r2 = gl, o2 = r2.baseQueue, a2 = n2.pending;
    if (a2 !== null) {
      if (o2 !== null) {
        var i2 = o2.next;
        o2.next = a2.next, a2.next = i2;
      }
      r2.baseQueue = o2 = a2, n2.pending = null;
    }
    if (o2 !== null) {
      o2 = o2.next, r2 = r2.baseState;
      var s2 = i2 = a2 = null, l2 = o2;
      do {
        var u2 = l2.lane;
        if ((ml & u2) === u2)
          s2 !== null && (s2 = s2.next = { lane: 0, action: l2.action, eagerReducer: l2.eagerReducer, eagerState: l2.eagerState, next: null }), r2 = l2.eagerReducer === e4 ? l2.eagerState : e4(r2, l2.action);
        else {
          var c2 = { lane: u2, action: l2.action, eagerReducer: l2.eagerReducer, eagerState: l2.eagerState, next: null };
          s2 === null ? (i2 = s2 = c2, a2 = r2) : s2 = s2.next = c2, vl.lanes |= u2, rc |= u2;
        }
        l2 = l2.next;
      } while (l2 !== null && l2 !== o2);
      s2 === null ? a2 = r2 : s2.next = i2, Ca(r2, t2.memoizedState) || (Zl = true), t2.memoizedState = r2, t2.baseState = a2, t2.baseQueue = s2, n2.lastRenderedState = r2;
    }
    return [t2.memoizedState, n2.dispatch];
  }
  function jl(e4) {
    var t2 = El(), n2 = t2.queue;
    if (n2 === null)
      throw Error(xt(311));
    n2.lastRenderedReducer = e4;
    var r2 = n2.dispatch, o2 = n2.pending, a2 = t2.memoizedState;
    if (o2 !== null) {
      n2.pending = null;
      var i2 = o2 = o2.next;
      do {
        a2 = e4(a2, i2.action), i2 = i2.next;
      } while (i2 !== o2);
      Ca(a2, t2.memoizedState) || (Zl = true), t2.memoizedState = a2, t2.baseQueue === null && (t2.baseState = a2), n2.lastRenderedState = a2;
    }
    return [a2, r2];
  }
  function Ol(e4, t2, n2) {
    var r2 = t2._getVersion;
    r2 = r2(t2._source);
    var o2 = t2._workInProgressVersionPrimary;
    if (o2 !== null ? e4 = o2 === r2 : (e4 = e4.mutableReadLanes, (e4 = (ml & e4) === e4) && (t2._workInProgressVersionPrimary = r2, dl.push(t2))), e4)
      return n2(t2._source);
    throw dl.push(t2), Error(xt(350));
  }
  function Tl(e4, t2, n2, r2) {
    var o2 = Xu;
    if (o2 === null)
      throw Error(xt(349));
    var a2 = t2._getVersion, i2 = a2(t2._source), s2 = pl.current, l2 = s2.useState(function() {
      return Ol(o2, t2, n2);
    }), u2 = l2[1], c2 = l2[0];
    l2 = yl;
    var d = e4.memoizedState, f = d.refs, p = f.getSnapshot, h2 = d.source;
    d = d.subscribe;
    var m2 = vl;
    return e4.memoizedState = { refs: f, source: t2, subscribe: r2 }, s2.useEffect(function() {
      f.getSnapshot = n2, f.setSnapshot = u2;
      var e5 = a2(t2._source);
      if (!Ca(i2, e5)) {
        e5 = n2(t2._source), Ca(c2, e5) || (u2(e5), e5 = Oc(m2), o2.mutableReadLanes |= e5 & o2.pendingLanes), e5 = o2.mutableReadLanes, o2.entangledLanes |= e5;
        for (var r3 = o2.entanglements, s3 = e5; 0 < s3; ) {
          var l3 = 31 - so(s3), d2 = 1 << l3;
          r3[l3] |= e5, s3 &= ~d2;
        }
      }
    }, [n2, t2, r2]), s2.useEffect(function() {
      return r2(t2._source, function() {
        var e5 = f.getSnapshot, n3 = f.setSnapshot;
        try {
          n3(e5(t2._source));
          var r3 = Oc(m2);
          o2.mutableReadLanes |= r3 & o2.pendingLanes;
        } catch (e6) {
          n3(function() {
            throw e6;
          });
        }
      });
    }, [t2, r2]), Ca(p, n2) && Ca(h2, t2) && Ca(d, r2) || ((e4 = { pending: null, dispatch: null, lastRenderedReducer: Pl, lastRenderedState: c2 }).dispatch = u2 = Kl.bind(null, vl, e4), l2.queue = e4, l2.baseQueue = null, c2 = Ol(o2, t2, n2), l2.memoizedState = l2.baseState = c2), c2;
  }
  function Il(e4, t2, n2) {
    return Tl(El(), e4, t2, n2);
  }
  function Dl(e4) {
    var t2 = _l();
    return typeof e4 == "function" && (e4 = e4()), t2.memoizedState = t2.baseState = e4, e4 = (e4 = t2.queue = { pending: null, dispatch: null, lastRenderedReducer: Pl, lastRenderedState: e4 }).dispatch = Kl.bind(null, vl, e4), [t2.memoizedState, e4];
  }
  function Rl(e4, t2, n2, r2) {
    return e4 = { tag: e4, create: t2, destroy: n2, deps: r2, next: null }, (t2 = vl.updateQueue) === null ? (t2 = { lastEffect: null }, vl.updateQueue = t2, t2.lastEffect = e4.next = e4) : (n2 = t2.lastEffect) === null ? t2.lastEffect = e4.next = e4 : (r2 = n2.next, n2.next = e4, e4.next = r2, t2.lastEffect = e4), e4;
  }
  function Nl(e4) {
    return e4 = { current: e4 }, _l().memoizedState = e4;
  }
  function Al() {
    return El().memoizedState;
  }
  function zl(e4, t2, n2, r2) {
    var o2 = _l();
    vl.flags |= e4, o2.memoizedState = Rl(1 | t2, n2, void 0, r2 === void 0 ? null : r2);
  }
  function Ml(e4, t2, n2, r2) {
    var o2 = El();
    r2 = r2 === void 0 ? null : r2;
    var a2 = void 0;
    if (gl !== null) {
      var i2 = gl.memoizedState;
      if (a2 = i2.destroy, r2 !== null && xl(r2, i2.deps))
        return void Rl(t2, n2, a2, r2);
    }
    vl.flags |= e4, o2.memoizedState = Rl(1 | t2, n2, a2, r2);
  }
  function Ll(e4, t2) {
    return zl(516, 4, e4, t2);
  }
  function Fl(e4, t2) {
    return Ml(516, 4, e4, t2);
  }
  function $l(e4, t2) {
    return Ml(4, 2, e4, t2);
  }
  function Bl(e4, t2) {
    return typeof t2 == "function" ? (e4 = e4(), t2(e4), function() {
      t2(null);
    }) : t2 != null ? (e4 = e4(), t2.current = e4, function() {
      t2.current = null;
    }) : void 0;
  }
  function Vl(e4, t2, n2) {
    return n2 = n2 != null ? n2.concat([e4]) : null, Ml(4, 2, Bl.bind(null, t2, e4), n2);
  }
  function Ul() {
  }
  function Hl(e4, t2) {
    var n2 = El();
    t2 = t2 === void 0 ? null : t2;
    var r2 = n2.memoizedState;
    return r2 !== null && t2 !== null && xl(t2, r2[1]) ? r2[0] : (n2.memoizedState = [e4, t2], e4);
  }
  function Wl(e4, t2) {
    var n2 = El();
    t2 = t2 === void 0 ? null : t2;
    var r2 = n2.memoizedState;
    return r2 !== null && t2 !== null && xl(t2, r2[1]) ? r2[0] : (e4 = e4(), n2.memoizedState = [e4, t2], e4);
  }
  function ql(e4, t2) {
    var n2 = ss();
    us(98 > n2 ? 98 : n2, function() {
      e4(true);
    }), us(97 < n2 ? 97 : n2, function() {
      var n3 = hl.transition;
      hl.transition = 1;
      try {
        e4(false), t2();
      } finally {
        hl.transition = n3;
      }
    });
  }
  function Kl(e4, t2, n2) {
    var r2 = jc(), o2 = Oc(e4), a2 = { lane: o2, action: n2, eagerReducer: null, eagerState: null, next: null }, i2 = t2.pending;
    if (i2 === null ? a2.next = a2 : (a2.next = i2.next, i2.next = a2), t2.pending = a2, i2 = e4.alternate, e4 === vl || i2 !== null && i2 === vl)
      wl = bl = true;
    else {
      if (e4.lanes === 0 && (i2 === null || i2.lanes === 0) && (i2 = t2.lastRenderedReducer) !== null)
        try {
          var s2 = t2.lastRenderedState, l2 = i2(s2, n2);
          if (a2.eagerReducer = i2, a2.eagerState = l2, Ca(l2, s2))
            return;
        } catch (e5) {
        }
      Tc(e4, o2, r2);
    }
  }
  var Yl = { readContext: Ss, useCallback: kl, useContext: kl, useEffect: kl, useImperativeHandle: kl, useLayoutEffect: kl, useMemo: kl, useReducer: kl, useRef: kl, useState: kl, useDebugValue: kl, useDeferredValue: kl, useTransition: kl, useMutableSource: kl, useOpaqueIdentifier: kl, unstable_isNewReconciler: false };
  var Xl = { readContext: Ss, useCallback: function(e4, t2) {
    return _l().memoizedState = [e4, t2 === void 0 ? null : t2], e4;
  }, useContext: Ss, useEffect: Ll, useImperativeHandle: function(e4, t2, n2) {
    return n2 = n2 != null ? n2.concat([e4]) : null, zl(4, 2, Bl.bind(null, t2, e4), n2);
  }, useLayoutEffect: function(e4, t2) {
    return zl(4, 2, e4, t2);
  }, useMemo: function(e4, t2) {
    var n2 = _l();
    return t2 = t2 === void 0 ? null : t2, e4 = e4(), n2.memoizedState = [e4, t2], e4;
  }, useReducer: function(e4, t2, n2) {
    var r2 = _l();
    return t2 = n2 !== void 0 ? n2(t2) : t2, r2.memoizedState = r2.baseState = t2, e4 = (e4 = r2.queue = { pending: null, dispatch: null, lastRenderedReducer: e4, lastRenderedState: t2 }).dispatch = Kl.bind(null, vl, e4), [r2.memoizedState, e4];
  }, useRef: Nl, useState: Dl, useDebugValue: Ul, useDeferredValue: function(e4) {
    var t2 = Dl(e4), n2 = t2[0], r2 = t2[1];
    return Ll(function() {
      var t3 = hl.transition;
      hl.transition = 1;
      try {
        r2(e4);
      } finally {
        hl.transition = t3;
      }
    }, [e4]), n2;
  }, useTransition: function() {
    var e4 = Dl(false), t2 = e4[0];
    return Nl(e4 = ql.bind(null, e4[1])), [e4, t2];
  }, useMutableSource: function(e4, t2, n2) {
    var r2 = _l();
    return r2.memoizedState = { refs: { getSnapshot: t2, setSnapshot: null }, source: e4, subscribe: n2 }, Tl(r2, e4, t2, n2);
  }, useOpaqueIdentifier: function() {
    if (ol) {
      var e4 = false, t2 = function(e5) {
        return { $$typeof: Qt, toString: e5, valueOf: e5 };
      }(function() {
        throw e4 || (e4 = true, n2("r:" + (pi++).toString(36))), Error(xt(355));
      }), n2 = Dl(t2)[1];
      return (2 & vl.mode) == 0 && (vl.flags |= 516, Rl(5, function() {
        n2("r:" + (pi++).toString(36));
      }, void 0, null)), t2;
    }
    return Dl(t2 = "r:" + (pi++).toString(36)), t2;
  }, unstable_isNewReconciler: false };
  var Gl = { readContext: Ss, useCallback: Hl, useContext: Ss, useEffect: Fl, useImperativeHandle: Vl, useLayoutEffect: $l, useMemo: Wl, useReducer: Cl, useRef: Al, useState: function() {
    return Cl(Pl);
  }, useDebugValue: Ul, useDeferredValue: function(e4) {
    var t2 = Cl(Pl), n2 = t2[0], r2 = t2[1];
    return Fl(function() {
      var t3 = hl.transition;
      hl.transition = 1;
      try {
        r2(e4);
      } finally {
        hl.transition = t3;
      }
    }, [e4]), n2;
  }, useTransition: function() {
    var e4 = Cl(Pl)[0];
    return [Al().current, e4];
  }, useMutableSource: Il, useOpaqueIdentifier: function() {
    return Cl(Pl)[0];
  }, unstable_isNewReconciler: false };
  var Ql = { readContext: Ss, useCallback: Hl, useContext: Ss, useEffect: Fl, useImperativeHandle: Vl, useLayoutEffect: $l, useMemo: Wl, useReducer: jl, useRef: Al, useState: function() {
    return jl(Pl);
  }, useDebugValue: Ul, useDeferredValue: function(e4) {
    var t2 = jl(Pl), n2 = t2[0], r2 = t2[1];
    return Fl(function() {
      var t3 = hl.transition;
      hl.transition = 1;
      try {
        r2(e4);
      } finally {
        hl.transition = t3;
      }
    }, [e4]), n2;
  }, useTransition: function() {
    var e4 = jl(Pl)[0];
    return [Al().current, e4];
  }, useMutableSource: Il, useOpaqueIdentifier: function() {
    return jl(Pl)[0];
  }, unstable_isNewReconciler: false };
  var Jl = Mt.ReactCurrentOwner;
  var Zl = false;
  function eu(e4, t2, n2, r2) {
    t2.child = e4 === null ? Hs(t2, null, n2, r2) : Us(t2, e4.child, n2, r2);
  }
  function tu(e4, t2, n2, r2, o2) {
    n2 = n2.render;
    var a2 = t2.ref;
    return xs(t2, o2), r2 = Sl(e4, t2, n2, r2, a2, o2), e4 === null || Zl ? (t2.flags |= 1, eu(e4, t2, r2, o2), t2.child) : (t2.updateQueue = e4.updateQueue, t2.flags &= -517, e4.lanes &= ~o2, ku(e4, t2, o2));
  }
  function nu(e4, t2, n2, r2, o2, a2) {
    if (e4 === null) {
      var i2 = n2.type;
      return typeof i2 != "function" || sd(i2) || i2.defaultProps !== void 0 || n2.compare !== null || n2.defaultProps !== void 0 ? ((e4 = ud(n2.type, null, r2, t2, t2.mode, a2)).ref = t2.ref, e4.return = t2, t2.child = e4) : (t2.tag = 15, t2.type = i2, ru(e4, t2, i2, r2, o2, a2));
    }
    return i2 = e4.child, (o2 & a2) == 0 && (o2 = i2.memoizedProps, (n2 = (n2 = n2.compare) !== null ? n2 : Oa)(o2, r2) && e4.ref === t2.ref) ? ku(e4, t2, a2) : (t2.flags |= 1, (e4 = ld(i2, r2)).ref = t2.ref, e4.return = t2, t2.child = e4);
  }
  function ru(e4, t2, n2, r2, o2, a2) {
    if (e4 !== null && Oa(e4.memoizedProps, r2) && e4.ref === t2.ref) {
      if (Zl = false, (a2 & o2) == 0)
        return t2.lanes = e4.lanes, ku(e4, t2, a2);
      (16384 & e4.flags) != 0 && (Zl = true);
    }
    return iu(e4, t2, n2, r2, a2);
  }
  function ou(e4, t2, n2) {
    var r2 = t2.pendingProps, o2 = r2.children, a2 = e4 !== null ? e4.memoizedState : null;
    if (r2.mode === "hidden" || r2.mode === "unstable-defer-without-hiding")
      if ((4 & t2.mode) == 0)
        t2.memoizedState = { baseLanes: 0 }, Lc(t2, n2);
      else {
        if ((1073741824 & n2) == 0)
          return e4 = a2 !== null ? a2.baseLanes | n2 : n2, t2.lanes = t2.childLanes = 1073741824, t2.memoizedState = { baseLanes: e4 }, Lc(t2, e4), null;
        t2.memoizedState = { baseLanes: 0 }, Lc(t2, a2 !== null ? a2.baseLanes : n2);
      }
    else
      a2 !== null ? (r2 = a2.baseLanes | n2, t2.memoizedState = null) : r2 = n2, Lc(t2, r2);
    return eu(e4, t2, o2, n2), t2.child;
  }
  function au(e4, t2) {
    var n2 = t2.ref;
    (e4 === null && n2 !== null || e4 !== null && e4.ref !== n2) && (t2.flags |= 128);
  }
  function iu(e4, t2, n2, r2, o2) {
    var a2 = Ni(n2) ? Di : Ti.current;
    return a2 = Ri(t2, a2), xs(t2, o2), n2 = Sl(e4, t2, n2, r2, a2, o2), e4 === null || Zl ? (t2.flags |= 1, eu(e4, t2, n2, o2), t2.child) : (t2.updateQueue = e4.updateQueue, t2.flags &= -517, e4.lanes &= ~o2, ku(e4, t2, o2));
  }
  function su(e4, t2, n2, r2, o2) {
    if (Ni(n2)) {
      var a2 = true;
      Li(t2);
    } else
      a2 = false;
    if (xs(t2, o2), t2.stateNode === null)
      e4 !== null && (e4.alternate = null, t2.alternate = null, t2.flags |= 2), zs(t2, n2, r2), Ls(t2, n2, r2, o2), r2 = true;
    else if (e4 === null) {
      var i2 = t2.stateNode, s2 = t2.memoizedProps;
      i2.props = s2;
      var l2 = i2.context, u2 = n2.contextType;
      typeof u2 == "object" && u2 !== null ? u2 = Ss(u2) : u2 = Ri(t2, u2 = Ni(n2) ? Di : Ti.current);
      var c2 = n2.getDerivedStateFromProps, d = typeof c2 == "function" || typeof i2.getSnapshotBeforeUpdate == "function";
      d || typeof i2.UNSAFE_componentWillReceiveProps != "function" && typeof i2.componentWillReceiveProps != "function" || (s2 !== r2 || l2 !== u2) && Ms(t2, i2, r2, u2), _s = false;
      var f = t2.memoizedState;
      i2.state = f, Ts(t2, r2, i2, o2), l2 = t2.memoizedState, s2 !== r2 || f !== l2 || Ii.current || _s ? (typeof c2 == "function" && (Rs(t2, n2, c2, r2), l2 = t2.memoizedState), (s2 = _s || As(t2, n2, s2, r2, f, l2, u2)) ? (d || typeof i2.UNSAFE_componentWillMount != "function" && typeof i2.componentWillMount != "function" || (typeof i2.componentWillMount == "function" && i2.componentWillMount(), typeof i2.UNSAFE_componentWillMount == "function" && i2.UNSAFE_componentWillMount()), typeof i2.componentDidMount == "function" && (t2.flags |= 4)) : (typeof i2.componentDidMount == "function" && (t2.flags |= 4), t2.memoizedProps = r2, t2.memoizedState = l2), i2.props = r2, i2.state = l2, i2.context = u2, r2 = s2) : (typeof i2.componentDidMount == "function" && (t2.flags |= 4), r2 = false);
    } else {
      i2 = t2.stateNode, Ps(e4, t2), s2 = t2.memoizedProps, u2 = t2.type === t2.elementType ? s2 : hs(t2.type, s2), i2.props = u2, d = t2.pendingProps, f = i2.context, typeof (l2 = n2.contextType) == "object" && l2 !== null ? l2 = Ss(l2) : l2 = Ri(t2, l2 = Ni(n2) ? Di : Ti.current);
      var p = n2.getDerivedStateFromProps;
      (c2 = typeof p == "function" || typeof i2.getSnapshotBeforeUpdate == "function") || typeof i2.UNSAFE_componentWillReceiveProps != "function" && typeof i2.componentWillReceiveProps != "function" || (s2 !== d || f !== l2) && Ms(t2, i2, r2, l2), _s = false, f = t2.memoizedState, i2.state = f, Ts(t2, r2, i2, o2);
      var h2 = t2.memoizedState;
      s2 !== d || f !== h2 || Ii.current || _s ? (typeof p == "function" && (Rs(t2, n2, p, r2), h2 = t2.memoizedState), (u2 = _s || As(t2, n2, u2, r2, f, h2, l2)) ? (c2 || typeof i2.UNSAFE_componentWillUpdate != "function" && typeof i2.componentWillUpdate != "function" || (typeof i2.componentWillUpdate == "function" && i2.componentWillUpdate(r2, h2, l2), typeof i2.UNSAFE_componentWillUpdate == "function" && i2.UNSAFE_componentWillUpdate(r2, h2, l2)), typeof i2.componentDidUpdate == "function" && (t2.flags |= 4), typeof i2.getSnapshotBeforeUpdate == "function" && (t2.flags |= 256)) : (typeof i2.componentDidUpdate != "function" || s2 === e4.memoizedProps && f === e4.memoizedState || (t2.flags |= 4), typeof i2.getSnapshotBeforeUpdate != "function" || s2 === e4.memoizedProps && f === e4.memoizedState || (t2.flags |= 256), t2.memoizedProps = r2, t2.memoizedState = h2), i2.props = r2, i2.state = h2, i2.context = l2, r2 = u2) : (typeof i2.componentDidUpdate != "function" || s2 === e4.memoizedProps && f === e4.memoizedState || (t2.flags |= 4), typeof i2.getSnapshotBeforeUpdate != "function" || s2 === e4.memoizedProps && f === e4.memoizedState || (t2.flags |= 256), r2 = false);
    }
    return lu(e4, t2, n2, r2, a2, o2);
  }
  function lu(e4, t2, n2, r2, o2, a2) {
    au(e4, t2);
    var i2 = (64 & t2.flags) != 0;
    if (!r2 && !i2)
      return o2 && Fi(t2, n2, false), ku(e4, t2, a2);
    r2 = t2.stateNode, Jl.current = t2;
    var s2 = i2 && typeof n2.getDerivedStateFromError != "function" ? null : r2.render();
    return t2.flags |= 1, e4 !== null && i2 ? (t2.child = Us(t2, e4.child, null, a2), t2.child = Us(t2, null, s2, a2)) : eu(e4, t2, s2, a2), t2.memoizedState = r2.state, o2 && Fi(t2, n2, true), t2.child;
  }
  function uu(e4) {
    var t2 = e4.stateNode;
    t2.pendingContext ? zi(0, t2.pendingContext, t2.pendingContext !== t2.context) : t2.context && zi(0, t2.context, false), Gs(e4, t2.containerInfo);
  }
  var cu;
  var du;
  var fu;
  var pu = { dehydrated: null, retryLane: 0 };
  function hu(e4, t2, n2) {
    var r2, o2 = t2.pendingProps, a2 = el.current, i2 = false;
    return (r2 = (64 & t2.flags) != 0) || (r2 = (e4 === null || e4.memoizedState !== null) && (2 & a2) != 0), r2 ? (i2 = true, t2.flags &= -65) : e4 !== null && e4.memoizedState === null || o2.fallback === void 0 || o2.unstable_avoidThisFallback === true || (a2 |= 1), ji(el, 1 & a2), e4 === null ? (o2.fallback !== void 0 && sl(t2), e4 = o2.children, a2 = o2.fallback, i2 ? (e4 = mu(t2, e4, a2, n2), t2.child.memoizedState = { baseLanes: n2 }, t2.memoizedState = pu, e4) : typeof o2.unstable_expectedLoadTime == "number" ? (e4 = mu(t2, e4, a2, n2), t2.child.memoizedState = { baseLanes: n2 }, t2.memoizedState = pu, t2.lanes = 33554432, e4) : ((n2 = dd({ mode: "visible", children: e4 }, t2.mode, n2, null)).return = t2, t2.child = n2)) : (e4.memoizedState, i2 ? (o2 = gu(e4, t2, o2.children, o2.fallback, n2), i2 = t2.child, a2 = e4.child.memoizedState, i2.memoizedState = a2 === null ? { baseLanes: n2 } : { baseLanes: a2.baseLanes | n2 }, i2.childLanes = e4.childLanes & ~n2, t2.memoizedState = pu, o2) : (n2 = vu(e4, t2, o2.children, n2), t2.memoizedState = null, n2));
  }
  function mu(e4, t2, n2, r2) {
    var o2 = e4.mode, a2 = e4.child;
    return t2 = { mode: "hidden", children: t2 }, (2 & o2) == 0 && a2 !== null ? (a2.childLanes = 0, a2.pendingProps = t2) : a2 = dd(t2, o2, 0, null), n2 = cd(n2, o2, r2, null), a2.return = e4, n2.return = e4, a2.sibling = n2, e4.child = a2, n2;
  }
  function vu(e4, t2, n2, r2) {
    var o2 = e4.child;
    return e4 = o2.sibling, n2 = ld(o2, { mode: "visible", children: n2 }), (2 & t2.mode) == 0 && (n2.lanes = r2), n2.return = t2, n2.sibling = null, e4 !== null && (e4.nextEffect = null, e4.flags = 8, t2.firstEffect = t2.lastEffect = e4), t2.child = n2;
  }
  function gu(e4, t2, n2, r2, o2) {
    var a2 = t2.mode, i2 = e4.child;
    e4 = i2.sibling;
    var s2 = { mode: "hidden", children: n2 };
    return (2 & a2) == 0 && t2.child !== i2 ? ((n2 = t2.child).childLanes = 0, n2.pendingProps = s2, (i2 = n2.lastEffect) !== null ? (t2.firstEffect = n2.firstEffect, t2.lastEffect = i2, i2.nextEffect = null) : t2.firstEffect = t2.lastEffect = null) : n2 = ld(i2, s2), e4 !== null ? r2 = ld(e4, r2) : (r2 = cd(r2, a2, o2, null)).flags |= 2, r2.return = t2, n2.return = t2, n2.sibling = r2, t2.child = n2, r2;
  }
  function yu(e4, t2) {
    e4.lanes |= t2;
    var n2 = e4.alternate;
    n2 !== null && (n2.lanes |= t2), ks(e4.return, t2);
  }
  function bu(e4, t2, n2, r2, o2, a2) {
    var i2 = e4.memoizedState;
    i2 === null ? e4.memoizedState = { isBackwards: t2, rendering: null, renderingStartTime: 0, last: r2, tail: n2, tailMode: o2, lastEffect: a2 } : (i2.isBackwards = t2, i2.rendering = null, i2.renderingStartTime = 0, i2.last = r2, i2.tail = n2, i2.tailMode = o2, i2.lastEffect = a2);
  }
  function wu(e4, t2, n2) {
    var r2 = t2.pendingProps, o2 = r2.revealOrder, a2 = r2.tail;
    if (eu(e4, t2, r2.children, n2), (2 & (r2 = el.current)) != 0)
      r2 = 1 & r2 | 2, t2.flags |= 64;
    else {
      if (e4 !== null && (64 & e4.flags) != 0)
        e:
          for (e4 = t2.child; e4 !== null; ) {
            if (e4.tag === 13)
              e4.memoizedState !== null && yu(e4, n2);
            else if (e4.tag === 19)
              yu(e4, n2);
            else if (e4.child !== null) {
              e4.child.return = e4, e4 = e4.child;
              continue;
            }
            if (e4 === t2)
              break e;
            for (; e4.sibling === null; ) {
              if (e4.return === null || e4.return === t2)
                break e;
              e4 = e4.return;
            }
            e4.sibling.return = e4.return, e4 = e4.sibling;
          }
      r2 &= 1;
    }
    if (ji(el, r2), (2 & t2.mode) == 0)
      t2.memoizedState = null;
    else
      switch (o2) {
        case "forwards":
          for (n2 = t2.child, o2 = null; n2 !== null; )
            (e4 = n2.alternate) !== null && tl(e4) === null && (o2 = n2), n2 = n2.sibling;
          (n2 = o2) === null ? (o2 = t2.child, t2.child = null) : (o2 = n2.sibling, n2.sibling = null), bu(t2, false, o2, n2, a2, t2.lastEffect);
          break;
        case "backwards":
          for (n2 = null, o2 = t2.child, t2.child = null; o2 !== null; ) {
            if ((e4 = o2.alternate) !== null && tl(e4) === null) {
              t2.child = o2;
              break;
            }
            e4 = o2.sibling, o2.sibling = n2, n2 = o2, o2 = e4;
          }
          bu(t2, true, n2, null, a2, t2.lastEffect);
          break;
        case "together":
          bu(t2, false, null, null, void 0, t2.lastEffect);
          break;
        default:
          t2.memoizedState = null;
      }
    return t2.child;
  }
  function ku(e4, t2, n2) {
    if (e4 !== null && (t2.dependencies = e4.dependencies), rc |= t2.lanes, (n2 & t2.childLanes) != 0) {
      if (e4 !== null && t2.child !== e4.child)
        throw Error(xt(153));
      if (t2.child !== null) {
        for (n2 = ld(e4 = t2.child, e4.pendingProps), t2.child = n2, n2.return = t2; e4.sibling !== null; )
          e4 = e4.sibling, (n2 = n2.sibling = ld(e4, e4.pendingProps)).return = t2;
        n2.sibling = null;
      }
      return t2.child;
    }
    return null;
  }
  function xu(e4, t2) {
    if (!ol)
      switch (e4.tailMode) {
        case "hidden":
          t2 = e4.tail;
          for (var n2 = null; t2 !== null; )
            t2.alternate !== null && (n2 = t2), t2 = t2.sibling;
          n2 === null ? e4.tail = null : n2.sibling = null;
          break;
        case "collapsed":
          n2 = e4.tail;
          for (var r2 = null; n2 !== null; )
            n2.alternate !== null && (r2 = n2), n2 = n2.sibling;
          r2 === null ? t2 || e4.tail === null ? e4.tail = null : e4.tail.sibling = null : r2.sibling = null;
      }
  }
  function Su(e4, t2, n2) {
    var r2 = t2.pendingProps;
    switch (t2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return null;
      case 1:
      case 17:
        return Ni(t2.type) && Ai(), null;
      case 3:
        return Qs(), Ci(Ii), Ci(Ti), fl(), (r2 = t2.stateNode).pendingContext && (r2.context = r2.pendingContext, r2.pendingContext = null), e4 !== null && e4.child !== null || (ul(t2) ? t2.flags |= 4 : r2.hydrate || (t2.flags |= 256)), null;
      case 5:
        Zs(t2);
        var o2 = Xs(Ys.current);
        if (n2 = t2.type, e4 !== null && t2.stateNode != null)
          du(e4, t2, n2, r2), e4.ref !== t2.ref && (t2.flags |= 128);
        else {
          if (!r2) {
            if (t2.stateNode === null)
              throw Error(xt(166));
            return null;
          }
          if (e4 = Xs(qs.current), ul(t2)) {
            r2 = t2.stateNode, n2 = t2.type;
            var a2 = t2.memoizedProps;
            switch (r2[mi] = t2, r2[vi] = a2, n2) {
              case "dialog":
                Ka("cancel", r2), Ka("close", r2);
                break;
              case "iframe":
              case "object":
              case "embed":
                Ka("load", r2);
                break;
              case "video":
              case "audio":
                for (e4 = 0; e4 < Ua.length; e4++)
                  Ka(Ua[e4], r2);
                break;
              case "source":
                Ka("error", r2);
                break;
              case "img":
              case "image":
              case "link":
                Ka("error", r2), Ka("load", r2);
                break;
              case "details":
                Ka("toggle", r2);
                break;
              case "input":
                gn(r2, a2), Ka("invalid", r2);
                break;
              case "select":
                r2._wrapperState = { wasMultiple: !!a2.multiple }, Ka("invalid", r2);
                break;
              case "textarea":
                En(r2, a2), Ka("invalid", r2);
            }
            for (var i2 in Bn(n2, a2), e4 = null, a2)
              a2.hasOwnProperty(i2) && (o2 = a2[i2], i2 === "children" ? typeof o2 == "string" ? r2.textContent !== o2 && (e4 = ["children", o2]) : typeof o2 == "number" && r2.textContent !== "" + o2 && (e4 = ["children", "" + o2]) : _t.hasOwnProperty(i2) && o2 != null && i2 === "onScroll" && Ka("scroll", r2));
            switch (n2) {
              case "input":
                pn(r2), wn(r2, a2, true);
                break;
              case "textarea":
                pn(r2), Cn(r2);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof a2.onClick == "function" && (r2.onclick = ri);
            }
            r2 = e4, t2.updateQueue = r2, r2 !== null && (t2.flags |= 4);
          } else {
            switch (i2 = o2.nodeType === 9 ? o2 : o2.ownerDocument, e4 === jn && (e4 = Tn(n2)), e4 === jn ? n2 === "script" ? ((e4 = i2.createElement("div")).innerHTML = "<script><\/script>", e4 = e4.removeChild(e4.firstChild)) : typeof r2.is == "string" ? e4 = i2.createElement(n2, { is: r2.is }) : (e4 = i2.createElement(n2), n2 === "select" && (i2 = e4, r2.multiple ? i2.multiple = true : r2.size && (i2.size = r2.size))) : e4 = i2.createElementNS(e4, n2), e4[mi] = t2, e4[vi] = r2, cu(e4, t2), t2.stateNode = e4, i2 = Vn(n2, r2), n2) {
              case "dialog":
                Ka("cancel", e4), Ka("close", e4), o2 = r2;
                break;
              case "iframe":
              case "object":
              case "embed":
                Ka("load", e4), o2 = r2;
                break;
              case "video":
              case "audio":
                for (o2 = 0; o2 < Ua.length; o2++)
                  Ka(Ua[o2], e4);
                o2 = r2;
                break;
              case "source":
                Ka("error", e4), o2 = r2;
                break;
              case "img":
              case "image":
              case "link":
                Ka("error", e4), Ka("load", e4), o2 = r2;
                break;
              case "details":
                Ka("toggle", e4), o2 = r2;
                break;
              case "input":
                gn(e4, r2), o2 = vn(e4, r2), Ka("invalid", e4);
                break;
              case "option":
                o2 = xn(e4, r2);
                break;
              case "select":
                e4._wrapperState = { wasMultiple: !!r2.multiple }, o2 = wt({}, r2, { value: void 0 }), Ka("invalid", e4);
                break;
              case "textarea":
                En(e4, r2), o2 = _n(e4, r2), Ka("invalid", e4);
                break;
              default:
                o2 = r2;
            }
            Bn(n2, o2);
            var s2 = o2;
            for (a2 in s2)
              if (s2.hasOwnProperty(a2)) {
                var l2 = s2[a2];
                a2 === "style" ? Fn(e4, l2) : a2 === "dangerouslySetInnerHTML" ? (l2 = l2 ? l2.__html : void 0) != null && Nn(e4, l2) : a2 === "children" ? typeof l2 == "string" ? (n2 !== "textarea" || l2 !== "") && An(e4, l2) : typeof l2 == "number" && An(e4, "" + l2) : a2 !== "suppressContentEditableWarning" && a2 !== "suppressHydrationWarning" && a2 !== "autoFocus" && (_t.hasOwnProperty(a2) ? l2 != null && a2 === "onScroll" && Ka("scroll", e4) : l2 != null && zt(e4, a2, l2, i2));
              }
            switch (n2) {
              case "input":
                pn(e4), wn(e4, r2, false);
                break;
              case "textarea":
                pn(e4), Cn(e4);
                break;
              case "option":
                r2.value != null && e4.setAttribute("value", "" + dn(r2.value));
                break;
              case "select":
                e4.multiple = !!r2.multiple, (a2 = r2.value) != null ? Sn(e4, !!r2.multiple, a2, false) : r2.defaultValue != null && Sn(e4, !!r2.multiple, r2.defaultValue, true);
                break;
              default:
                typeof o2.onClick == "function" && (e4.onclick = ri);
            }
            ii(n2, r2) && (t2.flags |= 4);
          }
          t2.ref !== null && (t2.flags |= 128);
        }
        return null;
      case 6:
        if (e4 && t2.stateNode != null)
          fu(0, t2, e4.memoizedProps, r2);
        else {
          if (typeof r2 != "string" && t2.stateNode === null)
            throw Error(xt(166));
          n2 = Xs(Ys.current), Xs(qs.current), ul(t2) ? (r2 = t2.stateNode, n2 = t2.memoizedProps, r2[mi] = t2, r2.nodeValue !== n2 && (t2.flags |= 4)) : ((r2 = (n2.nodeType === 9 ? n2 : n2.ownerDocument).createTextNode(r2))[mi] = t2, t2.stateNode = r2);
        }
        return null;
      case 13:
        return Ci(el), r2 = t2.memoizedState, (64 & t2.flags) != 0 ? (t2.lanes = n2, t2) : (r2 = r2 !== null, n2 = false, e4 === null ? t2.memoizedProps.fallback !== void 0 && ul(t2) : n2 = e4.memoizedState !== null, r2 && !n2 && (2 & t2.mode) != 0 && (e4 === null && t2.memoizedProps.unstable_avoidThisFallback !== true || (1 & el.current) != 0 ? ec === 0 && (ec = 3) : (ec !== 0 && ec !== 3 || (ec = 4), Xu === null || (134217727 & rc) == 0 && (134217727 & oc) == 0 || Nc(Xu, Qu))), (r2 || n2) && (t2.flags |= 4), null);
      case 4:
        return Qs(), e4 === null && Xa(t2.stateNode.containerInfo), null;
      case 10:
        return ws(t2), null;
      case 19:
        if (Ci(el), (r2 = t2.memoizedState) === null)
          return null;
        if (a2 = (64 & t2.flags) != 0, (i2 = r2.rendering) === null)
          if (a2)
            xu(r2, false);
          else {
            if (ec !== 0 || e4 !== null && (64 & e4.flags) != 0)
              for (e4 = t2.child; e4 !== null; ) {
                if ((i2 = tl(e4)) !== null) {
                  for (t2.flags |= 64, xu(r2, false), (a2 = i2.updateQueue) !== null && (t2.updateQueue = a2, t2.flags |= 4), r2.lastEffect === null && (t2.firstEffect = null), t2.lastEffect = r2.lastEffect, r2 = n2, n2 = t2.child; n2 !== null; )
                    e4 = r2, (a2 = n2).flags &= 2, a2.nextEffect = null, a2.firstEffect = null, a2.lastEffect = null, (i2 = a2.alternate) === null ? (a2.childLanes = 0, a2.lanes = e4, a2.child = null, a2.memoizedProps = null, a2.memoizedState = null, a2.updateQueue = null, a2.dependencies = null, a2.stateNode = null) : (a2.childLanes = i2.childLanes, a2.lanes = i2.lanes, a2.child = i2.child, a2.memoizedProps = i2.memoizedProps, a2.memoizedState = i2.memoizedState, a2.updateQueue = i2.updateQueue, a2.type = i2.type, e4 = i2.dependencies, a2.dependencies = e4 === null ? null : { lanes: e4.lanes, firstContext: e4.firstContext }), n2 = n2.sibling;
                  return ji(el, 1 & el.current | 2), t2.child;
                }
                e4 = e4.sibling;
              }
            r2.tail !== null && is() > lc && (t2.flags |= 64, a2 = true, xu(r2, false), t2.lanes = 33554432);
          }
        else {
          if (!a2)
            if ((e4 = tl(i2)) !== null) {
              if (t2.flags |= 64, a2 = true, (n2 = e4.updateQueue) !== null && (t2.updateQueue = n2, t2.flags |= 4), xu(r2, true), r2.tail === null && r2.tailMode === "hidden" && !i2.alternate && !ol)
                return (t2 = t2.lastEffect = r2.lastEffect) !== null && (t2.nextEffect = null), null;
            } else
              2 * is() - r2.renderingStartTime > lc && n2 !== 1073741824 && (t2.flags |= 64, a2 = true, xu(r2, false), t2.lanes = 33554432);
          r2.isBackwards ? (i2.sibling = t2.child, t2.child = i2) : ((n2 = r2.last) !== null ? n2.sibling = i2 : t2.child = i2, r2.last = i2);
        }
        return r2.tail !== null ? (n2 = r2.tail, r2.rendering = n2, r2.tail = n2.sibling, r2.lastEffect = t2.lastEffect, r2.renderingStartTime = is(), n2.sibling = null, t2 = el.current, ji(el, a2 ? 1 & t2 | 2 : 1 & t2), n2) : null;
      case 23:
      case 24:
        return Fc(), e4 !== null && e4.memoizedState !== null != (t2.memoizedState !== null) && r2.mode !== "unstable-defer-without-hiding" && (t2.flags |= 4), null;
    }
    throw Error(xt(156, t2.tag));
  }
  function _u(e4) {
    switch (e4.tag) {
      case 1:
        Ni(e4.type) && Ai();
        var t2 = e4.flags;
        return 4096 & t2 ? (e4.flags = -4097 & t2 | 64, e4) : null;
      case 3:
        if (Qs(), Ci(Ii), Ci(Ti), fl(), (64 & (t2 = e4.flags)) != 0)
          throw Error(xt(285));
        return e4.flags = -4097 & t2 | 64, e4;
      case 5:
        return Zs(e4), null;
      case 13:
        return Ci(el), 4096 & (t2 = e4.flags) ? (e4.flags = -4097 & t2 | 64, e4) : null;
      case 19:
        return Ci(el), null;
      case 4:
        return Qs(), null;
      case 10:
        return ws(e4), null;
      case 23:
      case 24:
        return Fc(), null;
      default:
        return null;
    }
  }
  function Eu(e4, t2) {
    try {
      var n2 = "", r2 = t2;
      do {
        n2 += un(r2), r2 = r2.return;
      } while (r2);
      var o2 = n2;
    } catch (e5) {
      o2 = "\nError generating stack: " + e5.message + "\n" + e5.stack;
    }
    return { value: e4, source: t2, stack: o2 };
  }
  function Pu(e4, t2) {
    try {
      console.error(t2.value);
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  cu = function(e4, t2) {
    for (var n2 = t2.child; n2 !== null; ) {
      if (n2.tag === 5 || n2.tag === 6)
        e4.appendChild(n2.stateNode);
      else if (n2.tag !== 4 && n2.child !== null) {
        n2.child.return = n2, n2 = n2.child;
        continue;
      }
      if (n2 === t2)
        break;
      for (; n2.sibling === null; ) {
        if (n2.return === null || n2.return === t2)
          return;
        n2 = n2.return;
      }
      n2.sibling.return = n2.return, n2 = n2.sibling;
    }
  }, du = function(e4, t2, n2, r2) {
    var o2 = e4.memoizedProps;
    if (o2 !== r2) {
      e4 = t2.stateNode, Xs(qs.current);
      var a2, i2 = null;
      switch (n2) {
        case "input":
          o2 = vn(e4, o2), r2 = vn(e4, r2), i2 = [];
          break;
        case "option":
          o2 = xn(e4, o2), r2 = xn(e4, r2), i2 = [];
          break;
        case "select":
          o2 = wt({}, o2, { value: void 0 }), r2 = wt({}, r2, { value: void 0 }), i2 = [];
          break;
        case "textarea":
          o2 = _n(e4, o2), r2 = _n(e4, r2), i2 = [];
          break;
        default:
          typeof o2.onClick != "function" && typeof r2.onClick == "function" && (e4.onclick = ri);
      }
      for (u2 in Bn(n2, r2), n2 = null, o2)
        if (!r2.hasOwnProperty(u2) && o2.hasOwnProperty(u2) && o2[u2] != null)
          if (u2 === "style") {
            var s2 = o2[u2];
            for (a2 in s2)
              s2.hasOwnProperty(a2) && (n2 || (n2 = {}), n2[a2] = "");
          } else
            u2 !== "dangerouslySetInnerHTML" && u2 !== "children" && u2 !== "suppressContentEditableWarning" && u2 !== "suppressHydrationWarning" && u2 !== "autoFocus" && (_t.hasOwnProperty(u2) ? i2 || (i2 = []) : (i2 = i2 || []).push(u2, null));
      for (u2 in r2) {
        var l2 = r2[u2];
        if (s2 = o2 != null ? o2[u2] : void 0, r2.hasOwnProperty(u2) && l2 !== s2 && (l2 != null || s2 != null))
          if (u2 === "style")
            if (s2) {
              for (a2 in s2)
                !s2.hasOwnProperty(a2) || l2 && l2.hasOwnProperty(a2) || (n2 || (n2 = {}), n2[a2] = "");
              for (a2 in l2)
                l2.hasOwnProperty(a2) && s2[a2] !== l2[a2] && (n2 || (n2 = {}), n2[a2] = l2[a2]);
            } else
              n2 || (i2 || (i2 = []), i2.push(u2, n2)), n2 = l2;
          else
            u2 === "dangerouslySetInnerHTML" ? (l2 = l2 ? l2.__html : void 0, s2 = s2 ? s2.__html : void 0, l2 != null && s2 !== l2 && (i2 = i2 || []).push(u2, l2)) : u2 === "children" ? typeof l2 != "string" && typeof l2 != "number" || (i2 = i2 || []).push(u2, "" + l2) : u2 !== "suppressContentEditableWarning" && u2 !== "suppressHydrationWarning" && (_t.hasOwnProperty(u2) ? (l2 != null && u2 === "onScroll" && Ka("scroll", e4), i2 || s2 === l2 || (i2 = [])) : typeof l2 == "object" && l2 !== null && l2.$$typeof === Qt ? l2.toString() : (i2 = i2 || []).push(u2, l2));
      }
      n2 && (i2 = i2 || []).push("style", n2);
      var u2 = i2;
      (t2.updateQueue = u2) && (t2.flags |= 4);
    }
  }, fu = function(e4, t2, n2, r2) {
    n2 !== r2 && (t2.flags |= 4);
  };
  var Cu = typeof WeakMap == "function" ? WeakMap : Map;
  function ju(e4, t2, n2) {
    (n2 = Cs(-1, n2)).tag = 3, n2.payload = { element: null };
    var r2 = t2.value;
    return n2.callback = function() {
      fc || (fc = true, pc = r2), Pu(0, t2);
    }, n2;
  }
  function Ou(e4, t2, n2) {
    (n2 = Cs(-1, n2)).tag = 3;
    var r2 = e4.type.getDerivedStateFromError;
    if (typeof r2 == "function") {
      var o2 = t2.value;
      n2.payload = function() {
        return Pu(0, t2), r2(o2);
      };
    }
    var a2 = e4.stateNode;
    return a2 !== null && typeof a2.componentDidCatch == "function" && (n2.callback = function() {
      typeof r2 != "function" && (hc === null ? hc = /* @__PURE__ */ new Set([this]) : hc.add(this), Pu(0, t2));
      var e5 = t2.stack;
      this.componentDidCatch(t2.value, { componentStack: e5 !== null ? e5 : "" });
    }), n2;
  }
  var Tu = typeof WeakSet == "function" ? WeakSet : Set;
  function Iu(e4) {
    var t2 = e4.ref;
    if (t2 !== null)
      if (typeof t2 == "function")
        try {
          t2(null);
        } catch (t3) {
          nd(e4, t3);
        }
      else
        t2.current = null;
  }
  function Du(e4, t2) {
    switch (t2.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
      case 5:
      case 6:
      case 4:
      case 17:
        return;
      case 1:
        if (256 & t2.flags && e4 !== null) {
          var n2 = e4.memoizedProps, r2 = e4.memoizedState;
          t2 = (e4 = t2.stateNode).getSnapshotBeforeUpdate(t2.elementType === t2.type ? n2 : hs(t2.type, n2), r2), e4.__reactInternalSnapshotBeforeUpdate = t2;
        }
        return;
      case 3:
        return void (256 & t2.flags && ci(t2.stateNode.containerInfo));
    }
    throw Error(xt(163));
  }
  function Ru(e4, t2, n2) {
    switch (n2.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        if ((t2 = (t2 = n2.updateQueue) !== null ? t2.lastEffect : null) !== null) {
          e4 = t2 = t2.next;
          do {
            if ((3 & e4.tag) == 3) {
              var r2 = e4.create;
              e4.destroy = r2();
            }
            e4 = e4.next;
          } while (e4 !== t2);
        }
        if ((t2 = (t2 = n2.updateQueue) !== null ? t2.lastEffect : null) !== null) {
          e4 = t2 = t2.next;
          do {
            var o2 = e4;
            r2 = o2.next, (4 & (o2 = o2.tag)) != 0 && (1 & o2) != 0 && (Zc(n2, e4), Jc(n2, e4)), e4 = r2;
          } while (e4 !== t2);
        }
        return;
      case 1:
        return e4 = n2.stateNode, 4 & n2.flags && (t2 === null ? e4.componentDidMount() : (r2 = n2.elementType === n2.type ? t2.memoizedProps : hs(n2.type, t2.memoizedProps), e4.componentDidUpdate(r2, t2.memoizedState, e4.__reactInternalSnapshotBeforeUpdate))), void ((t2 = n2.updateQueue) !== null && Is(n2, t2, e4));
      case 3:
        if ((t2 = n2.updateQueue) !== null) {
          if (e4 = null, n2.child !== null)
            switch (n2.child.tag) {
              case 5:
              case 1:
                e4 = n2.child.stateNode;
            }
          Is(n2, t2, e4);
        }
        return;
      case 5:
        return e4 = n2.stateNode, void (t2 === null && 4 & n2.flags && ii(n2.type, n2.memoizedProps) && e4.focus());
      case 6:
      case 4:
      case 12:
      case 19:
      case 17:
      case 20:
      case 21:
      case 23:
      case 24:
        return;
      case 13:
        return void (n2.memoizedState === null && (n2 = n2.alternate, n2 !== null && (n2 = n2.memoizedState, n2 !== null && (n2 = n2.dehydrated, n2 !== null && Fr(n2)))));
    }
    throw Error(xt(163));
  }
  function Nu(e4, t2) {
    for (var n2 = e4; ; ) {
      if (n2.tag === 5) {
        var r2 = n2.stateNode;
        if (t2)
          typeof (r2 = r2.style).setProperty == "function" ? r2.setProperty("display", "none", "important") : r2.display = "none";
        else {
          r2 = n2.stateNode;
          var o2 = n2.memoizedProps.style;
          o2 = o2 != null && o2.hasOwnProperty("display") ? o2.display : null, r2.style.display = Ln("display", o2);
        }
      } else if (n2.tag === 6)
        n2.stateNode.nodeValue = t2 ? "" : n2.memoizedProps;
      else if ((n2.tag !== 23 && n2.tag !== 24 || n2.memoizedState === null || n2 === e4) && n2.child !== null) {
        n2.child.return = n2, n2 = n2.child;
        continue;
      }
      if (n2 === e4)
        break;
      for (; n2.sibling === null; ) {
        if (n2.return === null || n2.return === e4)
          return;
        n2 = n2.return;
      }
      n2.sibling.return = n2.return, n2 = n2.sibling;
    }
  }
  function Au(e4, t2) {
    if (Bi && typeof Bi.onCommitFiberUnmount == "function")
      try {
        Bi.onCommitFiberUnmount($i, t2);
      } catch (e5) {
      }
    switch (t2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        if ((e4 = t2.updateQueue) !== null && (e4 = e4.lastEffect) !== null) {
          var n2 = e4 = e4.next;
          do {
            var r2 = n2, o2 = r2.destroy;
            if (r2 = r2.tag, o2 !== void 0)
              if ((4 & r2) != 0)
                Zc(t2, n2);
              else {
                r2 = t2;
                try {
                  o2();
                } catch (e5) {
                  nd(r2, e5);
                }
              }
            n2 = n2.next;
          } while (n2 !== e4);
        }
        break;
      case 1:
        if (Iu(t2), typeof (e4 = t2.stateNode).componentWillUnmount == "function")
          try {
            e4.props = t2.memoizedProps, e4.state = t2.memoizedState, e4.componentWillUnmount();
          } catch (e5) {
            nd(t2, e5);
          }
        break;
      case 5:
        Iu(t2);
        break;
      case 4:
        Bu(e4, t2);
    }
  }
  function zu(e4) {
    e4.alternate = null, e4.child = null, e4.dependencies = null, e4.firstEffect = null, e4.lastEffect = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.return = null, e4.updateQueue = null;
  }
  function Mu(e4) {
    return e4.tag === 5 || e4.tag === 3 || e4.tag === 4;
  }
  function Lu(e4) {
    e: {
      for (var t2 = e4.return; t2 !== null; ) {
        if (Mu(t2))
          break e;
        t2 = t2.return;
      }
      throw Error(xt(160));
    }
    var n2 = t2;
    switch (t2 = n2.stateNode, n2.tag) {
      case 5:
        var r2 = false;
        break;
      case 3:
      case 4:
        t2 = t2.containerInfo, r2 = true;
        break;
      default:
        throw Error(xt(161));
    }
    16 & n2.flags && (An(t2, ""), n2.flags &= -17);
    e:
      t:
        for (n2 = e4; ; ) {
          for (; n2.sibling === null; ) {
            if (n2.return === null || Mu(n2.return)) {
              n2 = null;
              break e;
            }
            n2 = n2.return;
          }
          for (n2.sibling.return = n2.return, n2 = n2.sibling; n2.tag !== 5 && n2.tag !== 6 && n2.tag !== 18; ) {
            if (2 & n2.flags)
              continue t;
            if (n2.child === null || n2.tag === 4)
              continue t;
            n2.child.return = n2, n2 = n2.child;
          }
          if (!(2 & n2.flags)) {
            n2 = n2.stateNode;
            break e;
          }
        }
    r2 ? Fu(e4, n2, t2) : $u(e4, n2, t2);
  }
  function Fu(e4, t2, n2) {
    var r2 = e4.tag, o2 = r2 === 5 || r2 === 6;
    if (o2)
      e4 = o2 ? e4.stateNode : e4.stateNode.instance, t2 ? n2.nodeType === 8 ? n2.parentNode.insertBefore(e4, t2) : n2.insertBefore(e4, t2) : (n2.nodeType === 8 ? (t2 = n2.parentNode).insertBefore(e4, n2) : (t2 = n2).appendChild(e4), (n2 = n2._reactRootContainer) != null || t2.onclick !== null || (t2.onclick = ri));
    else if (r2 !== 4 && (e4 = e4.child) !== null)
      for (Fu(e4, t2, n2), e4 = e4.sibling; e4 !== null; )
        Fu(e4, t2, n2), e4 = e4.sibling;
  }
  function $u(e4, t2, n2) {
    var r2 = e4.tag, o2 = r2 === 5 || r2 === 6;
    if (o2)
      e4 = o2 ? e4.stateNode : e4.stateNode.instance, t2 ? n2.insertBefore(e4, t2) : n2.appendChild(e4);
    else if (r2 !== 4 && (e4 = e4.child) !== null)
      for ($u(e4, t2, n2), e4 = e4.sibling; e4 !== null; )
        $u(e4, t2, n2), e4 = e4.sibling;
  }
  function Bu(e4, t2) {
    for (var n2, r2, o2 = t2, a2 = false; ; ) {
      if (!a2) {
        a2 = o2.return;
        e:
          for (; ; ) {
            if (a2 === null)
              throw Error(xt(160));
            switch (n2 = a2.stateNode, a2.tag) {
              case 5:
                r2 = false;
                break e;
              case 3:
              case 4:
                n2 = n2.containerInfo, r2 = true;
                break e;
            }
            a2 = a2.return;
          }
        a2 = true;
      }
      if (o2.tag === 5 || o2.tag === 6) {
        e:
          for (var i2 = e4, s2 = o2, l2 = s2; ; )
            if (Au(i2, l2), l2.child !== null && l2.tag !== 4)
              l2.child.return = l2, l2 = l2.child;
            else {
              if (l2 === s2)
                break e;
              for (; l2.sibling === null; ) {
                if (l2.return === null || l2.return === s2)
                  break e;
                l2 = l2.return;
              }
              l2.sibling.return = l2.return, l2 = l2.sibling;
            }
        r2 ? (i2 = n2, s2 = o2.stateNode, i2.nodeType === 8 ? i2.parentNode.removeChild(s2) : i2.removeChild(s2)) : n2.removeChild(o2.stateNode);
      } else if (o2.tag === 4) {
        if (o2.child !== null) {
          n2 = o2.stateNode.containerInfo, r2 = true, o2.child.return = o2, o2 = o2.child;
          continue;
        }
      } else if (Au(e4, o2), o2.child !== null) {
        o2.child.return = o2, o2 = o2.child;
        continue;
      }
      if (o2 === t2)
        break;
      for (; o2.sibling === null; ) {
        if (o2.return === null || o2.return === t2)
          return;
        (o2 = o2.return).tag === 4 && (a2 = false);
      }
      o2.sibling.return = o2.return, o2 = o2.sibling;
    }
  }
  function Vu(e4, t2) {
    switch (t2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        var n2 = t2.updateQueue;
        if ((n2 = n2 !== null ? n2.lastEffect : null) !== null) {
          var r2 = n2 = n2.next;
          do {
            (3 & r2.tag) == 3 && (e4 = r2.destroy, r2.destroy = void 0, e4 !== void 0 && e4()), r2 = r2.next;
          } while (r2 !== n2);
        }
        return;
      case 1:
      case 12:
      case 17:
        return;
      case 5:
        if ((n2 = t2.stateNode) != null) {
          r2 = t2.memoizedProps;
          var o2 = e4 !== null ? e4.memoizedProps : r2;
          e4 = t2.type;
          var a2 = t2.updateQueue;
          if (t2.updateQueue = null, a2 !== null) {
            for (n2[vi] = r2, e4 === "input" && r2.type === "radio" && r2.name != null && yn(n2, r2), Vn(e4, o2), t2 = Vn(e4, r2), o2 = 0; o2 < a2.length; o2 += 2) {
              var i2 = a2[o2], s2 = a2[o2 + 1];
              i2 === "style" ? Fn(n2, s2) : i2 === "dangerouslySetInnerHTML" ? Nn(n2, s2) : i2 === "children" ? An(n2, s2) : zt(n2, i2, s2, t2);
            }
            switch (e4) {
              case "input":
                bn(n2, r2);
                break;
              case "textarea":
                Pn(n2, r2);
                break;
              case "select":
                e4 = n2._wrapperState.wasMultiple, n2._wrapperState.wasMultiple = !!r2.multiple, (a2 = r2.value) != null ? Sn(n2, !!r2.multiple, a2, false) : e4 !== !!r2.multiple && (r2.defaultValue != null ? Sn(n2, !!r2.multiple, r2.defaultValue, true) : Sn(n2, !!r2.multiple, r2.multiple ? [] : "", false));
            }
          }
        }
        return;
      case 6:
        if (t2.stateNode === null)
          throw Error(xt(162));
        return void (t2.stateNode.nodeValue = t2.memoizedProps);
      case 3:
        return void ((n2 = t2.stateNode).hydrate && (n2.hydrate = false, Fr(n2.containerInfo)));
      case 13:
        return t2.memoizedState !== null && (sc = is(), Nu(t2.child, true)), void Uu(t2);
      case 19:
        return void Uu(t2);
      case 23:
      case 24:
        return void Nu(t2, t2.memoizedState !== null);
    }
    throw Error(xt(163));
  }
  function Uu(e4) {
    var t2 = e4.updateQueue;
    if (t2 !== null) {
      e4.updateQueue = null;
      var n2 = e4.stateNode;
      n2 === null && (n2 = e4.stateNode = new Tu()), t2.forEach(function(t3) {
        var r2 = od.bind(null, e4, t3);
        n2.has(t3) || (n2.add(t3), t3.then(r2, r2));
      });
    }
  }
  function Hu(e4, t2) {
    return e4 !== null && ((e4 = e4.memoizedState) === null || e4.dehydrated !== null) && ((t2 = t2.memoizedState) !== null && t2.dehydrated === null);
  }
  var Wu = Math.ceil;
  var qu = Mt.ReactCurrentDispatcher;
  var Ku = Mt.ReactCurrentOwner;
  var Yu = 0;
  var Xu = null;
  var Gu = null;
  var Qu = 0;
  var Ju = 0;
  var Zu = Pi(0);
  var ec = 0;
  var tc = null;
  var nc = 0;
  var rc = 0;
  var oc = 0;
  var ac = 0;
  var ic = null;
  var sc = 0;
  var lc = 1 / 0;
  function uc() {
    lc = is() + 500;
  }
  var cc;
  var dc = null;
  var fc = false;
  var pc = null;
  var hc = null;
  var mc = false;
  var vc = null;
  var gc = 90;
  var yc = [];
  var bc = [];
  var wc = null;
  var kc = 0;
  var xc = null;
  var Sc = -1;
  var _c = 0;
  var Ec = 0;
  var Pc = null;
  var Cc = false;
  function jc() {
    return (48 & Yu) != 0 ? is() : Sc !== -1 ? Sc : Sc = is();
  }
  function Oc(e4) {
    if ((2 & (e4 = e4.mode)) == 0)
      return 1;
    if ((4 & e4) == 0)
      return ss() === 99 ? 1 : 2;
    if (_c === 0 && (_c = nc), ps.transition !== 0) {
      Ec !== 0 && (Ec = ic !== null ? ic.pendingLanes : 0), e4 = _c;
      var t2 = 4186112 & ~Ec;
      return (t2 &= -t2) === 0 && ((t2 = (e4 = 4186112 & ~e4) & -e4) === 0 && (t2 = 8192)), t2;
    }
    return e4 = ss(), (4 & Yu) != 0 && e4 === 98 ? e4 = ro(12, _c) : e4 = ro(e4 = function(e5) {
      switch (e5) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }(e4), _c), e4;
  }
  function Tc(e4, t2, n2) {
    if (50 < kc)
      throw kc = 0, xc = null, Error(xt(185));
    if ((e4 = Ic(e4, t2)) === null)
      return null;
    io(e4, t2, n2), e4 === Xu && (oc |= t2, ec === 4 && Nc(e4, Qu));
    var r2 = ss();
    t2 === 1 ? (8 & Yu) != 0 && (48 & Yu) == 0 ? Ac(e4) : (Dc(e4, n2), Yu === 0 && (uc(), ds())) : ((4 & Yu) == 0 || r2 !== 98 && r2 !== 99 || (wc === null ? wc = /* @__PURE__ */ new Set([e4]) : wc.add(e4)), Dc(e4, n2)), ic = e4;
  }
  function Ic(e4, t2) {
    e4.lanes |= t2;
    var n2 = e4.alternate;
    for (n2 !== null && (n2.lanes |= t2), n2 = e4, e4 = e4.return; e4 !== null; )
      e4.childLanes |= t2, (n2 = e4.alternate) !== null && (n2.childLanes |= t2), n2 = e4, e4 = e4.return;
    return n2.tag === 3 ? n2.stateNode : null;
  }
  function Dc(e4, t2) {
    for (var n2 = e4.callbackNode, r2 = e4.suspendedLanes, o2 = e4.pingedLanes, a2 = e4.expirationTimes, i2 = e4.pendingLanes; 0 < i2; ) {
      var s2 = 31 - so(i2), l2 = 1 << s2, u2 = a2[s2];
      if (u2 === -1) {
        if ((l2 & r2) == 0 || (l2 & o2) != 0) {
          u2 = t2, eo(l2);
          var c2 = Zr;
          a2[s2] = 10 <= c2 ? u2 + 250 : 6 <= c2 ? u2 + 5e3 : -1;
        }
      } else
        u2 <= t2 && (e4.expiredLanes |= l2);
      i2 &= ~l2;
    }
    if (r2 = to(e4, e4 === Xu ? Qu : 0), t2 = Zr, r2 === 0)
      n2 !== null && (n2 !== es && Hi(n2), e4.callbackNode = null, e4.callbackPriority = 0);
    else {
      if (n2 !== null) {
        if (e4.callbackPriority === t2)
          return;
        n2 !== es && Hi(n2);
      }
      t2 === 15 ? (n2 = Ac.bind(null, e4), ns === null ? (ns = [n2], rs = Ui(Xi, fs)) : ns.push(n2), n2 = es) : t2 === 14 ? n2 = cs(99, Ac.bind(null, e4)) : (n2 = function(e5) {
        switch (e5) {
          case 15:
          case 14:
            return 99;
          case 13:
          case 12:
          case 11:
          case 10:
            return 98;
          case 9:
          case 8:
          case 7:
          case 6:
          case 4:
          case 5:
            return 97;
          case 3:
          case 2:
          case 1:
            return 95;
          case 0:
            return 90;
          default:
            throw Error(xt(358, e5));
        }
      }(t2), n2 = cs(n2, Rc.bind(null, e4))), e4.callbackPriority = t2, e4.callbackNode = n2;
    }
  }
  function Rc(e4) {
    if (Sc = -1, Ec = _c = 0, (48 & Yu) != 0)
      throw Error(xt(327));
    var t2 = e4.callbackNode;
    if (Qc() && e4.callbackNode !== t2)
      return null;
    var n2 = to(e4, e4 === Xu ? Qu : 0);
    if (n2 === 0)
      return null;
    var r2 = n2, o2 = Yu;
    Yu |= 16;
    var a2 = Vc();
    for (Xu === e4 && Qu === r2 || (uc(), $c(e4, r2)); ; )
      try {
        Wc();
        break;
      } catch (t3) {
        Bc(e4, t3);
      }
    if (bs(), qu.current = a2, Yu = o2, Gu !== null ? r2 = 0 : (Xu = null, Qu = 0, r2 = ec), (nc & oc) != 0)
      $c(e4, 0);
    else if (r2 !== 0) {
      if (r2 === 2 && (Yu |= 64, e4.hydrate && (e4.hydrate = false, ci(e4.containerInfo)), (n2 = no(e4)) !== 0 && (r2 = Uc(e4, n2))), r2 === 1)
        throw t2 = tc, $c(e4, 0), Nc(e4, n2), Dc(e4, is()), t2;
      switch (e4.finishedWork = e4.current.alternate, e4.finishedLanes = n2, r2) {
        case 0:
        case 1:
          throw Error(xt(345));
        case 2:
        case 5:
          Yc(e4);
          break;
        case 3:
          if (Nc(e4, n2), (62914560 & n2) === n2 && 10 < (r2 = sc + 500 - is())) {
            if (to(e4, 0) !== 0)
              break;
            if (((o2 = e4.suspendedLanes) & n2) !== n2) {
              jc(), e4.pingedLanes |= e4.suspendedLanes & o2;
              break;
            }
            e4.timeoutHandle = li(Yc.bind(null, e4), r2);
            break;
          }
          Yc(e4);
          break;
        case 4:
          if (Nc(e4, n2), (4186112 & n2) === n2)
            break;
          for (r2 = e4.eventTimes, o2 = -1; 0 < n2; ) {
            var i2 = 31 - so(n2);
            a2 = 1 << i2, (i2 = r2[i2]) > o2 && (o2 = i2), n2 &= ~a2;
          }
          if (n2 = o2, 10 < (n2 = (120 > (n2 = is() - n2) ? 120 : 480 > n2 ? 480 : 1080 > n2 ? 1080 : 1920 > n2 ? 1920 : 3e3 > n2 ? 3e3 : 4320 > n2 ? 4320 : 1960 * Wu(n2 / 1960)) - n2)) {
            e4.timeoutHandle = li(Yc.bind(null, e4), n2);
            break;
          }
          Yc(e4);
          break;
        default:
          throw Error(xt(329));
      }
    }
    return Dc(e4, is()), e4.callbackNode === t2 ? Rc.bind(null, e4) : null;
  }
  function Nc(e4, t2) {
    for (t2 &= ~ac, t2 &= ~oc, e4.suspendedLanes |= t2, e4.pingedLanes &= ~t2, e4 = e4.expirationTimes; 0 < t2; ) {
      var n2 = 31 - so(t2), r2 = 1 << n2;
      e4[n2] = -1, t2 &= ~r2;
    }
  }
  function Ac(e4) {
    if ((48 & Yu) != 0)
      throw Error(xt(327));
    if (Qc(), e4 === Xu && (e4.expiredLanes & Qu) != 0) {
      var t2 = Qu, n2 = Uc(e4, t2);
      (nc & oc) != 0 && (n2 = Uc(e4, t2 = to(e4, t2)));
    } else
      n2 = Uc(e4, t2 = to(e4, 0));
    if (e4.tag !== 0 && n2 === 2 && (Yu |= 64, e4.hydrate && (e4.hydrate = false, ci(e4.containerInfo)), (t2 = no(e4)) !== 0 && (n2 = Uc(e4, t2))), n2 === 1)
      throw n2 = tc, $c(e4, 0), Nc(e4, t2), Dc(e4, is()), n2;
    return e4.finishedWork = e4.current.alternate, e4.finishedLanes = t2, Yc(e4), Dc(e4, is()), null;
  }
  function zc(e4, t2) {
    var n2 = Yu;
    Yu |= 1;
    try {
      return e4(t2);
    } finally {
      (Yu = n2) === 0 && (uc(), ds());
    }
  }
  function Mc(e4, t2) {
    var n2 = Yu;
    Yu &= -2, Yu |= 8;
    try {
      return e4(t2);
    } finally {
      (Yu = n2) === 0 && (uc(), ds());
    }
  }
  function Lc(e4, t2) {
    ji(Zu, Ju), Ju |= t2, nc |= t2;
  }
  function Fc() {
    Ju = Zu.current, Ci(Zu);
  }
  function $c(e4, t2) {
    e4.finishedWork = null, e4.finishedLanes = 0;
    var n2 = e4.timeoutHandle;
    if (n2 !== -1 && (e4.timeoutHandle = -1, ui(n2)), Gu !== null)
      for (n2 = Gu.return; n2 !== null; ) {
        var r2 = n2;
        switch (r2.tag) {
          case 1:
            (r2 = r2.type.childContextTypes) != null && Ai();
            break;
          case 3:
            Qs(), Ci(Ii), Ci(Ti), fl();
            break;
          case 5:
            Zs(r2);
            break;
          case 4:
            Qs();
            break;
          case 13:
          case 19:
            Ci(el);
            break;
          case 10:
            ws(r2);
            break;
          case 23:
          case 24:
            Fc();
        }
        n2 = n2.return;
      }
    Xu = e4, Gu = ld(e4.current, null), Qu = Ju = nc = t2, ec = 0, tc = null, ac = oc = rc = 0;
  }
  function Bc(e4, t2) {
    for (; ; ) {
      var n2 = Gu;
      try {
        if (bs(), pl.current = Yl, bl) {
          for (var r2 = vl.memoizedState; r2 !== null; ) {
            var o2 = r2.queue;
            o2 !== null && (o2.pending = null), r2 = r2.next;
          }
          bl = false;
        }
        if (ml = 0, yl = gl = vl = null, wl = false, Ku.current = null, n2 === null || n2.return === null) {
          ec = 1, tc = t2, Gu = null;
          break;
        }
        e: {
          var a2 = e4, i2 = n2.return, s2 = n2, l2 = t2;
          if (t2 = Qu, s2.flags |= 2048, s2.firstEffect = s2.lastEffect = null, l2 !== null && typeof l2 == "object" && typeof l2.then == "function") {
            var u2 = l2;
            if ((2 & s2.mode) == 0) {
              var c2 = s2.alternate;
              c2 ? (s2.updateQueue = c2.updateQueue, s2.memoizedState = c2.memoizedState, s2.lanes = c2.lanes) : (s2.updateQueue = null, s2.memoizedState = null);
            }
            var d = (1 & el.current) != 0, f = i2;
            do {
              var p;
              if (p = f.tag === 13) {
                var h2 = f.memoizedState;
                if (h2 !== null)
                  p = h2.dehydrated !== null;
                else {
                  var m2 = f.memoizedProps;
                  p = m2.fallback !== void 0 && (m2.unstable_avoidThisFallback !== true || !d);
                }
              }
              if (p) {
                var v2 = f.updateQueue;
                if (v2 === null) {
                  var g2 = /* @__PURE__ */ new Set();
                  g2.add(u2), f.updateQueue = g2;
                } else
                  v2.add(u2);
                if ((2 & f.mode) == 0) {
                  if (f.flags |= 64, s2.flags |= 16384, s2.flags &= -2981, s2.tag === 1)
                    if (s2.alternate === null)
                      s2.tag = 17;
                    else {
                      var y2 = Cs(-1, 1);
                      y2.tag = 2, js(s2, y2);
                    }
                  s2.lanes |= 1;
                  break e;
                }
                l2 = void 0, s2 = t2;
                var b2 = a2.pingCache;
                if (b2 === null ? (b2 = a2.pingCache = new Cu(), l2 = /* @__PURE__ */ new Set(), b2.set(u2, l2)) : (l2 = b2.get(u2)) === void 0 && (l2 = /* @__PURE__ */ new Set(), b2.set(u2, l2)), !l2.has(s2)) {
                  l2.add(s2);
                  var w2 = rd.bind(null, a2, u2, s2);
                  u2.then(w2, w2);
                }
                f.flags |= 4096, f.lanes = t2;
                break e;
              }
              f = f.return;
            } while (f !== null);
            l2 = Error((cn(s2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
          }
          ec !== 5 && (ec = 2), l2 = Eu(l2, s2), f = i2;
          do {
            switch (f.tag) {
              case 3:
                a2 = l2, f.flags |= 4096, t2 &= -t2, f.lanes |= t2, Os(f, ju(0, a2, t2));
                break e;
              case 1:
                a2 = l2;
                var k2 = f.type, x2 = f.stateNode;
                if ((64 & f.flags) == 0 && (typeof k2.getDerivedStateFromError == "function" || x2 !== null && typeof x2.componentDidCatch == "function" && (hc === null || !hc.has(x2)))) {
                  f.flags |= 4096, t2 &= -t2, f.lanes |= t2, Os(f, Ou(f, a2, t2));
                  break e;
                }
            }
            f = f.return;
          } while (f !== null);
        }
        Kc(n2);
      } catch (e5) {
        t2 = e5, Gu === n2 && n2 !== null && (Gu = n2 = n2.return);
        continue;
      }
      break;
    }
  }
  function Vc() {
    var e4 = qu.current;
    return qu.current = Yl, e4 === null ? Yl : e4;
  }
  function Uc(e4, t2) {
    var n2 = Yu;
    Yu |= 16;
    var r2 = Vc();
    for (Xu === e4 && Qu === t2 || $c(e4, t2); ; )
      try {
        Hc();
        break;
      } catch (t3) {
        Bc(e4, t3);
      }
    if (bs(), Yu = n2, qu.current = r2, Gu !== null)
      throw Error(xt(261));
    return Xu = null, Qu = 0, ec;
  }
  function Hc() {
    for (; Gu !== null; )
      qc(Gu);
  }
  function Wc() {
    for (; Gu !== null && !Wi(); )
      qc(Gu);
  }
  function qc(e4) {
    var t2 = cc(e4.alternate, e4, Ju);
    e4.memoizedProps = e4.pendingProps, t2 === null ? Kc(e4) : Gu = t2, Ku.current = null;
  }
  function Kc(e4) {
    var t2 = e4;
    do {
      var n2 = t2.alternate;
      if (e4 = t2.return, (2048 & t2.flags) == 0) {
        if ((n2 = Su(n2, t2, Ju)) !== null)
          return void (Gu = n2);
        if ((n2 = t2).tag !== 24 && n2.tag !== 23 || n2.memoizedState === null || (1073741824 & Ju) != 0 || (4 & n2.mode) == 0) {
          for (var r2 = 0, o2 = n2.child; o2 !== null; )
            r2 |= o2.lanes | o2.childLanes, o2 = o2.sibling;
          n2.childLanes = r2;
        }
        e4 !== null && (2048 & e4.flags) == 0 && (e4.firstEffect === null && (e4.firstEffect = t2.firstEffect), t2.lastEffect !== null && (e4.lastEffect !== null && (e4.lastEffect.nextEffect = t2.firstEffect), e4.lastEffect = t2.lastEffect), 1 < t2.flags && (e4.lastEffect !== null ? e4.lastEffect.nextEffect = t2 : e4.firstEffect = t2, e4.lastEffect = t2));
      } else {
        if ((n2 = _u(t2)) !== null)
          return n2.flags &= 2047, void (Gu = n2);
        e4 !== null && (e4.firstEffect = e4.lastEffect = null, e4.flags |= 2048);
      }
      if ((t2 = t2.sibling) !== null)
        return void (Gu = t2);
      Gu = t2 = e4;
    } while (t2 !== null);
    ec === 0 && (ec = 5);
  }
  function Yc(e4) {
    var t2 = ss();
    return us(99, Xc.bind(null, e4, t2)), null;
  }
  function Xc(e4, t2) {
    do {
      Qc();
    } while (vc !== null);
    if ((48 & Yu) != 0)
      throw Error(xt(327));
    var n2 = e4.finishedWork;
    if (n2 === null)
      return null;
    if (e4.finishedWork = null, e4.finishedLanes = 0, n2 === e4.current)
      throw Error(xt(177));
    e4.callbackNode = null;
    var r2 = n2.lanes | n2.childLanes, o2 = r2, a2 = e4.pendingLanes & ~o2;
    e4.pendingLanes = o2, e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.expiredLanes &= o2, e4.mutableReadLanes &= o2, e4.entangledLanes &= o2, o2 = e4.entanglements;
    for (var i2 = e4.eventTimes, s2 = e4.expirationTimes; 0 < a2; ) {
      var l2 = 31 - so(a2), u2 = 1 << l2;
      o2[l2] = 0, i2[l2] = -1, s2[l2] = -1, a2 &= ~u2;
    }
    if (wc !== null && (24 & r2) == 0 && wc.has(e4) && wc.delete(e4), e4 === Xu && (Gu = Xu = null, Qu = 0), 1 < n2.flags ? n2.lastEffect !== null ? (n2.lastEffect.nextEffect = n2, r2 = n2.firstEffect) : r2 = n2 : r2 = n2.firstEffect, r2 !== null) {
      if (o2 = Yu, Yu |= 32, Ku.current = null, oi = po, Na(i2 = Ra())) {
        if ("selectionStart" in i2)
          s2 = { start: i2.selectionStart, end: i2.selectionEnd };
        else
          e:
            if (s2 = (s2 = i2.ownerDocument) && s2.defaultView || window, (u2 = s2.getSelection && s2.getSelection()) && u2.rangeCount !== 0) {
              s2 = u2.anchorNode, a2 = u2.anchorOffset, l2 = u2.focusNode, u2 = u2.focusOffset;
              try {
                s2.nodeType, l2.nodeType;
              } catch (e5) {
                s2 = null;
                break e;
              }
              var c2 = 0, d = -1, f = -1, p = 0, h2 = 0, m2 = i2, v2 = null;
              t:
                for (; ; ) {
                  for (var g2; m2 !== s2 || a2 !== 0 && m2.nodeType !== 3 || (d = c2 + a2), m2 !== l2 || u2 !== 0 && m2.nodeType !== 3 || (f = c2 + u2), m2.nodeType === 3 && (c2 += m2.nodeValue.length), (g2 = m2.firstChild) !== null; )
                    v2 = m2, m2 = g2;
                  for (; ; ) {
                    if (m2 === i2)
                      break t;
                    if (v2 === s2 && ++p === a2 && (d = c2), v2 === l2 && ++h2 === u2 && (f = c2), (g2 = m2.nextSibling) !== null)
                      break;
                    v2 = (m2 = v2).parentNode;
                  }
                  m2 = g2;
                }
              s2 = d === -1 || f === -1 ? null : { start: d, end: f };
            } else
              s2 = null;
        s2 = s2 || { start: 0, end: 0 };
      } else
        s2 = null;
      ai = { focusedElem: i2, selectionRange: s2 }, po = false, Pc = null, Cc = false, dc = r2;
      do {
        try {
          Gc();
        } catch (e5) {
          if (dc === null)
            throw Error(xt(330));
          nd(dc, e5), dc = dc.nextEffect;
        }
      } while (dc !== null);
      Pc = null, dc = r2;
      do {
        try {
          for (i2 = e4; dc !== null; ) {
            var y2 = dc.flags;
            if (16 & y2 && An(dc.stateNode, ""), 128 & y2) {
              var b2 = dc.alternate;
              if (b2 !== null) {
                var w2 = b2.ref;
                w2 !== null && (typeof w2 == "function" ? w2(null) : w2.current = null);
              }
            }
            switch (1038 & y2) {
              case 2:
                Lu(dc), dc.flags &= -3;
                break;
              case 6:
                Lu(dc), dc.flags &= -3, Vu(dc.alternate, dc);
                break;
              case 1024:
                dc.flags &= -1025;
                break;
              case 1028:
                dc.flags &= -1025, Vu(dc.alternate, dc);
                break;
              case 4:
                Vu(dc.alternate, dc);
                break;
              case 8:
                Bu(i2, s2 = dc);
                var k2 = s2.alternate;
                zu(s2), k2 !== null && zu(k2);
            }
            dc = dc.nextEffect;
          }
        } catch (e5) {
          if (dc === null)
            throw Error(xt(330));
          nd(dc, e5), dc = dc.nextEffect;
        }
      } while (dc !== null);
      if (w2 = ai, b2 = Ra(), y2 = w2.focusedElem, i2 = w2.selectionRange, b2 !== y2 && y2 && y2.ownerDocument && Da(y2.ownerDocument.documentElement, y2)) {
        i2 !== null && Na(y2) && (b2 = i2.start, (w2 = i2.end) === void 0 && (w2 = b2), "selectionStart" in y2 ? (y2.selectionStart = b2, y2.selectionEnd = Math.min(w2, y2.value.length)) : (w2 = (b2 = y2.ownerDocument || document) && b2.defaultView || window).getSelection && (w2 = w2.getSelection(), s2 = y2.textContent.length, k2 = Math.min(i2.start, s2), i2 = i2.end === void 0 ? k2 : Math.min(i2.end, s2), !w2.extend && k2 > i2 && (s2 = i2, i2 = k2, k2 = s2), s2 = Ia(y2, k2), a2 = Ia(y2, i2), s2 && a2 && (w2.rangeCount !== 1 || w2.anchorNode !== s2.node || w2.anchorOffset !== s2.offset || w2.focusNode !== a2.node || w2.focusOffset !== a2.offset) && ((b2 = b2.createRange()).setStart(s2.node, s2.offset), w2.removeAllRanges(), k2 > i2 ? (w2.addRange(b2), w2.extend(a2.node, a2.offset)) : (b2.setEnd(a2.node, a2.offset), w2.addRange(b2))))), b2 = [];
        for (w2 = y2; w2 = w2.parentNode; )
          w2.nodeType === 1 && b2.push({ element: w2, left: w2.scrollLeft, top: w2.scrollTop });
        for (typeof y2.focus == "function" && y2.focus(), y2 = 0; y2 < b2.length; y2++)
          (w2 = b2[y2]).element.scrollLeft = w2.left, w2.element.scrollTop = w2.top;
      }
      po = !!oi, ai = oi = null, e4.current = n2, dc = r2;
      do {
        try {
          for (y2 = e4; dc !== null; ) {
            var x2 = dc.flags;
            if (36 & x2 && Ru(y2, dc.alternate, dc), 128 & x2) {
              b2 = void 0;
              var S2 = dc.ref;
              if (S2 !== null) {
                var _2 = dc.stateNode;
                dc.tag, b2 = _2, typeof S2 == "function" ? S2(b2) : S2.current = b2;
              }
            }
            dc = dc.nextEffect;
          }
        } catch (e5) {
          if (dc === null)
            throw Error(xt(330));
          nd(dc, e5), dc = dc.nextEffect;
        }
      } while (dc !== null);
      dc = null, ts(), Yu = o2;
    } else
      e4.current = n2;
    if (mc)
      mc = false, vc = e4, gc = t2;
    else
      for (dc = r2; dc !== null; )
        t2 = dc.nextEffect, dc.nextEffect = null, 8 & dc.flags && ((x2 = dc).sibling = null, x2.stateNode = null), dc = t2;
    if ((r2 = e4.pendingLanes) === 0 && (hc = null), r2 === 1 ? e4 === xc ? kc++ : (kc = 0, xc = e4) : kc = 0, n2 = n2.stateNode, Bi && typeof Bi.onCommitFiberRoot == "function")
      try {
        Bi.onCommitFiberRoot($i, n2, void 0, (64 & n2.current.flags) == 64);
      } catch (e5) {
      }
    if (Dc(e4, is()), fc)
      throw fc = false, e4 = pc, pc = null, e4;
    return (8 & Yu) != 0 || ds(), null;
  }
  function Gc() {
    for (; dc !== null; ) {
      var e4 = dc.alternate;
      Cc || Pc === null || ((8 & dc.flags) != 0 ? gr(dc, Pc) && (Cc = true) : dc.tag === 13 && Hu(e4, dc) && gr(dc, Pc) && (Cc = true));
      var t2 = dc.flags;
      (256 & t2) != 0 && Du(e4, dc), (512 & t2) == 0 || mc || (mc = true, cs(97, function() {
        return Qc(), null;
      })), dc = dc.nextEffect;
    }
  }
  function Qc() {
    if (gc !== 90) {
      var e4 = 97 < gc ? 97 : gc;
      return gc = 90, us(e4, ed);
    }
    return false;
  }
  function Jc(e4, t2) {
    yc.push(t2, e4), mc || (mc = true, cs(97, function() {
      return Qc(), null;
    }));
  }
  function Zc(e4, t2) {
    bc.push(t2, e4), mc || (mc = true, cs(97, function() {
      return Qc(), null;
    }));
  }
  function ed() {
    if (vc === null)
      return false;
    var e4 = vc;
    if (vc = null, (48 & Yu) != 0)
      throw Error(xt(331));
    var t2 = Yu;
    Yu |= 32;
    var n2 = bc;
    bc = [];
    for (var r2 = 0; r2 < n2.length; r2 += 2) {
      var o2 = n2[r2], a2 = n2[r2 + 1], i2 = o2.destroy;
      if (o2.destroy = void 0, typeof i2 == "function")
        try {
          i2();
        } catch (e5) {
          if (a2 === null)
            throw Error(xt(330));
          nd(a2, e5);
        }
    }
    for (n2 = yc, yc = [], r2 = 0; r2 < n2.length; r2 += 2) {
      o2 = n2[r2], a2 = n2[r2 + 1];
      try {
        var s2 = o2.create;
        o2.destroy = s2();
      } catch (e5) {
        if (a2 === null)
          throw Error(xt(330));
        nd(a2, e5);
      }
    }
    for (s2 = e4.current.firstEffect; s2 !== null; )
      e4 = s2.nextEffect, s2.nextEffect = null, 8 & s2.flags && (s2.sibling = null, s2.stateNode = null), s2 = e4;
    return Yu = t2, ds(), true;
  }
  function td(e4, t2, n2) {
    js(e4, t2 = ju(0, t2 = Eu(n2, t2), 1)), t2 = jc(), (e4 = Ic(e4, 1)) !== null && (io(e4, 1, t2), Dc(e4, t2));
  }
  function nd(e4, t2) {
    if (e4.tag === 3)
      td(e4, e4, t2);
    else
      for (var n2 = e4.return; n2 !== null; ) {
        if (n2.tag === 3) {
          td(n2, e4, t2);
          break;
        }
        if (n2.tag === 1) {
          var r2 = n2.stateNode;
          if (typeof n2.type.getDerivedStateFromError == "function" || typeof r2.componentDidCatch == "function" && (hc === null || !hc.has(r2))) {
            var o2 = Ou(n2, e4 = Eu(t2, e4), 1);
            if (js(n2, o2), o2 = jc(), (n2 = Ic(n2, 1)) !== null)
              io(n2, 1, o2), Dc(n2, o2);
            else if (typeof r2.componentDidCatch == "function" && (hc === null || !hc.has(r2)))
              try {
                r2.componentDidCatch(t2, e4);
              } catch (e5) {
              }
            break;
          }
        }
        n2 = n2.return;
      }
  }
  function rd(e4, t2, n2) {
    var r2 = e4.pingCache;
    r2 !== null && r2.delete(t2), t2 = jc(), e4.pingedLanes |= e4.suspendedLanes & n2, Xu === e4 && (Qu & n2) === n2 && (ec === 4 || ec === 3 && (62914560 & Qu) === Qu && 500 > is() - sc ? $c(e4, 0) : ac |= n2), Dc(e4, t2);
  }
  function od(e4, t2) {
    var n2 = e4.stateNode;
    n2 !== null && n2.delete(t2), (t2 = 0) === 0 && ((2 & (t2 = e4.mode)) == 0 ? t2 = 1 : (4 & t2) == 0 ? t2 = ss() === 99 ? 1 : 2 : (_c === 0 && (_c = nc), (t2 = oo(62914560 & ~_c)) === 0 && (t2 = 4194304))), n2 = jc(), (e4 = Ic(e4, t2)) !== null && (io(e4, t2, n2), Dc(e4, n2));
  }
  function ad(e4, t2, n2, r2) {
    this.tag = e4, this.key = n2, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t2, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r2, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function id(e4, t2, n2, r2) {
    return new ad(e4, t2, n2, r2);
  }
  function sd(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  function ld(e4, t2) {
    var n2 = e4.alternate;
    return n2 === null ? ((n2 = id(e4.tag, t2, e4.key, e4.mode)).elementType = e4.elementType, n2.type = e4.type, n2.stateNode = e4.stateNode, n2.alternate = e4, e4.alternate = n2) : (n2.pendingProps = t2, n2.type = e4.type, n2.flags = 0, n2.nextEffect = null, n2.firstEffect = null, n2.lastEffect = null), n2.childLanes = e4.childLanes, n2.lanes = e4.lanes, n2.child = e4.child, n2.memoizedProps = e4.memoizedProps, n2.memoizedState = e4.memoizedState, n2.updateQueue = e4.updateQueue, t2 = e4.dependencies, n2.dependencies = t2 === null ? null : { lanes: t2.lanes, firstContext: t2.firstContext }, n2.sibling = e4.sibling, n2.index = e4.index, n2.ref = e4.ref, n2;
  }
  function ud(e4, t2, n2, r2, o2, a2) {
    var i2 = 2;
    if (r2 = e4, typeof e4 == "function")
      sd(e4) && (i2 = 1);
    else if (typeof e4 == "string")
      i2 = 5;
    else
      e:
        switch (e4) {
          case $t:
            return cd(n2.children, o2, a2, t2);
          case Jt:
            i2 = 8, o2 |= 16;
            break;
          case Bt:
            i2 = 8, o2 |= 1;
            break;
          case Vt:
            return (e4 = id(12, n2, t2, 8 | o2)).elementType = Vt, e4.type = Vt, e4.lanes = a2, e4;
          case qt:
            return (e4 = id(13, n2, t2, o2)).type = qt, e4.elementType = qt, e4.lanes = a2, e4;
          case Kt:
            return (e4 = id(19, n2, t2, o2)).elementType = Kt, e4.lanes = a2, e4;
          case Zt:
            return dd(n2, o2, a2, t2);
          case en:
            return (e4 = id(24, n2, t2, o2)).elementType = en, e4.lanes = a2, e4;
          default:
            if (typeof e4 == "object" && e4 !== null)
              switch (e4.$$typeof) {
                case Ut:
                  i2 = 10;
                  break e;
                case Ht:
                  i2 = 9;
                  break e;
                case Wt:
                  i2 = 11;
                  break e;
                case Yt:
                  i2 = 14;
                  break e;
                case Xt:
                  i2 = 16, r2 = null;
                  break e;
                case Gt:
                  i2 = 22;
                  break e;
              }
            throw Error(xt(130, e4 == null ? e4 : typeof e4, ""));
        }
    return (t2 = id(i2, n2, t2, o2)).elementType = e4, t2.type = r2, t2.lanes = a2, t2;
  }
  function cd(e4, t2, n2, r2) {
    return (e4 = id(7, e4, r2, t2)).lanes = n2, e4;
  }
  function dd(e4, t2, n2, r2) {
    return (e4 = id(23, e4, r2, t2)).elementType = Zt, e4.lanes = n2, e4;
  }
  function fd(e4, t2, n2) {
    return (e4 = id(6, e4, null, t2)).lanes = n2, e4;
  }
  function pd(e4, t2, n2) {
    return (t2 = id(4, e4.children !== null ? e4.children : [], e4.key, t2)).lanes = n2, t2.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, t2;
  }
  function hd(e4, t2, n2) {
    this.tag = t2, this.containerInfo = e4, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.pendingContext = this.context = null, this.hydrate = n2, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = ao(0), this.expirationTimes = ao(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ao(0), this.mutableSourceEagerHydrationData = null;
  }
  function md(e4, t2, n2) {
    var r2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Ft, key: r2 == null ? null : "" + r2, children: e4, containerInfo: t2, implementation: n2 };
  }
  function vd(e4, t2, n2, r2) {
    var o2 = t2.current, a2 = jc(), i2 = Oc(o2);
    e:
      if (n2) {
        t: {
          if (pr(n2 = n2._reactInternals) !== n2 || n2.tag !== 1)
            throw Error(xt(170));
          var s2 = n2;
          do {
            switch (s2.tag) {
              case 3:
                s2 = s2.stateNode.context;
                break t;
              case 1:
                if (Ni(s2.type)) {
                  s2 = s2.stateNode.__reactInternalMemoizedMergedChildContext;
                  break t;
                }
            }
            s2 = s2.return;
          } while (s2 !== null);
          throw Error(xt(171));
        }
        if (n2.tag === 1) {
          var l2 = n2.type;
          if (Ni(l2)) {
            n2 = Mi(n2, l2, s2);
            break e;
          }
        }
        n2 = s2;
      } else
        n2 = Oi;
    return t2.context === null ? t2.context = n2 : t2.pendingContext = n2, (t2 = Cs(a2, i2)).payload = { element: e4 }, (r2 = r2 === void 0 ? null : r2) !== null && (t2.callback = r2), js(o2, t2), Tc(o2, i2, a2), i2;
  }
  function gd(e4) {
    return (e4 = e4.current).child ? (e4.child.tag, e4.child.stateNode) : null;
  }
  function yd(e4, t2) {
    if ((e4 = e4.memoizedState) !== null && e4.dehydrated !== null) {
      var n2 = e4.retryLane;
      e4.retryLane = n2 !== 0 && n2 < t2 ? n2 : t2;
    }
  }
  function bd(e4, t2) {
    yd(e4, t2), (e4 = e4.alternate) && yd(e4, t2);
  }
  function wd(e4, t2, n2) {
    var r2 = n2 != null && n2.hydrationOptions != null && n2.hydrationOptions.mutableSources || null;
    if (n2 = new hd(e4, t2, n2 != null && n2.hydrate === true), t2 = id(3, null, null, t2 === 2 ? 7 : t2 === 1 ? 3 : 0), n2.current = t2, t2.stateNode = n2, Es(t2), e4[gi] = n2.current, Xa(e4.nodeType === 8 ? e4.parentNode : e4), r2)
      for (e4 = 0; e4 < r2.length; e4++) {
        var o2 = (t2 = r2[e4])._getVersion;
        o2 = o2(t2._source), n2.mutableSourceEagerHydrationData == null ? n2.mutableSourceEagerHydrationData = [t2, o2] : n2.mutableSourceEagerHydrationData.push(t2, o2);
      }
    this._internalRoot = n2;
  }
  function kd(e4) {
    return !(!e4 || e4.nodeType !== 1 && e4.nodeType !== 9 && e4.nodeType !== 11 && (e4.nodeType !== 8 || e4.nodeValue !== " react-mount-point-unstable "));
  }
  function xd(e4, t2, n2, r2, o2) {
    var a2 = n2._reactRootContainer;
    if (a2) {
      var i2 = a2._internalRoot;
      if (typeof o2 == "function") {
        var s2 = o2;
        o2 = function() {
          var e5 = gd(i2);
          s2.call(e5);
        };
      }
      vd(t2, i2, e4, o2);
    } else {
      if (a2 = n2._reactRootContainer = function(e5, t3) {
        if (t3 || (t3 = !(!(t3 = e5 ? e5.nodeType === 9 ? e5.documentElement : e5.firstChild : null) || t3.nodeType !== 1 || !t3.hasAttribute("data-reactroot"))), !t3)
          for (var n3; n3 = e5.lastChild; )
            e5.removeChild(n3);
        return new wd(e5, 0, t3 ? { hydrate: true } : void 0);
      }(n2, r2), i2 = a2._internalRoot, typeof o2 == "function") {
        var l2 = o2;
        o2 = function() {
          var e5 = gd(i2);
          l2.call(e5);
        };
      }
      Mc(function() {
        vd(t2, i2, e4, o2);
      });
    }
    return gd(i2);
  }
  function Sd(e4, t2) {
    var n2 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!kd(t2))
      throw Error(xt(200));
    return md(e4, t2, null, n2);
  }
  cc = function(e4, t2, n2) {
    var r2 = t2.lanes;
    if (e4 !== null)
      if (e4.memoizedProps !== t2.pendingProps || Ii.current)
        Zl = true;
      else {
        if ((n2 & r2) == 0) {
          switch (Zl = false, t2.tag) {
            case 3:
              uu(t2), cl();
              break;
            case 5:
              Js(t2);
              break;
            case 1:
              Ni(t2.type) && Li(t2);
              break;
            case 4:
              Gs(t2, t2.stateNode.containerInfo);
              break;
            case 10:
              r2 = t2.memoizedProps.value;
              var o2 = t2.type._context;
              ji(ms, o2._currentValue), o2._currentValue = r2;
              break;
            case 13:
              if (t2.memoizedState !== null)
                return (n2 & t2.child.childLanes) != 0 ? hu(e4, t2, n2) : (ji(el, 1 & el.current), (t2 = ku(e4, t2, n2)) !== null ? t2.sibling : null);
              ji(el, 1 & el.current);
              break;
            case 19:
              if (r2 = (n2 & t2.childLanes) != 0, (64 & e4.flags) != 0) {
                if (r2)
                  return wu(e4, t2, n2);
                t2.flags |= 64;
              }
              if ((o2 = t2.memoizedState) !== null && (o2.rendering = null, o2.tail = null, o2.lastEffect = null), ji(el, el.current), r2)
                break;
              return null;
            case 23:
            case 24:
              return t2.lanes = 0, ou(e4, t2, n2);
          }
          return ku(e4, t2, n2);
        }
        Zl = (16384 & e4.flags) != 0;
      }
    else
      Zl = false;
    switch (t2.lanes = 0, t2.tag) {
      case 2:
        if (r2 = t2.type, e4 !== null && (e4.alternate = null, t2.alternate = null, t2.flags |= 2), e4 = t2.pendingProps, o2 = Ri(t2, Ti.current), xs(t2, n2), o2 = Sl(null, t2, r2, e4, o2, n2), t2.flags |= 1, typeof o2 == "object" && o2 !== null && typeof o2.render == "function" && o2.$$typeof === void 0) {
          if (t2.tag = 1, t2.memoizedState = null, t2.updateQueue = null, Ni(r2)) {
            var a2 = true;
            Li(t2);
          } else
            a2 = false;
          t2.memoizedState = o2.state !== null && o2.state !== void 0 ? o2.state : null, Es(t2);
          var i2 = r2.getDerivedStateFromProps;
          typeof i2 == "function" && Rs(t2, r2, i2, e4), o2.updater = Ns, t2.stateNode = o2, o2._reactInternals = t2, Ls(t2, r2, e4, n2), t2 = lu(null, t2, r2, true, a2, n2);
        } else
          t2.tag = 0, eu(null, t2, o2, n2), t2 = t2.child;
        return t2;
      case 16:
        o2 = t2.elementType;
        e: {
          switch (e4 !== null && (e4.alternate = null, t2.alternate = null, t2.flags |= 2), e4 = t2.pendingProps, o2 = (a2 = o2._init)(o2._payload), t2.type = o2, a2 = t2.tag = function(e5) {
            if (typeof e5 == "function")
              return sd(e5) ? 1 : 0;
            if (e5 != null) {
              if ((e5 = e5.$$typeof) === Wt)
                return 11;
              if (e5 === Yt)
                return 14;
            }
            return 2;
          }(o2), e4 = hs(o2, e4), a2) {
            case 0:
              t2 = iu(null, t2, o2, e4, n2);
              break e;
            case 1:
              t2 = su(null, t2, o2, e4, n2);
              break e;
            case 11:
              t2 = tu(null, t2, o2, e4, n2);
              break e;
            case 14:
              t2 = nu(null, t2, o2, hs(o2.type, e4), r2, n2);
              break e;
          }
          throw Error(xt(306, o2, ""));
        }
        return t2;
      case 0:
        return r2 = t2.type, o2 = t2.pendingProps, iu(e4, t2, r2, o2 = t2.elementType === r2 ? o2 : hs(r2, o2), n2);
      case 1:
        return r2 = t2.type, o2 = t2.pendingProps, su(e4, t2, r2, o2 = t2.elementType === r2 ? o2 : hs(r2, o2), n2);
      case 3:
        if (uu(t2), r2 = t2.updateQueue, e4 === null || r2 === null)
          throw Error(xt(282));
        if (r2 = t2.pendingProps, o2 = (o2 = t2.memoizedState) !== null ? o2.element : null, Ps(e4, t2), Ts(t2, r2, null, n2), (r2 = t2.memoizedState.element) === o2)
          cl(), t2 = ku(e4, t2, n2);
        else {
          if ((a2 = (o2 = t2.stateNode).hydrate) && (rl = di(t2.stateNode.containerInfo.firstChild), nl = t2, a2 = ol = true), a2) {
            if ((e4 = o2.mutableSourceEagerHydrationData) != null)
              for (o2 = 0; o2 < e4.length; o2 += 2)
                (a2 = e4[o2])._workInProgressVersionPrimary = e4[o2 + 1], dl.push(a2);
            for (n2 = Hs(t2, null, r2, n2), t2.child = n2; n2; )
              n2.flags = -3 & n2.flags | 1024, n2 = n2.sibling;
          } else
            eu(e4, t2, r2, n2), cl();
          t2 = t2.child;
        }
        return t2;
      case 5:
        return Js(t2), e4 === null && sl(t2), r2 = t2.type, o2 = t2.pendingProps, a2 = e4 !== null ? e4.memoizedProps : null, i2 = o2.children, si(r2, o2) ? i2 = null : a2 !== null && si(r2, a2) && (t2.flags |= 16), au(e4, t2), eu(e4, t2, i2, n2), t2.child;
      case 6:
        return e4 === null && sl(t2), null;
      case 13:
        return hu(e4, t2, n2);
      case 4:
        return Gs(t2, t2.stateNode.containerInfo), r2 = t2.pendingProps, e4 === null ? t2.child = Us(t2, null, r2, n2) : eu(e4, t2, r2, n2), t2.child;
      case 11:
        return r2 = t2.type, o2 = t2.pendingProps, tu(e4, t2, r2, o2 = t2.elementType === r2 ? o2 : hs(r2, o2), n2);
      case 7:
        return eu(e4, t2, t2.pendingProps, n2), t2.child;
      case 8:
      case 12:
        return eu(e4, t2, t2.pendingProps.children, n2), t2.child;
      case 10:
        e: {
          r2 = t2.type._context, o2 = t2.pendingProps, i2 = t2.memoizedProps, a2 = o2.value;
          var s2 = t2.type._context;
          if (ji(ms, s2._currentValue), s2._currentValue = a2, i2 !== null)
            if (s2 = i2.value, (a2 = Ca(s2, a2) ? 0 : 0 | (typeof r2._calculateChangedBits == "function" ? r2._calculateChangedBits(s2, a2) : 1073741823)) === 0) {
              if (i2.children === o2.children && !Ii.current) {
                t2 = ku(e4, t2, n2);
                break e;
              }
            } else
              for ((s2 = t2.child) !== null && (s2.return = t2); s2 !== null; ) {
                var l2 = s2.dependencies;
                if (l2 !== null) {
                  i2 = s2.child;
                  for (var u2 = l2.firstContext; u2 !== null; ) {
                    if (u2.context === r2 && (u2.observedBits & a2) != 0) {
                      s2.tag === 1 && ((u2 = Cs(-1, n2 & -n2)).tag = 2, js(s2, u2)), s2.lanes |= n2, (u2 = s2.alternate) !== null && (u2.lanes |= n2), ks(s2.return, n2), l2.lanes |= n2;
                      break;
                    }
                    u2 = u2.next;
                  }
                } else
                  i2 = s2.tag === 10 && s2.type === t2.type ? null : s2.child;
                if (i2 !== null)
                  i2.return = s2;
                else
                  for (i2 = s2; i2 !== null; ) {
                    if (i2 === t2) {
                      i2 = null;
                      break;
                    }
                    if ((s2 = i2.sibling) !== null) {
                      s2.return = i2.return, i2 = s2;
                      break;
                    }
                    i2 = i2.return;
                  }
                s2 = i2;
              }
          eu(e4, t2, o2.children, n2), t2 = t2.child;
        }
        return t2;
      case 9:
        return o2 = t2.type, r2 = (a2 = t2.pendingProps).children, xs(t2, n2), r2 = r2(o2 = Ss(o2, a2.unstable_observedBits)), t2.flags |= 1, eu(e4, t2, r2, n2), t2.child;
      case 14:
        return a2 = hs(o2 = t2.type, t2.pendingProps), nu(e4, t2, o2, a2 = hs(o2.type, a2), r2, n2);
      case 15:
        return ru(e4, t2, t2.type, t2.pendingProps, r2, n2);
      case 17:
        return r2 = t2.type, o2 = t2.pendingProps, o2 = t2.elementType === r2 ? o2 : hs(r2, o2), e4 !== null && (e4.alternate = null, t2.alternate = null, t2.flags |= 2), t2.tag = 1, Ni(r2) ? (e4 = true, Li(t2)) : e4 = false, xs(t2, n2), zs(t2, r2, o2), Ls(t2, r2, o2, n2), lu(null, t2, r2, true, e4, n2);
      case 19:
        return wu(e4, t2, n2);
      case 23:
      case 24:
        return ou(e4, t2, n2);
    }
    throw Error(xt(156, t2.tag));
  }, wd.prototype.render = function(e4) {
    vd(e4, this._internalRoot, null, null);
  }, wd.prototype.unmount = function() {
    var e4 = this._internalRoot, t2 = e4.containerInfo;
    vd(null, e4, null, function() {
      t2[gi] = null;
    });
  }, yr = function(e4) {
    e4.tag === 13 && (Tc(e4, 4, jc()), bd(e4, 4));
  }, br = function(e4) {
    e4.tag === 13 && (Tc(e4, 67108864, jc()), bd(e4, 67108864));
  }, wr = function(e4) {
    if (e4.tag === 13) {
      var t2 = jc(), n2 = Oc(e4);
      Tc(e4, n2, t2), bd(e4, n2);
    }
  }, kr = function(e4, t2) {
    return t2();
  }, Hn = function(e4, t2, n2) {
    switch (t2) {
      case "input":
        if (bn(e4, n2), t2 = n2.name, n2.type === "radio" && t2 != null) {
          for (n2 = e4; n2.parentNode; )
            n2 = n2.parentNode;
          for (n2 = n2.querySelectorAll("input[name=" + JSON.stringify("" + t2) + '][type="radio"]'), t2 = 0; t2 < n2.length; t2++) {
            var r2 = n2[t2];
            if (r2 !== e4 && r2.form === e4.form) {
              var o2 = xi(r2);
              if (!o2)
                throw Error(xt(90));
              hn(r2), bn(r2, o2);
            }
          }
        }
        break;
      case "textarea":
        Pn(e4, n2);
        break;
      case "select":
        (t2 = n2.value) != null && Sn(e4, !!n2.multiple, t2, false);
    }
  }, Gn = zc, Qn = function(e4, t2, n2, r2, o2) {
    var a2 = Yu;
    Yu |= 4;
    try {
      return us(98, e4.bind(null, t2, n2, r2, o2));
    } finally {
      (Yu = a2) === 0 && (uc(), ds());
    }
  }, Jn = function() {
    (49 & Yu) == 0 && (function() {
      if (wc !== null) {
        var e4 = wc;
        wc = null, e4.forEach(function(e5) {
          e5.expiredLanes |= 24 & e5.pendingLanes, Dc(e5, is());
        });
      }
      ds();
    }(), Qc());
  }, Zn = function(e4, t2) {
    var n2 = Yu;
    Yu |= 2;
    try {
      return e4(t2);
    } finally {
      (Yu = n2) === 0 && (uc(), ds());
    }
  };
  var _d = { Events: [wi, ki, xi, Yn, Xn, Qc, { current: false }] };
  var Ed = { findFiberByHostInstance: bi, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
  var Pd = { bundleType: Ed.bundleType, version: Ed.version, rendererPackageName: Ed.rendererPackageName, rendererConfig: Ed.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Mt.ReactCurrentDispatcher, findHostInstanceByFiber: function(e4) {
    return (e4 = vr(e4)) === null ? null : e4.stateNode;
  }, findFiberByHostInstance: Ed.findFiberByHostInstance || function() {
    return null;
  }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined") {
    Cd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Cd.isDisabled && Cd.supportsFiber)
      try {
        $i = Cd.inject(Pd), Bi = Cd;
      } catch (Rn2) {
      }
  }
  var Cd;
  mt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _d, mt.createPortal = Sd, mt.findDOMNode = function(e4) {
    if (e4 == null)
      return null;
    if (e4.nodeType === 1)
      return e4;
    var t2 = e4._reactInternals;
    if (t2 === void 0) {
      if (typeof e4.render == "function")
        throw Error(xt(188));
      throw Error(xt(268, Object.keys(e4)));
    }
    return e4 = (e4 = vr(t2)) === null ? null : e4.stateNode;
  }, mt.flushSync = function(e4, t2) {
    var n2 = Yu;
    if ((48 & n2) != 0)
      return e4(t2);
    Yu |= 1;
    try {
      if (e4)
        return us(99, e4.bind(null, t2));
    } finally {
      Yu = n2, ds();
    }
  }, mt.hydrate = function(e4, t2, n2) {
    if (!kd(t2))
      throw Error(xt(200));
    return xd(null, e4, t2, true, n2);
  }, mt.render = function(e4, t2, n2) {
    if (!kd(t2))
      throw Error(xt(200));
    return xd(null, e4, t2, false, n2);
  }, mt.unmountComponentAtNode = function(e4) {
    if (!kd(e4))
      throw Error(xt(40));
    return !!e4._reactRootContainer && (Mc(function() {
      xd(null, null, e4, false, function() {
        e4._reactRootContainer = null, e4[gi] = null;
      });
    }), true);
  }, mt.unstable_batchedUpdates = zc, mt.unstable_createPortal = function(e4, t2) {
    return Sd(e4, t2, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
  }, mt.unstable_renderSubtreeIntoContainer = function(e4, t2, n2, r2) {
    if (!kd(n2))
      throw Error(xt(200));
    if (e4 == null || e4._reactInternals === void 0)
      throw Error(xt(38));
    return xd(e4, t2, n2, false, r2);
  }, mt.version = "17.0.2";
  var jd = {};
  var Od = { exports: {} };
  var Td = {};
  var Id = 0;
  Td.__interactionsRef = null, Td.__subscriberRef = null, Td.unstable_clear = function(e4) {
    return e4();
  }, Td.unstable_getCurrent = function() {
    return null;
  }, Td.unstable_getThreadID = function() {
    return ++Id;
  }, Td.unstable_subscribe = function() {
  }, Td.unstable_trace = function(e4, t2, n2) {
    return n2();
  }, Td.unstable_unsubscribe = function() {
  }, Td.unstable_wrap = function(e4) {
    return e4;
  };
  var Dd = {};
  !function(e4) {
    (function() {
      var t2 = 0, n2 = 0;
      e4.__interactionsRef = null, e4.__subscriberRef = null, e4.__interactionsRef = { current: /* @__PURE__ */ new Set() }, e4.__subscriberRef = { current: null };
      var r2 = null;
      function o2(e5) {
        var t3 = false, n3 = null;
        if (r2.forEach(function(r3) {
          try {
            r3.onInteractionTraced(e5);
          } catch (e6) {
            t3 || (t3 = true, n3 = e6);
          }
        }), t3)
          throw n3;
      }
      function a2(e5) {
        var t3 = false, n3 = null;
        if (r2.forEach(function(r3) {
          try {
            r3.onInteractionScheduledWorkCompleted(e5);
          } catch (e6) {
            t3 || (t3 = true, n3 = e6);
          }
        }), t3)
          throw n3;
      }
      function i2(e5, t3) {
        var n3 = false, o3 = null;
        if (r2.forEach(function(r3) {
          try {
            r3.onWorkScheduled(e5, t3);
          } catch (e6) {
            n3 || (n3 = true, o3 = e6);
          }
        }), n3)
          throw o3;
      }
      function s2(e5, t3) {
        var n3 = false, o3 = null;
        if (r2.forEach(function(r3) {
          try {
            r3.onWorkStarted(e5, t3);
          } catch (e6) {
            n3 || (n3 = true, o3 = e6);
          }
        }), n3)
          throw o3;
      }
      function l2(e5, t3) {
        var n3 = false, o3 = null;
        if (r2.forEach(function(r3) {
          try {
            r3.onWorkStopped(e5, t3);
          } catch (e6) {
            n3 || (n3 = true, o3 = e6);
          }
        }), n3)
          throw o3;
      }
      function u2(e5, t3) {
        var n3 = false, o3 = null;
        if (r2.forEach(function(r3) {
          try {
            r3.onWorkCanceled(e5, t3);
          } catch (e6) {
            n3 || (n3 = true, o3 = e6);
          }
        }), n3)
          throw o3;
      }
      r2 = /* @__PURE__ */ new Set(), e4.unstable_clear = function(t3) {
        var n3 = e4.__interactionsRef.current;
        e4.__interactionsRef.current = /* @__PURE__ */ new Set();
        try {
          return t3();
        } finally {
          e4.__interactionsRef.current = n3;
        }
      }, e4.unstable_getCurrent = function() {
        return e4.__interactionsRef.current;
      }, e4.unstable_getThreadID = function() {
        return ++n2;
      }, e4.unstable_subscribe = function(t3) {
        r2.add(t3), r2.size === 1 && (e4.__subscriberRef.current = { onInteractionScheduledWorkCompleted: a2, onInteractionTraced: o2, onWorkCanceled: u2, onWorkScheduled: i2, onWorkStarted: s2, onWorkStopped: l2 });
      }, e4.unstable_trace = function(n3, r3, o3) {
        var a3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, i3 = { __count: 1, id: t2++, name: n3, timestamp: r3 }, s3 = e4.__interactionsRef.current, l3 = new Set(s3);
        l3.add(i3), e4.__interactionsRef.current = l3;
        var u3, c2 = e4.__subscriberRef.current;
        try {
          c2 !== null && c2.onInteractionTraced(i3);
        } finally {
          try {
            c2 !== null && c2.onWorkStarted(l3, a3);
          } finally {
            try {
              u3 = o3();
            } finally {
              e4.__interactionsRef.current = s3;
              try {
                c2 !== null && c2.onWorkStopped(l3, a3);
              } finally {
                i3.__count--, c2 !== null && i3.__count === 0 && c2.onInteractionScheduledWorkCompleted(i3);
              }
            }
          }
        }
        return u3;
      }, e4.unstable_unsubscribe = function(t3) {
        r2.delete(t3), r2.size === 0 && (e4.__subscriberRef.current = null);
      }, e4.unstable_wrap = function(t3) {
        var n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r3 = e4.__interactionsRef.current, o3 = e4.__subscriberRef.current;
        o3 !== null && o3.onWorkScheduled(r3, n3), r3.forEach(function(e5) {
          e5.__count++;
        });
        var a3 = false;
        function i3() {
          var i4 = e4.__interactionsRef.current;
          e4.__interactionsRef.current = r3, o3 = e4.__subscriberRef.current;
          try {
            var s3;
            try {
              o3 !== null && o3.onWorkStarted(r3, n3);
            } finally {
              try {
                s3 = t3.apply(void 0, arguments);
              } finally {
                e4.__interactionsRef.current = i4, o3 !== null && o3.onWorkStopped(r3, n3);
              }
            }
            return s3;
          } finally {
            a3 || (a3 = true, r3.forEach(function(e5) {
              e5.__count--, o3 !== null && e5.__count === 0 && o3.onInteractionScheduledWorkCompleted(e5);
            }));
          }
        }
        return i3.cancel = function() {
          o3 = e4.__subscriberRef.current;
          try {
            o3 !== null && o3.onWorkCanceled(r3, n3);
          } finally {
            r3.forEach(function(e5) {
              e5.__count--, o3 && e5.__count === 0 && o3.onInteractionScheduledWorkCompleted(e5);
            });
          }
        }, i3;
      };
    })();
  }(Dd), false ? Od.exports = Td : Od.exports = Dd, function() {
    var e4 = je.exports, t2 = Ne, n2 = vt.exports, r2 = Od.exports, o2 = e4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a2(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      s2("warn", e5, n3);
    }
    function i2(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      s2("error", e5, n3);
    }
    function s2(e5, t3, n3) {
      var r3 = o2.ReactDebugCurrentFrame.getStackAddendum();
      r3 !== "" && (t3 += "%s", n3 = n3.concat([r3]));
      var a3 = n3.map(function(e6) {
        return "" + e6;
      });
      a3.unshift("Warning: " + t3), Function.prototype.apply.call(console[e5], console, a3);
    }
    if (!e4)
      throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
    var l2 = 10, u2 = 11, c2 = 12, d = 13, f = 14, p = 15, h2 = 17, m2 = 19, v2 = 20, g2 = 22, y2 = 23, b2 = 24, w2 = false, k2 = /* @__PURE__ */ new Set(), x2 = {}, S2 = {};
    function _2(e5, t3) {
      E2(e5, t3), E2(e5 + "Capture", t3);
    }
    function E2(e5, t3) {
      x2[e5] && i2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e5), x2[e5] = t3;
      var n3 = e5.toLowerCase();
      S2[n3] = e5, e5 === "onDoubleClick" && (S2.ondblclick = e5);
      for (var r3 = 0; r3 < t3.length; r3++)
        k2.add(t3[r3]);
    }
    var P2 = !(typeof window == "undefined" || window.document === void 0 || window.document.createElement === void 0), C2 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", j2 = C2 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", O2 = "data-reactroot", T2 = new RegExp("^[" + C2 + "][" + j2 + "]*$"), I2 = Object.prototype.hasOwnProperty, D2 = {}, R2 = {};
    function N2(e5) {
      return !!I2.call(R2, e5) || !I2.call(D2, e5) && (T2.test(e5) ? (R2[e5] = true, true) : (D2[e5] = true, i2("Invalid attribute name: `%s`", e5), false));
    }
    function A2(e5, t3, n3) {
      return t3 !== null ? t3.type === 0 : !n3 && (e5.length > 2 && (e5[0] === "o" || e5[0] === "O") && (e5[1] === "n" || e5[1] === "N"));
    }
    function z2(e5, t3, n3, r3) {
      if (n3 !== null && n3.type === 0)
        return false;
      switch (typeof t3) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (r3)
            return false;
          if (n3 !== null)
            return !n3.acceptsBooleans;
          var o3 = e5.toLowerCase().slice(0, 5);
          return o3 !== "data-" && o3 !== "aria-";
        default:
          return false;
      }
    }
    function M2(e5, t3, n3, r3) {
      if (t3 == null)
        return true;
      if (z2(e5, t3, n3, r3))
        return true;
      if (r3)
        return false;
      if (n3 !== null)
        switch (n3.type) {
          case 3:
            return !t3;
          case 4:
            return t3 === false;
          case 5:
            return isNaN(t3);
          case 6:
            return isNaN(t3) || t3 < 1;
        }
      return false;
    }
    function L2(e5) {
      return $2.hasOwnProperty(e5) ? $2[e5] : null;
    }
    function F2(e5, t3, n3, r3, o3, a3, i3) {
      this.acceptsBooleans = t3 === 2 || t3 === 3 || t3 === 4, this.attributeName = r3, this.attributeNamespace = o3, this.mustUseProperty = n3, this.propertyName = e5, this.type = t3, this.sanitizeURL = a3, this.removeEmptyString = i3;
    }
    var $2 = {};
    ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"].forEach(function(e5) {
      $2[e5] = new F2(e5, 0, false, e5, null, false, false);
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e5) {
      var t3 = e5[0], n3 = e5[1];
      $2[t3] = new F2(t3, 1, false, n3, null, false, false);
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e5) {
      $2[e5] = new F2(e5, 2, false, e5.toLowerCase(), null, false, false);
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e5) {
      $2[e5] = new F2(e5, 2, false, e5, null, false, false);
    }), ["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(function(e5) {
      $2[e5] = new F2(e5, 3, false, e5.toLowerCase(), null, false, false);
    }), ["checked", "multiple", "muted", "selected"].forEach(function(e5) {
      $2[e5] = new F2(e5, 3, true, e5, null, false, false);
    }), ["capture", "download"].forEach(function(e5) {
      $2[e5] = new F2(e5, 4, false, e5, null, false, false);
    }), ["cols", "rows", "size", "span"].forEach(function(e5) {
      $2[e5] = new F2(e5, 6, false, e5, null, false, false);
    }), ["rowSpan", "start"].forEach(function(e5) {
      $2[e5] = new F2(e5, 5, false, e5.toLowerCase(), null, false, false);
    });
    var B2 = /[\-\:]([a-z])/g, V2 = function(e5) {
      return e5[1].toUpperCase();
    };
    ["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(function(e5) {
      var t3 = e5.replace(B2, V2);
      $2[t3] = new F2(t3, 1, false, e5, null, false, false);
    }), ["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(function(e5) {
      var t3 = e5.replace(B2, V2);
      $2[t3] = new F2(t3, 1, false, e5, "http://www.w3.org/1999/xlink", false, false);
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function(e5) {
      var t3 = e5.replace(B2, V2);
      $2[t3] = new F2(t3, 1, false, e5, "http://www.w3.org/XML/1998/namespace", false, false);
    }), ["tabIndex", "crossOrigin"].forEach(function(e5) {
      $2[e5] = new F2(e5, 1, false, e5.toLowerCase(), null, false, false);
    });
    $2.xlinkHref = new F2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false), ["src", "href", "action", "formAction"].forEach(function(e5) {
      $2[e5] = new F2(e5, 1, false, e5.toLowerCase(), null, true, true);
    });
    var U2 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, H2 = false;
    function W2(e5) {
      !H2 && U2.test(e5) && (H2 = true, i2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e5)));
    }
    function q2(e5, t3, n3, r3) {
      if (r3.mustUseProperty)
        return e5[r3.propertyName];
      r3.sanitizeURL && W2("" + n3);
      var o3 = r3.attributeName, a3 = null;
      if (r3.type === 4) {
        if (e5.hasAttribute(o3)) {
          var i3 = e5.getAttribute(o3);
          return i3 === "" || (M2(t3, n3, r3, false) ? i3 : i3 === "" + n3 ? n3 : i3);
        }
      } else if (e5.hasAttribute(o3)) {
        if (M2(t3, n3, r3, false))
          return e5.getAttribute(o3);
        if (r3.type === 3)
          return n3;
        a3 = e5.getAttribute(o3);
      }
      return M2(t3, n3, r3, false) ? a3 === null ? n3 : a3 : a3 === "" + n3 ? n3 : a3;
    }
    function K2(e5, t3, n3) {
      if (N2(t3)) {
        if (function(e6) {
          return e6 !== null && typeof e6 == "object" && e6.$$typeof === le2;
        }(n3))
          return n3;
        if (!e5.hasAttribute(t3))
          return n3 === void 0 ? void 0 : null;
        var r3 = e5.getAttribute(t3);
        return r3 === "" + n3 ? n3 : r3;
      }
    }
    function Y2(e5, t3, n3, r3) {
      var o3 = L2(t3);
      if (!A2(t3, o3, r3))
        if (M2(t3, n3, o3, r3) && (n3 = null), r3 || o3 === null) {
          if (N2(t3)) {
            var a3 = t3;
            n3 === null ? e5.removeAttribute(a3) : e5.setAttribute(a3, "" + n3);
          }
        } else if (o3.mustUseProperty) {
          var i3 = o3.propertyName;
          if (n3 === null) {
            var s3 = o3.type;
            e5[i3] = s3 !== 3 && "";
          } else
            e5[i3] = n3;
        } else {
          var l3 = o3.attributeName, u3 = o3.attributeNamespace;
          if (n3 === null)
            e5.removeAttribute(l3);
          else {
            var c3, d2 = o3.type;
            d2 === 3 || d2 === 4 && n3 === true ? c3 = "" : (c3 = "" + n3, o3.sanitizeURL && W2(c3.toString())), u3 ? e5.setAttributeNS(u3, l3, c3) : e5.setAttribute(l3, c3);
          }
        }
    }
    var X2 = 60103, G2 = 60106, Q2 = 60107, J2 = 60108, Z2 = 60114, ee2 = 60109, te2 = 60110, ne2 = 60112, re2 = 60113, oe2 = 60120, ae2 = 60115, ie2 = 60116, se2 = 60121, le2 = 60128, ue2 = 60129, ce2 = 60130, de2 = 60131;
    if (typeof Symbol == "function" && Symbol.for) {
      var fe2 = Symbol.for;
      X2 = fe2("react.element"), G2 = fe2("react.portal"), Q2 = fe2("react.fragment"), J2 = fe2("react.strict_mode"), Z2 = fe2("react.profiler"), ee2 = fe2("react.provider"), te2 = fe2("react.context"), ne2 = fe2("react.forward_ref"), re2 = fe2("react.suspense"), oe2 = fe2("react.suspense_list"), ae2 = fe2("react.memo"), ie2 = fe2("react.lazy"), se2 = fe2("react.block"), fe2("react.server.block"), fe2("react.fundamental"), fe2("react.scope"), le2 = fe2("react.opaque.id"), ue2 = fe2("react.debug_trace_mode"), ce2 = fe2("react.offscreen"), de2 = fe2("react.legacy_hidden");
    }
    var pe2 = typeof Symbol == "function" && Symbol.iterator;
    function he2(e5) {
      if (e5 === null || typeof e5 != "object")
        return null;
      var t3 = pe2 && e5[pe2] || e5["@@iterator"];
      return typeof t3 == "function" ? t3 : null;
    }
    var me2, ve2, ge2, ye2, be2, we2, ke2, xe2 = 0;
    function Se2() {
    }
    function _e2() {
      if (xe2 === 0) {
        me2 = console.log, ve2 = console.info, ge2 = console.warn, ye2 = console.error, be2 = console.group, we2 = console.groupCollapsed, ke2 = console.groupEnd;
        var e5 = { configurable: true, enumerable: true, value: Se2, writable: true };
        Object.defineProperties(console, { info: e5, log: e5, warn: e5, error: e5, group: e5, groupCollapsed: e5, groupEnd: e5 });
      }
      xe2++;
    }
    function Ee2() {
      if (--xe2 === 0) {
        var e5 = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, { log: t2({}, e5, { value: me2 }), info: t2({}, e5, { value: ve2 }), warn: t2({}, e5, { value: ge2 }), error: t2({}, e5, { value: ye2 }), group: t2({}, e5, { value: be2 }), groupCollapsed: t2({}, e5, { value: we2 }), groupEnd: t2({}, e5, { value: ke2 }) });
      }
      xe2 < 0 && i2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    Se2.__reactDisabledLog = true;
    var Pe2, Ce2 = o2.ReactCurrentDispatcher;
    function Oe2(e5, t3, n3) {
      if (Pe2 === void 0)
        try {
          throw Error();
        } catch (e6) {
          var r3 = e6.stack.trim().match(/\n( *(at )?)/);
          Pe2 = r3 && r3[1] || "";
        }
      return "\n" + Pe2 + e5;
    }
    var Te2, Ie2 = false, De2 = typeof WeakMap == "function" ? WeakMap : Map;
    function Re2(e5, t3) {
      if (!e5 || Ie2)
        return "";
      var n3, r3 = Te2.get(e5);
      if (r3 !== void 0)
        return r3;
      Ie2 = true;
      var o3, a3 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0, o3 = Ce2.current, Ce2.current = null, _e2();
      try {
        if (t3) {
          var i3 = function() {
            throw Error();
          };
          if (Object.defineProperty(i3.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(i3, []);
            } catch (e6) {
              n3 = e6;
            }
            Reflect.construct(e5, [], i3);
          } else {
            try {
              i3.call();
            } catch (e6) {
              n3 = e6;
            }
            e5.call(i3.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (e6) {
            n3 = e6;
          }
          e5();
        }
      } catch (t4) {
        if (t4 && n3 && typeof t4.stack == "string") {
          for (var s3 = t4.stack.split("\n"), l3 = n3.stack.split("\n"), u3 = s3.length - 1, c3 = l3.length - 1; u3 >= 1 && c3 >= 0 && s3[u3] !== l3[c3]; )
            c3--;
          for (; u3 >= 1 && c3 >= 0; u3--, c3--)
            if (s3[u3] !== l3[c3]) {
              if (u3 !== 1 || c3 !== 1)
                do {
                  if (u3--, --c3 < 0 || s3[u3] !== l3[c3]) {
                    var d2 = "\n" + s3[u3].replace(" at new ", " at ");
                    return typeof e5 == "function" && Te2.set(e5, d2), d2;
                  }
                } while (u3 >= 1 && c3 >= 0);
              break;
            }
        }
      } finally {
        Ie2 = false, Ce2.current = o3, Ee2(), Error.prepareStackTrace = a3;
      }
      var f2 = e5 ? e5.displayName || e5.name : "", p2 = f2 ? Oe2(f2) : "";
      return typeof e5 == "function" && Te2.set(e5, p2), p2;
    }
    function Ae2(e5, t3, n3) {
      return Re2(e5, false);
    }
    function ze2(e5, t3, n3) {
      if (e5 == null)
        return "";
      if (typeof e5 == "function")
        return Re2(e5, !(!(r3 = e5.prototype) || !r3.isReactComponent));
      var r3;
      if (typeof e5 == "string")
        return Oe2(e5);
      switch (e5) {
        case re2:
          return Oe2("Suspense");
        case oe2:
          return Oe2("SuspenseList");
      }
      if (typeof e5 == "object")
        switch (e5.$$typeof) {
          case ne2:
            return Ae2(e5.render);
          case ae2:
            return ze2(e5.type, t3, n3);
          case se2:
            return Ae2(e5._render);
          case ie2:
            var o3 = e5, a3 = o3._payload, i3 = o3._init;
            try {
              return ze2(i3(a3), t3, n3);
            } catch (e6) {
            }
        }
      return "";
    }
    function Me2(e5) {
      switch (e5._debugOwner && e5._debugOwner.type, e5._debugSource, e5.tag) {
        case 5:
          return Oe2(e5.type);
        case 16:
          return Oe2("Lazy");
        case d:
          return Oe2("Suspense");
        case m2:
          return Oe2("SuspenseList");
        case 0:
        case 2:
        case p:
          return Ae2(e5.type);
        case u2:
          return Ae2(e5.type.render);
        case g2:
          return Ae2(e5.type._render);
        case 1:
          return Re2(e5.type, true);
        default:
          return "";
      }
    }
    function Le2(e5) {
      try {
        var t3 = "", n3 = e5;
        do {
          t3 += Me2(n3), n3 = n3.return;
        } while (n3);
        return t3;
      } catch (e6) {
        return "\nError generating stack: " + e6.message + "\n" + e6.stack;
      }
    }
    function Fe2(e5) {
      return e5.displayName || "Context";
    }
    function $e2(e5) {
      if (e5 == null)
        return null;
      if (typeof e5.tag == "number" && i2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof e5 == "function")
        return e5.displayName || e5.name || null;
      if (typeof e5 == "string")
        return e5;
      switch (e5) {
        case Q2:
          return "Fragment";
        case G2:
          return "Portal";
        case Z2:
          return "Profiler";
        case J2:
          return "StrictMode";
        case re2:
          return "Suspense";
        case oe2:
          return "SuspenseList";
      }
      if (typeof e5 == "object")
        switch (e5.$$typeof) {
          case te2:
            return Fe2(e5) + ".Consumer";
          case ee2:
            return Fe2(e5._context) + ".Provider";
          case ne2:
            return o3 = e5, a3 = e5.render, s3 = "ForwardRef", l3 = a3.displayName || a3.name || "", o3.displayName || (l3 !== "" ? s3 + "(" + l3 + ")" : s3);
          case ae2:
            return $e2(e5.type);
          case se2:
            return $e2(e5._render);
          case ie2:
            var t3 = e5, n3 = t3._payload, r3 = t3._init;
            try {
              return $e2(r3(n3));
            } catch (e6) {
              return null;
            }
        }
      var o3, a3, s3, l3;
      return null;
    }
    Te2 = new De2();
    var Be2 = o2.ReactDebugCurrentFrame, Ve2 = null, Ue = false;
    function He2() {
      if (Ve2 === null)
        return null;
      var e5 = Ve2._debugOwner;
      return e5 != null ? $e2(e5.type) : null;
    }
    function We2() {
      return Ve2 === null ? "" : Le2(Ve2);
    }
    function qe2() {
      Be2.getCurrentStack = null, Ve2 = null, Ue = false;
    }
    function Ke2(e5) {
      Be2.getCurrentStack = We2, Ve2 = e5, Ue = false;
    }
    function Ye2(e5) {
      Ue = e5;
    }
    function Xe2(e5) {
      return "" + e5;
    }
    function Ge2(e5) {
      switch (typeof e5) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return e5;
        default:
          return "";
      }
    }
    var Qe2 = { button: true, checkbox: true, image: true, hidden: true, radio: true, reset: true, submit: true };
    function Je2(e5, t3) {
      Qe2[t3.type] || t3.onChange || t3.onInput || t3.readOnly || t3.disabled || t3.value == null || i2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), t3.onChange || t3.readOnly || t3.disabled || t3.checked == null || i2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ze2(e5) {
      var t3 = e5.type, n3 = e5.nodeName;
      return n3 && n3.toLowerCase() === "input" && (t3 === "checkbox" || t3 === "radio");
    }
    function et2(e5) {
      return e5._valueTracker;
    }
    function tt2(e5) {
      et2(e5) || (e5._valueTracker = function(e6) {
        var t3 = Ze2(e6) ? "checked" : "value", n3 = Object.getOwnPropertyDescriptor(e6.constructor.prototype, t3), r3 = "" + e6[t3];
        if (!e6.hasOwnProperty(t3) && n3 !== void 0 && typeof n3.get == "function" && typeof n3.set == "function") {
          var o3 = n3.get, a3 = n3.set;
          Object.defineProperty(e6, t3, { configurable: true, get: function() {
            return o3.call(this);
          }, set: function(e7) {
            r3 = "" + e7, a3.call(this, e7);
          } }), Object.defineProperty(e6, t3, { enumerable: n3.enumerable });
          var i3 = { getValue: function() {
            return r3;
          }, setValue: function(e7) {
            r3 = "" + e7;
          }, stopTracking: function() {
            !function(e7) {
              e7._valueTracker = null;
            }(e6), delete e6[t3];
          } };
          return i3;
        }
      }(e5));
    }
    function nt2(e5) {
      if (!e5)
        return false;
      var t3 = et2(e5);
      if (!t3)
        return true;
      var n3 = t3.getValue(), r3 = function(e6) {
        var t4 = "";
        return e6 ? t4 = Ze2(e6) ? e6.checked ? "true" : "false" : e6.value : t4;
      }(e5);
      return r3 !== n3 && (t3.setValue(r3), true);
    }
    function rt2(e5) {
      if ((e5 = e5 || (typeof document != "undefined" ? document : void 0)) === void 0)
        return null;
      try {
        return e5.activeElement || e5.body;
      } catch (t3) {
        return e5.body;
      }
    }
    var ot2 = false, at2 = false, it2 = false, st2 = false;
    function lt2(e5) {
      return e5.type === "checkbox" || e5.type === "radio" ? e5.checked != null : e5.value != null;
    }
    function ut2(e5, n3) {
      var r3 = e5, o3 = n3.checked;
      return t2({}, n3, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: o3 != null ? o3 : r3._wrapperState.initialChecked });
    }
    function ct2(e5, t3) {
      Je2(0, t3), t3.checked === void 0 || t3.defaultChecked === void 0 || at2 || (i2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", He2() || "A component", t3.type), at2 = true), t3.value === void 0 || t3.defaultValue === void 0 || ot2 || (i2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", He2() || "A component", t3.type), ot2 = true);
      var n3 = e5, r3 = t3.defaultValue == null ? "" : t3.defaultValue;
      n3._wrapperState = { initialChecked: t3.checked != null ? t3.checked : t3.defaultChecked, initialValue: Ge2(t3.value != null ? t3.value : r3), controlled: lt2(t3) };
    }
    function dt2(e5, t3) {
      var n3 = e5, r3 = t3.checked;
      r3 != null && Y2(n3, "checked", r3, false);
    }
    function ft2(e5, t3) {
      var n3 = e5, r3 = lt2(t3);
      n3._wrapperState.controlled || !r3 || st2 || (i2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), st2 = true), !n3._wrapperState.controlled || r3 || it2 || (i2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), it2 = true), dt2(e5, t3);
      var o3 = Ge2(t3.value), a3 = t3.type;
      if (o3 != null)
        a3 === "number" ? (o3 === 0 && n3.value === "" || n3.value != o3) && (n3.value = Xe2(o3)) : n3.value !== Xe2(o3) && (n3.value = Xe2(o3));
      else if (a3 === "submit" || a3 === "reset")
        return void n3.removeAttribute("value");
      t3.hasOwnProperty("value") ? mt2(n3, t3.type, o3) : t3.hasOwnProperty("defaultValue") && mt2(n3, t3.type, Ge2(t3.defaultValue)), t3.checked == null && t3.defaultChecked != null && (n3.defaultChecked = !!t3.defaultChecked);
    }
    function pt2(e5, t3, n3) {
      var r3 = e5;
      if (t3.hasOwnProperty("value") || t3.hasOwnProperty("defaultValue")) {
        var o3 = t3.type;
        if ((o3 === "submit" || o3 === "reset") && (t3.value === void 0 || t3.value === null))
          return;
        var a3 = Xe2(r3._wrapperState.initialValue);
        n3 || a3 !== r3.value && (r3.value = a3), r3.defaultValue = a3;
      }
      var i3 = r3.name;
      i3 !== "" && (r3.name = ""), r3.defaultChecked = !r3.defaultChecked, r3.defaultChecked = !!r3._wrapperState.initialChecked, i3 !== "" && (r3.name = i3);
    }
    function ht2(e5, t3) {
      var n3 = e5;
      ft2(n3, t3), function(e6, t4) {
        var n4 = t4.name;
        if (t4.type === "radio" && n4 != null) {
          for (var r3 = e6; r3.parentNode; )
            r3 = r3.parentNode;
          for (var o3 = r3.querySelectorAll("input[name=" + JSON.stringify("" + n4) + '][type="radio"]'), a3 = 0; a3 < o3.length; a3++) {
            var i3 = o3[a3];
            if (i3 !== e6 && i3.form === e6.form) {
              var s3 = gl2(i3);
              if (!s3)
                throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              nt2(i3), ft2(i3, s3);
            }
          }
        }
      }(n3, t3);
    }
    function mt2(e5, t3, n3) {
      t3 === "number" && rt2(e5.ownerDocument) === e5 || (n3 == null ? e5.defaultValue = Xe2(e5._wrapperState.initialValue) : e5.defaultValue !== Xe2(n3) && (e5.defaultValue = Xe2(n3)));
    }
    var gt2, yt2 = false, bt2 = false;
    function wt2(t3, n3) {
      typeof n3.children == "object" && n3.children !== null && e4.Children.forEach(n3.children, function(e5) {
        e5 != null && typeof e5 != "string" && typeof e5 != "number" && typeof e5.type == "string" && (bt2 || (bt2 = true, i2("Only strings and numbers are supported as <option> children.")));
      }), n3.selected == null || yt2 || (i2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), yt2 = true);
    }
    function kt2(n3, r3) {
      var o3 = t2({ children: void 0 }, r3), a3 = function(t3) {
        var n4 = "";
        return e4.Children.forEach(t3, function(e5) {
          e5 != null && (n4 += e5);
        }), n4;
      }(r3.children);
      return a3 && (o3.children = a3), o3;
    }
    function xt2() {
      var e5 = He2();
      return e5 ? "\n\nCheck the render method of `" + e5 + "`." : "";
    }
    gt2 = false;
    var St2 = ["value", "defaultValue"];
    function _t2(e5, t3, n3, r3) {
      var o3 = e5.options;
      if (t3) {
        for (var a3 = n3, i3 = {}, s3 = 0; s3 < a3.length; s3++)
          i3["$" + a3[s3]] = true;
        for (var l3 = 0; l3 < o3.length; l3++) {
          var u3 = i3.hasOwnProperty("$" + o3[l3].value);
          o3[l3].selected !== u3 && (o3[l3].selected = u3), u3 && r3 && (o3[l3].defaultSelected = true);
        }
      } else {
        for (var c3 = Xe2(Ge2(n3)), d2 = null, f2 = 0; f2 < o3.length; f2++) {
          if (o3[f2].value === c3)
            return o3[f2].selected = true, void (r3 && (o3[f2].defaultSelected = true));
          d2 !== null || o3[f2].disabled || (d2 = o3[f2]);
        }
        d2 !== null && (d2.selected = true);
      }
    }
    function Et2(e5, n3) {
      return t2({}, n3, { value: void 0 });
    }
    function Pt2(e5, t3) {
      var n3 = e5;
      !function(e6) {
        Je2(0, e6);
        for (var t4 = 0; t4 < St2.length; t4++) {
          var n4 = St2[t4];
          if (e6[n4] != null) {
            var r3 = Array.isArray(e6[n4]);
            e6.multiple && !r3 ? i2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", n4, xt2()) : !e6.multiple && r3 && i2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", n4, xt2());
          }
        }
      }(t3), n3._wrapperState = { wasMultiple: !!t3.multiple }, t3.value === void 0 || t3.defaultValue === void 0 || gt2 || (i2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), gt2 = true);
    }
    var Ct2 = false;
    function jt2(e5, n3) {
      var r3 = e5;
      if (n3.dangerouslySetInnerHTML != null)
        throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      return t2({}, n3, { value: void 0, defaultValue: void 0, children: Xe2(r3._wrapperState.initialValue) });
    }
    function Ot2(e5, t3) {
      var n3 = e5;
      Je2(0, t3), t3.value === void 0 || t3.defaultValue === void 0 || Ct2 || (i2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", He2() || "A component"), Ct2 = true);
      var r3 = t3.value;
      if (r3 == null) {
        var o3 = t3.children, a3 = t3.defaultValue;
        if (o3 != null) {
          if (i2("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), a3 != null)
            throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (Array.isArray(o3)) {
            if (!(o3.length <= 1))
              throw Error("<textarea> can only have at most one child.");
            o3 = o3[0];
          }
          a3 = o3;
        }
        a3 == null && (a3 = ""), r3 = a3;
      }
      n3._wrapperState = { initialValue: Ge2(r3) };
    }
    function Tt2(e5, t3) {
      var n3 = e5, r3 = Ge2(t3.value), o3 = Ge2(t3.defaultValue);
      if (r3 != null) {
        var a3 = Xe2(r3);
        a3 !== n3.value && (n3.value = a3), t3.defaultValue == null && n3.defaultValue !== a3 && (n3.defaultValue = a3);
      }
      o3 != null && (n3.defaultValue = Xe2(o3));
    }
    function It2(e5, t3) {
      var n3 = e5, r3 = n3.textContent;
      r3 === n3._wrapperState.initialValue && r3 !== "" && r3 !== null && (n3.value = r3);
    }
    var Dt2 = "http://www.w3.org/1999/xhtml", Rt2 = "http://www.w3.org/1998/Math/MathML", Nt2 = "http://www.w3.org/2000/svg", At2 = Dt2, zt2 = Nt2;
    function Mt2(e5) {
      switch (e5) {
        case "svg":
          return Nt2;
        case "math":
          return Rt2;
        default:
          return Dt2;
      }
    }
    function Lt2(e5, t3) {
      return e5 == null || e5 === Dt2 ? Mt2(t3) : e5 === Nt2 && t3 === "foreignObject" ? Dt2 : e5;
    }
    var Ft2, $t2 = function(e5) {
      return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function(t3, n3, r3, o3) {
        MSApp.execUnsafeLocalFunction(function() {
          return e5(t3, n3, r3, o3);
        });
      } : e5;
    }(function(e5, t3) {
      if (e5.namespaceURI !== zt2 || "innerHTML" in e5)
        e5.innerHTML = t3;
      else {
        (Ft2 = Ft2 || document.createElement("div")).innerHTML = "<svg>" + t3.valueOf().toString() + "</svg>";
        for (var n3 = Ft2.firstChild; e5.firstChild; )
          e5.removeChild(e5.firstChild);
        for (; n3.firstChild; )
          e5.appendChild(n3.firstChild);
      }
    }), Bt2 = 8, Vt2 = function(e5, t3) {
      if (t3) {
        var n3 = e5.firstChild;
        if (n3 && n3 === e5.lastChild && n3.nodeType === 3)
          return void (n3.nodeValue = t3);
      }
      e5.textContent = t3;
    }, Ut2 = { animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"], background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"], backgroundPosition: ["backgroundPositionX", "backgroundPositionY"], border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"], borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"], borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"], borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"], borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"], borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"], borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"], borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"], borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"], borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"], borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"], borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"], borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"], borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"], columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"], columns: ["columnCount", "columnWidth"], flex: ["flexBasis", "flexGrow", "flexShrink"], flexFlow: ["flexDirection", "flexWrap"], font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"], fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"], gap: ["columnGap", "rowGap"], grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"], gridColumn: ["gridColumnEnd", "gridColumnStart"], gridColumnGap: ["columnGap"], gridGap: ["columnGap", "rowGap"], gridRow: ["gridRowEnd", "gridRowStart"], gridRowGap: ["rowGap"], gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], listStyle: ["listStyleImage", "listStylePosition", "listStyleType"], margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"], marker: ["markerEnd", "markerMid", "markerStart"], mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"], maskPosition: ["maskPositionX", "maskPositionY"], outline: ["outlineColor", "outlineStyle", "outlineWidth"], overflow: ["overflowX", "overflowY"], padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"], placeContent: ["alignContent", "justifyContent"], placeItems: ["alignItems", "justifyItems"], placeSelf: ["alignSelf", "justifySelf"], textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"], textEmphasis: ["textEmphasisColor", "textEmphasisStyle"], transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"], wordWrap: ["overflowWrap"] }, Ht2 = { animationIterationCount: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridArea: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true };
    var Wt2 = ["Webkit", "ms", "Moz", "O"];
    function qt2(e5, t3, n3) {
      return t3 == null || typeof t3 == "boolean" || t3 === "" ? "" : n3 || typeof t3 != "number" || t3 === 0 || Ht2.hasOwnProperty(e5) && Ht2[e5] ? ("" + t3).trim() : t3 + "px";
    }
    Object.keys(Ht2).forEach(function(e5) {
      Wt2.forEach(function(t3) {
        Ht2[function(e6, t4) {
          return e6 + t4.charAt(0).toUpperCase() + t4.substring(1);
        }(t3, e5)] = Ht2[e5];
      });
    });
    var Kt2 = /([A-Z])/g, Yt2 = /^ms-/;
    var Xt2 = /^(?:webkit|moz|o)[A-Z]/, Gt2 = /^-ms-/, Qt2 = /-(.)/g, Jt2 = /;\s*$/, Zt2 = {}, en2 = {}, tn = false, nn2 = false, rn2 = function(e5) {
      Zt2.hasOwnProperty(e5) && Zt2[e5] || (Zt2[e5] = true, i2("Unsupported style property %s. Did you mean %s?", e5, e5.replace(Gt2, "ms-").replace(Qt2, function(e6, t3) {
        return t3.toUpperCase();
      })));
    }, on2 = function(e5, t3) {
      e5.indexOf("-") > -1 ? rn2(e5) : Xt2.test(e5) ? function(e6) {
        Zt2.hasOwnProperty(e6) && Zt2[e6] || (Zt2[e6] = true, i2("Unsupported vendor-prefixed style property %s. Did you mean %s?", e6, e6.charAt(0).toUpperCase() + e6.slice(1)));
      }(e5) : Jt2.test(t3) && function(e6, t4) {
        en2.hasOwnProperty(t4) && en2[t4] || (en2[t4] = true, i2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e6, t4.replace(Jt2, "")));
      }(e5, t3), typeof t3 == "number" && (isNaN(t3) ? function(e6, t4) {
        tn || (tn = true, i2("`NaN` is an invalid value for the `%s` css style property.", e6));
      }(e5) : isFinite(t3) || function(e6, t4) {
        nn2 || (nn2 = true, i2("`Infinity` is an invalid value for the `%s` css style property.", e6));
      }(e5));
    };
    function an2(e5) {
      var t3 = "", n3 = "";
      for (var r3 in e5)
        if (e5.hasOwnProperty(r3)) {
          var o3 = e5[r3];
          if (o3 != null) {
            var a3 = r3.indexOf("--") === 0;
            t3 += n3 + (a3 ? r3 : r3.replace(Kt2, "-$1").toLowerCase().replace(Yt2, "-ms-")) + ":", t3 += qt2(r3, o3, a3), n3 = ";";
          }
        }
      return t3 || null;
    }
    function sn2(e5, t3) {
      var n3 = e5.style;
      for (var r3 in t3)
        if (t3.hasOwnProperty(r3)) {
          var o3 = r3.indexOf("--") === 0;
          o3 || on2(r3, t3[r3]);
          var a3 = qt2(r3, t3[r3], o3);
          r3 === "float" && (r3 = "cssFloat"), o3 ? n3.setProperty(r3, a3) : n3[r3] = a3;
        }
    }
    function ln2(e5) {
      var t3 = {};
      for (var n3 in e5)
        for (var r3 = Ut2[n3] || [n3], o3 = 0; o3 < r3.length; o3++)
          t3[r3[o3]] = n3;
      return t3;
    }
    var un2 = t2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function cn2(e5, t3) {
      if (t3) {
        if (un2[e5] && (t3.children != null || t3.dangerouslySetInnerHTML != null))
          throw Error(e5 + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (t3.dangerouslySetInnerHTML != null) {
          if (t3.children != null)
            throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof t3.dangerouslySetInnerHTML != "object" || !("__html" in t3.dangerouslySetInnerHTML))
            throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!t3.suppressContentEditableWarning && t3.contentEditable && t3.children != null && i2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), t3.style != null && typeof t3.style != "object")
          throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function dn2(e5, t3) {
      if (e5.indexOf("-") === -1)
        return typeof t3.is == "string";
      switch (e5) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var fn2 = { accept: "accept", acceptcharset: "acceptCharset", "accept-charset": "acceptCharset", accesskey: "accessKey", action: "action", allowfullscreen: "allowFullScreen", alt: "alt", as: "as", async: "async", autocapitalize: "autoCapitalize", autocomplete: "autoComplete", autocorrect: "autoCorrect", autofocus: "autoFocus", autoplay: "autoPlay", autosave: "autoSave", capture: "capture", cellpadding: "cellPadding", cellspacing: "cellSpacing", challenge: "challenge", charset: "charSet", checked: "checked", children: "children", cite: "cite", class: "className", classid: "classID", classname: "className", cols: "cols", colspan: "colSpan", content: "content", contenteditable: "contentEditable", contextmenu: "contextMenu", controls: "controls", controlslist: "controlsList", coords: "coords", crossorigin: "crossOrigin", dangerouslysetinnerhtml: "dangerouslySetInnerHTML", data: "data", datetime: "dateTime", default: "default", defaultchecked: "defaultChecked", defaultvalue: "defaultValue", defer: "defer", dir: "dir", disabled: "disabled", disablepictureinpicture: "disablePictureInPicture", disableremoteplayback: "disableRemotePlayback", download: "download", draggable: "draggable", enctype: "encType", enterkeyhint: "enterKeyHint", for: "htmlFor", form: "form", formmethod: "formMethod", formaction: "formAction", formenctype: "formEncType", formnovalidate: "formNoValidate", formtarget: "formTarget", frameborder: "frameBorder", headers: "headers", height: "height", hidden: "hidden", high: "high", href: "href", hreflang: "hrefLang", htmlfor: "htmlFor", httpequiv: "httpEquiv", "http-equiv": "httpEquiv", icon: "icon", id: "id", innerhtml: "innerHTML", inputmode: "inputMode", integrity: "integrity", is: "is", itemid: "itemID", itemprop: "itemProp", itemref: "itemRef", itemscope: "itemScope", itemtype: "itemType", keyparams: "keyParams", keytype: "keyType", kind: "kind", label: "label", lang: "lang", list: "list", loop: "loop", low: "low", manifest: "manifest", marginwidth: "marginWidth", marginheight: "marginHeight", max: "max", maxlength: "maxLength", media: "media", mediagroup: "mediaGroup", method: "method", min: "min", minlength: "minLength", multiple: "multiple", muted: "muted", name: "name", nomodule: "noModule", nonce: "nonce", novalidate: "noValidate", open: "open", optimum: "optimum", pattern: "pattern", placeholder: "placeholder", playsinline: "playsInline", poster: "poster", preload: "preload", profile: "profile", radiogroup: "radioGroup", readonly: "readOnly", referrerpolicy: "referrerPolicy", rel: "rel", required: "required", reversed: "reversed", role: "role", rows: "rows", rowspan: "rowSpan", sandbox: "sandbox", scope: "scope", scoped: "scoped", scrolling: "scrolling", seamless: "seamless", selected: "selected", shape: "shape", size: "size", sizes: "sizes", span: "span", spellcheck: "spellCheck", src: "src", srcdoc: "srcDoc", srclang: "srcLang", srcset: "srcSet", start: "start", step: "step", style: "style", summary: "summary", tabindex: "tabIndex", target: "target", title: "title", type: "type", usemap: "useMap", value: "value", width: "width", wmode: "wmode", wrap: "wrap", about: "about", accentheight: "accentHeight", "accent-height": "accentHeight", accumulate: "accumulate", additive: "additive", alignmentbaseline: "alignmentBaseline", "alignment-baseline": "alignmentBaseline", allowreorder: "allowReorder", alphabetic: "alphabetic", amplitude: "amplitude", arabicform: "arabicForm", "arabic-form": "arabicForm", ascent: "ascent", attributename: "attributeName", attributetype: "attributeType", autoreverse: "autoReverse", azimuth: "azimuth", basefrequency: "baseFrequency", baselineshift: "baselineShift", "baseline-shift": "baselineShift", baseprofile: "baseProfile", bbox: "bbox", begin: "begin", bias: "bias", by: "by", calcmode: "calcMode", capheight: "capHeight", "cap-height": "capHeight", clip: "clip", clippath: "clipPath", "clip-path": "clipPath", clippathunits: "clipPathUnits", cliprule: "clipRule", "clip-rule": "clipRule", color: "color", colorinterpolation: "colorInterpolation", "color-interpolation": "colorInterpolation", colorinterpolationfilters: "colorInterpolationFilters", "color-interpolation-filters": "colorInterpolationFilters", colorprofile: "colorProfile", "color-profile": "colorProfile", colorrendering: "colorRendering", "color-rendering": "colorRendering", contentscripttype: "contentScriptType", contentstyletype: "contentStyleType", cursor: "cursor", cx: "cx", cy: "cy", d: "d", datatype: "datatype", decelerate: "decelerate", descent: "descent", diffuseconstant: "diffuseConstant", direction: "direction", display: "display", divisor: "divisor", dominantbaseline: "dominantBaseline", "dominant-baseline": "dominantBaseline", dur: "dur", dx: "dx", dy: "dy", edgemode: "edgeMode", elevation: "elevation", enablebackground: "enableBackground", "enable-background": "enableBackground", end: "end", exponent: "exponent", externalresourcesrequired: "externalResourcesRequired", fill: "fill", fillopacity: "fillOpacity", "fill-opacity": "fillOpacity", fillrule: "fillRule", "fill-rule": "fillRule", filter: "filter", filterres: "filterRes", filterunits: "filterUnits", floodopacity: "floodOpacity", "flood-opacity": "floodOpacity", floodcolor: "floodColor", "flood-color": "floodColor", focusable: "focusable", fontfamily: "fontFamily", "font-family": "fontFamily", fontsize: "fontSize", "font-size": "fontSize", fontsizeadjust: "fontSizeAdjust", "font-size-adjust": "fontSizeAdjust", fontstretch: "fontStretch", "font-stretch": "fontStretch", fontstyle: "fontStyle", "font-style": "fontStyle", fontvariant: "fontVariant", "font-variant": "fontVariant", fontweight: "fontWeight", "font-weight": "fontWeight", format: "format", from: "from", fx: "fx", fy: "fy", g1: "g1", g2: "g2", glyphname: "glyphName", "glyph-name": "glyphName", glyphorientationhorizontal: "glyphOrientationHorizontal", "glyph-orientation-horizontal": "glyphOrientationHorizontal", glyphorientationvertical: "glyphOrientationVertical", "glyph-orientation-vertical": "glyphOrientationVertical", glyphref: "glyphRef", gradienttransform: "gradientTransform", gradientunits: "gradientUnits", hanging: "hanging", horizadvx: "horizAdvX", "horiz-adv-x": "horizAdvX", horizoriginx: "horizOriginX", "horiz-origin-x": "horizOriginX", ideographic: "ideographic", imagerendering: "imageRendering", "image-rendering": "imageRendering", in2: "in2", in: "in", inlist: "inlist", intercept: "intercept", k1: "k1", k2: "k2", k3: "k3", k4: "k4", k: "k", kernelmatrix: "kernelMatrix", kernelunitlength: "kernelUnitLength", kerning: "kerning", keypoints: "keyPoints", keysplines: "keySplines", keytimes: "keyTimes", lengthadjust: "lengthAdjust", letterspacing: "letterSpacing", "letter-spacing": "letterSpacing", lightingcolor: "lightingColor", "lighting-color": "lightingColor", limitingconeangle: "limitingConeAngle", local: "local", markerend: "markerEnd", "marker-end": "markerEnd", markerheight: "markerHeight", markermid: "markerMid", "marker-mid": "markerMid", markerstart: "markerStart", "marker-start": "markerStart", markerunits: "markerUnits", markerwidth: "markerWidth", mask: "mask", maskcontentunits: "maskContentUnits", maskunits: "maskUnits", mathematical: "mathematical", mode: "mode", numoctaves: "numOctaves", offset: "offset", opacity: "opacity", operator: "operator", order: "order", orient: "orient", orientation: "orientation", origin: "origin", overflow: "overflow", overlineposition: "overlinePosition", "overline-position": "overlinePosition", overlinethickness: "overlineThickness", "overline-thickness": "overlineThickness", paintorder: "paintOrder", "paint-order": "paintOrder", panose1: "panose1", "panose-1": "panose1", pathlength: "pathLength", patterncontentunits: "patternContentUnits", patterntransform: "patternTransform", patternunits: "patternUnits", pointerevents: "pointerEvents", "pointer-events": "pointerEvents", points: "points", pointsatx: "pointsAtX", pointsaty: "pointsAtY", pointsatz: "pointsAtZ", prefix: "prefix", preservealpha: "preserveAlpha", preserveaspectratio: "preserveAspectRatio", primitiveunits: "primitiveUnits", property: "property", r: "r", radius: "radius", refx: "refX", refy: "refY", renderingintent: "renderingIntent", "rendering-intent": "renderingIntent", repeatcount: "repeatCount", repeatdur: "repeatDur", requiredextensions: "requiredExtensions", requiredfeatures: "requiredFeatures", resource: "resource", restart: "restart", result: "result", results: "results", rotate: "rotate", rx: "rx", ry: "ry", scale: "scale", security: "security", seed: "seed", shaperendering: "shapeRendering", "shape-rendering": "shapeRendering", slope: "slope", spacing: "spacing", specularconstant: "specularConstant", specularexponent: "specularExponent", speed: "speed", spreadmethod: "spreadMethod", startoffset: "startOffset", stddeviation: "stdDeviation", stemh: "stemh", stemv: "stemv", stitchtiles: "stitchTiles", stopcolor: "stopColor", "stop-color": "stopColor", stopopacity: "stopOpacity", "stop-opacity": "stopOpacity", strikethroughposition: "strikethroughPosition", "strikethrough-position": "strikethroughPosition", strikethroughthickness: "strikethroughThickness", "strikethrough-thickness": "strikethroughThickness", string: "string", stroke: "stroke", strokedasharray: "strokeDasharray", "stroke-dasharray": "strokeDasharray", strokedashoffset: "strokeDashoffset", "stroke-dashoffset": "strokeDashoffset", strokelinecap: "strokeLinecap", "stroke-linecap": "strokeLinecap", strokelinejoin: "strokeLinejoin", "stroke-linejoin": "strokeLinejoin", strokemiterlimit: "strokeMiterlimit", "stroke-miterlimit": "strokeMiterlimit", strokewidth: "strokeWidth", "stroke-width": "strokeWidth", strokeopacity: "strokeOpacity", "stroke-opacity": "strokeOpacity", suppresscontenteditablewarning: "suppressContentEditableWarning", suppresshydrationwarning: "suppressHydrationWarning", surfacescale: "surfaceScale", systemlanguage: "systemLanguage", tablevalues: "tableValues", targetx: "targetX", targety: "targetY", textanchor: "textAnchor", "text-anchor": "textAnchor", textdecoration: "textDecoration", "text-decoration": "textDecoration", textlength: "textLength", textrendering: "textRendering", "text-rendering": "textRendering", to: "to", transform: "transform", typeof: "typeof", u1: "u1", u2: "u2", underlineposition: "underlinePosition", "underline-position": "underlinePosition", underlinethickness: "underlineThickness", "underline-thickness": "underlineThickness", unicode: "unicode", unicodebidi: "unicodeBidi", "unicode-bidi": "unicodeBidi", unicoderange: "unicodeRange", "unicode-range": "unicodeRange", unitsperem: "unitsPerEm", "units-per-em": "unitsPerEm", unselectable: "unselectable", valphabetic: "vAlphabetic", "v-alphabetic": "vAlphabetic", values: "values", vectoreffect: "vectorEffect", "vector-effect": "vectorEffect", version: "version", vertadvy: "vertAdvY", "vert-adv-y": "vertAdvY", vertoriginx: "vertOriginX", "vert-origin-x": "vertOriginX", vertoriginy: "vertOriginY", "vert-origin-y": "vertOriginY", vhanging: "vHanging", "v-hanging": "vHanging", videographic: "vIdeographic", "v-ideographic": "vIdeographic", viewbox: "viewBox", viewtarget: "viewTarget", visibility: "visibility", vmathematical: "vMathematical", "v-mathematical": "vMathematical", vocab: "vocab", widths: "widths", wordspacing: "wordSpacing", "word-spacing": "wordSpacing", writingmode: "writingMode", "writing-mode": "writingMode", x1: "x1", x2: "x2", x: "x", xchannelselector: "xChannelSelector", xheight: "xHeight", "x-height": "xHeight", xlinkactuate: "xlinkActuate", "xlink:actuate": "xlinkActuate", xlinkarcrole: "xlinkArcrole", "xlink:arcrole": "xlinkArcrole", xlinkhref: "xlinkHref", "xlink:href": "xlinkHref", xlinkrole: "xlinkRole", "xlink:role": "xlinkRole", xlinkshow: "xlinkShow", "xlink:show": "xlinkShow", xlinktitle: "xlinkTitle", "xlink:title": "xlinkTitle", xlinktype: "xlinkType", "xlink:type": "xlinkType", xmlbase: "xmlBase", "xml:base": "xmlBase", xmllang: "xmlLang", "xml:lang": "xmlLang", xmlns: "xmlns", "xml:space": "xmlSpace", xmlnsxlink: "xmlnsXlink", "xmlns:xlink": "xmlnsXlink", xmlspace: "xmlSpace", y1: "y1", y2: "y2", y: "y", ychannelselector: "yChannelSelector", z: "z", zoomandpan: "zoomAndPan" }, pn2 = { "aria-current": 0, "aria-details": 0, "aria-disabled": 0, "aria-hidden": 0, "aria-invalid": 0, "aria-keyshortcuts": 0, "aria-label": 0, "aria-roledescription": 0, "aria-autocomplete": 0, "aria-checked": 0, "aria-expanded": 0, "aria-haspopup": 0, "aria-level": 0, "aria-modal": 0, "aria-multiline": 0, "aria-multiselectable": 0, "aria-orientation": 0, "aria-placeholder": 0, "aria-pressed": 0, "aria-readonly": 0, "aria-required": 0, "aria-selected": 0, "aria-sort": 0, "aria-valuemax": 0, "aria-valuemin": 0, "aria-valuenow": 0, "aria-valuetext": 0, "aria-atomic": 0, "aria-busy": 0, "aria-live": 0, "aria-relevant": 0, "aria-dropeffect": 0, "aria-grabbed": 0, "aria-activedescendant": 0, "aria-colcount": 0, "aria-colindex": 0, "aria-colspan": 0, "aria-controls": 0, "aria-describedby": 0, "aria-errormessage": 0, "aria-flowto": 0, "aria-labelledby": 0, "aria-owns": 0, "aria-posinset": 0, "aria-rowcount": 0, "aria-rowindex": 0, "aria-rowspan": 0, "aria-setsize": 0 }, hn2 = {}, mn2 = new RegExp("^(aria)-[" + j2 + "]*$"), vn2 = new RegExp("^(aria)[A-Z][" + j2 + "]*$"), gn2 = Object.prototype.hasOwnProperty;
    function yn2(e5, t3) {
      if (gn2.call(hn2, t3) && hn2[t3])
        return true;
      if (vn2.test(t3)) {
        var n3 = "aria-" + t3.slice(4).toLowerCase(), r3 = pn2.hasOwnProperty(n3) ? n3 : null;
        if (r3 == null)
          return i2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", t3), hn2[t3] = true, true;
        if (t3 !== r3)
          return i2("Invalid ARIA attribute `%s`. Did you mean `%s`?", t3, r3), hn2[t3] = true, true;
      }
      if (mn2.test(t3)) {
        var o3 = t3.toLowerCase(), a3 = pn2.hasOwnProperty(o3) ? o3 : null;
        if (a3 == null)
          return hn2[t3] = true, false;
        if (t3 !== a3)
          return i2("Unknown ARIA attribute `%s`. Did you mean `%s`?", t3, a3), hn2[t3] = true, true;
      }
      return true;
    }
    function bn2(e5, t3) {
      dn2(e5, t3) || function(e6, t4) {
        var n3 = [];
        for (var r3 in t4)
          yn2(0, r3) || n3.push(r3);
        var o3 = n3.map(function(e7) {
          return "`" + e7 + "`";
        }).join(", ");
        n3.length === 1 ? i2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", o3, e6) : n3.length > 1 && i2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", o3, e6);
      }(e5, t3);
    }
    var wn2 = false;
    var kn2, xn2 = {}, Sn2 = Object.prototype.hasOwnProperty, _n2 = /^on./, En2 = /^on[^A-Z]/, Pn2 = new RegExp("^(aria)-[" + j2 + "]*$"), Cn2 = new RegExp("^(aria)[A-Z][" + j2 + "]*$");
    kn2 = function(e5, t3, n3, r3) {
      if (Sn2.call(xn2, t3) && xn2[t3])
        return true;
      var o3 = t3.toLowerCase();
      if (o3 === "onfocusin" || o3 === "onfocusout")
        return i2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), xn2[t3] = true, true;
      if (r3 != null) {
        var a3 = r3.registrationNameDependencies, s3 = r3.possibleRegistrationNames;
        if (a3.hasOwnProperty(t3))
          return true;
        var l3 = s3.hasOwnProperty(o3) ? s3[o3] : null;
        if (l3 != null)
          return i2("Invalid event handler property `%s`. Did you mean `%s`?", t3, l3), xn2[t3] = true, true;
        if (_n2.test(t3))
          return i2("Unknown event handler property `%s`. It will be ignored.", t3), xn2[t3] = true, true;
      } else if (_n2.test(t3))
        return En2.test(t3) && i2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", t3), xn2[t3] = true, true;
      if (Pn2.test(t3) || Cn2.test(t3))
        return true;
      if (o3 === "innerhtml")
        return i2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), xn2[t3] = true, true;
      if (o3 === "aria")
        return i2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), xn2[t3] = true, true;
      if (o3 === "is" && n3 != null && typeof n3 != "string")
        return i2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof n3), xn2[t3] = true, true;
      if (typeof n3 == "number" && isNaN(n3))
        return i2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", t3), xn2[t3] = true, true;
      var u3 = L2(t3), c3 = u3 !== null && u3.type === 0;
      if (fn2.hasOwnProperty(o3)) {
        var d2 = fn2[o3];
        if (d2 !== t3)
          return i2("Invalid DOM property `%s`. Did you mean `%s`?", t3, d2), xn2[t3] = true, true;
      } else if (!c3 && t3 !== o3)
        return i2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", t3, o3), xn2[t3] = true, true;
      return typeof n3 == "boolean" && z2(t3, n3, u3, false) ? (n3 ? i2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', n3, t3, t3, n3, t3) : i2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', n3, t3, t3, n3, t3, t3, t3), xn2[t3] = true, true) : !!c3 || (z2(t3, n3, u3, false) ? (xn2[t3] = true, false) : (n3 !== "false" && n3 !== "true" || u3 === null || u3.type !== 3 || (i2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", n3, t3, n3 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', t3, n3), xn2[t3] = true), true));
    };
    function jn2(e5, t3, n3) {
      dn2(e5, t3) || function(e6, t4, n4) {
        var r3 = [];
        for (var o3 in t4)
          kn2(0, o3, t4[o3], n4) || r3.push(o3);
        var a3 = r3.map(function(e7) {
          return "`" + e7 + "`";
        }).join(", ");
        r3.length === 1 ? i2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", a3, e6) : r3.length > 1 && i2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", a3, e6);
      }(e5, t3, n3);
    }
    function On2(e5) {
      var t3 = e5.target || e5.srcElement || window;
      return t3.correspondingUseElement && (t3 = t3.correspondingUseElement), t3.nodeType === 3 ? t3.parentNode : t3;
    }
    var Tn2 = null, In2 = null, Dn2 = null;
    function Rn2(e5) {
      var t3 = ml2(e5);
      if (t3) {
        if (typeof Tn2 != "function")
          throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var n3 = t3.stateNode;
        if (n3) {
          var r3 = gl2(n3);
          Tn2(t3.stateNode, t3.type, r3);
        }
      }
    }
    function Nn2(e5) {
      In2 ? Dn2 ? Dn2.push(e5) : Dn2 = [e5] : In2 = e5;
    }
    function An2() {
      if (In2) {
        var e5 = In2, t3 = Dn2;
        if (In2 = null, Dn2 = null, Rn2(e5), t3)
          for (var n3 = 0; n3 < t3.length; n3++)
            Rn2(t3[n3]);
      }
    }
    var zn2 = function(e5, t3) {
      return e5(t3);
    }, Mn2 = function(e5, t3, n3, r3, o3) {
      return e5(t3, n3, r3, o3);
    }, Ln2 = function() {
    }, Fn2 = zn2, $n2 = false, Bn2 = false;
    function Vn2() {
      (In2 !== null || Dn2 !== null) && (Ln2(), An2());
    }
    function Un2(e5, t3) {
      var n3 = e5.stateNode;
      if (n3 === null)
        return null;
      var r3 = gl2(n3);
      if (r3 === null)
        return null;
      var o3 = r3[t3];
      if (function(e6, t4, n4) {
        switch (e6) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            return !(!n4.disabled || (r4 = t4, r4 !== "button" && r4 !== "input" && r4 !== "select" && r4 !== "textarea"));
          default:
            return false;
        }
        var r4;
      }(t3, e5.type, r3))
        return null;
      if (o3 && typeof o3 != "function")
        throw Error("Expected `" + t3 + "` listener to be a function, instead got a value of `" + typeof o3 + "` type.");
      return o3;
    }
    var Hn2 = false;
    if (P2)
      try {
        var Wn2 = {};
        Object.defineProperty(Wn2, "passive", { get: function() {
          Hn2 = true;
        } }), window.addEventListener("test", Wn2, Wn2), window.removeEventListener("test", Wn2, Wn2);
      } catch (e5) {
        Hn2 = false;
      }
    function qn2(e5, t3, n3, r3, o3, a3, i3, s3, l3) {
      var u3 = Array.prototype.slice.call(arguments, 3);
      try {
        t3.apply(n3, u3);
      } catch (e6) {
        this.onError(e6);
      }
    }
    var Kn2 = qn2;
    if (typeof window != "undefined" && typeof window.dispatchEvent == "function" && typeof document != "undefined" && typeof document.createEvent == "function") {
      var Yn2 = document.createElement("react");
      Kn2 = function(e5, t3, n3, r3, o3, a3, i3, s3, l3) {
        if (typeof document == "undefined")
          throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var u3 = document.createEvent("Event"), c3 = false, d2 = true, f2 = window.event, p2 = Object.getOwnPropertyDescriptor(window, "event");
        function h3() {
          Yn2.removeEventListener(k3, g3, false), window.event !== void 0 && window.hasOwnProperty("event") && (window.event = f2);
        }
        var m3, v3 = Array.prototype.slice.call(arguments, 3);
        function g3() {
          c3 = true, h3(), t3.apply(n3, v3), d2 = false;
        }
        var y3 = false, b3 = false;
        function w3(e6) {
          if (m3 = e6.error, y3 = true, m3 === null && e6.colno === 0 && e6.lineno === 0 && (b3 = true), e6.defaultPrevented && m3 != null && typeof m3 == "object")
            try {
              m3._suppressLogging = true;
            } catch (e7) {
            }
        }
        var k3 = "react-" + (e5 || "invokeguardedcallback");
        if (window.addEventListener("error", w3), Yn2.addEventListener(k3, g3, false), u3.initEvent(k3, false, false), Yn2.dispatchEvent(u3), p2 && Object.defineProperty(window, "event", p2), c3 && d2 && (y3 ? b3 && (m3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : m3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(m3)), window.removeEventListener("error", w3), !c3)
          return h3(), qn2.apply(this, arguments);
      };
    }
    var Xn2 = Kn2, Gn2 = false, Qn2 = null, Jn2 = false, Zn2 = null, er2 = { onError: function(e5) {
      Gn2 = true, Qn2 = e5;
    } };
    function tr2(e5, t3, n3, r3, o3, a3, i3, s3, l3) {
      Gn2 = false, Qn2 = null, Xn2.apply(er2, arguments);
    }
    function nr2() {
      return Gn2;
    }
    function rr2() {
      if (Gn2) {
        var e5 = Qn2;
        return Gn2 = false, Qn2 = null, e5;
      }
      throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function or2(e5) {
      return e5._reactInternals;
    }
    var ar, ir2, sr2, lr2, ur2 = 64, cr2 = 128, dr2 = 256, fr2 = 512, pr2 = 8192, hr2 = 1024, mr2 = 2048, vr2 = 4096, gr2 = 16384, yr2 = o2.ReactCurrentOwner;
    function br2(e5) {
      var t3 = e5, n3 = e5;
      if (e5.alternate)
        for (; t3.return; )
          t3 = t3.return;
      else {
        var r3 = t3;
        do {
          (1026 & (t3 = r3).flags) != 0 && (n3 = t3.return), r3 = t3.return;
        } while (r3);
      }
      return t3.tag === 3 ? n3 : null;
    }
    function wr2(e5) {
      if (e5.tag === d) {
        var t3 = e5.memoizedState;
        if (t3 === null) {
          var n3 = e5.alternate;
          n3 !== null && (t3 = n3.memoizedState);
        }
        if (t3 !== null)
          return t3.dehydrated;
      }
      return null;
    }
    function kr2(e5) {
      return e5.tag === 3 ? e5.stateNode.containerInfo : null;
    }
    function xr2(e5) {
      if (br2(e5) !== e5)
        throw Error("Unable to find node on an unmounted component.");
    }
    function Sr2(e5) {
      var t3 = e5.alternate;
      if (!t3) {
        var n3 = br2(e5);
        if (n3 === null)
          throw Error("Unable to find node on an unmounted component.");
        return n3 !== e5 ? null : e5;
      }
      for (var r3 = e5, o3 = t3; ; ) {
        var a3 = r3.return;
        if (a3 === null)
          break;
        var i3 = a3.alternate;
        if (i3 === null) {
          var s3 = a3.return;
          if (s3 !== null) {
            r3 = o3 = s3;
            continue;
          }
          break;
        }
        if (a3.child === i3.child) {
          for (var l3 = a3.child; l3; ) {
            if (l3 === r3)
              return xr2(a3), e5;
            if (l3 === o3)
              return xr2(a3), t3;
            l3 = l3.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (r3.return !== o3.return)
          r3 = a3, o3 = i3;
        else {
          for (var u3 = false, c3 = a3.child; c3; ) {
            if (c3 === r3) {
              u3 = true, r3 = a3, o3 = i3;
              break;
            }
            if (c3 === o3) {
              u3 = true, o3 = a3, r3 = i3;
              break;
            }
            c3 = c3.sibling;
          }
          if (!u3) {
            for (c3 = i3.child; c3; ) {
              if (c3 === r3) {
                u3 = true, r3 = i3, o3 = a3;
                break;
              }
              if (c3 === o3) {
                u3 = true, o3 = i3, r3 = a3;
                break;
              }
              c3 = c3.sibling;
            }
            if (!u3)
              throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (r3.alternate !== o3)
          throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (r3.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return r3.stateNode.current === r3 ? e5 : t3;
    }
    function _r2(e5) {
      var t3 = Sr2(e5);
      if (!t3)
        return null;
      for (var n3 = t3; ; ) {
        if (n3.tag === 5 || n3.tag === 6)
          return n3;
        if (n3.child)
          n3.child.return = n3, n3 = n3.child;
        else {
          if (n3 === t3)
            return null;
          for (; !n3.sibling; ) {
            if (!n3.return || n3.return === t3)
              return null;
            n3 = n3.return;
          }
          n3.sibling.return = n3.return, n3 = n3.sibling;
        }
      }
      return null;
    }
    function Er2(e5, t3) {
      for (var n3 = t3, r3 = e5.alternate; n3 !== null; ) {
        if (n3 === e5 || n3 === r3)
          return true;
        n3 = n3.return;
      }
      return false;
    }
    var Pr2 = false, Cr2 = [], jr2 = null, Or2 = null, Tr2 = null, Ir2 = /* @__PURE__ */ new Map(), Dr2 = /* @__PURE__ */ new Map(), Rr2 = [];
    var Nr2 = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset", "submit"];
    function Ar2(e5) {
      return Nr2.indexOf(e5) > -1;
    }
    function zr2(e5, t3, n3, r3, o3) {
      return { blockedOn: e5, domEventName: t3, eventSystemFlags: 16 | n3, nativeEvent: o3, targetContainers: [r3] };
    }
    function Mr2(e5, t3, n3, r3, o3) {
      var a3 = zr2(e5, t3, n3, r3, o3);
      Cr2.push(a3);
    }
    function Lr2(e5, t3) {
      switch (e5) {
        case "focusin":
        case "focusout":
          jr2 = null;
          break;
        case "dragenter":
        case "dragleave":
          Or2 = null;
          break;
        case "mouseover":
        case "mouseout":
          Tr2 = null;
          break;
        case "pointerover":
        case "pointerout":
          var n3 = t3.pointerId;
          Ir2.delete(n3);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          var r3 = t3.pointerId;
          Dr2.delete(r3);
      }
    }
    function Fr2(e5, t3, n3, r3, o3, a3) {
      if (e5 === null || e5.nativeEvent !== a3) {
        var i3 = zr2(t3, n3, r3, o3, a3);
        if (t3 !== null) {
          var s3 = ml2(t3);
          s3 !== null && ir2(s3);
        }
        return i3;
      }
      e5.eventSystemFlags |= r3;
      var l3 = e5.targetContainers;
      return o3 !== null && l3.indexOf(o3) === -1 && l3.push(o3), e5;
    }
    function $r2(e5) {
      var t3 = hl2(e5.target);
      if (t3 !== null) {
        var r3 = br2(t3);
        if (r3 !== null) {
          var o3 = r3.tag;
          if (o3 === d) {
            var a3 = wr2(r3);
            if (a3 !== null)
              return e5.blockedOn = a3, void lr2(e5.lanePriority, function() {
                n2.unstable_runWithPriority(e5.priority, function() {
                  sr2(r3);
                });
              });
          } else if (o3 === 3) {
            if (r3.stateNode.hydrate)
              return void (e5.blockedOn = kr2(r3));
          }
        }
      }
      e5.blockedOn = null;
    }
    function Br2(e5) {
      if (e5.blockedOn !== null)
        return false;
      for (var t3 = e5.targetContainers; t3.length > 0; ) {
        var n3 = t3[0], r3 = Qo2(e5.domEventName, e5.eventSystemFlags, n3, e5.nativeEvent);
        if (r3 !== null) {
          var o3 = ml2(r3);
          return o3 !== null && ir2(o3), e5.blockedOn = r3, false;
        }
        t3.shift();
      }
      return true;
    }
    function Vr2(e5, t3, n3) {
      Br2(e5) && n3.delete(t3);
    }
    function Ur2() {
      for (Pr2 = false; Cr2.length > 0; ) {
        var e5 = Cr2[0];
        if (e5.blockedOn !== null) {
          var t3 = ml2(e5.blockedOn);
          t3 !== null && ar(t3);
          break;
        }
        for (var n3 = e5.targetContainers; n3.length > 0; ) {
          var r3 = n3[0], o3 = Qo2(e5.domEventName, e5.eventSystemFlags, r3, e5.nativeEvent);
          if (o3 !== null) {
            e5.blockedOn = o3;
            break;
          }
          n3.shift();
        }
        e5.blockedOn === null && Cr2.shift();
      }
      jr2 !== null && Br2(jr2) && (jr2 = null), Or2 !== null && Br2(Or2) && (Or2 = null), Tr2 !== null && Br2(Tr2) && (Tr2 = null), Ir2.forEach(Vr2), Dr2.forEach(Vr2);
    }
    function Hr2(e5, t3) {
      e5.blockedOn === t3 && (e5.blockedOn = null, Pr2 || (Pr2 = true, n2.unstable_scheduleCallback(n2.unstable_NormalPriority, Ur2)));
    }
    function Wr2(e5) {
      if (Cr2.length > 0) {
        Hr2(Cr2[0], e5);
        for (var t3 = 1; t3 < Cr2.length; t3++) {
          var n3 = Cr2[t3];
          n3.blockedOn === e5 && (n3.blockedOn = null);
        }
      }
      jr2 !== null && Hr2(jr2, e5), Or2 !== null && Hr2(Or2, e5), Tr2 !== null && Hr2(Tr2, e5);
      var r3 = function(t4) {
        return Hr2(t4, e5);
      };
      Ir2.forEach(r3), Dr2.forEach(r3);
      for (var o3 = 0; o3 < Rr2.length; o3++) {
        var a3 = Rr2[o3];
        a3.blockedOn === e5 && (a3.blockedOn = null);
      }
      for (; Rr2.length > 0; ) {
        var i3 = Rr2[0];
        if (i3.blockedOn !== null)
          break;
        $r2(i3), i3.blockedOn === null && Rr2.shift();
      }
    }
    function qr2(e5, t3) {
      var n3 = {};
      return n3[e5.toLowerCase()] = t3.toLowerCase(), n3["Webkit" + e5] = "webkit" + t3, n3["Moz" + e5] = "moz" + t3, n3;
    }
    var Kr2 = { animationend: qr2("Animation", "AnimationEnd"), animationiteration: qr2("Animation", "AnimationIteration"), animationstart: qr2("Animation", "AnimationStart"), transitionend: qr2("Transition", "TransitionEnd") }, Yr2 = {}, Xr2 = {};
    function Gr2(e5) {
      if (Yr2[e5])
        return Yr2[e5];
      if (!Kr2[e5])
        return e5;
      var t3 = Kr2[e5];
      for (var n3 in t3)
        if (t3.hasOwnProperty(n3) && n3 in Xr2)
          return Yr2[e5] = t3[n3];
      return e5;
    }
    P2 && (Xr2 = document.createElement("div").style, "AnimationEvent" in window || (delete Kr2.animationend.animation, delete Kr2.animationiteration.animation, delete Kr2.animationstart.animation), "TransitionEvent" in window || delete Kr2.transitionend.transition);
    var Qr2 = Gr2("animationend"), Jr2 = Gr2("animationiteration"), Zr2 = Gr2("animationstart"), eo2 = Gr2("transitionend"), to2 = /* @__PURE__ */ new Map(), no2 = /* @__PURE__ */ new Map(), ro2 = ["cancel", "cancel", "click", "click", "close", "close", "contextmenu", "contextMenu", "copy", "copy", "cut", "cut", "auxclick", "auxClick", "dblclick", "doubleClick", "dragend", "dragEnd", "dragstart", "dragStart", "drop", "drop", "focusin", "focus", "focusout", "blur", "input", "input", "invalid", "invalid", "keydown", "keyDown", "keypress", "keyPress", "keyup", "keyUp", "mousedown", "mouseDown", "mouseup", "mouseUp", "paste", "paste", "pause", "pause", "play", "play", "pointercancel", "pointerCancel", "pointerdown", "pointerDown", "pointerup", "pointerUp", "ratechange", "rateChange", "reset", "reset", "seeked", "seeked", "submit", "submit", "touchcancel", "touchCancel", "touchend", "touchEnd", "touchstart", "touchStart", "volumechange", "volumeChange"], oo2 = ["change", "selectionchange", "textInput", "compositionstart", "compositionend", "compositionupdate"], ao2 = ["drag", "drag", "dragenter", "dragEnter", "dragexit", "dragExit", "dragleave", "dragLeave", "dragover", "dragOver", "mousemove", "mouseMove", "mouseout", "mouseOut", "mouseover", "mouseOver", "pointermove", "pointerMove", "pointerout", "pointerOut", "pointerover", "pointerOver", "scroll", "scroll", "toggle", "toggle", "touchmove", "touchMove", "wheel", "wheel"], io2 = ["abort", "abort", Qr2, "animationEnd", Jr2, "animationIteration", Zr2, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", eo2, "transitionEnd", "waiting", "waiting"];
    function so2(e5, t3) {
      for (var n3 = 0; n3 < e5.length; n3 += 2) {
        var r3 = e5[n3], o3 = e5[n3 + 1], a3 = "on" + (o3[0].toUpperCase() + o3.slice(1));
        no2.set(r3, t3), to2.set(r3, a3), _2(a3, [r3]);
      }
    }
    var lo2 = n2.unstable_now;
    if (r2.__interactionsRef == null || r2.__interactionsRef.current == null)
      throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
    lo2();
    var uo2 = 15, co2 = 10, fo2 = 3584, po2 = 4186112, ho2 = 62914560, mo2 = 33554432, vo2 = 67108864, go2 = 134217727, yo2 = 134217728, bo2 = 805306368, wo2 = 1073741824, ko2 = -1;
    var xo2 = 8;
    function So2(e5) {
      if ((1 & e5) != 0)
        return xo2 = uo2, 1;
      if ((2 & e5) != 0)
        return xo2 = 14, 2;
      if ((4 & e5) != 0)
        return xo2 = 13, 4;
      var t3 = 24 & e5;
      if (t3 !== 0)
        return xo2 = 12, t3;
      if ((32 & e5) != 0)
        return xo2 = 11, 32;
      var n3 = 192 & e5;
      if (n3 !== 0)
        return xo2 = co2, n3;
      if ((256 & e5) != 0)
        return xo2 = 9, 256;
      var r3 = fo2 & e5;
      if (r3 !== 0)
        return xo2 = 8, r3;
      if ((4096 & e5) != 0)
        return xo2 = 7, 4096;
      var o3 = po2 & e5;
      if (o3 !== 0)
        return xo2 = 6, o3;
      var a3 = ho2 & e5;
      if (a3 !== 0)
        return xo2 = 5, a3;
      if (e5 & vo2)
        return xo2 = 4, vo2;
      if ((e5 & yo2) != 0)
        return xo2 = 3, yo2;
      var s3 = bo2 & e5;
      return s3 !== 0 ? (xo2 = 2, s3) : (wo2 & e5) != 0 ? (xo2 = 1, wo2) : (i2("Should have found matching lanes. This is a bug in React."), xo2 = 8, e5);
    }
    function _o2(e5, t3) {
      var n3 = e5.pendingLanes;
      if (n3 === 0)
        return xo2 = 0, 0;
      var r3 = 0, o3 = 0, a3 = e5.expiredLanes, i3 = e5.suspendedLanes, s3 = e5.pingedLanes;
      if (a3 !== 0)
        r3 = a3, o3 = xo2 = uo2;
      else {
        var l3 = n3 & go2;
        if (l3 !== 0) {
          var u3 = l3 & ~i3;
          if (u3 !== 0)
            r3 = So2(u3), o3 = xo2;
          else {
            var c3 = l3 & s3;
            c3 !== 0 && (r3 = So2(c3), o3 = xo2);
          }
        } else {
          var d2 = n3 & ~i3;
          d2 !== 0 ? (r3 = So2(d2), o3 = xo2) : s3 !== 0 && (r3 = So2(s3), o3 = xo2);
        }
      }
      if (r3 === 0)
        return 0;
      if (r3 = n3 & function(e6) {
        return (function(e7) {
          var t4 = 31 - $o2(e7);
          return t4 < 0 ? 0 : 1 << t4;
        }(e6) << 1) - 1;
      }(r3), t3 !== 0 && t3 !== r3 && (t3 & i3) == 0) {
        if (So2(t3), o3 <= xo2)
          return t3;
        xo2 = o3;
      }
      var f2 = e5.entangledLanes;
      if (f2 !== 0)
        for (var p2 = e5.entanglements, h3 = r3 & f2; h3 > 0; ) {
          var m3 = Io2(h3), v3 = 1 << m3;
          r3 |= p2[m3], h3 &= ~v3;
        }
      return r3;
    }
    function Eo2(e5, t3) {
      So2(e5);
      return xo2 >= co2 ? t3 + 250 : xo2 >= 6 ? t3 + 5e3 : ko2;
    }
    function Po2(e5) {
      var t3 = -1073741825 & e5.pendingLanes;
      return t3 !== 0 ? t3 : t3 & wo2 ? wo2 : 0;
    }
    function Co2(e5) {
      return (e5 & go2) != 0;
    }
    function jo2(e5) {
      return (e5 & ho2) === e5;
    }
    function Oo2(e5, t3) {
      switch (e5) {
        case 0:
          break;
        case uo2:
          return 1;
        case 14:
          return 2;
        case 12:
          var n3 = To2(24 & ~t3);
          return n3 === 0 ? Oo2(co2, t3) : n3;
        case co2:
          var r3 = To2(192 & ~t3);
          return r3 === 0 ? Oo2(8, t3) : r3;
        case 8:
          var o3 = To2(fo2 & ~t3);
          return o3 === 0 && (o3 = To2(po2 & ~t3)) === 0 && (o3 = To2(fo2)), o3;
        case 6:
        case 5:
          break;
        case 2:
          var a3 = To2(bo2 & ~t3);
          return a3 === 0 && (a3 = To2(bo2)), a3;
      }
      throw Error("Invalid update priority: " + e5 + ". This is a bug in React.");
    }
    function To2(e5) {
      return function(e6) {
        return e6 & -e6;
      }(e5);
    }
    function Io2(e5) {
      return 31 - $o2(e5);
    }
    function Do2(e5, t3) {
      return (e5 & t3) != 0;
    }
    function Ro2(e5, t3) {
      return (e5 & t3) === t3;
    }
    function No2(e5, t3) {
      return e5 | t3;
    }
    function Ao2(e5, t3) {
      return e5 & ~t3;
    }
    function zo2(e5) {
      for (var t3 = [], n3 = 0; n3 < 31; n3++)
        t3.push(e5);
      return t3;
    }
    function Mo2(e5, t3, n3) {
      e5.pendingLanes |= t3;
      var r3 = t3 - 1;
      e5.suspendedLanes &= r3, e5.pingedLanes &= r3, e5.eventTimes[Io2(t3)] = n3;
    }
    function Lo2(e5, t3, n3) {
      e5.pingedLanes |= e5.suspendedLanes & t3;
    }
    function Fo2(e5, t3) {
      e5.mutableReadLanes |= t3 & e5.pendingLanes;
    }
    var $o2 = Math.clz32 ? Math.clz32 : function(e5) {
      if (e5 === 0)
        return 32;
      return 31 - (Bo2(e5) / Vo2 | 0) | 0;
    }, Bo2 = Math.log, Vo2 = Math.LN2;
    var Uo2 = n2.unstable_UserBlockingPriority, Ho2 = n2.unstable_runWithPriority, Wo2 = true;
    function qo2(e5) {
      Wo2 = !!e5;
    }
    function Ko2(e5, t3, n3) {
      var r3, o3 = function(e6) {
        var t4 = no2.get(e6);
        return t4 === void 0 ? 2 : t4;
      }(t3);
      switch (o3) {
        case 0:
          r3 = Yo2;
          break;
        case 1:
          r3 = Xo2;
          break;
        default:
          r3 = Go2;
      }
      return r3.bind(null, t3, n3, e5);
    }
    function Yo2(e5, t3, n3, r3) {
      r3.timeStamp, $n2 || Ln2(), function(e6, t4, n4, r4, o3) {
        var a3 = $n2;
        $n2 = true;
        try {
          Mn2(e6, t4, n4, r4, o3);
        } finally {
          ($n2 = a3) || Vn2();
        }
      }(Go2, e5, t3, n3, r3);
    }
    function Xo2(e5, t3, n3, r3) {
      Ho2(Uo2, Go2.bind(null, e5, t3, n3, r3));
    }
    function Go2(e5, t3, n3, r3) {
      if (Wo2) {
        var o3;
        if ((o3 = (4 & t3) == 0) && Cr2.length > 0 && Ar2(e5))
          Mr2(null, e5, t3, n3, r3);
        else {
          var a3 = Qo2(e5, t3, n3, r3);
          if (a3 !== null) {
            if (o3) {
              if (Ar2(e5))
                return void Mr2(a3, e5, t3, n3, r3);
              if (function(e6, t4, n4, r4, o4) {
                switch (t4) {
                  case "focusin":
                    return jr2 = Fr2(jr2, e6, t4, n4, r4, o4), true;
                  case "dragenter":
                    return Or2 = Fr2(Or2, e6, t4, n4, r4, o4), true;
                  case "mouseover":
                    return Tr2 = Fr2(Tr2, e6, t4, n4, r4, o4), true;
                  case "pointerover":
                    var a4 = o4, i3 = a4.pointerId;
                    return Ir2.set(i3, Fr2(Ir2.get(i3) || null, e6, t4, n4, r4, a4)), true;
                  case "gotpointercapture":
                    var s3 = o4, l3 = s3.pointerId;
                    return Dr2.set(l3, Fr2(Dr2.get(l3) || null, e6, t4, n4, r4, s3)), true;
                }
                return false;
              }(a3, e5, t3, n3, r3))
                return;
              Lr2(e5, r3);
            }
            Hi2(e5, t3, r3, null, n3);
          } else
            o3 && Lr2(e5, r3);
        }
      }
    }
    function Qo2(e5, t3, n3, r3) {
      var o3 = hl2(On2(r3));
      if (o3 !== null) {
        var a3 = br2(o3);
        if (a3 === null)
          o3 = null;
        else {
          var i3 = a3.tag;
          if (i3 === d) {
            var s3 = wr2(a3);
            if (s3 !== null)
              return s3;
            o3 = null;
          } else if (i3 === 3) {
            if (a3.stateNode.hydrate)
              return kr2(a3);
            o3 = null;
          } else
            a3 !== o3 && (o3 = null);
        }
      }
      return Hi2(e5, t3, r3, o3, n3), null;
    }
    var Jo2 = null, Zo2 = null, ea2 = null;
    function ta2() {
      if (ea2)
        return ea2;
      var e5, t3, n3 = Zo2, r3 = n3.length, o3 = na2(), a3 = o3.length;
      for (e5 = 0; e5 < r3 && n3[e5] === o3[e5]; e5++)
        ;
      var i3 = r3 - e5;
      for (t3 = 1; t3 <= i3 && n3[r3 - t3] === o3[a3 - t3]; t3++)
        ;
      var s3 = t3 > 1 ? 1 - t3 : void 0;
      return ea2 = o3.slice(e5, s3);
    }
    function na2() {
      return "value" in Jo2 ? Jo2.value : Jo2.textContent;
    }
    function ra2(e5) {
      var t3, n3 = e5.keyCode;
      return "charCode" in e5 ? (t3 = e5.charCode) === 0 && n3 === 13 && (t3 = 13) : t3 = n3, t3 === 10 && (t3 = 13), t3 >= 32 || t3 === 13 ? t3 : 0;
    }
    function oa2() {
      return true;
    }
    function aa2() {
      return false;
    }
    function ia2(e5) {
      function n3(t3, n4, r3, o3, a3) {
        for (var i3 in this._reactName = t3, this._targetInst = r3, this.type = n4, this.nativeEvent = o3, this.target = a3, this.currentTarget = null, e5)
          if (e5.hasOwnProperty(i3)) {
            var s3 = e5[i3];
            this[i3] = s3 ? s3(o3) : o3[i3];
          }
        var l3 = o3.defaultPrevented != null ? o3.defaultPrevented : o3.returnValue === false;
        return this.isDefaultPrevented = l3 ? oa2 : aa2, this.isPropagationStopped = aa2, this;
      }
      return t2(n3.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var e6 = this.nativeEvent;
        e6 && (e6.preventDefault ? e6.preventDefault() : typeof e6.returnValue != "unknown" && (e6.returnValue = false), this.isDefaultPrevented = oa2);
      }, stopPropagation: function() {
        var e6 = this.nativeEvent;
        e6 && (e6.stopPropagation ? e6.stopPropagation() : typeof e6.cancelBubble != "unknown" && (e6.cancelBubble = true), this.isPropagationStopped = oa2);
      }, persist: function() {
      }, isPersistent: oa2 }), n3;
    }
    var sa2, la2, ua2, ca2 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(e5) {
      return e5.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, da2 = ia2(ca2), fa2 = t2({}, ca2, { view: 0, detail: 0 }), pa2 = ia2(fa2);
    var ha2 = t2({}, fa2, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Pa2, button: 0, buttons: 0, relatedTarget: function(e5) {
      return e5.relatedTarget === void 0 ? e5.fromElement === e5.srcElement ? e5.toElement : e5.fromElement : e5.relatedTarget;
    }, movementX: function(e5) {
      return "movementX" in e5 ? e5.movementX : (function(e6) {
        e6 !== ua2 && (ua2 && e6.type === "mousemove" ? (sa2 = e6.screenX - ua2.screenX, la2 = e6.screenY - ua2.screenY) : (sa2 = 0, la2 = 0), ua2 = e6);
      }(e5), sa2);
    }, movementY: function(e5) {
      return "movementY" in e5 ? e5.movementY : la2;
    } }), ma2 = ia2(ha2), va2 = ia2(t2({}, ha2, { dataTransfer: 0 })), ga2 = ia2(t2({}, fa2, { relatedTarget: 0 })), ya = ia2(t2({}, ca2, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), ba = ia2(t2({}, ca2, { clipboardData: function(e5) {
      return "clipboardData" in e5 ? e5.clipboardData : window.clipboardData;
    } })), wa = ia2(t2({}, ca2, { data: 0 })), ka2 = wa, xa2 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Sa2 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };
    var _a2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Ea2(e5) {
      var t3 = this.nativeEvent;
      if (t3.getModifierState)
        return t3.getModifierState(e5);
      var n3 = _a2[e5];
      return !!n3 && !!t3[n3];
    }
    function Pa2(e5) {
      return Ea2;
    }
    var Ca2 = ia2(t2({}, fa2, { key: function(e5) {
      if (e5.key) {
        var t3 = xa2[e5.key] || e5.key;
        if (t3 !== "Unidentified")
          return t3;
      }
      if (e5.type === "keypress") {
        var n3 = ra2(e5);
        return n3 === 13 ? "Enter" : String.fromCharCode(n3);
      }
      return e5.type === "keydown" || e5.type === "keyup" ? Sa2[e5.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Pa2, charCode: function(e5) {
      return e5.type === "keypress" ? ra2(e5) : 0;
    }, keyCode: function(e5) {
      return e5.type === "keydown" || e5.type === "keyup" ? e5.keyCode : 0;
    }, which: function(e5) {
      return e5.type === "keypress" ? ra2(e5) : e5.type === "keydown" || e5.type === "keyup" ? e5.keyCode : 0;
    } })), ja2 = ia2(t2({}, ha2, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Oa2 = ia2(t2({}, fa2, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Pa2 })), Ta2 = ia2(t2({}, ca2, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), Ia2 = ia2(t2({}, ha2, { deltaX: function(e5) {
      return "deltaX" in e5 ? e5.deltaX : "wheelDeltaX" in e5 ? -e5.wheelDeltaX : 0;
    }, deltaY: function(e5) {
      return "deltaY" in e5 ? e5.deltaY : "wheelDeltaY" in e5 ? -e5.wheelDeltaY : "wheelDelta" in e5 ? -e5.wheelDelta : 0;
    }, deltaZ: 0, deltaMode: 0 })), Da2 = [9, 13, 27, 32], Ra2 = P2 && "CompositionEvent" in window, Na2 = null;
    P2 && "documentMode" in document && (Na2 = document.documentMode);
    var Aa2 = P2 && "TextEvent" in window && !Na2, za2 = P2 && (!Ra2 || Na2 && Na2 > 8 && Na2 <= 11), Ma2 = String.fromCharCode(32);
    var La2 = false;
    function Fa2(e5, t3) {
      switch (e5) {
        case "keyup":
          return Da2.indexOf(t3.keyCode) !== -1;
        case "keydown":
          return t3.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function $a2(e5) {
      var t3 = e5.detail;
      return typeof t3 == "object" && "data" in t3 ? t3.data : null;
    }
    function Ba(e5) {
      return e5.locale === "ko";
    }
    var Va = false;
    function Ua2(e5, t3, n3, r3, o3) {
      var a3, i3;
      if (Ra2 ? a3 = function(e6) {
        switch (e6) {
          case "compositionstart":
            return "onCompositionStart";
          case "compositionend":
            return "onCompositionEnd";
          case "compositionupdate":
            return "onCompositionUpdate";
        }
      }(t3) : Va ? Fa2(t3, r3) && (a3 = "onCompositionEnd") : function(e6, t4) {
        return e6 === "keydown" && t4.keyCode === 229;
      }(t3, r3) && (a3 = "onCompositionStart"), !a3)
        return null;
      za2 && !Ba(r3) && (Va || a3 !== "onCompositionStart" ? a3 === "onCompositionEnd" && Va && (i3 = ta2()) : Va = function(e6) {
        return Jo2 = e6, Zo2 = na2(), true;
      }(o3));
      var s3 = qi2(n3, a3);
      if (s3.length > 0) {
        var l3 = new wa(a3, t3, null, r3, o3);
        if (e5.push({ event: l3, listeners: s3 }), i3)
          l3.data = i3;
        else {
          var u3 = $a2(r3);
          u3 !== null && (l3.data = u3);
        }
      }
    }
    function Ha2(e5, t3) {
      if (Va) {
        if (e5 === "compositionend" || !Ra2 && Fa2(e5, t3)) {
          var n3 = ta2();
          return Jo2 = null, Zo2 = null, ea2 = null, Va = false, n3;
        }
        return null;
      }
      switch (e5) {
        case "paste":
        default:
          return null;
        case "keypress":
          if (!function(e6) {
            return (e6.ctrlKey || e6.altKey || e6.metaKey) && !(e6.ctrlKey && e6.altKey);
          }(t3)) {
            if (t3.char && t3.char.length > 1)
              return t3.char;
            if (t3.which)
              return String.fromCharCode(t3.which);
          }
          return null;
        case "compositionend":
          return za2 && !Ba(t3) ? null : t3.data;
      }
    }
    function Wa2(e5, t3, n3, r3, o3) {
      var a3;
      if (!(a3 = Aa2 ? function(e6, t4) {
        switch (e6) {
          case "compositionend":
            return $a2(t4);
          case "keypress":
            return t4.which !== 32 ? null : (La2 = true, Ma2);
          case "textInput":
            var n4 = t4.data;
            return n4 === Ma2 && La2 ? null : n4;
          default:
            return null;
        }
      }(t3, r3) : Ha2(t3, r3)))
        return null;
      var i3 = qi2(n3, "onBeforeInput");
      if (i3.length > 0) {
        var s3 = new ka2("onBeforeInput", "beforeinput", null, r3, o3);
        e5.push({ event: s3, listeners: i3 }), s3.data = a3;
      }
    }
    var qa2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function Ka2(e5) {
      var t3 = e5 && e5.nodeName && e5.nodeName.toLowerCase();
      return t3 === "input" ? !!qa2[e5.type] : t3 === "textarea";
    }
    function Ya2(e5, t3, n3, r3) {
      Nn2(r3);
      var o3 = qi2(t3, "onChange");
      if (o3.length > 0) {
        var a3 = new da2("onChange", "change", null, n3, r3);
        e5.push({ event: a3, listeners: o3 });
      }
    }
    var Xa2 = null, Ga2 = null;
    function Qa2(e5) {
      var t3 = [];
      Ya2(t3, Ga2, e5, On2(e5)), function(e6, t4) {
        if ($n2)
          return e6(t4);
        $n2 = true;
        try {
          zn2(e6, t4);
        } finally {
          $n2 = false, Vn2();
        }
      }(Ja2, t3);
    }
    function Ja2(e5) {
      Mi2(e5, 0);
    }
    function Za2(e5) {
      if (nt2(vl2(e5)))
        return e5;
    }
    function ei2(e5, t3) {
      if (e5 === "change")
        return t3;
    }
    var ti2 = false;
    function ni2() {
      Xa2 && (Xa2.detachEvent("onpropertychange", ri2), Xa2 = null, Ga2 = null);
    }
    function ri2(e5) {
      e5.propertyName === "value" && Za2(Ga2) && Qa2(e5);
    }
    function oi2(e5, t3, n3) {
      e5 === "focusin" ? (ni2(), function(e6, t4) {
        Ga2 = t4, (Xa2 = e6).attachEvent("onpropertychange", ri2);
      }(t3, n3)) : e5 === "focusout" && ni2();
    }
    function ai2(e5, t3) {
      if (e5 === "selectionchange" || e5 === "keyup" || e5 === "keydown")
        return Za2(Ga2);
    }
    function ii2(e5, t3) {
      if (e5 === "click")
        return Za2(t3);
    }
    function si2(e5, t3) {
      if (e5 === "input" || e5 === "change")
        return Za2(t3);
    }
    function li2(e5, t3, n3, r3, o3, a3, i3) {
      var s3, l3, u3, c3, d2, f2, p2 = n3 ? vl2(n3) : window;
      if ((c3 = (u3 = p2).nodeName && u3.nodeName.toLowerCase()) === "select" || c3 === "input" && u3.type === "file" ? s3 = ei2 : Ka2(p2) ? ti2 ? s3 = si2 : (s3 = ai2, l3 = oi2) : function(e6) {
        var t4 = e6.nodeName;
        return t4 && t4.toLowerCase() === "input" && (e6.type === "checkbox" || e6.type === "radio");
      }(p2) && (s3 = ii2), s3) {
        var h3 = s3(t3, n3);
        if (h3)
          return void Ya2(e5, h3, r3, o3);
      }
      l3 && l3(t3, p2, n3), t3 === "focusout" && (f2 = (d2 = p2)._wrapperState) && f2.controlled && d2.type === "number" && mt2(d2, "number", d2.value);
    }
    function ui2(e5, t3, n3, r3, o3, a3, i3) {
      var s3 = t3 === "mouseover" || t3 === "pointerover", l3 = t3 === "mouseout" || t3 === "pointerout";
      if (s3 && (16 & a3) == 0) {
        var u3 = r3.relatedTarget || r3.fromElement;
        if (u3 && (hl2(u3) || pl2(u3)))
          return;
      }
      if (l3 || s3) {
        var c3, d2, f2;
        if (o3.window === o3)
          c3 = o3;
        else {
          var p2 = o3.ownerDocument;
          c3 = p2 ? p2.defaultView || p2.parentWindow : window;
        }
        if (l3) {
          var h3 = r3.relatedTarget || r3.toElement;
          if (d2 = n3, (f2 = h3 ? hl2(h3) : null) !== null)
            (f2 !== br2(f2) || f2.tag !== 5 && f2.tag !== 6) && (f2 = null);
        } else
          d2 = null, f2 = n3;
        if (d2 !== f2) {
          var m3 = ma2, v3 = "onMouseLeave", g3 = "onMouseEnter", y3 = "mouse";
          t3 !== "pointerout" && t3 !== "pointerover" || (m3 = ja2, v3 = "onPointerLeave", g3 = "onPointerEnter", y3 = "pointer");
          var b3 = d2 == null ? c3 : vl2(d2), w3 = f2 == null ? c3 : vl2(f2), k3 = new m3(v3, y3 + "leave", d2, r3, o3);
          k3.target = b3, k3.relatedTarget = w3;
          var x3 = null;
          if (hl2(o3) === n3) {
            var S3 = new m3(g3, y3 + "enter", f2, r3, o3);
            S3.target = w3, S3.relatedTarget = b3, x3 = S3;
          }
          !function(e6, t4, n4, r4, o4) {
            var a4 = r4 && o4 ? function(e7, t5) {
              for (var n5 = e7, r5 = t5, o5 = 0, a5 = n5; a5; a5 = Ki2(a5))
                o5++;
              for (var i4 = 0, s4 = r5; s4; s4 = Ki2(s4))
                i4++;
              for (; o5 - i4 > 0; )
                n5 = Ki2(n5), o5--;
              for (; i4 - o5 > 0; )
                r5 = Ki2(r5), i4--;
              var l4 = o5;
              for (; l4--; ) {
                if (n5 === r5 || r5 !== null && n5 === r5.alternate)
                  return n5;
                n5 = Ki2(n5), r5 = Ki2(r5);
              }
              return null;
            }(r4, o4) : null;
            r4 !== null && Yi2(e6, t4, r4, a4, false);
            o4 !== null && n4 !== null && Yi2(e6, n4, o4, a4, true);
          }(e5, k3, x3, d2, f2);
        }
      }
    }
    P2 && (ti2 = function(e5) {
      if (!P2)
        return false;
      var t3 = "on" + e5, n3 = t3 in document;
      if (!n3) {
        var r3 = document.createElement("div");
        r3.setAttribute(t3, "return;"), n3 = typeof r3[t3] == "function";
      }
      return n3;
    }("input") && (!document.documentMode || document.documentMode > 9));
    var ci2 = typeof Object.is == "function" ? Object.is : function(e5, t3) {
      return e5 === t3 && (e5 !== 0 || 1 / e5 == 1 / t3) || e5 != e5 && t3 != t3;
    }, di2 = Object.prototype.hasOwnProperty;
    function fi2(e5, t3) {
      if (ci2(e5, t3))
        return true;
      if (typeof e5 != "object" || e5 === null || typeof t3 != "object" || t3 === null)
        return false;
      var n3 = Object.keys(e5), r3 = Object.keys(t3);
      if (n3.length !== r3.length)
        return false;
      for (var o3 = 0; o3 < n3.length; o3++)
        if (!di2.call(t3, n3[o3]) || !ci2(e5[n3[o3]], t3[n3[o3]]))
          return false;
      return true;
    }
    function pi2(e5) {
      for (; e5 && e5.firstChild; )
        e5 = e5.firstChild;
      return e5;
    }
    function hi2(e5) {
      for (; e5; ) {
        if (e5.nextSibling)
          return e5.nextSibling;
        e5 = e5.parentNode;
      }
    }
    function mi2(e5, t3) {
      for (var n3 = pi2(e5), r3 = 0, o3 = 0; n3; ) {
        if (n3.nodeType === 3) {
          if (o3 = r3 + n3.textContent.length, r3 <= t3 && o3 >= t3)
            return { node: n3, offset: t3 - r3 };
          r3 = o3;
        }
        n3 = pi2(hi2(n3));
      }
    }
    function vi2(e5) {
      var t3 = e5.ownerDocument, n3 = t3 && t3.defaultView || window, r3 = n3.getSelection && n3.getSelection();
      if (!r3 || r3.rangeCount === 0)
        return null;
      var o3 = r3.anchorNode, a3 = r3.anchorOffset, i3 = r3.focusNode, s3 = r3.focusOffset;
      try {
        o3.nodeType, i3.nodeType;
      } catch (e6) {
        return null;
      }
      return function(e6, t4, n4, r4, o4) {
        var a4 = 0, i4 = -1, s4 = -1, l3 = 0, u3 = 0, c3 = e6, d2 = null;
        e:
          for (; ; ) {
            for (var f2 = null; c3 !== t4 || n4 !== 0 && c3.nodeType !== 3 || (i4 = a4 + n4), c3 !== r4 || o4 !== 0 && c3.nodeType !== 3 || (s4 = a4 + o4), c3.nodeType === 3 && (a4 += c3.nodeValue.length), (f2 = c3.firstChild) !== null; )
              d2 = c3, c3 = f2;
            for (; ; ) {
              if (c3 === e6)
                break e;
              if (d2 === t4 && ++l3 === n4 && (i4 = a4), d2 === r4 && ++u3 === o4 && (s4 = a4), (f2 = c3.nextSibling) !== null)
                break;
              d2 = (c3 = d2).parentNode;
            }
            c3 = f2;
          }
        if (i4 === -1 || s4 === -1)
          return null;
        return { start: i4, end: s4 };
      }(e5, o3, a3, i3, s3);
    }
    function gi2(e5) {
      return e5 && e5.nodeType === 3;
    }
    function yi2(e5, t3) {
      return !(!e5 || !t3) && (e5 === t3 || !gi2(e5) && (gi2(t3) ? yi2(e5, t3.parentNode) : "contains" in e5 ? e5.contains(t3) : !!e5.compareDocumentPosition && !!(16 & e5.compareDocumentPosition(t3))));
    }
    function bi2(e5) {
      return e5 && e5.ownerDocument && yi2(e5.ownerDocument.documentElement, e5);
    }
    function wi2(e5) {
      try {
        return typeof e5.contentWindow.location.href == "string";
      } catch (e6) {
        return false;
      }
    }
    function ki2() {
      for (var e5 = window, t3 = rt2(); t3 instanceof e5.HTMLIFrameElement; ) {
        if (!wi2(t3))
          return t3;
        t3 = rt2((e5 = t3.contentWindow).document);
      }
      return t3;
    }
    function xi2(e5) {
      var t3 = e5 && e5.nodeName && e5.nodeName.toLowerCase();
      return t3 && (t3 === "input" && (e5.type === "text" || e5.type === "search" || e5.type === "tel" || e5.type === "url" || e5.type === "password") || t3 === "textarea" || e5.contentEditable === "true");
    }
    function Si2(e5) {
      var t3 = ki2(), n3 = e5.focusedElem, r3 = e5.selectionRange;
      if (t3 !== n3 && bi2(n3)) {
        r3 !== null && xi2(n3) && function(e6, t4) {
          var n4 = t4.start, r4 = t4.end;
          r4 === void 0 && (r4 = n4);
          "selectionStart" in e6 ? (e6.selectionStart = n4, e6.selectionEnd = Math.min(r4, e6.value.length)) : function(e7, t5) {
            var n5 = e7.ownerDocument || document, r5 = n5 && n5.defaultView || window;
            if (r5.getSelection) {
              var o4 = r5.getSelection(), a4 = e7.textContent.length, i4 = Math.min(t5.start, a4), s4 = t5.end === void 0 ? i4 : Math.min(t5.end, a4);
              if (!o4.extend && i4 > s4) {
                var l3 = s4;
                s4 = i4, i4 = l3;
              }
              var u3 = mi2(e7, i4), c3 = mi2(e7, s4);
              if (u3 && c3) {
                if (o4.rangeCount === 1 && o4.anchorNode === u3.node && o4.anchorOffset === u3.offset && o4.focusNode === c3.node && o4.focusOffset === c3.offset)
                  return;
                var d2 = n5.createRange();
                d2.setStart(u3.node, u3.offset), o4.removeAllRanges(), i4 > s4 ? (o4.addRange(d2), o4.extend(c3.node, c3.offset)) : (d2.setEnd(c3.node, c3.offset), o4.addRange(d2));
              }
            }
          }(e6, t4);
        }(n3, r3);
        for (var o3 = [], a3 = n3; a3 = a3.parentNode; )
          a3.nodeType === 1 && o3.push({ element: a3, left: a3.scrollLeft, top: a3.scrollTop });
        typeof n3.focus == "function" && n3.focus();
        for (var i3 = 0; i3 < o3.length; i3++) {
          var s3 = o3[i3];
          s3.element.scrollLeft = s3.left, s3.element.scrollTop = s3.top;
        }
      }
    }
    function _i2(e5) {
      return ("selectionStart" in e5 ? { start: e5.selectionStart, end: e5.selectionEnd } : vi2(e5)) || { start: 0, end: 0 };
    }
    var Ei2 = P2 && "documentMode" in document && document.documentMode <= 11;
    var Pi2 = null, Ci2 = null, ji2 = null, Oi2 = false;
    function Ti2(e5, t3, n3) {
      var r3, o3 = (r3 = n3).window === r3 ? r3.document : r3.nodeType === 9 ? r3 : r3.ownerDocument;
      if (!Oi2 && Pi2 != null && Pi2 === rt2(o3)) {
        var a3 = function(e6) {
          if ("selectionStart" in e6 && xi2(e6))
            return { start: e6.selectionStart, end: e6.selectionEnd };
          var t4 = (e6.ownerDocument && e6.ownerDocument.defaultView || window).getSelection();
          return { anchorNode: t4.anchorNode, anchorOffset: t4.anchorOffset, focusNode: t4.focusNode, focusOffset: t4.focusOffset };
        }(Pi2);
        if (!ji2 || !fi2(ji2, a3)) {
          ji2 = a3;
          var i3 = qi2(Ci2, "onSelect");
          if (i3.length > 0) {
            var s3 = new da2("onSelect", "select", null, t3, n3);
            e5.push({ event: s3, listeners: i3 }), s3.target = Pi2;
          }
        }
      }
    }
    function Ii2(e5, t3, n3, r3, o3, a3, i3) {
      var s3 = to2.get(t3);
      if (s3 !== void 0) {
        var l3 = da2, u3 = t3;
        switch (t3) {
          case "keypress":
            if (ra2(r3) === 0)
              return;
          case "keydown":
          case "keyup":
            l3 = Ca2;
            break;
          case "focusin":
            u3 = "focus", l3 = ga2;
            break;
          case "focusout":
            u3 = "blur", l3 = ga2;
            break;
          case "beforeblur":
          case "afterblur":
            l3 = ga2;
            break;
          case "click":
            if (r3.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            l3 = ma2;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            l3 = va2;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            l3 = Oa2;
            break;
          case Qr2:
          case Jr2:
          case Zr2:
            l3 = ya;
            break;
          case eo2:
            l3 = Ta2;
            break;
          case "scroll":
            l3 = pa2;
            break;
          case "wheel":
            l3 = Ia2;
            break;
          case "copy":
          case "cut":
          case "paste":
            l3 = ba;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            l3 = ja2;
        }
        var c3 = (4 & a3) != 0, d2 = !c3 && t3 === "scroll", f2 = function(e6, t4, n4, r4, o4) {
          var a4 = t4 !== null ? t4 + "Capture" : null, i4 = r4 ? a4 : t4, s4 = [], l4 = e6, u4 = null;
          for (; l4 !== null; ) {
            var c4 = l4, d3 = c4.stateNode;
            if (c4.tag === 5 && d3 !== null && (u4 = d3, i4 !== null)) {
              var f3 = Un2(l4, i4);
              f3 != null && s4.push(Wi2(l4, f3, u4));
            }
            if (o4)
              break;
            l4 = l4.return;
          }
          return s4;
        }(n3, s3, r3.type, c3, d2);
        if (f2.length > 0) {
          var p2 = new l3(s3, u3, null, r3, o3);
          e5.push({ event: p2, listeners: f2 });
        }
      }
    }
    function Di2(e5, t3, n3, r3, o3, a3, i3) {
      Ii2(e5, t3, n3, r3, o3, a3), (7 & a3) == 0 && (ui2(e5, t3, n3, r3, o3, a3), li2(e5, t3, n3, r3, o3), function(e6, t4, n4, r4, o4, a4, i4) {
        var s3 = n4 ? vl2(n4) : window;
        switch (t4) {
          case "focusin":
            (Ka2(s3) || s3.contentEditable === "true") && (Pi2 = s3, Ci2 = n4, ji2 = null);
            break;
          case "focusout":
            Pi2 = null, Ci2 = null, ji2 = null;
            break;
          case "mousedown":
            Oi2 = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Oi2 = false, Ti2(e6, r4, o4);
            break;
          case "selectionchange":
            if (Ei2)
              break;
          case "keydown":
          case "keyup":
            Ti2(e6, r4, o4);
        }
      }(e5, t3, n3, r3, o3), function(e6, t4, n4, r4, o4, a4, i4) {
        Ua2(e6, t4, n4, r4, o4), Wa2(e6, t4, n4, r4, o4);
      }(e5, t3, n3, r3, o3));
    }
    so2(ro2, 0), so2(ao2, 1), so2(io2, 2), function(e5, t3) {
      for (var n3 = 0; n3 < e5.length; n3++)
        no2.set(e5[n3], t3);
    }(oo2, 0), E2("onMouseEnter", ["mouseout", "mouseover"]), E2("onMouseLeave", ["mouseout", "mouseover"]), E2("onPointerEnter", ["pointerout", "pointerover"]), E2("onPointerLeave", ["pointerout", "pointerover"]), _2("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]), _2("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]), _2("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), _2("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), _2("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), _2("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    var Ri2 = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Ni2 = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Ri2));
    function Ai2(e5, t3, n3) {
      var r3 = e5.type || "unknown-event";
      e5.currentTarget = n3, function(e6, t4, n4, r4, o3, a3, i3, s3, l3) {
        if (tr2.apply(this, arguments), Gn2) {
          var u3 = rr2();
          Jn2 || (Jn2 = true, Zn2 = u3);
        }
      }(r3, t3, void 0, e5), e5.currentTarget = null;
    }
    function zi2(e5, t3, n3) {
      var r3;
      if (n3)
        for (var o3 = t3.length - 1; o3 >= 0; o3--) {
          var a3 = t3[o3], i3 = a3.instance, s3 = a3.currentTarget, l3 = a3.listener;
          if (i3 !== r3 && e5.isPropagationStopped())
            return;
          Ai2(e5, l3, s3), r3 = i3;
        }
      else
        for (var u3 = 0; u3 < t3.length; u3++) {
          var c3 = t3[u3], d2 = c3.instance, f2 = c3.currentTarget, p2 = c3.listener;
          if (d2 !== r3 && e5.isPropagationStopped())
            return;
          Ai2(e5, p2, f2), r3 = d2;
        }
    }
    function Mi2(e5, t3) {
      for (var n3 = (4 & t3) != 0, r3 = 0; r3 < e5.length; r3++) {
        var o3 = e5[r3];
        zi2(o3.event, o3.listeners, n3);
      }
      !function() {
        if (Jn2) {
          var e6 = Zn2;
          throw Jn2 = false, Zn2 = null, e6;
        }
      }();
    }
    function Li2(e5, t3) {
      var n3 = bl2(t3), r3 = Xi2(e5, false);
      n3.has(r3) || (Vi2(t3, e5, 2, false), n3.add(r3));
    }
    var Fi2 = "_reactListening" + Math.random().toString(36).slice(2);
    function $i2(e5) {
      e5[Fi2] || (e5[Fi2] = true, k2.forEach(function(t3) {
        Ni2.has(t3) || Bi2(t3, false, e5, null), Bi2(t3, true, e5, null);
      }));
    }
    function Bi2(e5, t3, n3, r3) {
      var o3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, a3 = n3;
      if (e5 === "selectionchange" && n3.nodeType !== 9 && (a3 = n3.ownerDocument), r3 !== null && !t3 && Ni2.has(e5)) {
        if (e5 !== "scroll")
          return;
        o3 |= 2, a3 = r3;
      }
      var i3 = bl2(a3), s3 = Xi2(e5, t3);
      i3.has(s3) || (t3 && (o3 |= 4), Vi2(a3, e5, o3, t3), i3.add(s3));
    }
    function Vi2(e5, t3, n3, r3, o3) {
      var a3 = Ko2(e5, t3, n3), i3 = void 0;
      Hn2 && (t3 !== "touchstart" && t3 !== "touchmove" && t3 !== "wheel" || (i3 = true)), e5 = e5, r3 ? i3 !== void 0 ? function(e6, t4, n4, r4) {
        e6.addEventListener(t4, n4, { capture: true, passive: r4 });
      }(e5, t3, a3, i3) : function(e6, t4, n4) {
        e6.addEventListener(t4, n4, true);
      }(e5, t3, a3) : i3 !== void 0 ? function(e6, t4, n4, r4) {
        e6.addEventListener(t4, n4, { passive: r4 });
      }(e5, t3, a3, i3) : function(e6, t4, n4) {
        e6.addEventListener(t4, n4, false);
      }(e5, t3, a3);
    }
    function Ui2(e5, t3) {
      return e5 === t3 || e5.nodeType === 8 && e5.parentNode === t3;
    }
    function Hi2(e5, t3, n3, r3, o3) {
      var a3 = r3;
      if ((1 & t3) == 0 && (2 & t3) == 0) {
        var i3 = o3;
        if (r3 !== null) {
          var s3 = r3;
          e:
            for (; ; ) {
              if (s3 === null)
                return;
              var l3 = s3.tag;
              if (l3 === 3 || l3 === 4) {
                var u3 = s3.stateNode.containerInfo;
                if (Ui2(u3, i3))
                  break;
                if (l3 === 4)
                  for (var c3 = s3.return; c3 !== null; ) {
                    var d2 = c3.tag;
                    if (d2 === 3 || d2 === 4) {
                      if (Ui2(c3.stateNode.containerInfo, i3))
                        return;
                    }
                    c3 = c3.return;
                  }
                for (; u3 !== null; ) {
                  var f2 = hl2(u3);
                  if (f2 === null)
                    return;
                  var p2 = f2.tag;
                  if (p2 === 5 || p2 === 6) {
                    s3 = a3 = f2;
                    continue e;
                  }
                  u3 = u3.parentNode;
                }
              }
              s3 = s3.return;
            }
        }
      }
      !function(e6, t4, n4) {
        if (Bn2)
          return e6(t4, n4);
        Bn2 = true;
        try {
          Fn2(e6, t4, n4);
        } finally {
          Bn2 = false, Vn2();
        }
      }(function() {
        return function(e6, t4, n4, r4, o4) {
          var a4 = [];
          Di2(a4, e6, r4, n4, On2(n4), t4), Mi2(a4, t4);
        }(e5, t3, n3, a3);
      });
    }
    function Wi2(e5, t3, n3) {
      return { instance: e5, listener: t3, currentTarget: n3 };
    }
    function qi2(e5, t3) {
      for (var n3 = t3 + "Capture", r3 = [], o3 = e5; o3 !== null; ) {
        var a3 = o3, i3 = a3.stateNode;
        if (a3.tag === 5 && i3 !== null) {
          var s3 = i3, l3 = Un2(o3, n3);
          l3 != null && r3.unshift(Wi2(o3, l3, s3));
          var u3 = Un2(o3, t3);
          u3 != null && r3.push(Wi2(o3, u3, s3));
        }
        o3 = o3.return;
      }
      return r3;
    }
    function Ki2(e5) {
      if (e5 === null)
        return null;
      do {
        e5 = e5.return;
      } while (e5 && e5.tag !== 5);
      return e5 || null;
    }
    function Yi2(e5, t3, n3, r3, o3) {
      for (var a3 = t3._reactName, i3 = [], s3 = n3; s3 !== null && s3 !== r3; ) {
        var l3 = s3, u3 = l3.alternate, c3 = l3.stateNode, d2 = l3.tag;
        if (u3 !== null && u3 === r3)
          break;
        if (d2 === 5 && c3 !== null) {
          var f2 = c3;
          if (o3) {
            var p2 = Un2(s3, a3);
            p2 != null && i3.unshift(Wi2(s3, p2, f2));
          } else if (!o3) {
            var h3 = Un2(s3, a3);
            h3 != null && i3.push(Wi2(s3, h3, f2));
          }
        }
        s3 = s3.return;
      }
      i3.length !== 0 && e5.push({ event: t3, listeners: i3 });
    }
    function Xi2(e5, t3) {
      return e5 + "__" + (t3 ? "capture" : "bubble");
    }
    var Gi2, Qi2, Ji2, Zi2, es2, ts2, ns2, rs2, os2, as2, is2 = false, ss2 = "dangerouslySetInnerHTML", ls2 = "suppressContentEditableWarning", us2 = "suppressHydrationWarning", cs2 = "autoFocus", ds2 = "children", fs2 = "style", ps2 = At2;
    Gi2 = { dialog: true, webview: true }, Ji2 = function(e5, t3) {
      bn2(e5, t3), function(e6, t4) {
        e6 !== "input" && e6 !== "textarea" && e6 !== "select" || t4 == null || t4.value !== null || wn2 || (wn2 = true, e6 === "select" && t4.multiple ? i2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e6) : i2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e6));
      }(e5, t3), jn2(e5, t3, { registrationNameDependencies: x2, possibleRegistrationNames: S2 });
    }, rs2 = P2 && !document.documentMode;
    var hs2 = /\r\n?/g, ms2 = /\u0000|\uFFFD/g;
    function vs2(e5) {
      return e5.nodeType === 9 ? e5 : e5.ownerDocument;
    }
    function gs2() {
    }
    function ys2(e5) {
      e5.onclick = gs2;
    }
    function bs2(e5, t3, n3, r3) {
      var o3, a3 = dn2(t3, n3);
      switch (Ji2(t3, n3), t3) {
        case "dialog":
          Li2("cancel", e5), Li2("close", e5), o3 = n3;
          break;
        case "iframe":
        case "object":
        case "embed":
          Li2("load", e5), o3 = n3;
          break;
        case "video":
        case "audio":
          for (var i3 = 0; i3 < Ri2.length; i3++)
            Li2(Ri2[i3], e5);
          o3 = n3;
          break;
        case "source":
          Li2("error", e5), o3 = n3;
          break;
        case "img":
        case "image":
        case "link":
          Li2("error", e5), Li2("load", e5), o3 = n3;
          break;
        case "details":
          Li2("toggle", e5), o3 = n3;
          break;
        case "input":
          ct2(e5, n3), o3 = ut2(e5, n3), Li2("invalid", e5);
          break;
        case "option":
          wt2(0, n3), o3 = kt2(0, n3);
          break;
        case "select":
          Pt2(e5, n3), o3 = Et2(0, n3), Li2("invalid", e5);
          break;
        case "textarea":
          Ot2(e5, n3), o3 = jt2(e5, n3), Li2("invalid", e5);
          break;
        default:
          o3 = n3;
      }
      switch (cn2(t3, o3), function(e6, t4, n4, r4, o4) {
        for (var a4 in r4)
          if (r4.hasOwnProperty(a4)) {
            var i4 = r4[a4];
            if (a4 === fs2)
              i4 && Object.freeze(i4), sn2(t4, i4);
            else if (a4 === ss2) {
              var s3 = i4 ? i4.__html : void 0;
              s3 != null && $t2(t4, s3);
            } else
              a4 === ds2 ? typeof i4 == "string" ? (e6 !== "textarea" || i4 !== "") && Vt2(t4, i4) : typeof i4 == "number" && Vt2(t4, "" + i4) : a4 === ls2 || a4 === us2 || a4 === cs2 || (x2.hasOwnProperty(a4) ? i4 != null && (typeof i4 != "function" && ns2(a4, i4), a4 === "onScroll" && Li2("scroll", t4)) : i4 != null && Y2(t4, a4, i4, o4));
          }
      }(t3, e5, 0, o3, a3), t3) {
        case "input":
          tt2(e5), pt2(e5, n3, false);
          break;
        case "textarea":
          tt2(e5), It2(e5);
          break;
        case "option":
          !function(e6, t4) {
            t4.value != null && e6.setAttribute("value", Xe2(Ge2(t4.value)));
          }(e5, n3);
          break;
        case "select":
          !function(e6, t4) {
            var n4 = e6;
            n4.multiple = !!t4.multiple;
            var r4 = t4.value;
            r4 != null ? _t2(n4, !!t4.multiple, r4, false) : t4.defaultValue != null && _t2(n4, !!t4.multiple, t4.defaultValue, true);
          }(e5, n3);
          break;
        default:
          typeof o3.onClick == "function" && ys2(e5);
      }
    }
    function ws2(e5, t3, n3, r3, o3) {
      Ji2(t3, r3);
      var a3, s3, l3, u3, c3 = null;
      switch (t3) {
        case "input":
          a3 = ut2(e5, n3), s3 = ut2(e5, r3), c3 = [];
          break;
        case "option":
          a3 = kt2(0, n3), s3 = kt2(0, r3), c3 = [];
          break;
        case "select":
          a3 = Et2(0, n3), s3 = Et2(0, r3), c3 = [];
          break;
        case "textarea":
          a3 = jt2(e5, n3), s3 = jt2(e5, r3), c3 = [];
          break;
        default:
          s3 = r3, typeof (a3 = n3).onClick != "function" && typeof s3.onClick == "function" && ys2(e5);
      }
      cn2(t3, s3);
      var d2 = null;
      for (l3 in a3)
        if (!s3.hasOwnProperty(l3) && a3.hasOwnProperty(l3) && a3[l3] != null)
          if (l3 === fs2) {
            var f2 = a3[l3];
            for (u3 in f2)
              f2.hasOwnProperty(u3) && (d2 || (d2 = {}), d2[u3] = "");
          } else
            l3 === ss2 || l3 === ds2 || l3 === ls2 || l3 === us2 || l3 === cs2 || (x2.hasOwnProperty(l3) ? c3 || (c3 = []) : (c3 = c3 || []).push(l3, null));
      for (l3 in s3) {
        var p2 = s3[l3], h3 = a3 != null ? a3[l3] : void 0;
        if (s3.hasOwnProperty(l3) && p2 !== h3 && (p2 != null || h3 != null))
          if (l3 === fs2)
            if (p2 && Object.freeze(p2), h3) {
              for (u3 in h3)
                !h3.hasOwnProperty(u3) || p2 && p2.hasOwnProperty(u3) || (d2 || (d2 = {}), d2[u3] = "");
              for (u3 in p2)
                p2.hasOwnProperty(u3) && h3[u3] !== p2[u3] && (d2 || (d2 = {}), d2[u3] = p2[u3]);
            } else
              d2 || (c3 || (c3 = []), c3.push(l3, d2)), d2 = p2;
          else if (l3 === ss2) {
            var m3 = p2 ? p2.__html : void 0, v3 = h3 ? h3.__html : void 0;
            m3 != null && v3 !== m3 && (c3 = c3 || []).push(l3, m3);
          } else
            l3 === ds2 ? typeof p2 != "string" && typeof p2 != "number" || (c3 = c3 || []).push(l3, "" + p2) : l3 === ls2 || l3 === us2 || (x2.hasOwnProperty(l3) ? (p2 != null && (typeof p2 != "function" && ns2(l3, p2), l3 === "onScroll" && Li2("scroll", e5)), c3 || h3 === p2 || (c3 = [])) : typeof p2 == "object" && p2 !== null && p2.$$typeof === le2 ? p2.toString() : (c3 = c3 || []).push(l3, p2));
      }
      return d2 && (!function(e6, t4) {
        if (t4) {
          var n4, r4 = ln2(e6), o4 = ln2(t4), a4 = {};
          for (var s4 in r4) {
            var l4 = r4[s4], u4 = o4[s4];
            if (u4 && l4 !== u4) {
              var c4 = l4 + "," + u4;
              if (a4[c4])
                continue;
              a4[c4] = true, i2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", (n4 = e6[l4]) == null || typeof n4 == "boolean" || n4 === "" ? "Removing" : "Updating", l4, u4);
            }
          }
        }
      }(d2, s3.style), (c3 = c3 || []).push(fs2, d2)), c3;
    }
    function ks2(e5, t3, n3, r3, o3) {
      n3 === "input" && o3.type === "radio" && o3.name != null && dt2(e5, o3);
      dn2(n3, r3);
      switch (function(e6, t4, n4, r4) {
        for (var o4 = 0; o4 < t4.length; o4 += 2) {
          var a3 = t4[o4], i3 = t4[o4 + 1];
          a3 === fs2 ? sn2(e6, i3) : a3 === ss2 ? $t2(e6, i3) : a3 === ds2 ? Vt2(e6, i3) : Y2(e6, a3, i3, r4);
        }
      }(e5, t3, 0, dn2(n3, o3)), n3) {
        case "input":
          ft2(e5, o3);
          break;
        case "textarea":
          Tt2(e5, o3);
          break;
        case "select":
          !function(e6, t4) {
            var n4 = e6, r4 = n4._wrapperState.wasMultiple;
            n4._wrapperState.wasMultiple = !!t4.multiple;
            var o4 = t4.value;
            o4 != null ? _t2(n4, !!t4.multiple, o4, false) : r4 !== !!t4.multiple && (t4.defaultValue != null ? _t2(n4, !!t4.multiple, t4.defaultValue, true) : _t2(n4, !!t4.multiple, t4.multiple ? [] : "", false));
          }(e5, o3);
      }
    }
    function xs2(e5, t3) {
      Zi2(e5.nodeValue, t3);
    }
    function Ss2(e5, t3) {
      is2 || (is2 = true, i2("Did not expect server HTML to contain a <%s> in <%s>.", t3.nodeName.toLowerCase(), e5.nodeName.toLowerCase()));
    }
    function _s2(e5, t3) {
      is2 || (is2 = true, i2('Did not expect server HTML to contain the text node "%s" in <%s>.', t3.nodeValue, e5.nodeName.toLowerCase()));
    }
    function Es2(e5, t3, n3) {
      is2 || (is2 = true, i2("Expected server HTML to contain a matching <%s> in <%s>.", t3, e5.nodeName.toLowerCase()));
    }
    function Ps2(e5, t3) {
      t3 !== "" && (is2 || (is2 = true, i2('Expected server HTML to contain a matching text node for "%s" in <%s>.', t3, e5.nodeName.toLowerCase())));
    }
    os2 = function(e5) {
      return (typeof e5 == "string" ? e5 : "" + e5).replace(hs2, "\n").replace(ms2, "");
    }, Zi2 = function(e5, t3) {
      if (!is2) {
        var n3 = os2(t3), r3 = os2(e5);
        r3 !== n3 && (is2 = true, i2('Text content did not match. Server: "%s" Client: "%s"', r3, n3));
      }
    }, es2 = function(e5, t3, n3) {
      if (!is2) {
        var r3 = os2(n3), o3 = os2(t3);
        o3 !== r3 && (is2 = true, i2("Prop `%s` did not match. Server: %s Client: %s", e5, JSON.stringify(o3), JSON.stringify(r3)));
      }
    }, ts2 = function(e5) {
      if (!is2) {
        is2 = true;
        var t3 = [];
        e5.forEach(function(e6) {
          t3.push(e6);
        }), i2("Extra attributes from the server: %s", t3);
      }
    }, ns2 = function(e5, t3) {
      t3 === false ? i2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e5, e5, e5) : i2("Expected `%s` listener to be a function, instead got a value of `%s` type.", e5, typeof t3);
    }, as2 = function(e5, t3) {
      var n3 = e5.namespaceURI === ps2 ? e5.ownerDocument.createElement(e5.tagName) : e5.ownerDocument.createElementNS(e5.namespaceURI, e5.tagName);
      return n3.innerHTML = t3, n3.innerHTML;
    };
    var Cs2, js2, Os2 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], Ts2 = ["applet", "caption", "html", "table", "td", "th", "marquee", "object", "template", "foreignObject", "desc", "title"], Is2 = Ts2.concat(["button"]), Ds2 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], Rs2 = { current: null, formTag: null, aTagInScope: null, buttonTagInScope: null, nobrTagInScope: null, pTagInButtonScope: null, listItemTagAutoclosing: null, dlItemTagAutoclosing: null };
    js2 = function(e5, n3) {
      var r3 = t2({}, e5 || Rs2), o3 = { tag: n3 };
      return Ts2.indexOf(n3) !== -1 && (r3.aTagInScope = null, r3.buttonTagInScope = null, r3.nobrTagInScope = null), Is2.indexOf(n3) !== -1 && (r3.pTagInButtonScope = null), Os2.indexOf(n3) !== -1 && n3 !== "address" && n3 !== "div" && n3 !== "p" && (r3.listItemTagAutoclosing = null, r3.dlItemTagAutoclosing = null), r3.current = o3, n3 === "form" && (r3.formTag = o3), n3 === "a" && (r3.aTagInScope = o3), n3 === "button" && (r3.buttonTagInScope = o3), n3 === "nobr" && (r3.nobrTagInScope = o3), n3 === "p" && (r3.pTagInButtonScope = o3), n3 === "li" && (r3.listItemTagAutoclosing = o3), n3 !== "dd" && n3 !== "dt" || (r3.dlItemTagAutoclosing = o3), r3;
    };
    var Ns2 = {};
    Cs2 = function(e5, t3, n3) {
      var r3 = (n3 = n3 || Rs2).current, o3 = r3 && r3.tag;
      t3 != null && (e5 != null && i2("validateDOMNesting: when childText is passed, childTag should be null"), e5 = "#text");
      var a3 = function(e6, t4) {
        switch (t4) {
          case "select":
            return e6 === "option" || e6 === "optgroup" || e6 === "#text";
          case "optgroup":
            return e6 === "option" || e6 === "#text";
          case "option":
            return e6 === "#text";
          case "tr":
            return e6 === "th" || e6 === "td" || e6 === "style" || e6 === "script" || e6 === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e6 === "tr" || e6 === "style" || e6 === "script" || e6 === "template";
          case "colgroup":
            return e6 === "col" || e6 === "template";
          case "table":
            return e6 === "caption" || e6 === "colgroup" || e6 === "tbody" || e6 === "tfoot" || e6 === "thead" || e6 === "style" || e6 === "script" || e6 === "template";
          case "head":
            return e6 === "base" || e6 === "basefont" || e6 === "bgsound" || e6 === "link" || e6 === "meta" || e6 === "title" || e6 === "noscript" || e6 === "noframes" || e6 === "style" || e6 === "script" || e6 === "template";
          case "html":
            return e6 === "head" || e6 === "body" || e6 === "frameset";
          case "frameset":
            return e6 === "frame";
          case "#document":
            return e6 === "html";
        }
        switch (e6) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t4 !== "h1" && t4 !== "h2" && t4 !== "h3" && t4 !== "h4" && t4 !== "h5" && t4 !== "h6";
          case "rp":
          case "rt":
            return Ds2.indexOf(t4) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return t4 == null;
        }
        return true;
      }(e5, o3) ? null : r3, s3 = a3 ? null : function(e6, t4) {
        switch (e6) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t4.pTagInButtonScope;
          case "form":
            return t4.formTag || t4.pTagInButtonScope;
          case "li":
            return t4.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return t4.dlItemTagAutoclosing;
          case "button":
            return t4.buttonTagInScope;
          case "a":
            return t4.aTagInScope;
          case "nobr":
            return t4.nobrTagInScope;
        }
        return null;
      }(e5, n3), l3 = a3 || s3;
      if (l3) {
        var u3 = l3.tag, c3 = !!a3 + "|" + e5 + "|" + u3;
        if (!Ns2[c3]) {
          Ns2[c3] = true;
          var d2 = e5, f2 = "";
          if (e5 === "#text" ? /\S/.test(t3) ? d2 = "Text nodes" : (d2 = "Whitespace text nodes", f2 = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : d2 = "<" + e5 + ">", a3) {
            var p2 = "";
            u3 === "table" && e5 === "tr" && (p2 += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), i2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", d2, u3, f2, p2);
          } else
            i2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", d2, u3);
        }
      }
    };
    var As2 = "$?", zs2 = "$!", Ms2 = null, Ls2 = null;
    function Fs2(e5, t3) {
      switch (e5) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!t3.autoFocus;
      }
      return false;
    }
    function $s2(e5) {
      var t3;
      Ms2 = Wo2, t3 = ki2(), Ls2 = { focusedElem: t3, selectionRange: xi2(t3) ? _i2(t3) : null };
      return qo2(false), null;
    }
    function Bs2(e5, t3, n3, r3, o3) {
      var a3 = r3;
      if (Cs2(e5, null, a3.ancestorInfo), typeof t3.children == "string" || typeof t3.children == "number") {
        var s3 = "" + t3.children, l3 = js2(a3.ancestorInfo, e5);
        Cs2(null, s3, l3);
      }
      var u3 = function(e6, t4, n4, r4) {
        var o4, a4, s4 = vs2(n4), l4 = r4;
        if (l4 === ps2 && (l4 = Mt2(e6)), l4 === ps2) {
          if ((o4 = dn2(e6, t4)) || e6 === e6.toLowerCase() || i2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e6), e6 === "script") {
            var u4 = s4.createElement("div");
            u4.innerHTML = "<script><\/script>";
            var c3 = u4.firstChild;
            a4 = u4.removeChild(c3);
          } else if (typeof t4.is == "string")
            a4 = s4.createElement(e6, { is: t4.is });
          else if (a4 = s4.createElement(e6), e6 === "select") {
            var d2 = a4;
            t4.multiple ? d2.multiple = true : t4.size && (d2.size = t4.size);
          }
        } else
          a4 = s4.createElementNS(l4, e6);
        return l4 === ps2 && (o4 || Object.prototype.toString.call(a4) !== "[object HTMLUnknownElement]" || Object.prototype.hasOwnProperty.call(Gi2, e6) || (Gi2[e6] = true, i2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e6))), a4;
      }(e5, t3, n3, a3.namespace);
      return dl2(o3, u3), yl2(u3, t3), u3;
    }
    function Vs2(e5, t3) {
      return e5 === "textarea" || e5 === "option" || e5 === "noscript" || typeof t3.children == "string" || typeof t3.children == "number" || typeof t3.dangerouslySetInnerHTML == "object" && t3.dangerouslySetInnerHTML !== null && t3.dangerouslySetInnerHTML.__html != null;
    }
    function Us2(e5, t3, n3, r3) {
      Cs2(null, e5, n3.ancestorInfo);
      var o3 = function(e6, t4) {
        return vs2(t4).createTextNode(e6);
      }(e5, t3);
      return dl2(r3, o3), o3;
    }
    var Hs2 = typeof setTimeout == "function" ? setTimeout : void 0, Ws2 = typeof clearTimeout == "function" ? clearTimeout : void 0;
    function qs2(e5) {
      Vt2(e5, "");
    }
    function Ks2(e5, t3) {
      e5.removeChild(t3);
    }
    function Ys2(e5) {
      var t3 = (e5 = e5).style;
      typeof t3.setProperty == "function" ? t3.setProperty("display", "none", "important") : t3.display = "none";
    }
    function Xs2(e5, t3) {
      e5 = e5;
      var n3 = t3.style, r3 = n3 != null && n3.hasOwnProperty("display") ? n3.display : null;
      e5.style.display = qt2("display", r3);
    }
    function Gs2(e5, t3) {
      e5.nodeValue = t3;
    }
    function Qs2(e5) {
      if (e5.nodeType === 1)
        e5.textContent = "";
      else if (e5.nodeType === 9) {
        var t3 = e5.body;
        t3 != null && (t3.textContent = "");
      }
    }
    function Js2(e5) {
      return e5.data === zs2;
    }
    function Zs2(e5) {
      for (; e5 != null; e5 = e5.nextSibling) {
        var t3 = e5.nodeType;
        if (t3 === 1 || t3 === 3)
          break;
      }
      return e5;
    }
    function el2(e5) {
      return Zs2(e5.nextSibling);
    }
    function tl2(e5) {
      return Zs2(e5.firstChild);
    }
    function nl2(e5, t3, n3, r3, o3, a3) {
      return dl2(a3, e5), yl2(e5, n3), function(e6, t4, n4, r4, o4) {
        var a4, i3;
        switch (Qi2 = n4.suppressHydrationWarning === true, a4 = dn2(t4, n4), Ji2(t4, n4), t4) {
          case "dialog":
            Li2("cancel", e6), Li2("close", e6);
            break;
          case "iframe":
          case "object":
          case "embed":
            Li2("load", e6);
            break;
          case "video":
          case "audio":
            for (var s3 = 0; s3 < Ri2.length; s3++)
              Li2(Ri2[s3], e6);
            break;
          case "source":
            Li2("error", e6);
            break;
          case "img":
          case "image":
          case "link":
            Li2("error", e6), Li2("load", e6);
            break;
          case "details":
            Li2("toggle", e6);
            break;
          case "input":
            ct2(e6, n4), Li2("invalid", e6);
            break;
          case "option":
            wt2(0, n4);
            break;
          case "select":
            Pt2(e6, n4), Li2("invalid", e6);
            break;
          case "textarea":
            Ot2(e6, n4), Li2("invalid", e6);
        }
        cn2(t4, n4), i3 = /* @__PURE__ */ new Set();
        for (var l3 = e6.attributes, u3 = 0; u3 < l3.length; u3++)
          switch (l3[u3].name.toLowerCase()) {
            case "data-reactroot":
            case "value":
            case "checked":
            case "selected":
              break;
            default:
              i3.add(l3[u3].name);
          }
        var c3, d2 = null;
        for (var f2 in n4)
          if (n4.hasOwnProperty(f2)) {
            var p2 = n4[f2];
            if (f2 === ds2)
              typeof p2 == "string" ? e6.textContent !== p2 && (Qi2 || Zi2(e6.textContent, p2), d2 = [ds2, p2]) : typeof p2 == "number" && e6.textContent !== "" + p2 && (Qi2 || Zi2(e6.textContent, p2), d2 = [ds2, "" + p2]);
            else if (x2.hasOwnProperty(f2))
              p2 != null && (typeof p2 != "function" && ns2(f2, p2), f2 === "onScroll" && Li2("scroll", e6));
            else if (typeof a4 == "boolean") {
              var h3 = void 0, m3 = L2(f2);
              if (Qi2)
                ;
              else if (f2 === ls2 || f2 === us2 || f2 === "value" || f2 === "checked" || f2 === "selected")
                ;
              else if (f2 === ss2) {
                var v3 = e6.innerHTML, g3 = p2 ? p2.__html : void 0;
                if (g3 != null) {
                  var y3 = as2(e6, g3);
                  y3 !== v3 && es2(f2, v3, y3);
                }
              } else if (f2 === fs2) {
                if (i3.delete(f2), rs2) {
                  var b3 = an2(p2);
                  b3 !== (h3 = e6.getAttribute("style")) && es2(f2, h3, b3);
                }
              } else if (a4)
                i3.delete(f2.toLowerCase()), p2 !== (h3 = K2(e6, f2, p2)) && es2(f2, h3, p2);
              else if (!A2(f2, m3, a4) && !M2(f2, p2, m3, a4)) {
                var w3 = false;
                if (m3 !== null)
                  i3.delete(m3.attributeName), h3 = q2(e6, f2, p2, m3);
                else {
                  var k3 = r4;
                  if (k3 === ps2 && (k3 = Mt2(t4)), k3 === ps2)
                    i3.delete(f2.toLowerCase());
                  else {
                    var S3 = (c3 = void 0, c3 = f2.toLowerCase(), fn2.hasOwnProperty(c3) && fn2[c3] || null);
                    S3 !== null && S3 !== f2 && (w3 = true, i3.delete(S3)), i3.delete(f2);
                  }
                  h3 = K2(e6, f2, p2);
                }
                p2 === h3 || w3 || es2(f2, h3, p2);
              }
            }
          }
        switch (i3.size > 0 && !Qi2 && ts2(i3), t4) {
          case "input":
            tt2(e6), pt2(e6, n4, true);
            break;
          case "textarea":
            tt2(e6), It2(e6);
            break;
          case "select":
          case "option":
            break;
          default:
            typeof n4.onClick == "function" && ys2(e6);
        }
        return d2;
      }(e5, t3, n3, o3.namespace);
    }
    function rl2(e5) {
      for (var t3 = e5.previousSibling, n3 = 0; t3; ) {
        if (t3.nodeType === 8) {
          var r3 = t3.data;
          if (r3 === "$" || r3 === zs2 || r3 === As2) {
            if (n3 === 0)
              return t3;
            n3--;
          } else
            r3 === "/$" && n3++;
        }
        t3 = t3.previousSibling;
      }
      return null;
    }
    var ol2 = 0;
    function al2(e5) {
      var t3 = "r:" + (ol2++).toString(36);
      return { toString: function() {
        return e5(), t3;
      }, valueOf: function() {
        return e5(), t3;
      } };
    }
    var il2 = Math.random().toString(36).slice(2), sl2 = "__reactFiber$" + il2, ll2 = "__reactProps$" + il2, ul2 = "__reactContainer$" + il2, cl2 = "__reactEvents$" + il2;
    function dl2(e5, t3) {
      t3[sl2] = e5;
    }
    function fl2(e5) {
      e5[ul2] = null;
    }
    function pl2(e5) {
      return !!e5[ul2];
    }
    function hl2(e5) {
      var t3 = e5[sl2];
      if (t3)
        return t3;
      for (var n3 = e5.parentNode; n3; ) {
        if (t3 = n3[ul2] || n3[sl2]) {
          var r3 = t3.alternate;
          if (t3.child !== null || r3 !== null && r3.child !== null)
            for (var o3 = rl2(e5); o3 !== null; ) {
              var a3 = o3[sl2];
              if (a3)
                return a3;
              o3 = rl2(o3);
            }
          return t3;
        }
        n3 = (e5 = n3).parentNode;
      }
      return null;
    }
    function ml2(e5) {
      var t3 = e5[sl2] || e5[ul2];
      return t3 && (t3.tag === 5 || t3.tag === 6 || t3.tag === d || t3.tag === 3) ? t3 : null;
    }
    function vl2(e5) {
      if (e5.tag === 5 || e5.tag === 6)
        return e5.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function gl2(e5) {
      return e5[ll2] || null;
    }
    function yl2(e5, t3) {
      e5[ll2] = t3;
    }
    function bl2(e5) {
      var t3 = e5[cl2];
      return t3 === void 0 && (t3 = e5[cl2] = /* @__PURE__ */ new Set()), t3;
    }
    var wl2 = {}, kl2 = o2.ReactDebugCurrentFrame;
    function xl2(e5) {
      if (e5) {
        var t3 = e5._owner, n3 = ze2(e5.type, e5._source, t3 ? t3.type : null);
        kl2.setExtraStackFrame(n3);
      } else
        kl2.setExtraStackFrame(null);
    }
    function Sl2(e5, t3, n3, r3, o3) {
      var a3 = Function.call.bind(Object.prototype.hasOwnProperty);
      for (var s3 in e5)
        if (a3(e5, s3)) {
          var l3 = void 0;
          try {
            if (typeof e5[s3] != "function") {
              var u3 = Error((r3 || "React class") + ": " + n3 + " type `" + s3 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e5[s3] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
              throw u3.name = "Invariant Violation", u3;
            }
            l3 = e5[s3](t3, s3, r3, n3, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
          } catch (e6) {
            l3 = e6;
          }
          !l3 || l3 instanceof Error || (xl2(o3), i2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", r3 || "React class", n3, s3, typeof l3), xl2(null)), l3 instanceof Error && !(l3.message in wl2) && (wl2[l3.message] = true, xl2(o3), i2("Failed %s type: %s", n3, l3.message), xl2(null));
        }
    }
    var _l2, El2 = [];
    _l2 = [];
    var Pl2, Cl2 = -1;
    function jl2(e5) {
      return { current: e5 };
    }
    function Ol2(e5, t3) {
      Cl2 < 0 ? i2("Unexpected pop.") : (t3 !== _l2[Cl2] && i2("Unexpected Fiber popped."), e5.current = El2[Cl2], El2[Cl2] = null, _l2[Cl2] = null, Cl2--);
    }
    function Tl2(e5, t3, n3) {
      Cl2++, El2[Cl2] = e5.current, _l2[Cl2] = n3, e5.current = t3;
    }
    Pl2 = {};
    var Il2 = {};
    Object.freeze(Il2);
    var Dl2 = jl2(Il2), Rl2 = jl2(false), Nl2 = Il2;
    function Al2(e5, t3, n3) {
      return n3 && Fl2(t3) ? Nl2 : Dl2.current;
    }
    function zl2(e5, t3, n3) {
      var r3 = e5.stateNode;
      r3.__reactInternalMemoizedUnmaskedChildContext = t3, r3.__reactInternalMemoizedMaskedChildContext = n3;
    }
    function Ml2(e5, t3) {
      var n3 = e5.type, r3 = n3.contextTypes;
      if (!r3)
        return Il2;
      var o3 = e5.stateNode;
      if (o3 && o3.__reactInternalMemoizedUnmaskedChildContext === t3)
        return o3.__reactInternalMemoizedMaskedChildContext;
      var a3 = {};
      for (var i3 in r3)
        a3[i3] = t3[i3];
      return Sl2(r3, a3, "context", $e2(n3) || "Unknown"), o3 && zl2(e5, t3, a3), a3;
    }
    function Ll2() {
      return Rl2.current;
    }
    function Fl2(e5) {
      var t3 = e5.childContextTypes;
      return t3 != null;
    }
    function $l2(e5) {
      Ol2(Rl2, e5), Ol2(Dl2, e5);
    }
    function Bl2(e5) {
      Ol2(Rl2, e5), Ol2(Dl2, e5);
    }
    function Vl2(e5, t3, n3) {
      if (Dl2.current !== Il2)
        throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
      Tl2(Dl2, t3, e5), Tl2(Rl2, n3, e5);
    }
    function Ul2(e5, n3, r3) {
      var o3 = e5.stateNode, a3 = n3.childContextTypes;
      if (typeof o3.getChildContext != "function") {
        var s3 = $e2(n3) || "Unknown";
        return Pl2[s3] || (Pl2[s3] = true, i2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", s3, s3)), r3;
      }
      var l3 = o3.getChildContext();
      for (var u3 in l3)
        if (!(u3 in a3))
          throw Error(($e2(n3) || "Unknown") + '.getChildContext(): key "' + u3 + '" is not defined in childContextTypes.');
      return Sl2(a3, l3, "child context", $e2(n3) || "Unknown"), t2({}, r3, l3);
    }
    function Hl2(e5) {
      var t3 = e5.stateNode, n3 = t3 && t3.__reactInternalMemoizedMergedChildContext || Il2;
      return Nl2 = Dl2.current, Tl2(Dl2, n3, e5), Tl2(Rl2, Rl2.current, e5), true;
    }
    function Wl2(e5, t3, n3) {
      var r3 = e5.stateNode;
      if (!r3)
        throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
      if (n3) {
        var o3 = Ul2(e5, t3, Nl2);
        r3.__reactInternalMemoizedMergedChildContext = o3, Ol2(Rl2, e5), Ol2(Dl2, e5), Tl2(Dl2, o3, e5), Tl2(Rl2, n3, e5);
      } else
        Ol2(Rl2, e5), Tl2(Rl2, n3, e5);
    }
    function ql2(e5) {
      if (!function(e6) {
        return br2(e6) === e6;
      }(e5) || e5.tag !== 1)
        throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
      var t3 = e5;
      do {
        switch (t3.tag) {
          case 3:
            return t3.stateNode.context;
          case 1:
            if (Fl2(t3.type))
              return t3.stateNode.__reactInternalMemoizedMergedChildContext;
        }
        t3 = t3.return;
      } while (t3 !== null);
      throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    var Kl2 = null, Yl2 = null, Xl2 = false, Gl2 = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined";
    function Ql2(e5, t3) {
      if (Yl2 && typeof Yl2.onCommitFiberRoot == "function")
        try {
          var n3 = (e5.current.flags & ur2) === ur2;
          Yl2.onCommitFiberRoot(Kl2, e5, t3, n3);
        } catch (e6) {
          Xl2 || (Xl2 = true, i2("React instrumentation encountered an error: %s", e6));
        }
    }
    var Jl2 = n2.unstable_runWithPriority, Zl2 = n2.unstable_scheduleCallback, eu2 = n2.unstable_cancelCallback, tu2 = n2.unstable_shouldYield, nu2 = n2.unstable_requestPaint, ru2 = n2.unstable_now, ou2 = n2.unstable_getCurrentPriorityLevel, au2 = n2.unstable_ImmediatePriority, iu2 = n2.unstable_UserBlockingPriority, su2 = n2.unstable_NormalPriority, lu2 = n2.unstable_LowPriority, uu2 = n2.unstable_IdlePriority;
    if (r2.__interactionsRef == null || r2.__interactionsRef.current == null)
      throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
    var cu2 = {}, du2 = 99, fu2 = 98, pu2 = 97, hu2 = tu2, mu2 = nu2 !== void 0 ? nu2 : function() {
    }, vu2 = null, gu2 = null, yu2 = false, bu2 = ru2(), wu2 = bu2 < 1e4 ? ru2 : function() {
      return ru2() - bu2;
    };
    function ku2() {
      switch (ou2()) {
        case au2:
          return du2;
        case iu2:
          return fu2;
        case su2:
          return pu2;
        case lu2:
          return 96;
        case uu2:
          return 95;
        default:
          throw Error("Unknown priority level.");
      }
    }
    function xu2(e5) {
      switch (e5) {
        case du2:
          return au2;
        case fu2:
          return iu2;
        case pu2:
          return su2;
        case 96:
          return lu2;
        case 95:
          return uu2;
        default:
          throw Error("Unknown priority level.");
      }
    }
    function Su2(e5, t3) {
      var n3 = xu2(e5);
      return Jl2(n3, t3);
    }
    function _u2(e5, t3, n3) {
      var r3 = xu2(e5);
      return Zl2(r3, t3, n3);
    }
    function Eu2(e5) {
      e5 !== cu2 && eu2(e5);
    }
    function Pu2() {
      if (gu2 !== null) {
        var e5 = gu2;
        gu2 = null, eu2(e5);
      }
      Cu2();
    }
    function Cu2() {
      if (!yu2 && vu2 !== null) {
        yu2 = true;
        var e5 = 0;
        try {
          var t3 = vu2;
          Su2(du2, function() {
            for (; e5 < t3.length; e5++) {
              var n3 = t3[e5];
              do {
                n3 = n3(true);
              } while (n3 !== null);
            }
          }), vu2 = null;
        } catch (t4) {
          throw vu2 !== null && (vu2 = vu2.slice(e5 + 1)), Zl2(au2, Pu2), t4;
        } finally {
          yu2 = false;
        }
      }
    }
    var ju2 = "17.0.2", Ou2 = o2.ReactCurrentBatchConfig;
    var Tu2 = { recordUnsafeLifecycleWarnings: function(e5, t3) {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function(e5, t3) {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } }, Iu2 = function(e5) {
      var t3 = [];
      return e5.forEach(function(e6) {
        t3.push(e6);
      }), t3.sort().join(", ");
    }, Du2 = [], Ru2 = [], Nu2 = [], Au2 = [], zu2 = [], Mu2 = [], Lu2 = /* @__PURE__ */ new Set();
    Tu2.recordUnsafeLifecycleWarnings = function(e5, t3) {
      Lu2.has(e5.type) || (typeof t3.componentWillMount == "function" && t3.componentWillMount.__suppressDeprecationWarning !== true && Du2.push(e5), 1 & e5.mode && typeof t3.UNSAFE_componentWillMount == "function" && Ru2.push(e5), typeof t3.componentWillReceiveProps == "function" && t3.componentWillReceiveProps.__suppressDeprecationWarning !== true && Nu2.push(e5), 1 & e5.mode && typeof t3.UNSAFE_componentWillReceiveProps == "function" && Au2.push(e5), typeof t3.componentWillUpdate == "function" && t3.componentWillUpdate.__suppressDeprecationWarning !== true && zu2.push(e5), 1 & e5.mode && typeof t3.UNSAFE_componentWillUpdate == "function" && Mu2.push(e5));
    }, Tu2.flushPendingUnsafeLifecycleWarnings = function() {
      var e5 = /* @__PURE__ */ new Set();
      Du2.length > 0 && (Du2.forEach(function(t4) {
        e5.add($e2(t4.type) || "Component"), Lu2.add(t4.type);
      }), Du2 = []);
      var t3 = /* @__PURE__ */ new Set();
      Ru2.length > 0 && (Ru2.forEach(function(e6) {
        t3.add($e2(e6.type) || "Component"), Lu2.add(e6.type);
      }), Ru2 = []);
      var n3 = /* @__PURE__ */ new Set();
      Nu2.length > 0 && (Nu2.forEach(function(e6) {
        n3.add($e2(e6.type) || "Component"), Lu2.add(e6.type);
      }), Nu2 = []);
      var r3 = /* @__PURE__ */ new Set();
      Au2.length > 0 && (Au2.forEach(function(e6) {
        r3.add($e2(e6.type) || "Component"), Lu2.add(e6.type);
      }), Au2 = []);
      var o3 = /* @__PURE__ */ new Set();
      zu2.length > 0 && (zu2.forEach(function(e6) {
        o3.add($e2(e6.type) || "Component"), Lu2.add(e6.type);
      }), zu2 = []);
      var s3 = /* @__PURE__ */ new Set();
      (Mu2.length > 0 && (Mu2.forEach(function(e6) {
        s3.add($e2(e6.type) || "Component"), Lu2.add(e6.type);
      }), Mu2 = []), t3.size > 0) && i2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", Iu2(t3));
      r3.size > 0 && i2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", Iu2(r3));
      s3.size > 0 && i2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", Iu2(s3));
      e5.size > 0 && a2("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", Iu2(e5));
      n3.size > 0 && a2("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", Iu2(n3));
      o3.size > 0 && a2("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", Iu2(o3));
    };
    var Fu2 = /* @__PURE__ */ new Map(), $u2 = /* @__PURE__ */ new Set();
    function Bu2(e5, n3) {
      if (e5 && e5.defaultProps) {
        var r3 = t2({}, n3), o3 = e5.defaultProps;
        for (var a3 in o3)
          r3[a3] === void 0 && (r3[a3] = o3[a3]);
        return r3;
      }
      return n3;
    }
    Tu2.recordLegacyContextWarning = function(e5, t3) {
      var n3 = function(e6) {
        for (var t4 = null, n4 = e6; n4 !== null; )
          1 & n4.mode && (t4 = n4), n4 = n4.return;
        return t4;
      }(e5);
      if (n3 !== null) {
        if (!$u2.has(e5.type)) {
          var r3 = Fu2.get(n3);
          (e5.type.contextTypes != null || e5.type.childContextTypes != null || t3 !== null && typeof t3.getChildContext == "function") && (r3 === void 0 && (r3 = [], Fu2.set(n3, r3)), r3.push(e5));
        }
      } else
        i2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
    }, Tu2.flushLegacyContextWarning = function() {
      Fu2.forEach(function(e5, t3) {
        if (e5.length !== 0) {
          var n3 = e5[0], r3 = /* @__PURE__ */ new Set();
          e5.forEach(function(e6) {
            r3.add($e2(e6.type) || "Component"), $u2.add(e6.type);
          });
          var o3 = Iu2(r3);
          try {
            Ke2(n3), i2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", o3);
          } finally {
            qe2();
          }
        }
      });
    }, Tu2.discardPendingWarnings = function() {
      Du2 = [], Ru2 = [], Nu2 = [], Au2 = [], zu2 = [], Mu2 = [], Fu2 = /* @__PURE__ */ new Map();
    };
    var Vu2, Uu2 = 1073741823, Hu2 = jl2(null);
    Vu2 = {};
    var Wu2 = null, qu2 = null, Ku2 = null, Yu2 = false;
    function Xu2() {
      Wu2 = null, qu2 = null, Ku2 = null, Yu2 = false;
    }
    function Gu2() {
      Yu2 = true;
    }
    function Qu2() {
      Yu2 = false;
    }
    function Ju2(e5, t3) {
      var n3 = e5.type._context;
      Tl2(Hu2, n3._currentValue, e5), n3._currentValue = t3, n3._currentRenderer !== void 0 && n3._currentRenderer !== null && n3._currentRenderer !== Vu2 && i2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), n3._currentRenderer = Vu2;
    }
    function Zu2(e5) {
      var t3 = Hu2.current;
      Ol2(Hu2, e5), e5.type._context._currentValue = t3;
    }
    function ec2(e5, t3) {
      for (var n3 = e5; n3 !== null; ) {
        var r3 = n3.alternate;
        if (Ro2(n3.childLanes, t3)) {
          if (r3 === null || Ro2(r3.childLanes, t3))
            break;
          r3.childLanes = No2(r3.childLanes, t3);
        } else
          n3.childLanes = No2(n3.childLanes, t3), r3 !== null && (r3.childLanes = No2(r3.childLanes, t3));
        n3 = n3.return;
      }
    }
    function tc2(e5, t3) {
      Wu2 = e5, qu2 = null, Ku2 = null;
      var n3 = e5.dependencies;
      n3 !== null && (n3.firstContext !== null && (Do2(n3.lanes, t3) && oh2(), n3.firstContext = null));
    }
    function nc2(e5, t3) {
      if (Yu2 && i2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Ku2 === e5)
        ;
      else if (t3 === false || t3 === 0)
        ;
      else {
        var n3;
        typeof t3 != "number" || t3 === Uu2 ? (Ku2 = e5, n3 = Uu2) : n3 = t3;
        var r3 = { context: e5, observedBits: n3, next: null };
        if (qu2 === null) {
          if (Wu2 === null)
            throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          qu2 = r3, Wu2.dependencies = { lanes: 0, firstContext: r3, responders: null };
        } else
          qu2 = qu2.next = r3;
      }
      return e5._currentValue;
    }
    var rc2, oc2, ac2 = 2, ic2 = false;
    function sc2(e5) {
      var t3 = { baseState: e5.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
      e5.updateQueue = t3;
    }
    function lc2(e5, t3) {
      var n3 = t3.updateQueue, r3 = e5.updateQueue;
      if (n3 === r3) {
        var o3 = { baseState: r3.baseState, firstBaseUpdate: r3.firstBaseUpdate, lastBaseUpdate: r3.lastBaseUpdate, shared: r3.shared, effects: r3.effects };
        t3.updateQueue = o3;
      }
    }
    function uc2(e5, t3) {
      return { eventTime: e5, lane: t3, tag: 0, payload: null, callback: null, next: null };
    }
    function cc2(e5, t3) {
      var n3 = e5.updateQueue;
      if (n3 !== null) {
        var r3 = n3.shared, o3 = r3.pending;
        o3 === null ? t3.next = t3 : (t3.next = o3.next, o3.next = t3), r3.pending = t3, oc2 !== r3 || rc2 || (i2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), rc2 = true);
      }
    }
    function dc2(e5, t3) {
      var n3 = e5.updateQueue, r3 = e5.alternate;
      if (r3 !== null) {
        var o3 = r3.updateQueue;
        if (n3 === o3) {
          var a3 = null, i3 = null, s3 = n3.firstBaseUpdate;
          if (s3 !== null) {
            var l3 = s3;
            do {
              var u3 = { eventTime: l3.eventTime, lane: l3.lane, tag: l3.tag, payload: l3.payload, callback: l3.callback, next: null };
              i3 === null ? a3 = i3 = u3 : (i3.next = u3, i3 = u3), l3 = l3.next;
            } while (l3 !== null);
            i3 === null ? a3 = i3 = t3 : (i3.next = t3, i3 = t3);
          } else
            a3 = i3 = t3;
          return n3 = { baseState: o3.baseState, firstBaseUpdate: a3, lastBaseUpdate: i3, shared: o3.shared, effects: o3.effects }, void (e5.updateQueue = n3);
        }
      }
      var c3 = n3.lastBaseUpdate;
      c3 === null ? n3.firstBaseUpdate = t3 : c3.next = t3, n3.lastBaseUpdate = t3;
    }
    function fc2(e5, n3, r3, o3, a3, i3) {
      switch (r3.tag) {
        case 1:
          var s3 = r3.payload;
          if (typeof s3 == "function") {
            Gu2();
            var l3 = s3.call(i3, o3, a3);
            if (1 & e5.mode) {
              _e2();
              try {
                s3.call(i3, o3, a3);
              } finally {
                Ee2();
              }
            }
            return Qu2(), l3;
          }
          return s3;
        case 3:
          e5.flags = -4097 & e5.flags | ur2;
        case 0:
          var u3, c3 = r3.payload;
          if (typeof c3 == "function") {
            if (Gu2(), u3 = c3.call(i3, o3, a3), 1 & e5.mode) {
              _e2();
              try {
                c3.call(i3, o3, a3);
              } finally {
                Ee2();
              }
            }
            Qu2();
          } else
            u3 = c3;
          return u3 == null ? o3 : t2({}, o3, u3);
        case ac2:
          return ic2 = true, o3;
      }
      return o3;
    }
    function pc2(e5, t3, n3, r3) {
      var o3 = e5.updateQueue;
      ic2 = false, oc2 = o3.shared;
      var a3 = o3.firstBaseUpdate, i3 = o3.lastBaseUpdate, s3 = o3.shared.pending;
      if (s3 !== null) {
        o3.shared.pending = null;
        var l3 = s3, u3 = l3.next;
        l3.next = null, i3 === null ? a3 = u3 : i3.next = u3, i3 = l3;
        var c3 = e5.alternate;
        if (c3 !== null) {
          var d2 = c3.updateQueue, f2 = d2.lastBaseUpdate;
          f2 !== i3 && (f2 === null ? d2.firstBaseUpdate = u3 : f2.next = u3, d2.lastBaseUpdate = l3);
        }
      }
      if (a3 !== null) {
        for (var p2 = o3.baseState, h3 = 0, m3 = null, v3 = null, g3 = null, y3 = a3; ; ) {
          var b3 = y3.lane, w3 = y3.eventTime;
          if (Ro2(r3, b3)) {
            if (g3 !== null) {
              var k3 = { eventTime: w3, lane: 0, tag: y3.tag, payload: y3.payload, callback: y3.callback, next: null };
              g3 = g3.next = k3;
            }
            if (p2 = fc2(e5, 0, y3, p2, t3, n3), y3.callback !== null) {
              e5.flags |= 32;
              var x3 = o3.effects;
              x3 === null ? o3.effects = [y3] : x3.push(y3);
            }
          } else {
            var S3 = { eventTime: w3, lane: b3, tag: y3.tag, payload: y3.payload, callback: y3.callback, next: null };
            g3 === null ? (v3 = g3 = S3, m3 = p2) : g3 = g3.next = S3, h3 = No2(h3, b3);
          }
          if ((y3 = y3.next) === null) {
            if ((s3 = o3.shared.pending) === null)
              break;
            var _3 = s3, E3 = _3.next;
            _3.next = null, y3 = E3, o3.lastBaseUpdate = _3, o3.shared.pending = null;
          }
        }
        g3 === null && (m3 = p2), o3.baseState = m3, o3.firstBaseUpdate = v3, o3.lastBaseUpdate = g3, tv(h3), e5.lanes = h3, e5.memoizedState = p2;
      }
      oc2 = null;
    }
    function hc2(e5, t3) {
      if (typeof e5 != "function")
        throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + e5);
      e5.call(t3);
    }
    function mc2() {
      ic2 = false;
    }
    function vc2() {
      return ic2;
    }
    function gc2(e5, t3, n3) {
      var r3 = t3.effects;
      if (t3.effects = null, r3 !== null)
        for (var o3 = 0; o3 < r3.length; o3++) {
          var a3 = r3[o3], i3 = a3.callback;
          i3 !== null && (a3.callback = null, hc2(i3, n3));
        }
    }
    rc2 = false, oc2 = null;
    var yc2, bc2, wc2, kc2, xc2, Sc2, _c2, Ec2, Pc2, Cc2, jc2 = {}, Oc2 = Array.isArray, Tc2 = new e4.Component().refs;
    yc2 = /* @__PURE__ */ new Set(), bc2 = /* @__PURE__ */ new Set(), wc2 = /* @__PURE__ */ new Set(), kc2 = /* @__PURE__ */ new Set(), Ec2 = /* @__PURE__ */ new Set(), xc2 = /* @__PURE__ */ new Set(), Pc2 = /* @__PURE__ */ new Set(), Cc2 = /* @__PURE__ */ new Set();
    var Ic2 = /* @__PURE__ */ new Set();
    function Dc2(e5, n3, r3, o3) {
      var a3 = e5.memoizedState;
      if (1 & e5.mode) {
        _e2();
        try {
          r3(o3, a3);
        } finally {
          Ee2();
        }
      }
      var i3 = r3(o3, a3);
      Sc2(n3, i3);
      var s3 = i3 == null ? a3 : t2({}, a3, i3);
      (e5.memoizedState = s3, e5.lanes === 0) && (e5.updateQueue.baseState = s3);
    }
    _c2 = function(e5, t3) {
      if (e5 !== null && typeof e5 != "function") {
        var n3 = t3 + "_" + e5;
        Ic2.has(n3) || (Ic2.add(n3), i2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t3, e5));
      }
    }, Sc2 = function(e5, t3) {
      if (t3 === void 0) {
        var n3 = $e2(e5) || "Component";
        xc2.has(n3) || (xc2.add(n3), i2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", n3));
      }
    }, Object.defineProperty(jc2, "_processChildContext", { enumerable: false, value: function() {
      throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
    } }), Object.freeze(jc2);
    var Rc2, Nc2, Ac2, zc2, Mc2, Lc2 = { isMounted: function(e5) {
      var t3 = yr2.current;
      if (t3 !== null && t3.tag === 1) {
        var n3 = t3, r3 = n3.stateNode;
        r3._warnedAboutRefsInRender || i2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", $e2(n3.type) || "A component"), r3._warnedAboutRefsInRender = true;
      }
      var o3 = or2(e5);
      return !!o3 && br2(o3) === o3;
    }, enqueueSetState: function(e5, t3, n3) {
      var r3 = or2(e5), o3 = Am(), a3 = zm(r3), i3 = uc2(o3, a3);
      i3.payload = t3, n3 != null && (_c2(n3, "setState"), i3.callback = n3), cc2(r3, i3), Lm(r3, a3, o3);
    }, enqueueReplaceState: function(e5, t3, n3) {
      var r3 = or2(e5), o3 = Am(), a3 = zm(r3), i3 = uc2(o3, a3);
      i3.tag = 1, i3.payload = t3, n3 != null && (_c2(n3, "replaceState"), i3.callback = n3), cc2(r3, i3), Lm(r3, a3, o3);
    }, enqueueForceUpdate: function(e5, t3) {
      var n3 = or2(e5), r3 = Am(), o3 = zm(n3), a3 = uc2(r3, o3);
      a3.tag = ac2, t3 != null && (_c2(t3, "forceUpdate"), a3.callback = t3), cc2(n3, a3), Lm(n3, o3, r3);
    } };
    function Fc2(e5, t3, n3, r3, o3, a3, s3) {
      var l3 = e5.stateNode;
      if (typeof l3.shouldComponentUpdate == "function") {
        if (1 & e5.mode) {
          _e2();
          try {
            l3.shouldComponentUpdate(r3, a3, s3);
          } finally {
            Ee2();
          }
        }
        var u3 = l3.shouldComponentUpdate(r3, a3, s3);
        return u3 === void 0 && i2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", $e2(t3) || "Component"), u3;
      }
      return !t3.prototype || !t3.prototype.isPureReactComponent || (!fi2(n3, r3) || !fi2(o3, a3));
    }
    function $c2(e5, t3) {
      var n3;
      t3.updater = Lc2, e5.stateNode = t3, n3 = e5, t3._reactInternals = n3, t3._reactInternalInstance = jc2;
    }
    function Bc2(e5, t3, n3) {
      var r3 = false, o3 = Il2, a3 = Il2, s3 = t3.contextType;
      if ("contextType" in t3 && (!(s3 === null || s3 !== void 0 && s3.$$typeof === te2 && s3._context === void 0) && !Cc2.has(t3))) {
        Cc2.add(t3);
        var l3 = "";
        l3 = s3 === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof s3 != "object" ? " However, it is set to a " + typeof s3 + "." : s3.$$typeof === ee2 ? " Did you accidentally pass the Context.Provider instead?" : s3._context !== void 0 ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(s3).join(", ") + "}.", i2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", $e2(t3) || "Component", l3);
      }
      if (typeof s3 == "object" && s3 !== null)
        a3 = nc2(s3);
      else {
        o3 = Al2(0, t3, true);
        var u3 = t3.contextTypes;
        a3 = (r3 = u3 != null) ? Ml2(e5, o3) : Il2;
      }
      if (1 & e5.mode) {
        _e2();
        try {
          new t3(n3, a3);
        } finally {
          Ee2();
        }
      }
      var c3 = new t3(n3, a3), d2 = e5.memoizedState = c3.state !== null && c3.state !== void 0 ? c3.state : null;
      if ($c2(e5, c3), typeof t3.getDerivedStateFromProps == "function" && d2 === null) {
        var f2 = $e2(t3) || "Component";
        bc2.has(f2) || (bc2.add(f2), i2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", f2, c3.state === null ? "null" : "undefined", f2));
      }
      if (typeof t3.getDerivedStateFromProps == "function" || typeof c3.getSnapshotBeforeUpdate == "function") {
        var p2 = null, h3 = null, m3 = null;
        if (typeof c3.componentWillMount == "function" && c3.componentWillMount.__suppressDeprecationWarning !== true ? p2 = "componentWillMount" : typeof c3.UNSAFE_componentWillMount == "function" && (p2 = "UNSAFE_componentWillMount"), typeof c3.componentWillReceiveProps == "function" && c3.componentWillReceiveProps.__suppressDeprecationWarning !== true ? h3 = "componentWillReceiveProps" : typeof c3.UNSAFE_componentWillReceiveProps == "function" && (h3 = "UNSAFE_componentWillReceiveProps"), typeof c3.componentWillUpdate == "function" && c3.componentWillUpdate.__suppressDeprecationWarning !== true ? m3 = "componentWillUpdate" : typeof c3.UNSAFE_componentWillUpdate == "function" && (m3 = "UNSAFE_componentWillUpdate"), p2 !== null || h3 !== null || m3 !== null) {
          var v3 = $e2(t3) || "Component", g3 = typeof t3.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
          kc2.has(v3) || (kc2.add(v3), i2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", v3, g3, p2 !== null ? "\n  " + p2 : "", h3 !== null ? "\n  " + h3 : "", m3 !== null ? "\n  " + m3 : ""));
        }
      }
      return r3 && zl2(e5, o3, a3), c3;
    }
    function Vc2(e5, t3, n3, r3) {
      var o3 = t3.state;
      if (typeof t3.componentWillReceiveProps == "function" && t3.componentWillReceiveProps(n3, r3), typeof t3.UNSAFE_componentWillReceiveProps == "function" && t3.UNSAFE_componentWillReceiveProps(n3, r3), t3.state !== o3) {
        var a3 = $e2(e5.type) || "Component";
        yc2.has(a3) || (yc2.add(a3), i2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", a3)), Lc2.enqueueReplaceState(t3, t3.state, null);
      }
    }
    function Uc2(e5, t3, n3, r3) {
      !function(e6, t4, n4) {
        var r4 = e6.stateNode, o4 = $e2(t4) || "Component";
        r4.render || (t4.prototype && typeof t4.prototype.render == "function" ? i2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", o4) : i2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", o4)), !r4.getInitialState || r4.getInitialState.isReactClassApproved || r4.state || i2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", o4), r4.getDefaultProps && !r4.getDefaultProps.isReactClassApproved && i2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", o4), r4.propTypes && i2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", o4), r4.contextType && i2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", o4), r4.contextTypes && i2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", o4), t4.contextType && t4.contextTypes && !Pc2.has(t4) && (Pc2.add(t4), i2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", o4)), typeof r4.componentShouldUpdate == "function" && i2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", o4), t4.prototype && t4.prototype.isPureReactComponent && r4.shouldComponentUpdate !== void 0 && i2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", $e2(t4) || "A pure component"), typeof r4.componentDidUnmount == "function" && i2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", o4), typeof r4.componentDidReceiveProps == "function" && i2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", o4), typeof r4.componentWillRecieveProps == "function" && i2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", o4), typeof r4.UNSAFE_componentWillRecieveProps == "function" && i2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", o4);
        var a4 = r4.props !== n4;
        r4.props !== void 0 && a4 && i2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", o4, o4), r4.defaultProps && i2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", o4, o4), typeof r4.getSnapshotBeforeUpdate != "function" || typeof r4.componentDidUpdate == "function" || wc2.has(t4) || (wc2.add(t4), i2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", $e2(t4))), typeof r4.getDerivedStateFromProps == "function" && i2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o4), typeof r4.getDerivedStateFromError == "function" && i2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o4), typeof t4.getSnapshotBeforeUpdate == "function" && i2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", o4);
        var s4 = r4.state;
        s4 && (typeof s4 != "object" || Oc2(s4)) && i2("%s.state: must be set to an object or null", o4), typeof r4.getChildContext == "function" && typeof t4.childContextTypes != "object" && i2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", o4);
      }(e5, t3, n3);
      var o3 = e5.stateNode;
      o3.props = n3, o3.state = e5.memoizedState, o3.refs = Tc2, sc2(e5);
      var a3 = t3.contextType;
      if (typeof a3 == "object" && a3 !== null)
        o3.context = nc2(a3);
      else {
        var s3 = Al2(0, t3, true);
        o3.context = Ml2(e5, s3);
      }
      if (o3.state === n3) {
        var l3 = $e2(t3) || "Component";
        Ec2.has(l3) || (Ec2.add(l3), i2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", l3));
      }
      1 & e5.mode && Tu2.recordLegacyContextWarning(e5, o3), Tu2.recordUnsafeLifecycleWarnings(e5, o3), pc2(e5, n3, o3, r3), o3.state = e5.memoizedState;
      var u3 = t3.getDerivedStateFromProps;
      typeof u3 == "function" && (Dc2(e5, t3, u3, n3), o3.state = e5.memoizedState), typeof t3.getDerivedStateFromProps == "function" || typeof o3.getSnapshotBeforeUpdate == "function" || typeof o3.UNSAFE_componentWillMount != "function" && typeof o3.componentWillMount != "function" || (!function(e6, t4) {
        var n4 = t4.state;
        typeof t4.componentWillMount == "function" && t4.componentWillMount(), typeof t4.UNSAFE_componentWillMount == "function" && t4.UNSAFE_componentWillMount(), n4 !== t4.state && (i2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", $e2(e6.type) || "Component"), Lc2.enqueueReplaceState(t4, t4.state, null));
      }(e5, o3), pc2(e5, n3, o3, r3), o3.state = e5.memoizedState), typeof o3.componentDidMount == "function" && (e5.flags |= 4);
    }
    var Hc2;
    Rc2 = false, Nc2 = false, Ac2 = {}, zc2 = {}, Mc2 = {}, Hc2 = function(e5, t3) {
      if (e5 !== null && typeof e5 == "object" && e5._store && !e5._store.validated && e5.key == null) {
        if (typeof e5._store != "object")
          throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e5._store.validated = true;
        var n3 = $e2(t3.type) || "Component";
        zc2[n3] || (zc2[n3] = true, i2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    var Wc2 = Array.isArray;
    function qc2(e5, t3, n3) {
      var r3 = n3.ref;
      if (r3 !== null && typeof r3 != "function" && typeof r3 != "object") {
        if (1 & e5.mode && (!n3._owner || !n3._self || n3._owner.stateNode === n3._self)) {
          var o3 = $e2(e5.type) || "Component";
          Ac2[o3] || (i2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', r3), Ac2[o3] = true);
        }
        if (n3._owner) {
          var a3, s3 = n3._owner;
          if (s3) {
            var l3 = s3;
            if (l3.tag !== 1)
              throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            a3 = l3.stateNode;
          }
          if (!a3)
            throw Error("Missing owner for string ref " + r3 + ". This error is likely caused by a bug in React. Please file an issue.");
          var u3 = "" + r3;
          if (t3 !== null && t3.ref !== null && typeof t3.ref == "function" && t3.ref._stringRef === u3)
            return t3.ref;
          var c3 = function(e6) {
            var t4 = a3.refs;
            t4 === Tc2 && (t4 = a3.refs = {}), e6 === null ? delete t4[u3] : t4[u3] = e6;
          };
          return c3._stringRef = u3, c3;
        }
        if (typeof r3 != "string")
          throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
        if (!n3._owner)
          throw Error("Element ref was specified as a string (" + r3 + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
      }
      return r3;
    }
    function Kc2(e5, t3) {
      if (e5.type !== "textarea")
        throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(t3) === "[object Object]" ? "object with keys {" + Object.keys(t3).join(", ") + "}" : t3) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Yc2(e5) {
      var t3 = $e2(e5.type) || "Component";
      Mc2[t3] || (Mc2[t3] = true, i2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it."));
    }
    function Xc2(e5) {
      function t3(t4, n4) {
        if (e5) {
          var r4 = t4.lastEffect;
          r4 !== null ? (r4.nextEffect = n4, t4.lastEffect = n4) : t4.firstEffect = t4.lastEffect = n4, n4.nextEffect = null, n4.flags = 8;
        }
      }
      function n3(n4, r4) {
        if (!e5)
          return null;
        for (var o4 = r4; o4 !== null; )
          t3(n4, o4), o4 = o4.sibling;
        return null;
      }
      function r3(e6, t4) {
        for (var n4 = /* @__PURE__ */ new Map(), r4 = t4; r4 !== null; )
          r4.key !== null ? n4.set(r4.key, r4) : n4.set(r4.index, r4), r4 = r4.sibling;
        return n4;
      }
      function o3(e6, t4) {
        var n4 = cg(e6, t4);
        return n4.index = 0, n4.sibling = null, n4;
      }
      function a3(t4, n4, r4) {
        if (t4.index = r4, !e5)
          return n4;
        var o4 = t4.alternate;
        if (o4 !== null) {
          var a4 = o4.index;
          return a4 < n4 ? (t4.flags = 2, n4) : a4;
        }
        return t4.flags = 2, n4;
      }
      function s3(t4) {
        return e5 && t4.alternate === null && (t4.flags = 2), t4;
      }
      function l3(e6, t4, n4, r4) {
        if (t4 === null || t4.tag !== 6) {
          var a4 = vg(n4, e6.mode, r4);
          return a4.return = e6, a4;
        }
        var i3 = o3(t4, n4);
        return i3.return = e6, i3;
      }
      function c3(e6, t4, n4, r4) {
        if (t4 !== null && (t4.elementType === n4.type || Xv(t4, n4))) {
          var a4 = o3(t4, n4.props);
          return a4.ref = qc2(e6, t4, n4), a4.return = e6, a4._debugSource = n4._source, a4._debugOwner = n4._owner, a4;
        }
        var i3 = pg(n4, e6.mode, r4);
        return i3.ref = qc2(e6, t4, n4), i3.return = e6, i3;
      }
      function d2(e6, t4, n4, r4) {
        if (t4 === null || t4.tag !== 4 || t4.stateNode.containerInfo !== n4.containerInfo || t4.stateNode.implementation !== n4.implementation) {
          var a4 = gg(n4, e6.mode, r4);
          return a4.return = e6, a4;
        }
        var i3 = o3(t4, n4.children || []);
        return i3.return = e6, i3;
      }
      function f2(e6, t4, n4, r4, a4) {
        if (t4 === null || t4.tag !== 7) {
          var i3 = hg(n4, e6.mode, r4, a4);
          return i3.return = e6, i3;
        }
        var s4 = o3(t4, n4);
        return s4.return = e6, s4;
      }
      function h3(e6, t4, n4) {
        if (typeof t4 == "string" || typeof t4 == "number") {
          var r4 = vg("" + t4, e6.mode, n4);
          return r4.return = e6, r4;
        }
        if (typeof t4 == "object" && t4 !== null) {
          switch (t4.$$typeof) {
            case X2:
              var o4 = pg(t4, e6.mode, n4);
              return o4.ref = qc2(e6, null, t4), o4.return = e6, o4;
            case G2:
              var a4 = gg(t4, e6.mode, n4);
              return a4.return = e6, a4;
          }
          if (Wc2(t4) || he2(t4)) {
            var i3 = hg(t4, e6.mode, n4, null);
            return i3.return = e6, i3;
          }
          Kc2(e6, t4);
        }
        return typeof t4 == "function" && Yc2(e6), null;
      }
      function m3(e6, t4, n4, r4) {
        var o4 = t4 !== null ? t4.key : null;
        if (typeof n4 == "string" || typeof n4 == "number")
          return o4 !== null ? null : l3(e6, t4, "" + n4, r4);
        if (typeof n4 == "object" && n4 !== null) {
          switch (n4.$$typeof) {
            case X2:
              return n4.key === o4 ? n4.type === Q2 ? f2(e6, t4, n4.props.children, r4, o4) : c3(e6, t4, n4, r4) : null;
            case G2:
              return n4.key === o4 ? d2(e6, t4, n4, r4) : null;
          }
          if (Wc2(n4) || he2(n4))
            return o4 !== null ? null : f2(e6, t4, n4, r4, null);
          Kc2(e6, n4);
        }
        return typeof n4 == "function" && Yc2(e6), null;
      }
      function v3(e6, t4, n4, r4, o4) {
        if (typeof r4 == "string" || typeof r4 == "number")
          return l3(t4, e6.get(n4) || null, "" + r4, o4);
        if (typeof r4 == "object" && r4 !== null) {
          switch (r4.$$typeof) {
            case X2:
              var a4 = e6.get(r4.key === null ? n4 : r4.key) || null;
              return r4.type === Q2 ? f2(t4, a4, r4.props.children, o4, r4.key) : c3(t4, a4, r4, o4);
            case G2:
              return d2(t4, e6.get(r4.key === null ? n4 : r4.key) || null, r4, o4);
          }
          if (Wc2(r4) || he2(r4))
            return f2(t4, e6.get(n4) || null, r4, o4, null);
          Kc2(t4, r4);
        }
        return typeof r4 == "function" && Yc2(t4), null;
      }
      function y3(e6, t4, n4) {
        if (typeof e6 != "object" || e6 === null)
          return t4;
        switch (e6.$$typeof) {
          case X2:
          case G2:
            Hc2(e6, n4);
            var r4 = e6.key;
            if (typeof r4 != "string")
              break;
            if (t4 === null) {
              (t4 = /* @__PURE__ */ new Set()).add(r4);
              break;
            }
            if (!t4.has(r4)) {
              t4.add(r4);
              break;
            }
            i2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", r4);
        }
        return t4;
      }
      return function(l4, c4, d3, f3) {
        var b3 = typeof d3 == "object" && d3 !== null && d3.type === Q2 && d3.key === null;
        b3 && (d3 = d3.props.children);
        var w3 = typeof d3 == "object" && d3 !== null;
        if (w3)
          switch (d3.$$typeof) {
            case X2:
              return s3(function(e6, r4, a4, i3) {
                for (var s4 = a4.key, l5 = r4; l5 !== null; ) {
                  if (l5.key === s4) {
                    if (l5.tag === 7) {
                      if (a4.type === Q2) {
                        n3(e6, l5.sibling);
                        var u3 = o3(l5, a4.props.children);
                        return u3.return = e6, u3._debugSource = a4._source, u3._debugOwner = a4._owner, u3;
                      }
                    } else if (l5.elementType === a4.type || Xv(l5, a4)) {
                      n3(e6, l5.sibling);
                      var c5 = o3(l5, a4.props);
                      return c5.ref = qc2(e6, l5, a4), c5.return = e6, c5._debugSource = a4._source, c5._debugOwner = a4._owner, c5;
                    }
                    n3(e6, l5);
                    break;
                  }
                  t3(e6, l5), l5 = l5.sibling;
                }
                if (a4.type === Q2) {
                  var d4 = hg(a4.props.children, e6.mode, i3, a4.key);
                  return d4.return = e6, d4;
                }
                var f4 = pg(a4, e6.mode, i3);
                return f4.ref = qc2(e6, r4, a4), f4.return = e6, f4;
              }(l4, c4, d3, f3));
            case G2:
              return s3(function(e6, r4, a4, i3) {
                for (var s4 = a4.key, l5 = r4; l5 !== null; ) {
                  if (l5.key === s4) {
                    if (l5.tag === 4 && l5.stateNode.containerInfo === a4.containerInfo && l5.stateNode.implementation === a4.implementation) {
                      n3(e6, l5.sibling);
                      var u3 = o3(l5, a4.children || []);
                      return u3.return = e6, u3;
                    }
                    n3(e6, l5);
                    break;
                  }
                  t3(e6, l5), l5 = l5.sibling;
                }
                var c5 = gg(a4, e6.mode, i3);
                return c5.return = e6, c5;
              }(l4, c4, d3, f3));
          }
        if (typeof d3 == "string" || typeof d3 == "number")
          return s3(function(e6, t4, r4, a4) {
            if (t4 !== null && t4.tag === 6) {
              n3(e6, t4.sibling);
              var i3 = o3(t4, r4);
              return i3.return = e6, i3;
            }
            n3(e6, t4);
            var s4 = vg(r4, e6.mode, a4);
            return s4.return = e6, s4;
          }(l4, c4, "" + d3, f3));
        if (Wc2(d3))
          return function(o4, i3, s4, l5) {
            for (var u3 = null, c5 = 0; c5 < s4.length; c5++)
              u3 = y3(s4[c5], u3, o4);
            for (var d4 = null, f4 = null, p2 = i3, g3 = 0, b4 = 0, w4 = null; p2 !== null && b4 < s4.length; b4++) {
              p2.index > b4 ? (w4 = p2, p2 = null) : w4 = p2.sibling;
              var k3 = m3(o4, p2, s4[b4], l5);
              if (k3 === null) {
                p2 === null && (p2 = w4);
                break;
              }
              e5 && p2 && k3.alternate === null && t3(o4, p2), g3 = a3(k3, g3, b4), f4 === null ? d4 = k3 : f4.sibling = k3, f4 = k3, p2 = w4;
            }
            if (b4 === s4.length)
              return n3(o4, p2), d4;
            if (p2 === null) {
              for (; b4 < s4.length; b4++) {
                var x3 = h3(o4, s4[b4], l5);
                x3 !== null && (g3 = a3(x3, g3, b4), f4 === null ? d4 = x3 : f4.sibling = x3, f4 = x3);
              }
              return d4;
            }
            for (var S3 = r3(0, p2); b4 < s4.length; b4++) {
              var _3 = v3(S3, o4, b4, s4[b4], l5);
              _3 !== null && (e5 && _3.alternate !== null && S3.delete(_3.key === null ? b4 : _3.key), g3 = a3(_3, g3, b4), f4 === null ? d4 = _3 : f4.sibling = _3, f4 = _3);
            }
            return e5 && S3.forEach(function(e6) {
              return t3(o4, e6);
            }), d4;
          }(l4, c4, d3, f3);
        if (he2(d3))
          return function(o4, s4, l5, u3) {
            var c5 = he2(l5);
            if (typeof c5 != "function")
              throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            typeof Symbol == "function" && l5[Symbol.toStringTag] === "Generator" && (Nc2 || i2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Nc2 = true), l5.entries === c5 && (Rc2 || i2("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Rc2 = true);
            var d4 = c5.call(l5);
            if (d4)
              for (var f4 = null, p2 = d4.next(); !p2.done; p2 = d4.next())
                f4 = y3(p2.value, f4, o4);
            var g3 = c5.call(l5);
            if (g3 == null)
              throw Error("An iterable object provided no iterator.");
            for (var b4 = null, w4 = null, k3 = s4, x3 = 0, S3 = 0, _3 = null, E3 = g3.next(); k3 !== null && !E3.done; S3++, E3 = g3.next()) {
              k3.index > S3 ? (_3 = k3, k3 = null) : _3 = k3.sibling;
              var P3 = m3(o4, k3, E3.value, u3);
              if (P3 === null) {
                k3 === null && (k3 = _3);
                break;
              }
              e5 && k3 && P3.alternate === null && t3(o4, k3), x3 = a3(P3, x3, S3), w4 === null ? b4 = P3 : w4.sibling = P3, w4 = P3, k3 = _3;
            }
            if (E3.done)
              return n3(o4, k3), b4;
            if (k3 === null) {
              for (; !E3.done; S3++, E3 = g3.next()) {
                var C3 = h3(o4, E3.value, u3);
                C3 !== null && (x3 = a3(C3, x3, S3), w4 === null ? b4 = C3 : w4.sibling = C3, w4 = C3);
              }
              return b4;
            }
            for (var j3 = r3(0, k3); !E3.done; S3++, E3 = g3.next()) {
              var O3 = v3(j3, o4, S3, E3.value, u3);
              O3 !== null && (e5 && O3.alternate !== null && j3.delete(O3.key === null ? S3 : O3.key), x3 = a3(O3, x3, S3), w4 === null ? b4 = O3 : w4.sibling = O3, w4 = O3);
            }
            return e5 && j3.forEach(function(e6) {
              return t3(o4, e6);
            }), b4;
          }(l4, c4, d3, f3);
        if (w3 && Kc2(l4, d3), typeof d3 == "function" && Yc2(l4), d3 === void 0 && !b3)
          switch (l4.tag) {
            case 1:
              if (l4.stateNode.render._isMockFunction)
                break;
            case g2:
            case 0:
            case u2:
            case p:
              throw Error(($e2(l4.type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
          }
        return n3(l4, c4);
      };
    }
    var Gc2 = Xc2(true), Qc2 = Xc2(false);
    function Jc2(e5, t3) {
      for (var n3 = e5.child; n3 !== null; )
        dg(n3, t3), n3 = n3.sibling;
    }
    var Zc2 = {}, ed2 = jl2(Zc2), td2 = jl2(Zc2), nd2 = jl2(Zc2);
    function rd2(e5) {
      if (e5 === Zc2)
        throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e5;
    }
    function od2() {
      return rd2(nd2.current);
    }
    function ad2(e5, t3) {
      Tl2(nd2, t3, e5), Tl2(td2, e5, e5), Tl2(ed2, Zc2, e5);
      var n3 = function(e6) {
        var t4, n4, r3 = e6.nodeType;
        switch (r3) {
          case 9:
          case 11:
            t4 = r3 === 9 ? "#document" : "#fragment";
            var o3 = e6.documentElement;
            n4 = o3 ? o3.namespaceURI : Lt2(null, "");
            break;
          default:
            var a3 = r3 === 8 ? e6.parentNode : e6;
            n4 = Lt2(a3.namespaceURI || null, t4 = a3.tagName);
        }
        var i3 = t4.toLowerCase();
        return { namespace: n4, ancestorInfo: js2(null, i3) };
      }(t3);
      Ol2(ed2, e5), Tl2(ed2, n3, e5);
    }
    function id2(e5) {
      Ol2(ed2, e5), Ol2(td2, e5), Ol2(nd2, e5);
    }
    function sd2() {
      return rd2(ed2.current);
    }
    function ld2(e5) {
      rd2(nd2.current);
      var t3, n3, r3, o3 = rd2(ed2.current), a3 = (t3 = o3, n3 = e5.type, { namespace: Lt2((r3 = t3).namespace, n3), ancestorInfo: js2(r3.ancestorInfo, n3) });
      o3 !== a3 && (Tl2(td2, e5, e5), Tl2(ed2, a3, e5));
    }
    function ud2(e5) {
      td2.current === e5 && (Ol2(ed2, e5), Ol2(td2, e5));
    }
    var cd2 = jl2(0);
    function dd2(e5, t3) {
      return (e5 & t3) != 0;
    }
    function fd2(e5) {
      return 1 & e5;
    }
    function pd2(e5, t3) {
      return 1 & e5 | t3;
    }
    function hd2(e5, t3) {
      Tl2(cd2, t3, e5);
    }
    function md2(e5) {
      Ol2(cd2, e5);
    }
    function vd2(e5, t3) {
      var n3 = e5.memoizedState;
      if (n3 !== null)
        return n3.dehydrated !== null;
      var r3 = e5.memoizedProps;
      return r3.fallback !== void 0 && (r3.unstable_avoidThisFallback !== true || !t3);
    }
    function gd2(e5) {
      for (var t3 = e5; t3 !== null; ) {
        if (t3.tag === d) {
          var n3 = t3.memoizedState;
          if (n3 !== null) {
            var r3 = n3.dehydrated;
            if (r3 === null || r3.data === As2 || Js2(r3))
              return t3;
          }
        } else if (t3.tag === m2 && t3.memoizedProps.revealOrder !== void 0) {
          if ((t3.flags & ur2) != 0)
            return t3;
        } else if (t3.child !== null) {
          t3.child.return = t3, t3 = t3.child;
          continue;
        }
        if (t3 === e5)
          return null;
        for (; t3.sibling === null; ) {
          if (t3.return === null || t3.return === e5)
            return null;
          t3 = t3.return;
        }
        t3.sibling.return = t3.return, t3 = t3.sibling;
      }
      return null;
    }
    var yd2 = null, bd2 = null, wd2 = false;
    function kd2(e5, t3) {
      switch (e5.tag) {
        case 3:
          !function(e6, t4) {
            t4.nodeType === 1 ? Ss2(e6, t4) : t4.nodeType === 8 || _s2(e6, t4);
          }(e5.stateNode.containerInfo, t3);
          break;
        case 5:
          !function(e6, t4, n4, r4) {
            t4.suppressHydrationWarning !== true && (r4.nodeType === 1 ? Ss2(n4, r4) : r4.nodeType === 8 || _s2(n4, r4));
          }(e5.type, e5.memoizedProps, e5.stateNode, t3);
      }
      var n3, r3 = ((n3 = lg(5, null, null, 0)).elementType = "DELETED", n3.type = "DELETED", n3);
      r3.stateNode = t3, r3.return = e5, r3.flags = 8, e5.lastEffect !== null ? (e5.lastEffect.nextEffect = r3, e5.lastEffect = r3) : e5.firstEffect = e5.lastEffect = r3;
    }
    function xd2(e5, t3) {
      switch (t3.flags = -1025 & t3.flags | 2, e5.tag) {
        case 3:
          var n3 = e5.stateNode.containerInfo;
          switch (t3.tag) {
            case 5:
              var r3 = t3.type;
              t3.pendingProps, function(e6, t4, n4) {
                Es2(e6, t4);
              }(n3, r3);
              break;
            case 6:
              !function(e6, t4) {
                Ps2(e6, t4);
              }(n3, t3.pendingProps);
          }
          break;
        case 5:
          e5.type;
          var o3 = e5.memoizedProps, a3 = e5.stateNode;
          switch (t3.tag) {
            case 5:
              var i3 = t3.type;
              t3.pendingProps, function(e6, t4, n4, r4, o4) {
                t4.suppressHydrationWarning !== true && Es2(n4, r4);
              }(0, o3, a3, i3);
              break;
            case 6:
              !function(e6, t4, n4, r4) {
                t4.suppressHydrationWarning !== true && Ps2(n4, r4);
              }(0, o3, a3, t3.pendingProps);
              break;
            case d:
              !function(e6, t4, n4) {
                t4.suppressHydrationWarning;
              }(0, o3);
          }
          break;
        default:
          return;
      }
    }
    function Sd2(e5, t3) {
      switch (e5.tag) {
        case 5:
          var n3 = e5.type;
          e5.pendingProps;
          var r3 = function(e6, t4, n4) {
            return e6.nodeType !== 1 || t4.toLowerCase() !== e6.nodeName.toLowerCase() ? null : e6;
          }(t3, n3);
          return r3 !== null && (e5.stateNode = r3, true);
        case 6:
          var o3 = function(e6, t4) {
            return t4 === "" || e6.nodeType !== 3 ? null : e6;
          }(t3, e5.pendingProps);
          return o3 !== null && (e5.stateNode = o3, true);
        default:
          return false;
      }
    }
    function _d2(e5) {
      if (wd2) {
        var t3 = bd2;
        if (!t3)
          return xd2(yd2, e5), wd2 = false, void (yd2 = e5);
        var n3 = t3;
        if (!Sd2(e5, t3)) {
          if (!(t3 = el2(n3)) || !Sd2(e5, t3))
            return xd2(yd2, e5), wd2 = false, void (yd2 = e5);
          kd2(yd2, n3);
        }
        yd2 = e5, bd2 = tl2(t3);
      }
    }
    function Ed2(e5) {
      var t3 = e5.stateNode, n3 = e5.memoizedProps, r3 = function(e6, t4, n4) {
        return dl2(n4, e6), function(e7, t5) {
          return e7.nodeValue !== t5;
        }(e6, t4);
      }(t3, n3, e5);
      if (r3) {
        var o3 = yd2;
        if (o3 !== null)
          switch (o3.tag) {
            case 3:
              o3.stateNode.containerInfo;
              !function(e6, t4, n4) {
                xs2(t4, n4);
              }(0, t3, n3);
              break;
            case 5:
              o3.type;
              var a3 = o3.memoizedProps;
              o3.stateNode;
              !function(e6, t4, n4, r4, o4) {
                t4.suppressHydrationWarning !== true && xs2(r4, o4);
              }(0, a3, 0, t3, n3);
          }
      }
      return r3;
    }
    function Pd2(e5) {
      var t3 = e5.memoizedState, n3 = t3 !== null ? t3.dehydrated : null;
      if (!n3)
        throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return function(e6) {
        for (var t4 = e6.nextSibling, n4 = 0; t4; ) {
          if (t4.nodeType === 8) {
            var r3 = t4.data;
            if (r3 === "/$") {
              if (n4 === 0)
                return el2(t4);
              n4--;
            } else
              r3 !== "$" && r3 !== zs2 && r3 !== As2 || n4++;
          }
          t4 = t4.nextSibling;
        }
        return null;
      }(n3);
    }
    function Cd(e5) {
      for (var t3 = e5.return; t3 !== null && t3.tag !== 5 && t3.tag !== 3 && t3.tag !== d; )
        t3 = t3.return;
      yd2 = t3;
    }
    function Td2(e5) {
      if (e5 !== yd2)
        return false;
      if (!wd2)
        return Cd(e5), wd2 = true, false;
      var t3 = e5.type;
      if (e5.tag !== 5 || t3 !== "head" && t3 !== "body" && !Vs2(t3, e5.memoizedProps))
        for (var n3 = bd2; n3; )
          kd2(e5, n3), n3 = el2(n3);
      return Cd(e5), bd2 = e5.tag === d ? Pd2(e5) : yd2 ? el2(e5.stateNode) : null, true;
    }
    function Id2() {
      yd2 = null, bd2 = null, wd2 = false;
    }
    function Dd2() {
      return wd2;
    }
    var Rd2, Nd2 = [];
    function Ad2() {
      for (var e5 = 0; e5 < Nd2.length; e5++) {
        Nd2[e5]._workInProgressVersionPrimary = null;
      }
      Nd2.length = 0;
    }
    function zd2(e5, t3) {
      e5._workInProgressVersionPrimary = t3, Nd2.push(e5);
    }
    Rd2 = {};
    var Md2, Ld2, Fd2 = o2.ReactCurrentDispatcher, $d2 = o2.ReactCurrentBatchConfig;
    Ld2 = {}, Md2 = /* @__PURE__ */ new Set();
    var Bd2 = 0, Vd2 = null, Ud2 = null, Hd2 = null, Wd2 = false, qd2 = false, Kd2 = null, Yd2 = null, Xd2 = -1, Gd2 = false;
    function Qd2() {
      var e5 = Kd2;
      Yd2 === null ? Yd2 = [e5] : Yd2.push(e5);
    }
    function Jd2() {
      var e5 = Kd2;
      Yd2 !== null && (Xd2++, Yd2[Xd2] !== e5 && function(e6) {
        var t3 = $e2(Vd2.type);
        if (!Md2.has(t3) && (Md2.add(t3), Yd2 !== null)) {
          for (var n3 = "", r3 = 30, o3 = 0; o3 <= Xd2; o3++) {
            for (var a3 = Yd2[o3], s3 = o3 === Xd2 ? e6 : a3, l3 = o3 + 1 + ". " + a3; l3.length < r3; )
              l3 += " ";
            n3 += l3 += s3 + "\n";
          }
          i2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", t3, n3);
        }
      }(e5));
    }
    function Zd2(e5) {
      e5 == null || Array.isArray(e5) || i2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Kd2, typeof e5);
    }
    function ef2() {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function tf2(e5, t3) {
      if (Gd2)
        return false;
      if (t3 === null)
        return i2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Kd2), false;
      e5.length !== t3.length && i2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", Kd2, "[" + t3.join(", ") + "]", "[" + e5.join(", ") + "]");
      for (var n3 = 0; n3 < t3.length && n3 < e5.length; n3++)
        if (!ci2(e5[n3], t3[n3]))
          return false;
      return true;
    }
    function nf2(e5, t3, n3, r3, o3, a3) {
      Bd2 = a3, Vd2 = t3, Yd2 = e5 !== null ? e5._debugHookTypes : null, Xd2 = -1, Gd2 = e5 !== null && e5.type !== t3.type, t3.memoizedState = null, t3.updateQueue = null, t3.lanes = 0, e5 !== null && e5.memoizedState !== null ? Fd2.current = Zf2 : Fd2.current = Yd2 !== null ? Jf2 : Qf2;
      var i3 = n3(r3, o3);
      if (qd2) {
        var s3 = 0;
        do {
          if (qd2 = false, !(s3 < 25))
            throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          s3 += 1, Gd2 = false, Ud2 = null, Hd2 = null, t3.updateQueue = null, Xd2 = -1, Fd2.current = ep2, i3 = n3(r3, o3);
        } while (qd2);
      }
      Fd2.current = Gf2, t3._debugHookTypes = Yd2;
      var l3 = Ud2 !== null && Ud2.next !== null;
      if (Bd2 = 0, Vd2 = null, Ud2 = null, Hd2 = null, Kd2 = null, Yd2 = null, Xd2 = -1, Wd2 = false, l3)
        throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return i3;
    }
    function rf2(e5, t3, n3) {
      t3.updateQueue = e5.updateQueue, t3.flags &= -517, e5.lanes = Ao2(e5.lanes, n3);
    }
    function of2() {
      if (Fd2.current = Gf2, Wd2) {
        for (var e5 = Vd2.memoizedState; e5 !== null; ) {
          var t3 = e5.queue;
          t3 !== null && (t3.pending = null), e5 = e5.next;
        }
        Wd2 = false;
      }
      Bd2 = 0, Vd2 = null, Ud2 = null, Hd2 = null, Yd2 = null, Xd2 = -1, Kd2 = null, Hf2 = false, qd2 = false;
    }
    function af2() {
      var e5 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Hd2 === null ? Vd2.memoizedState = Hd2 = e5 : Hd2 = Hd2.next = e5, Hd2;
    }
    function sf2() {
      var e5, t3;
      if (Ud2 === null) {
        var n3 = Vd2.alternate;
        e5 = n3 !== null ? n3.memoizedState : null;
      } else
        e5 = Ud2.next;
      if ((t3 = Hd2 === null ? Vd2.memoizedState : Hd2.next) !== null)
        t3 = (Hd2 = t3).next, Ud2 = e5;
      else {
        if (e5 === null)
          throw Error("Rendered more hooks than during the previous render.");
        var r3 = { memoizedState: (Ud2 = e5).memoizedState, baseState: Ud2.baseState, baseQueue: Ud2.baseQueue, queue: Ud2.queue, next: null };
        Hd2 === null ? Vd2.memoizedState = Hd2 = r3 : Hd2 = Hd2.next = r3;
      }
      return Hd2;
    }
    function lf2(e5, t3) {
      return typeof t3 == "function" ? t3(e5) : t3;
    }
    function uf2(e5, t3, n3) {
      var r3, o3 = af2();
      r3 = n3 !== void 0 ? n3(t3) : t3, o3.memoizedState = o3.baseState = r3;
      var a3 = o3.queue = { pending: null, dispatch: null, lastRenderedReducer: e5, lastRenderedState: r3 }, i3 = a3.dispatch = Xf2.bind(null, Vd2, a3);
      return [o3.memoizedState, i3];
    }
    function cf2(e5, t3, n3) {
      var r3 = sf2(), o3 = r3.queue;
      if (o3 === null)
        throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      o3.lastRenderedReducer = e5;
      var a3 = Ud2, s3 = a3.baseQueue, l3 = o3.pending;
      if (l3 !== null) {
        if (s3 !== null) {
          var u3 = s3.next, c3 = l3.next;
          s3.next = c3, l3.next = u3;
        }
        a3.baseQueue !== s3 && i2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), a3.baseQueue = s3 = l3, o3.pending = null;
      }
      if (s3 !== null) {
        var d2 = s3.next, f2 = a3.baseState, p2 = null, h3 = null, m3 = null, v3 = d2;
        do {
          var g3 = v3.lane;
          if (Ro2(Bd2, g3)) {
            if (m3 !== null) {
              var y3 = { lane: 0, action: v3.action, eagerReducer: v3.eagerReducer, eagerState: v3.eagerState, next: null };
              m3 = m3.next = y3;
            }
            if (v3.eagerReducer === e5)
              f2 = v3.eagerState;
            else
              f2 = e5(f2, v3.action);
          } else {
            var b3 = { lane: g3, action: v3.action, eagerReducer: v3.eagerReducer, eagerState: v3.eagerState, next: null };
            m3 === null ? (h3 = m3 = b3, p2 = f2) : m3 = m3.next = b3, Vd2.lanes = No2(Vd2.lanes, g3), tv(g3);
          }
          v3 = v3.next;
        } while (v3 !== null && v3 !== d2);
        m3 === null ? p2 = f2 : m3.next = h3, ci2(f2, r3.memoizedState) || oh2(), r3.memoizedState = f2, r3.baseState = p2, r3.baseQueue = m3, o3.lastRenderedState = f2;
      }
      var w3 = o3.dispatch;
      return [r3.memoizedState, w3];
    }
    function df2(e5, t3, n3) {
      var r3 = sf2(), o3 = r3.queue;
      if (o3 === null)
        throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      o3.lastRenderedReducer = e5;
      var a3 = o3.dispatch, i3 = o3.pending, s3 = r3.memoizedState;
      if (i3 !== null) {
        o3.pending = null;
        var l3 = i3.next, u3 = l3;
        do {
          s3 = e5(s3, u3.action), u3 = u3.next;
        } while (u3 !== l3);
        ci2(s3, r3.memoizedState) || oh2(), r3.memoizedState = s3, r3.baseQueue === null && (r3.baseState = s3), o3.lastRenderedState = s3;
      }
      return [s3, a3];
    }
    function ff2(e5, t3, n3) {
      var r3;
      (r3 = t3)._currentPrimaryRenderer == null ? r3._currentPrimaryRenderer = Rd2 : r3._currentPrimaryRenderer !== Rd2 && i2("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
      var o3 = (0, t3._getVersion)(t3._source), a3 = false, s3 = function(e6) {
        return e6._workInProgressVersionPrimary;
      }(t3);
      if (s3 !== null ? a3 = s3 === o3 : (a3 = Ro2(Bd2, e5.mutableReadLanes)) && zd2(t3, o3), a3) {
        var l3 = n3(t3._source);
        return typeof l3 == "function" && i2("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing."), l3;
      }
      throw function(e6) {
        Nd2.push(e6);
      }(t3), Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
    }
    function pf2(e5, t3, n3, r3) {
      var o3 = Jh;
      if (o3 === null)
        throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
      var a3 = t3._getVersion, s3 = a3(t3._source), l3 = Fd2.current, u3 = l3.useState(function() {
        return ff2(o3, t3, n3);
      }), c3 = u3[0], d2 = u3[1], f2 = c3, p2 = Hd2, h3 = e5.memoizedState, m3 = h3.refs, v3 = m3.getSnapshot, g3 = h3.source, y3 = h3.subscribe, b3 = Vd2;
      if (e5.memoizedState = { refs: m3, source: t3, subscribe: r3 }, l3.useEffect(function() {
        m3.getSnapshot = n3, m3.setSnapshot = d2;
        var e6 = a3(t3._source);
        if (!ci2(s3, e6)) {
          var r4 = n3(t3._source);
          if (typeof r4 == "function" && i2("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing."), !ci2(f2, r4)) {
            d2(r4);
            var l4 = zm(b3);
            Fo2(o3, l4);
          }
          !function(e7, t4) {
            e7.entangledLanes |= t4;
            for (var n4 = e7.entanglements, r5 = t4; r5 > 0; ) {
              var o4 = Io2(r5), a4 = 1 << o4;
              n4[o4] |= t4, r5 &= ~a4;
            }
          }(o3, o3.mutableReadLanes);
        }
      }, [n3, t3, r3]), l3.useEffect(function() {
        var e6 = r3(t3._source, function() {
          var e7 = m3.getSnapshot, n4 = m3.setSnapshot;
          try {
            n4(e7(t3._source));
            var r4 = zm(b3);
            Fo2(o3, r4);
          } catch (e8) {
            n4(function() {
              throw e8;
            });
          }
        });
        return typeof e6 != "function" && i2("Mutable source subscribe function must return an unsubscribe function."), e6;
      }, [t3, r3]), !ci2(v3, n3) || !ci2(g3, t3) || !ci2(y3, r3)) {
        var w3 = { pending: null, dispatch: null, lastRenderedReducer: lf2, lastRenderedState: f2 };
        w3.dispatch = d2 = Xf2.bind(null, Vd2, w3), p2.queue = w3, p2.baseQueue = null, f2 = ff2(o3, t3, n3), p2.memoizedState = p2.baseState = f2;
      }
      return f2;
    }
    function hf2(e5, t3, n3) {
      var r3 = af2();
      return r3.memoizedState = { refs: { getSnapshot: t3, setSnapshot: null }, source: e5, subscribe: n3 }, pf2(r3, e5, t3, n3);
    }
    function mf2(e5, t3, n3) {
      return pf2(sf2(), e5, t3, n3);
    }
    function vf2(e5) {
      var t3 = af2();
      typeof e5 == "function" && (e5 = e5()), t3.memoizedState = t3.baseState = e5;
      var n3 = t3.queue = { pending: null, dispatch: null, lastRenderedReducer: lf2, lastRenderedState: e5 }, r3 = n3.dispatch = Xf2.bind(null, Vd2, n3);
      return [t3.memoizedState, r3];
    }
    function gf2(e5) {
      return cf2(lf2);
    }
    function yf2(e5) {
      return df2(lf2);
    }
    function bf2(e5, t3, n3, r3) {
      var o3 = { tag: e5, create: t3, destroy: n3, deps: r3, next: null }, a3 = Vd2.updateQueue;
      if (a3 === null)
        a3 = { lastEffect: null }, Vd2.updateQueue = a3, a3.lastEffect = o3.next = o3;
      else {
        var i3 = a3.lastEffect;
        if (i3 === null)
          a3.lastEffect = o3.next = o3;
        else {
          var s3 = i3.next;
          i3.next = o3, o3.next = s3, a3.lastEffect = o3;
        }
      }
      return o3;
    }
    function wf2(e5) {
      var t3 = af2(), n3 = { current: e5 };
      return Object.seal(n3), t3.memoizedState = n3, n3;
    }
    function kf2(e5) {
      return sf2().memoizedState;
    }
    function xf2(e5, t3, n3, r3) {
      var o3 = af2(), a3 = r3 === void 0 ? null : r3;
      Vd2.flags |= e5, o3.memoizedState = bf2(1 | t3, n3, void 0, a3);
    }
    function Sf2(e5, t3, n3, r3) {
      var o3 = sf2(), a3 = r3 === void 0 ? null : r3, i3 = void 0;
      if (Ud2 !== null) {
        var s3 = Ud2.memoizedState;
        if (i3 = s3.destroy, a3 !== null) {
          if (tf2(a3, s3.deps))
            return void bf2(t3, n3, i3, a3);
        }
      }
      Vd2.flags |= e5, o3.memoizedState = bf2(1 | t3, n3, i3, a3);
    }
    function _f2(e5, t3) {
      return typeof jest != "undefined" && Dv(Vd2), xf2(516, 4, e5, t3);
    }
    function Ef2(e5, t3) {
      return typeof jest != "undefined" && Dv(Vd2), Sf2(516, 4, e5, t3);
    }
    function Pf2(e5, t3) {
      return xf2(4, 2, e5, t3);
    }
    function Cf2(e5, t3) {
      return Sf2(4, 2, e5, t3);
    }
    function jf2(e5, t3) {
      if (typeof t3 == "function") {
        var n3 = t3, r3 = e5();
        return n3(r3), function() {
          n3(null);
        };
      }
      if (t3 != null) {
        var o3 = t3;
        o3.hasOwnProperty("current") || i2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(o3).join(", ") + "}");
        var a3 = e5();
        return o3.current = a3, function() {
          o3.current = null;
        };
      }
    }
    function Of2(e5, t3, n3) {
      typeof t3 != "function" && i2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t3 !== null ? typeof t3 : "null");
      var r3 = n3 != null ? n3.concat([e5]) : null;
      return xf2(4, 2, jf2.bind(null, t3, e5), r3);
    }
    function Tf2(e5, t3, n3) {
      typeof t3 != "function" && i2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t3 !== null ? typeof t3 : "null");
      var r3 = n3 != null ? n3.concat([e5]) : null;
      return Sf2(4, 2, jf2.bind(null, t3, e5), r3);
    }
    function If2(e5, t3) {
    }
    var Df2 = If2;
    function Rf2(e5, t3) {
      var n3 = t3 === void 0 ? null : t3;
      return af2().memoizedState = [e5, n3], e5;
    }
    function Nf2(e5, t3) {
      var n3 = sf2(), r3 = t3 === void 0 ? null : t3, o3 = n3.memoizedState;
      if (o3 !== null && (r3 !== null && tf2(r3, o3[1])))
        return o3[0];
      return n3.memoizedState = [e5, r3], e5;
    }
    function Af2(e5, t3) {
      var n3 = af2(), r3 = t3 === void 0 ? null : t3, o3 = e5();
      return n3.memoizedState = [o3, r3], o3;
    }
    function zf2(e5, t3) {
      var n3 = sf2(), r3 = t3 === void 0 ? null : t3, o3 = n3.memoizedState;
      if (o3 !== null && (r3 !== null && tf2(r3, o3[1])))
        return o3[0];
      var a3 = e5();
      return n3.memoizedState = [a3, r3], a3;
    }
    function Mf2(e5) {
      var t3 = vf2(e5), n3 = t3[0], r3 = t3[1];
      return _f2(function() {
        var t4 = $d2.transition;
        $d2.transition = 1;
        try {
          r3(e5);
        } finally {
          $d2.transition = t4;
        }
      }, [e5]), n3;
    }
    function Lf2(e5) {
      var t3 = gf2(), n3 = t3[0], r3 = t3[1];
      return Ef2(function() {
        var t4 = $d2.transition;
        $d2.transition = 1;
        try {
          r3(e5);
        } finally {
          $d2.transition = t4;
        }
      }, [e5]), n3;
    }
    function Ff2(e5) {
      var t3 = yf2(), n3 = t3[0], r3 = t3[1];
      return Ef2(function() {
        var t4 = $d2.transition;
        $d2.transition = 1;
        try {
          r3(e5);
        } finally {
          $d2.transition = t4;
        }
      }, [e5]), n3;
    }
    function $f2(e5, t3) {
      var n3 = ku2();
      Su2(n3 < fu2 ? fu2 : n3, function() {
        e5(true);
      }), Su2(n3 > pu2 ? pu2 : n3, function() {
        var n4 = $d2.transition;
        $d2.transition = 1;
        try {
          e5(false), t3();
        } finally {
          $d2.transition = n4;
        }
      });
    }
    function Bf2() {
      var e5 = vf2(false), t3 = e5[0], n3 = e5[1], r3 = $f2.bind(null, n3);
      return wf2(r3), [r3, t3];
    }
    function Vf2() {
      var e5 = gf2()[0];
      return [kf2().current, e5];
    }
    function Uf2() {
      var e5 = yf2()[0];
      return [kf2().current, e5];
    }
    var Hf2 = false;
    function Wf2(e5) {
      var t3 = $e2(e5.type) || "Unknown";
      Ue && !Ld2[t3] && (i2("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly."), Ld2[t3] = true);
    }
    function qf2() {
      var e5 = al2.bind(null, Wf2.bind(null, Vd2));
      if (Dd2()) {
        var t3 = false, n3 = Vd2, r3 = { $$typeof: le2, toString: a3 = function() {
          throw t3 || (t3 = true, Hf2 = true, o3(e5()), Hf2 = false, Wf2(n3)), Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
        }, valueOf: a3 }, o3 = vf2(r3)[1];
        return (2 & Vd2.mode) == 0 && (Vd2.flags |= 516, bf2(5, function() {
          o3(e5());
        }, void 0, null)), r3;
      }
      var a3, i3 = e5();
      return vf2(i3), i3;
    }
    function Kf2() {
      return gf2()[0];
    }
    function Yf2() {
      return yf2()[0];
    }
    function Xf2(e5, t3, n3) {
      typeof arguments[3] == "function" && i2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var r3 = Am(), o3 = zm(e5), a3 = { lane: o3, action: n3, eagerReducer: null, eagerState: null, next: null }, s3 = t3.pending;
      s3 === null ? a3.next = a3 : (a3.next = s3.next, s3.next = a3), t3.pending = a3;
      var l3 = e5.alternate;
      if (e5 === Vd2 || l3 !== null && l3 === Vd2)
        qd2 = Wd2 = true;
      else {
        if (e5.lanes === 0 && (l3 === null || l3.lanes === 0)) {
          var u3 = t3.lastRenderedReducer;
          if (u3 !== null) {
            var c3;
            c3 = Fd2.current, Fd2.current = np2;
            try {
              var d2 = t3.lastRenderedState, f2 = u3(d2, n3);
              if (a3.eagerReducer = u3, a3.eagerState = f2, ci2(f2, d2))
                return;
            } catch (e6) {
            } finally {
              Fd2.current = c3;
            }
          }
        }
        typeof jest != "undefined" && (Iv(e5), Rv(e5)), Lm(e5, o3, r3);
      }
    }
    var Gf2 = { readContext: nc2, useCallback: ef2, useContext: ef2, useEffect: ef2, useImperativeHandle: ef2, useLayoutEffect: ef2, useMemo: ef2, useReducer: ef2, useRef: ef2, useState: ef2, useDebugValue: ef2, useDeferredValue: ef2, useTransition: ef2, useMutableSource: ef2, useOpaqueIdentifier: ef2, unstable_isNewReconciler: w2 }, Qf2 = null, Jf2 = null, Zf2 = null, ep2 = null, tp2 = null, np2 = null, rp2 = null, op2 = function() {
      i2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }, ap2 = function() {
      i2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
    };
    Qf2 = { readContext: function(e5, t3) {
      return nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", Qd2(), Zd2(t3), Rf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", Qd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", Qd2(), Zd2(t3), _f2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", Qd2(), Zd2(n3), Of2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", Qd2(), Zd2(t3), Pf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", Qd2(), Zd2(t3);
      var n3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return Af2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", Qd2();
      var r3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return uf2(e5, t3, n3);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", Qd2(), wf2(e5);
    }, useState: function(e5) {
      Kd2 = "useState", Qd2();
      var t3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return vf2(e5);
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      Kd2 = "useDebugValue", Qd2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", Qd2(), Mf2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", Qd2(), Bf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", Qd2(), hf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", Qd2(), qf2();
    }, unstable_isNewReconciler: w2 }, Jf2 = { readContext: function(e5, t3) {
      return nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", Jd2(), Rf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", Jd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", Jd2(), _f2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", Jd2(), Of2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", Jd2(), Pf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", Jd2();
      var n3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return Af2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", Jd2();
      var r3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return uf2(e5, t3, n3);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", Jd2(), wf2(e5);
    }, useState: function(e5) {
      Kd2 = "useState", Jd2();
      var t3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return vf2(e5);
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      Kd2 = "useDebugValue", Jd2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", Jd2(), Mf2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", Jd2(), Bf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", Jd2(), hf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", Jd2(), qf2();
    }, unstable_isNewReconciler: w2 }, Zf2 = { readContext: function(e5, t3) {
      return nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", Jd2(), Nf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", Jd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", Jd2(), Ef2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", Jd2(), Tf2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", Jd2(), Cf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", Jd2();
      var n3 = Fd2.current;
      Fd2.current = np2;
      try {
        return zf2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", Jd2();
      var r3 = Fd2.current;
      Fd2.current = np2;
      try {
        return cf2(e5);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", Jd2(), kf2();
    }, useState: function(e5) {
      Kd2 = "useState", Jd2();
      var t3 = Fd2.current;
      Fd2.current = np2;
      try {
        return gf2();
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      return Kd2 = "useDebugValue", Jd2(), Df2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", Jd2(), Lf2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", Jd2(), Vf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", Jd2(), mf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", Jd2(), Kf2();
    }, unstable_isNewReconciler: w2 }, ep2 = { readContext: function(e5, t3) {
      return nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", Jd2(), Nf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", Jd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", Jd2(), Ef2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", Jd2(), Tf2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", Jd2(), Cf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", Jd2();
      var n3 = Fd2.current;
      Fd2.current = rp2;
      try {
        return zf2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", Jd2();
      var r3 = Fd2.current;
      Fd2.current = rp2;
      try {
        return df2(e5);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", Jd2(), kf2();
    }, useState: function(e5) {
      Kd2 = "useState", Jd2();
      var t3 = Fd2.current;
      Fd2.current = rp2;
      try {
        return yf2();
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      return Kd2 = "useDebugValue", Jd2(), Df2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", Jd2(), Ff2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", Jd2(), Uf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", Jd2(), mf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", Jd2(), Yf2();
    }, unstable_isNewReconciler: w2 }, tp2 = { readContext: function(e5, t3) {
      return op2(), nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", ap2(), Qd2(), Rf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", ap2(), Qd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", ap2(), Qd2(), _f2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", ap2(), Qd2(), Of2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", ap2(), Qd2(), Pf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", ap2(), Qd2();
      var n3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return Af2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", ap2(), Qd2();
      var r3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return uf2(e5, t3, n3);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", ap2(), Qd2(), wf2(e5);
    }, useState: function(e5) {
      Kd2 = "useState", ap2(), Qd2();
      var t3 = Fd2.current;
      Fd2.current = tp2;
      try {
        return vf2(e5);
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      Kd2 = "useDebugValue", ap2(), Qd2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", ap2(), Qd2(), Mf2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", ap2(), Qd2(), Bf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", ap2(), Qd2(), hf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", ap2(), Qd2(), qf2();
    }, unstable_isNewReconciler: w2 }, np2 = { readContext: function(e5, t3) {
      return op2(), nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", ap2(), Jd2(), Nf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", ap2(), Jd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", ap2(), Jd2(), Ef2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", ap2(), Jd2(), Tf2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", ap2(), Jd2(), Cf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", ap2(), Jd2();
      var n3 = Fd2.current;
      Fd2.current = np2;
      try {
        return zf2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", ap2(), Jd2();
      var r3 = Fd2.current;
      Fd2.current = np2;
      try {
        return cf2(e5);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", ap2(), Jd2(), kf2();
    }, useState: function(e5) {
      Kd2 = "useState", ap2(), Jd2();
      var t3 = Fd2.current;
      Fd2.current = np2;
      try {
        return gf2();
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      return Kd2 = "useDebugValue", ap2(), Jd2(), Df2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", ap2(), Jd2(), Lf2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", ap2(), Jd2(), Vf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", ap2(), Jd2(), mf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", ap2(), Jd2(), Kf2();
    }, unstable_isNewReconciler: w2 }, rp2 = { readContext: function(e5, t3) {
      return op2(), nc2(e5, t3);
    }, useCallback: function(e5, t3) {
      return Kd2 = "useCallback", ap2(), Jd2(), Nf2(e5, t3);
    }, useContext: function(e5, t3) {
      return Kd2 = "useContext", ap2(), Jd2(), nc2(e5, t3);
    }, useEffect: function(e5, t3) {
      return Kd2 = "useEffect", ap2(), Jd2(), Ef2(e5, t3);
    }, useImperativeHandle: function(e5, t3, n3) {
      return Kd2 = "useImperativeHandle", ap2(), Jd2(), Tf2(e5, t3, n3);
    }, useLayoutEffect: function(e5, t3) {
      return Kd2 = "useLayoutEffect", ap2(), Jd2(), Cf2(e5, t3);
    }, useMemo: function(e5, t3) {
      Kd2 = "useMemo", ap2(), Jd2();
      var n3 = Fd2.current;
      Fd2.current = np2;
      try {
        return zf2(e5, t3);
      } finally {
        Fd2.current = n3;
      }
    }, useReducer: function(e5, t3, n3) {
      Kd2 = "useReducer", ap2(), Jd2();
      var r3 = Fd2.current;
      Fd2.current = np2;
      try {
        return df2(e5);
      } finally {
        Fd2.current = r3;
      }
    }, useRef: function(e5) {
      return Kd2 = "useRef", ap2(), Jd2(), kf2();
    }, useState: function(e5) {
      Kd2 = "useState", ap2(), Jd2();
      var t3 = Fd2.current;
      Fd2.current = np2;
      try {
        return yf2();
      } finally {
        Fd2.current = t3;
      }
    }, useDebugValue: function(e5, t3) {
      return Kd2 = "useDebugValue", ap2(), Jd2(), Df2();
    }, useDeferredValue: function(e5) {
      return Kd2 = "useDeferredValue", ap2(), Jd2(), Ff2(e5);
    }, useTransition: function() {
      return Kd2 = "useTransition", ap2(), Jd2(), Uf2();
    }, useMutableSource: function(e5, t3, n3) {
      return Kd2 = "useMutableSource", ap2(), Jd2(), mf2(e5, t3, n3);
    }, useOpaqueIdentifier: function() {
      return Kd2 = "useOpaqueIdentifier", ap2(), Jd2(), Yf2();
    }, unstable_isNewReconciler: w2 };
    var ip2 = n2.unstable_now, sp2 = 0, lp2 = -1;
    function up2() {
      return sp2;
    }
    function cp2() {
      sp2 = ip2();
    }
    function dp2(e5) {
      lp2 = ip2(), e5.actualStartTime < 0 && (e5.actualStartTime = ip2());
    }
    function fp2(e5) {
      lp2 = -1;
    }
    function pp2(e5, t3) {
      if (lp2 >= 0) {
        var n3 = ip2() - lp2;
        e5.actualDuration += n3, t3 && (e5.selfBaseDuration = n3), lp2 = -1;
      }
    }
    function hp2(e5) {
      for (var t3 = e5.child; t3; )
        e5.actualDuration += t3.actualDuration, t3 = t3.sibling;
    }
    var mp2, vp2, gp2, yp2, bp2, wp2, kp2, xp2, Sp2 = o2.ReactCurrentOwner, _p2 = false;
    function Ep2(e5, t3, n3, r3) {
      t3.child = e5 === null ? Qc2(t3, null, n3, r3) : Gc2(t3, e5.child, n3, r3);
    }
    function Pp2(e5, t3, n3, r3, o3) {
      if (t3.type !== t3.elementType) {
        var a3 = n3.propTypes;
        a3 && Sl2(a3, r3, "prop", $e2(n3));
      }
      var i3, s3 = n3.render, l3 = t3.ref;
      if (tc2(t3, o3), Sp2.current = t3, Ye2(true), i3 = nf2(e5, t3, s3, r3, l3, o3), 1 & t3.mode) {
        _e2();
        try {
          i3 = nf2(e5, t3, s3, r3, l3, o3);
        } finally {
          Ee2();
        }
      }
      return Ye2(false), e5 === null || _p2 ? (t3.flags |= 1, Ep2(e5, t3, i3, o3), t3.child) : (rf2(e5, t3, o3), ah2(e5, t3, o3));
    }
    function Cp2(e5, t3, n3, r3, o3, a3) {
      if (e5 === null) {
        var i3 = n3.type;
        if (function(e6) {
          return typeof e6 == "function" && !ug(e6) && e6.defaultProps === void 0;
        }(i3) && n3.compare === null && n3.defaultProps === void 0) {
          var s3;
          return s3 = qv(i3), t3.tag = p, t3.type = s3, Lp2(t3, i3), jp2(e5, t3, s3, r3, o3, a3);
        }
        var l3 = i3.propTypes;
        l3 && Sl2(l3, r3, "prop", $e2(i3));
        var u3 = fg(n3.type, null, r3, t3, t3.mode, a3);
        return u3.ref = t3.ref, u3.return = t3, t3.child = u3, u3;
      }
      var c3 = n3.type, d2 = c3.propTypes;
      d2 && Sl2(d2, r3, "prop", $e2(c3));
      var f2 = e5.child;
      if (!Do2(o3, a3)) {
        var h3 = f2.memoizedProps, m3 = n3.compare;
        if ((m3 = m3 !== null ? m3 : fi2)(h3, r3) && e5.ref === t3.ref)
          return ah2(e5, t3, a3);
      }
      t3.flags |= 1;
      var v3 = cg(f2, r3);
      return v3.ref = t3.ref, v3.return = t3, t3.child = v3, v3;
    }
    function jp2(e5, t3, n3, r3, o3, a3) {
      if (t3.type !== t3.elementType) {
        var i3 = t3.elementType;
        if (i3.$$typeof === ie2) {
          var s3 = i3, l3 = s3._payload, u3 = s3._init;
          try {
            i3 = u3(l3);
          } catch (e6) {
            i3 = null;
          }
          var c3 = i3 && i3.propTypes;
          c3 && Sl2(c3, r3, "prop", $e2(i3));
        }
      }
      if (e5 !== null && (fi2(e5.memoizedProps, r3) && e5.ref === t3.ref && t3.type === e5.type)) {
        if (_p2 = false, !Do2(a3, o3))
          return t3.lanes = e5.lanes, ah2(e5, t3, a3);
        (e5.flags & gr2) != 0 && (_p2 = true);
      }
      return Dp2(e5, t3, n3, r3, a3);
    }
    function Op2(e5, t3, n3) {
      var r3, o3 = t3.pendingProps, a3 = o3.children, i3 = e5 !== null ? e5.memoizedState : null;
      if (o3.mode === "hidden" || o3.mode === "unstable-defer-without-hiding")
        if ((4 & t3.mode) == 0) {
          var s3 = { baseLanes: 0 };
          t3.memoizedState = s3, Km(t3, n3);
        } else {
          if (!Do2(n3, wo2)) {
            var l3;
            if (i3 !== null)
              l3 = No2(i3.baseLanes, n3);
            else
              l3 = n3;
            zv(wo2), t3.lanes = t3.childLanes = wo2;
            var u3 = { baseLanes: l3 };
            return t3.memoizedState = u3, Km(t3, l3), null;
          }
          var c3 = { baseLanes: 0 };
          t3.memoizedState = c3, Km(t3, i3 !== null ? i3.baseLanes : n3);
        }
      else
        i3 !== null ? (r3 = No2(i3.baseLanes, n3), t3.memoizedState = null) : r3 = n3, Km(t3, r3);
      return Ep2(e5, t3, a3, n3), t3.child;
    }
    mp2 = {}, vp2 = {}, gp2 = {}, yp2 = {}, bp2 = {}, wp2 = false, kp2 = {}, xp2 = {};
    var Tp2 = Op2;
    function Ip2(e5, t3) {
      var n3 = t3.ref;
      (e5 === null && n3 !== null || e5 !== null && e5.ref !== n3) && (t3.flags |= cr2);
    }
    function Dp2(e5, t3, n3, r3, o3) {
      if (t3.type !== t3.elementType) {
        var a3 = n3.propTypes;
        a3 && Sl2(a3, r3, "prop", $e2(n3));
      }
      var i3, s3;
      if (i3 = Ml2(t3, Al2(0, n3, true)), tc2(t3, o3), Sp2.current = t3, Ye2(true), s3 = nf2(e5, t3, n3, r3, i3, o3), 1 & t3.mode) {
        _e2();
        try {
          s3 = nf2(e5, t3, n3, r3, i3, o3);
        } finally {
          Ee2();
        }
      }
      return Ye2(false), e5 === null || _p2 ? (t3.flags |= 1, Ep2(e5, t3, s3, o3), t3.child) : (rf2(e5, t3, o3), ah2(e5, t3, o3));
    }
    function Rp2(e5, t3, n3, r3, o3) {
      if (t3.type !== t3.elementType) {
        var a3 = n3.propTypes;
        a3 && Sl2(a3, r3, "prop", $e2(n3));
      }
      var s3, l3;
      Fl2(n3) ? (s3 = true, Hl2(t3)) : s3 = false, tc2(t3, o3), t3.stateNode === null ? (e5 !== null && (e5.alternate = null, t3.alternate = null, t3.flags |= 2), Bc2(t3, n3, r3), Uc2(t3, n3, r3, o3), l3 = true) : l3 = e5 === null ? function(e6, t4, n4, r4) {
        var o4 = e6.stateNode, a4 = e6.memoizedProps;
        o4.props = a4;
        var i3 = o4.context, s4 = t4.contextType, l4 = Il2;
        l4 = typeof s4 == "object" && s4 !== null ? nc2(s4) : Ml2(e6, Al2(0, t4, true));
        var u4 = t4.getDerivedStateFromProps, c4 = typeof u4 == "function" || typeof o4.getSnapshotBeforeUpdate == "function";
        c4 || typeof o4.UNSAFE_componentWillReceiveProps != "function" && typeof o4.componentWillReceiveProps != "function" || a4 === n4 && i3 === l4 || Vc2(e6, o4, n4, l4), mc2();
        var d2 = e6.memoizedState, f2 = o4.state = d2;
        if (pc2(e6, n4, o4, r4), f2 = e6.memoizedState, a4 === n4 && d2 === f2 && !Ll2() && !vc2())
          return typeof o4.componentDidMount == "function" && (e6.flags |= 4), false;
        typeof u4 == "function" && (Dc2(e6, t4, u4, n4), f2 = e6.memoizedState);
        var p2 = vc2() || Fc2(e6, t4, a4, n4, d2, f2, l4);
        return p2 ? (c4 || typeof o4.UNSAFE_componentWillMount != "function" && typeof o4.componentWillMount != "function" || (typeof o4.componentWillMount == "function" && o4.componentWillMount(), typeof o4.UNSAFE_componentWillMount == "function" && o4.UNSAFE_componentWillMount()), typeof o4.componentDidMount == "function" && (e6.flags |= 4)) : (typeof o4.componentDidMount == "function" && (e6.flags |= 4), e6.memoizedProps = n4, e6.memoizedState = f2), o4.props = n4, o4.state = f2, o4.context = l4, p2;
      }(t3, n3, r3, o3) : function(e6, t4, n4, r4, o4) {
        var a4 = t4.stateNode;
        lc2(e6, t4);
        var i3 = t4.memoizedProps, s4 = t4.type === t4.elementType ? i3 : Bu2(t4.type, i3);
        a4.props = s4;
        var l4 = t4.pendingProps, u4 = a4.context, c4 = n4.contextType, d2 = Il2;
        d2 = typeof c4 == "object" && c4 !== null ? nc2(c4) : Ml2(t4, Al2(0, n4, true));
        var f2 = n4.getDerivedStateFromProps, p2 = typeof f2 == "function" || typeof a4.getSnapshotBeforeUpdate == "function";
        p2 || typeof a4.UNSAFE_componentWillReceiveProps != "function" && typeof a4.componentWillReceiveProps != "function" || i3 === l4 && u4 === d2 || Vc2(t4, a4, r4, d2), mc2();
        var h3 = t4.memoizedState, m3 = a4.state = h3;
        if (pc2(t4, r4, a4, o4), m3 = t4.memoizedState, i3 === l4 && h3 === m3 && !Ll2() && !vc2())
          return typeof a4.componentDidUpdate == "function" && (i3 === e6.memoizedProps && h3 === e6.memoizedState || (t4.flags |= 4)), typeof a4.getSnapshotBeforeUpdate == "function" && (i3 === e6.memoizedProps && h3 === e6.memoizedState || (t4.flags |= dr2)), false;
        typeof f2 == "function" && (Dc2(t4, n4, f2, r4), m3 = t4.memoizedState);
        var v3 = vc2() || Fc2(t4, n4, s4, r4, h3, m3, d2);
        return v3 ? (p2 || typeof a4.UNSAFE_componentWillUpdate != "function" && typeof a4.componentWillUpdate != "function" || (typeof a4.componentWillUpdate == "function" && a4.componentWillUpdate(r4, m3, d2), typeof a4.UNSAFE_componentWillUpdate == "function" && a4.UNSAFE_componentWillUpdate(r4, m3, d2)), typeof a4.componentDidUpdate == "function" && (t4.flags |= 4), typeof a4.getSnapshotBeforeUpdate == "function" && (t4.flags |= dr2)) : (typeof a4.componentDidUpdate == "function" && (i3 === e6.memoizedProps && h3 === e6.memoizedState || (t4.flags |= 4)), typeof a4.getSnapshotBeforeUpdate == "function" && (i3 === e6.memoizedProps && h3 === e6.memoizedState || (t4.flags |= dr2)), t4.memoizedProps = r4, t4.memoizedState = m3), a4.props = r4, a4.state = m3, a4.context = d2, v3;
      }(e5, t3, n3, r3, o3);
      var u3 = Np2(e5, t3, n3, l3, s3, o3), c3 = t3.stateNode;
      return l3 && c3.props !== r3 && (wp2 || i2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", $e2(t3.type) || "a component"), wp2 = true), u3;
    }
    function Np2(e5, t3, n3, r3, o3, a3) {
      Ip2(e5, t3);
      var i3 = (t3.flags & ur2) != 0;
      if (!r3 && !i3)
        return o3 && Wl2(t3, n3, false), ah2(e5, t3, a3);
      var s3, l3 = t3.stateNode;
      if (Sp2.current = t3, i3 && typeof n3.getDerivedStateFromError != "function")
        s3 = null, fp2();
      else {
        if (Ye2(true), s3 = l3.render(), 1 & t3.mode) {
          _e2();
          try {
            l3.render();
          } finally {
            Ee2();
          }
        }
        Ye2(false);
      }
      return t3.flags |= 1, e5 !== null && i3 ? function(e6, t4, n4, r4) {
        t4.child = Gc2(t4, e6.child, null, r4), t4.child = Gc2(t4, null, n4, r4);
      }(e5, t3, s3, a3) : Ep2(e5, t3, s3, a3), t3.memoizedState = l3.state, o3 && Wl2(t3, n3, true), t3.child;
    }
    function Ap2(e5) {
      var t3 = e5.stateNode;
      t3.pendingContext ? Vl2(e5, t3.pendingContext, t3.pendingContext !== t3.context) : t3.context && Vl2(e5, t3.context, false), ad2(e5, t3.containerInfo);
    }
    function zp2(e5, t3, n3) {
      Ap2(t3);
      var r3 = t3.updateQueue;
      if (e5 === null || r3 === null)
        throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
      var o3 = t3.pendingProps, a3 = t3.memoizedState, i3 = a3 !== null ? a3.element : null;
      lc2(e5, t3), pc2(t3, o3, null, n3);
      var s3 = t3.memoizedState.element;
      if (s3 === i3)
        return Id2(), ah2(e5, t3, n3);
      var l3, u3, c3 = t3.stateNode;
      if (c3.hydrate && (u3 = (l3 = t3).stateNode.containerInfo, bd2 = tl2(u3), yd2 = l3, wd2 = true, 1)) {
        var d2 = c3.mutableSourceEagerHydrationData;
        if (d2 != null)
          for (var f2 = 0; f2 < d2.length; f2 += 2) {
            zd2(d2[f2], d2[f2 + 1]);
          }
        var p2 = Qc2(t3, null, s3, n3);
        t3.child = p2;
        for (var h3 = p2; h3; )
          h3.flags = -3 & h3.flags | hr2, h3 = h3.sibling;
      } else
        Ep2(e5, t3, s3, n3), Id2();
      return t3.child;
    }
    function Mp2(e5, t3, n3, r3, o3) {
      e5 !== null && (e5.alternate = null, t3.alternate = null, t3.flags |= 2);
      var a3 = t3.pendingProps, i3 = n3, s3 = i3._payload, l3 = (0, i3._init)(s3);
      t3.type = l3;
      var c3 = t3.tag = function(e6) {
        if (typeof e6 == "function")
          return ug(e6) ? 1 : 0;
        if (e6 != null) {
          var t4 = e6.$$typeof;
          if (t4 === ne2)
            return u2;
          if (t4 === ae2)
            return f;
        }
        return 2;
      }(l3), d2 = Bu2(l3, a3);
      switch (c3) {
        case 0:
          return Lp2(t3, l3), t3.type = l3 = qv(l3), Dp2(null, t3, l3, d2, o3);
        case 1:
          return t3.type = l3 = Kv(l3), Rp2(null, t3, l3, d2, o3);
        case u2:
          return t3.type = l3 = Yv(l3), Pp2(null, t3, l3, d2, o3);
        case f:
          if (t3.type !== t3.elementType) {
            var p2 = l3.propTypes;
            p2 && Sl2(p2, d2, "prop", $e2(l3));
          }
          return Cp2(null, t3, l3, Bu2(l3.type, d2), r3, o3);
      }
      var h3 = "";
      throw l3 !== null && typeof l3 == "object" && l3.$$typeof === ie2 && (h3 = " Did you wrap a component in React.lazy() more than once?"), Error("Element type is invalid. Received a promise that resolves to: " + l3 + ". Lazy element type must resolve to a class or function." + h3);
    }
    function Lp2(e5, t3) {
      if (t3 && t3.childContextTypes && i2("%s(...): childContextTypes cannot be defined on a function component.", t3.displayName || t3.name || "Component"), e5.ref !== null) {
        var n3 = "", r3 = He2();
        r3 && (n3 += "\n\nCheck the render method of `" + r3 + "`.");
        var o3 = r3 || e5._debugID || "", a3 = e5._debugSource;
        a3 && (o3 = a3.fileName + ":" + a3.lineNumber), bp2[o3] || (bp2[o3] = true, i2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", n3));
      }
      if (typeof t3.getDerivedStateFromProps == "function") {
        var s3 = $e2(t3) || "Unknown";
        yp2[s3] || (i2("%s: Function components do not support getDerivedStateFromProps.", s3), yp2[s3] = true);
      }
      if (typeof t3.contextType == "object" && t3.contextType !== null) {
        var l3 = $e2(t3) || "Unknown";
        gp2[l3] || (i2("%s: Function components do not support contextType.", l3), gp2[l3] = true);
      }
    }
    var Fp2 = { dehydrated: null, retryLane: 0 };
    function $p2(e5) {
      return { baseLanes: e5 };
    }
    function Bp2(e5, t3) {
      return { baseLanes: No2(e5.baseLanes, t3) };
    }
    function Vp2(e5, t3) {
      return Ao2(e5.childLanes, t3);
    }
    function Up2(e5, t3, n3) {
      var r3 = t3.pendingProps;
      jg(t3) && (t3.flags |= ur2);
      var o3 = cd2.current, a3 = false;
      if ((t3.flags & ur2) != 0 || function(e6, t4, n4, r4) {
        return (t4 === null || t4.memoizedState !== null) && dd2(e6, 2);
      }(o3, e5) ? (a3 = true, t3.flags &= -65) : e5 !== null && e5.memoizedState === null || r3.fallback !== void 0 && r3.unstable_avoidThisFallback !== true && (o3 = o3 | 1), hd2(t3, o3 = fd2(o3)), e5 === null) {
        r3.fallback !== void 0 && _d2(t3);
        var i3 = r3.children, s3 = r3.fallback;
        if (a3) {
          var l3 = Hp2(t3, i3, s3, n3);
          return t3.child.memoizedState = $p2(n3), t3.memoizedState = Fp2, l3;
        }
        if (typeof r3.unstable_expectedLoadTime == "number") {
          var u3 = Hp2(t3, i3, s3, n3);
          return t3.child.memoizedState = $p2(n3), t3.memoizedState = Fp2, t3.lanes = mo2, zv(mo2), u3;
        }
        return function(e6, t4, n4) {
          var r4 = e6.mode, o4 = mg({ mode: "visible", children: t4 }, r4, n4, null);
          return o4.return = e6, e6.child = o4, o4;
        }(t3, i3, n3);
      }
      if (e5.memoizedState !== null) {
        if (a3) {
          var c3 = r3.fallback, d2 = Kp2(e5, t3, r3.children, c3, n3), f2 = t3.child, p2 = e5.child.memoizedState;
          return f2.memoizedState = p2 === null ? $p2(n3) : Bp2(p2, n3), f2.childLanes = Vp2(e5, n3), t3.memoizedState = Fp2, d2;
        }
        var h3 = qp2(e5, t3, r3.children, n3);
        return t3.memoizedState = null, h3;
      }
      if (a3) {
        var m3 = r3.fallback, v3 = Kp2(e5, t3, r3.children, m3, n3), g3 = t3.child, y3 = e5.child.memoizedState;
        return g3.memoizedState = y3 === null ? $p2(n3) : Bp2(y3, n3), g3.childLanes = Vp2(e5, n3), t3.memoizedState = Fp2, v3;
      }
      var b3 = qp2(e5, t3, r3.children, n3);
      return t3.memoizedState = null, b3;
    }
    function Hp2(e5, t3, n3, r3) {
      var o3, a3, i3 = e5.mode, s3 = e5.child, l3 = { mode: "hidden", children: t3 };
      return (2 & i3) == 0 && s3 !== null ? ((o3 = s3).childLanes = 0, o3.pendingProps = l3, 8 & e5.mode && (o3.actualDuration = 0, o3.actualStartTime = -1, o3.selfBaseDuration = 0, o3.treeBaseDuration = 0), a3 = hg(n3, i3, r3, null)) : (o3 = mg(l3, i3, 0, null), a3 = hg(n3, i3, r3, null)), o3.return = e5, a3.return = e5, o3.sibling = a3, e5.child = o3, a3;
    }
    function Wp2(e5, t3) {
      return cg(e5, t3);
    }
    function qp2(e5, t3, n3, r3) {
      var o3 = e5.child, a3 = o3.sibling, i3 = Wp2(o3, { mode: "visible", children: n3 });
      return (2 & t3.mode) == 0 && (i3.lanes = r3), i3.return = t3, i3.sibling = null, a3 !== null && (a3.nextEffect = null, a3.flags = 8, t3.firstEffect = t3.lastEffect = a3), t3.child = i3, i3;
    }
    function Kp2(e5, t3, n3, r3, o3) {
      var a3, i3, s3 = t3.mode, l3 = e5.child, u3 = l3.sibling, c3 = { mode: "hidden", children: n3 };
      if ((2 & s3) == 0 && t3.child !== l3) {
        (a3 = t3.child).childLanes = 0, a3.pendingProps = c3, 8 & t3.mode && (a3.actualDuration = 0, a3.actualStartTime = -1, a3.selfBaseDuration = l3.selfBaseDuration, a3.treeBaseDuration = l3.treeBaseDuration);
        var d2 = a3.lastEffect;
        d2 !== null ? (t3.firstEffect = a3.firstEffect, t3.lastEffect = d2, d2.nextEffect = null) : t3.firstEffect = t3.lastEffect = null;
      } else
        a3 = Wp2(l3, c3);
      return u3 !== null ? i3 = cg(u3, r3) : (i3 = hg(r3, s3, o3, null)).flags |= 2, i3.return = t3, a3.return = t3, a3.sibling = i3, t3.child = a3, i3;
    }
    function Yp2(e5, t3) {
      e5.lanes = No2(e5.lanes, t3);
      var n3 = e5.alternate;
      n3 !== null && (n3.lanes = No2(n3.lanes, t3)), ec2(e5.return, t3);
    }
    function Xp2(e5, t3) {
      var n3 = Array.isArray(e5), r3 = !n3 && typeof he2(e5) == "function";
      if (n3 || r3) {
        var o3 = n3 ? "array" : "iterable";
        return i2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", o3, t3, o3), false;
      }
      return true;
    }
    function Gp2(e5, t3, n3, r3, o3, a3) {
      var i3 = e5.memoizedState;
      i3 === null ? e5.memoizedState = { isBackwards: t3, rendering: null, renderingStartTime: 0, last: r3, tail: n3, tailMode: o3, lastEffect: a3 } : (i3.isBackwards = t3, i3.rendering = null, i3.renderingStartTime = 0, i3.last = r3, i3.tail = n3, i3.tailMode = o3, i3.lastEffect = a3);
    }
    function Qp2(e5, t3, n3) {
      var r3 = t3.pendingProps, o3 = r3.revealOrder, a3 = r3.tail, s3 = r3.children;
      !function(e6) {
        if (e6 !== void 0 && e6 !== "forwards" && e6 !== "backwards" && e6 !== "together" && !kp2[e6])
          if (kp2[e6] = true, typeof e6 == "string")
            switch (e6.toLowerCase()) {
              case "together":
              case "forwards":
              case "backwards":
                i2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e6, e6.toLowerCase());
                break;
              case "forward":
              case "backward":
                i2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e6, e6.toLowerCase());
                break;
              default:
                i2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e6);
            }
          else
            i2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e6);
      }(o3), function(e6, t4) {
        e6 === void 0 || xp2[e6] || (e6 !== "collapsed" && e6 !== "hidden" ? (xp2[e6] = true, i2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e6)) : t4 !== "forwards" && t4 !== "backwards" && (xp2[e6] = true, i2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e6)));
      }(a3, o3), function(e6, t4) {
        if ((t4 === "forwards" || t4 === "backwards") && e6 != null && e6 !== false)
          if (Array.isArray(e6)) {
            for (var n4 = 0; n4 < e6.length; n4++)
              if (!Xp2(e6[n4], n4))
                return;
          } else {
            var r4 = he2(e6);
            if (typeof r4 == "function") {
              var o4 = r4.call(e6);
              if (o4)
                for (var a4 = o4.next(), s4 = 0; !a4.done; a4 = o4.next()) {
                  if (!Xp2(a4.value, s4))
                    return;
                  s4++;
                }
            } else
              i2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', t4);
          }
      }(s3, o3), Ep2(e5, t3, s3, n3);
      var l3 = cd2.current;
      dd2(l3, 2) ? (l3 = pd2(l3, 2), t3.flags |= ur2) : (e5 !== null && (e5.flags & ur2) != 0 && function(e6, t4, n4) {
        for (var r4 = t4; r4 !== null; ) {
          if (r4.tag === d)
            r4.memoizedState !== null && Yp2(r4, n4);
          else if (r4.tag === m2)
            Yp2(r4, n4);
          else if (r4.child !== null) {
            r4.child.return = r4, r4 = r4.child;
            continue;
          }
          if (r4 === e6)
            return;
          for (; r4.sibling === null; ) {
            if (r4.return === null || r4.return === e6)
              return;
            r4 = r4.return;
          }
          r4.sibling.return = r4.return, r4 = r4.sibling;
        }
      }(t3, t3.child, n3), l3 = fd2(l3));
      if (hd2(t3, l3), (2 & t3.mode) == 0)
        t3.memoizedState = null;
      else
        switch (o3) {
          case "forwards":
            var u3, c3 = function(e6) {
              for (var t4 = e6, n4 = null; t4 !== null; ) {
                var r4 = t4.alternate;
                r4 !== null && gd2(r4) === null && (n4 = t4), t4 = t4.sibling;
              }
              return n4;
            }(t3.child);
            c3 === null ? (u3 = t3.child, t3.child = null) : (u3 = c3.sibling, c3.sibling = null), Gp2(t3, false, u3, c3, a3, t3.lastEffect);
            break;
          case "backwards":
            var f2 = null, p2 = t3.child;
            for (t3.child = null; p2 !== null; ) {
              var h3 = p2.alternate;
              if (h3 !== null && gd2(h3) === null) {
                t3.child = p2;
                break;
              }
              var v3 = p2.sibling;
              p2.sibling = f2, f2 = p2, p2 = v3;
            }
            Gp2(t3, true, f2, null, a3, t3.lastEffect);
            break;
          case "together":
            Gp2(t3, false, null, null, void 0, t3.lastEffect);
            break;
          default:
            t3.memoizedState = null;
        }
      return t3.child;
    }
    var Jp2 = false;
    function Zp2(e5, t3, n3) {
      var r3 = t3.type._context, o3 = t3.pendingProps, a3 = t3.memoizedProps, s3 = o3.value;
      "value" in o3 || Jp2 || (Jp2 = true, i2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
      var u3 = t3.type.propTypes;
      if (u3 && Sl2(u3, o3, "prop", "Context.Provider"), Ju2(t3, s3), a3 !== null) {
        var c3 = function(e6, t4, n4) {
          if (ci2(n4, t4))
            return 0;
          var r4 = typeof e6._calculateChangedBits == "function" ? e6._calculateChangedBits(n4, t4) : Uu2;
          return (r4 & Uu2) !== r4 && i2("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", r4), 0 | r4;
        }(r3, s3, a3.value);
        if (c3 === 0) {
          if (a3.children === o3.children && !Ll2())
            return ah2(e5, t3, n3);
        } else
          !function(e6, t4, n4, r4) {
            var o4 = e6.child;
            for (o4 !== null && (o4.return = e6); o4 !== null; ) {
              var a4 = void 0, i3 = o4.dependencies;
              if (i3 !== null) {
                a4 = o4.child;
                for (var s4 = i3.firstContext; s4 !== null; ) {
                  if (s4.context === t4 && (s4.observedBits & n4) != 0) {
                    if (o4.tag === 1) {
                      var u4 = uc2(ko2, To2(r4));
                      u4.tag = ac2, cc2(o4, u4);
                    }
                    o4.lanes = No2(o4.lanes, r4);
                    var c4 = o4.alternate;
                    c4 !== null && (c4.lanes = No2(c4.lanes, r4)), ec2(o4.return, r4), i3.lanes = No2(i3.lanes, r4);
                    break;
                  }
                  s4 = s4.next;
                }
              } else
                a4 = o4.tag === l2 && o4.type === e6.type ? null : o4.child;
              if (a4 !== null)
                a4.return = o4;
              else
                for (a4 = o4; a4 !== null; ) {
                  if (a4 === e6) {
                    a4 = null;
                    break;
                  }
                  var d2 = a4.sibling;
                  if (d2 !== null) {
                    d2.return = a4.return, a4 = d2;
                    break;
                  }
                  a4 = a4.return;
                }
              o4 = a4;
            }
          }(t3, r3, c3, n3);
      }
      return Ep2(e5, t3, o3.children, n3), t3.child;
    }
    var eh2, th2, nh2, rh2 = false;
    function oh2() {
      _p2 = true;
    }
    function ah2(e5, t3, n3) {
      return e5 !== null && (t3.dependencies = e5.dependencies), fp2(), tv(t3.lanes), Do2(n3, t3.childLanes) ? (function(e6, t4) {
        if (e6 !== null && t4.child !== e6.child)
          throw Error("Resuming work not yet implemented.");
        if (t4.child !== null) {
          var n4 = t4.child, r3 = cg(n4, n4.pendingProps);
          for (t4.child = r3, r3.return = t4; n4.sibling !== null; )
            n4 = n4.sibling, (r3 = r3.sibling = cg(n4, n4.pendingProps)).return = t4;
          r3.sibling = null;
        }
      }(e5, t3), t3.child) : null;
    }
    function ih2(e5, t3, n3) {
      var r3 = t3.lanes;
      if (t3._debugNeedsRemount && e5 !== null)
        return function(e6, t4, n4) {
          var r4 = t4.return;
          if (r4 === null)
            throw new Error("Cannot swap the root fiber.");
          if (e6.alternate = null, t4.alternate = null, n4.index = t4.index, n4.sibling = t4.sibling, n4.return = t4.return, n4.ref = t4.ref, t4 === r4.child)
            r4.child = n4;
          else {
            var o4 = r4.child;
            if (o4 === null)
              throw new Error("Expected parent to have a child.");
            for (; o4.sibling !== t4; )
              if ((o4 = o4.sibling) === null)
                throw new Error("Expected to find the previous sibling.");
            o4.sibling = n4;
          }
          var a4 = r4.lastEffect;
          return a4 !== null ? (a4.nextEffect = e6, r4.lastEffect = e6) : r4.firstEffect = r4.lastEffect = e6, e6.nextEffect = null, e6.flags = 8, n4.flags |= 2, n4;
        }(e5, t3, fg(t3.type, t3.key, t3.pendingProps, t3._debugOwner || null, t3.mode, t3.lanes));
      if (e5 !== null)
        if (e5.memoizedProps !== t3.pendingProps || Ll2() || t3.type !== e5.type)
          _p2 = true;
        else {
          if (!Do2(n3, r3)) {
            switch (_p2 = false, t3.tag) {
              case 3:
                Ap2(t3), Id2();
                break;
              case 5:
                ld2(t3);
                break;
              case 1:
                Fl2(t3.type) && Hl2(t3);
                break;
              case 4:
                ad2(t3, t3.stateNode.containerInfo);
                break;
              case l2:
                Ju2(t3, t3.memoizedProps.value);
                break;
              case c2:
                Do2(n3, t3.childLanes) && (t3.flags |= 4);
                var o3 = t3.stateNode;
                o3.effectDuration = 0, o3.passiveEffectDuration = 0;
                break;
              case d:
                if (t3.memoizedState !== null) {
                  if (Do2(n3, t3.child.childLanes))
                    return Up2(e5, t3, n3);
                  hd2(t3, fd2(cd2.current));
                  var a3 = ah2(e5, t3, n3);
                  return a3 !== null ? a3.sibling : null;
                }
                hd2(t3, fd2(cd2.current));
                break;
              case m2:
                var s3 = (e5.flags & ur2) != 0, w3 = Do2(n3, t3.childLanes);
                if (s3) {
                  if (w3)
                    return Qp2(e5, t3, n3);
                  t3.flags |= ur2;
                }
                var k3 = t3.memoizedState;
                if (k3 !== null && (k3.rendering = null, k3.tail = null, k3.lastEffect = null), hd2(t3, cd2.current), w3)
                  break;
                return null;
              case y2:
              case b2:
                return t3.lanes = 0, Op2(e5, t3, n3);
            }
            return ah2(e5, t3, n3);
          }
          _p2 = (e5.flags & gr2) != 0;
        }
      else
        _p2 = false;
      switch (t3.lanes = 0, t3.tag) {
        case 2:
          return function(e6, t4, n4, r4) {
            e6 !== null && (e6.alternate = null, t4.alternate = null, t4.flags |= 2);
            var o4, a4, s4 = t4.pendingProps;
            if (o4 = Ml2(t4, Al2(0, n4, false)), tc2(t4, r4), n4.prototype && typeof n4.prototype.render == "function") {
              var l3 = $e2(n4) || "Unknown";
              mp2[l3] || (i2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", l3, l3), mp2[l3] = true);
            }
            if (1 & t4.mode && Tu2.recordLegacyContextWarning(t4, null), Ye2(true), Sp2.current = t4, a4 = nf2(null, t4, n4, s4, o4, r4), Ye2(false), t4.flags |= 1, typeof a4 == "object" && a4 !== null && typeof a4.render == "function" && a4.$$typeof === void 0) {
              var u3 = $e2(n4) || "Unknown";
              vp2[u3] || (i2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", u3, u3, u3), vp2[u3] = true);
            }
            if (typeof a4 == "object" && a4 !== null && typeof a4.render == "function" && a4.$$typeof === void 0) {
              var c3 = $e2(n4) || "Unknown";
              vp2[c3] || (i2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", c3, c3, c3), vp2[c3] = true), t4.tag = 1, t4.memoizedState = null, t4.updateQueue = null;
              var d2 = false;
              Fl2(n4) ? (d2 = true, Hl2(t4)) : d2 = false, t4.memoizedState = a4.state !== null && a4.state !== void 0 ? a4.state : null, sc2(t4);
              var f2 = n4.getDerivedStateFromProps;
              return typeof f2 == "function" && Dc2(t4, n4, f2, s4), $c2(t4, a4), Uc2(t4, n4, s4, r4), Np2(null, t4, n4, true, d2, r4);
            }
            if (t4.tag = 0, 1 & t4.mode) {
              _e2();
              try {
                a4 = nf2(null, t4, n4, s4, o4, r4);
              } finally {
                Ee2();
              }
            }
            return Ep2(null, t4, a4, r4), Lp2(t4, n4), t4.child;
          }(e5, t3, t3.type, n3);
        case 16:
          return Mp2(e5, t3, t3.elementType, r3, n3);
        case 0:
          var x3 = t3.type, S3 = t3.pendingProps;
          return Dp2(e5, t3, x3, t3.elementType === x3 ? S3 : Bu2(x3, S3), n3);
        case 1:
          var _3 = t3.type, E3 = t3.pendingProps;
          return Rp2(e5, t3, _3, t3.elementType === _3 ? E3 : Bu2(_3, E3), n3);
        case 3:
          return zp2(e5, t3, n3);
        case 5:
          return function(e6, t4, n4) {
            ld2(t4), e6 === null && _d2(t4);
            var r4 = t4.type, o4 = t4.pendingProps, a4 = e6 !== null ? e6.memoizedProps : null, i3 = o4.children;
            return Vs2(r4, o4) ? i3 = null : a4 !== null && Vs2(r4, a4) && (t4.flags |= 16), Ip2(e6, t4), Ep2(e6, t4, i3, n4), t4.child;
          }(e5, t3, n3);
        case 6:
          return function(e6, t4) {
            return e6 === null && _d2(t4), null;
          }(e5, t3);
        case d:
          return Up2(e5, t3, n3);
        case 4:
          return function(e6, t4, n4) {
            ad2(t4, t4.stateNode.containerInfo);
            var r4 = t4.pendingProps;
            return e6 === null ? t4.child = Gc2(t4, null, r4, n4) : Ep2(e6, t4, r4, n4), t4.child;
          }(e5, t3, n3);
        case u2:
          var P3 = t3.type, C3 = t3.pendingProps;
          return Pp2(e5, t3, P3, t3.elementType === P3 ? C3 : Bu2(P3, C3), n3);
        case 7:
          return function(e6, t4, n4) {
            return Ep2(e6, t4, t4.pendingProps, n4), t4.child;
          }(e5, t3, n3);
        case 8:
          return function(e6, t4, n4) {
            return Ep2(e6, t4, t4.pendingProps.children, n4), t4.child;
          }(e5, t3, n3);
        case c2:
          return function(e6, t4, n4) {
            t4.flags |= 4;
            var r4 = t4.stateNode;
            return r4.effectDuration = 0, r4.passiveEffectDuration = 0, Ep2(e6, t4, t4.pendingProps.children, n4), t4.child;
          }(e5, t3, n3);
        case l2:
          return Zp2(e5, t3, n3);
        case 9:
          return function(e6, t4, n4) {
            var r4 = t4.type;
            r4._context === void 0 ? r4 !== r4.Consumer && (rh2 || (rh2 = true, i2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : r4 = r4._context;
            var o4 = t4.pendingProps, a4 = o4.children;
            typeof a4 != "function" && i2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), tc2(t4, n4);
            var s4, l3 = nc2(r4, o4.unstable_observedBits);
            return Sp2.current = t4, Ye2(true), s4 = a4(l3), Ye2(false), t4.flags |= 1, Ep2(e6, t4, s4, n4), t4.child;
          }(e5, t3, n3);
        case f:
          var j3 = t3.type, O3 = Bu2(j3, t3.pendingProps);
          if (t3.type !== t3.elementType) {
            var T3 = j3.propTypes;
            T3 && Sl2(T3, O3, "prop", $e2(j3));
          }
          return Cp2(e5, t3, j3, O3 = Bu2(j3.type, O3), r3, n3);
        case p:
          return jp2(e5, t3, t3.type, t3.pendingProps, r3, n3);
        case h2:
          var I3 = t3.type, D3 = t3.pendingProps;
          return function(e6, t4, n4, r4, o4) {
            var a4;
            return e6 !== null && (e6.alternate = null, t4.alternate = null, t4.flags |= 2), t4.tag = 1, Fl2(n4) ? (a4 = true, Hl2(t4)) : a4 = false, tc2(t4, o4), Bc2(t4, n4, r4), Uc2(t4, n4, r4, o4), Np2(null, t4, n4, true, a4, o4);
          }(e5, t3, I3, t3.elementType === I3 ? D3 : Bu2(I3, D3), n3);
        case m2:
          return Qp2(e5, t3, n3);
        case v2:
        case 21:
        case g2:
          break;
        case y2:
          return Op2(e5, t3, n3);
        case b2:
          return Tp2(e5, t3, n3);
      }
      throw Error("Unknown unit of work tag (" + t3.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function sh2(e5) {
      e5.flags |= 4;
    }
    function lh2(e5) {
      e5.flags |= cr2;
    }
    function uh2(e5, t3) {
      if (!Dd2())
        switch (e5.tailMode) {
          case "hidden":
            for (var n3 = e5.tail, r3 = null; n3 !== null; )
              n3.alternate !== null && (r3 = n3), n3 = n3.sibling;
            r3 === null ? e5.tail = null : r3.sibling = null;
            break;
          case "collapsed":
            for (var o3 = e5.tail, a3 = null; o3 !== null; )
              o3.alternate !== null && (a3 = o3), o3 = o3.sibling;
            a3 === null ? t3 || e5.tail === null ? e5.tail = null : e5.tail.sibling = null : a3.sibling = null;
        }
    }
    function ch2(e5, t3, n3) {
      var r3, o3, a3, i3 = t3.pendingProps;
      switch (t3.tag) {
        case 2:
        case 16:
        case p:
        case 0:
        case u2:
        case 7:
        case 8:
        case c2:
        case 9:
        case f:
          return null;
        case 1:
          return Fl2(t3.type) && $l2(t3), null;
        case 3:
          id2(t3), Bl2(t3), Ad2();
          var s3 = t3.stateNode;
          if (s3.pendingContext && (s3.context = s3.pendingContext, s3.pendingContext = null), e5 === null || e5.child === null)
            Td2(t3) ? sh2(t3) : s3.hydrate || (t3.flags |= dr2);
          return null;
        case 5:
          ud2(t3);
          var w3 = od2(), k3 = t3.type;
          if (e5 !== null && t3.stateNode != null)
            th2(e5, t3, k3, i3), e5.ref !== t3.ref && lh2(t3);
          else {
            if (!i3) {
              if (t3.stateNode === null)
                throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return null;
            }
            var x3 = sd2();
            if (Td2(t3))
              o3 = x3, a3 = nl2((r3 = t3).stateNode, r3.type, r3.memoizedProps, 0, o3, r3), r3.updateQueue = a3, a3 !== null && sh2(t3);
            else {
              var S3 = Bs2(k3, i3, w3, x3, t3);
              eh2(S3, t3), t3.stateNode = S3, function(e6, t4, n4, r4, o4) {
                return bs2(e6, t4, n4), Fs2(t4, n4);
              }(S3, k3, i3) && sh2(t3);
            }
            t3.ref !== null && lh2(t3);
          }
          return null;
        case 6:
          var _3 = i3;
          if (e5 && t3.stateNode != null) {
            var E3 = e5.memoizedProps;
            nh2(0, t3, E3, _3);
          } else {
            if (typeof _3 != "string" && t3.stateNode === null)
              throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var P3 = od2(), C3 = sd2();
            Td2(t3) ? Ed2(t3) && sh2(t3) : t3.stateNode = Us2(_3, P3, C3, t3);
          }
          return null;
        case d:
          md2(t3);
          var j3 = t3.memoizedState;
          if ((t3.flags & ur2) != 0)
            return t3.lanes = n3, (8 & t3.mode) != 0 && hp2(t3), t3;
          var O3 = j3 !== null, T3 = false;
          if (e5 === null)
            t3.memoizedProps.fallback !== void 0 && Td2(t3);
          else
            T3 = e5.memoizedState !== null;
          if (O3 && !T3) {
            if ((2 & t3.mode) != 0)
              e5 === null && t3.memoizedProps.unstable_avoidThisFallback !== true || dd2(cd2.current, 1) ? rm === 0 && (rm = 3) : function() {
                rm !== 0 && rm !== 3 || (rm = 4);
                Jh !== null && (Co2(im) || Co2(sm)) && Vm(Jh, em);
              }();
          }
          return (O3 || T3) && (t3.flags |= 4), null;
        case 4:
          return id2(t3), e5 === null && $i2(t3.stateNode.containerInfo), null;
        case l2:
          return Zu2(t3), null;
        case h2:
          return Fl2(t3.type) && $l2(t3), null;
        case m2:
          md2(t3);
          var I3 = t3.memoizedState;
          if (I3 === null)
            return null;
          var D3 = (t3.flags & ur2) != 0, R3 = I3.rendering;
          if (R3 === null)
            if (D3)
              uh2(I3, false);
            else {
              if (!(rm === 0 && (e5 === null || (e5.flags & ur2) == 0)))
                for (var N3 = t3.child; N3 !== null; ) {
                  var A3 = gd2(N3);
                  if (A3 !== null) {
                    D3 = true, t3.flags |= ur2, uh2(I3, false);
                    var z3 = A3.updateQueue;
                    return z3 !== null && (t3.updateQueue = z3, t3.flags |= 4), I3.lastEffect === null && (t3.firstEffect = null), t3.lastEffect = I3.lastEffect, Jc2(t3, n3), hd2(t3, pd2(cd2.current, 2)), t3.child;
                  }
                  N3 = N3.sibling;
                }
              I3.tail !== null && wu2() > pm() && (t3.flags |= ur2, D3 = true, uh2(I3, false), t3.lanes = mo2, zv(mo2));
            }
          else {
            if (!D3) {
              var M3 = gd2(R3);
              if (M3 !== null) {
                t3.flags |= ur2, D3 = true;
                var L3 = M3.updateQueue;
                if (L3 !== null && (t3.updateQueue = L3, t3.flags |= 4), uh2(I3, true), I3.tail === null && I3.tailMode === "hidden" && !R3.alternate && !Dd2()) {
                  var F3 = t3.lastEffect = I3.lastEffect;
                  return F3 !== null && (F3.nextEffect = null), null;
                }
              } else
                2 * wu2() - I3.renderingStartTime > pm() && n3 !== wo2 && (t3.flags |= ur2, D3 = true, uh2(I3, false), t3.lanes = mo2, zv(mo2));
            }
            if (I3.isBackwards)
              R3.sibling = t3.child, t3.child = R3;
            else {
              var $3 = I3.last;
              $3 !== null ? $3.sibling = R3 : t3.child = R3, I3.last = R3;
            }
          }
          if (I3.tail !== null) {
            var B3 = I3.tail;
            I3.rendering = B3, I3.tail = B3.sibling, I3.lastEffect = t3.lastEffect, I3.renderingStartTime = wu2(), B3.sibling = null;
            var V3 = cd2.current;
            return hd2(t3, V3 = D3 ? pd2(V3, 2) : fd2(V3)), B3;
          }
          return null;
        case v2:
        case 21:
        case g2:
          break;
        case y2:
        case b2:
          if (Ym(t3), e5 !== null) {
            var U3 = t3.memoizedState;
            e5.memoizedState !== null !== (U3 !== null) && i3.mode !== "unstable-defer-without-hiding" && (t3.flags |= 4);
          }
          return null;
      }
      throw Error("Unknown unit of work tag (" + t3.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function dh2(e5, t3) {
      switch (e5.tag) {
        case 1:
          Fl2(e5.type) && $l2(e5);
          var n3 = e5.flags;
          return n3 & vr2 ? (e5.flags = -4097 & n3 | ur2, (8 & e5.mode) != 0 && hp2(e5), e5) : null;
        case 3:
          id2(e5), Bl2(e5), Ad2();
          var r3 = e5.flags;
          if ((r3 & ur2) != 0)
            throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
          return e5.flags = -4097 & r3 | ur2, e5;
        case 5:
          return ud2(e5), null;
        case d:
          md2(e5);
          var o3 = e5.flags;
          return o3 & vr2 ? (e5.flags = -4097 & o3 | ur2, (8 & e5.mode) != 0 && hp2(e5), e5) : null;
        case m2:
          return md2(e5), null;
        case 4:
          return id2(e5), null;
        case l2:
          return Zu2(e5), null;
        case y2:
        case b2:
          return Ym(e5), null;
        default:
          return null;
      }
    }
    function fh2(e5) {
      switch (e5.tag) {
        case 1:
          var t3 = e5.type.childContextTypes;
          t3 != null && $l2(e5);
          break;
        case 3:
          id2(e5), Bl2(e5), Ad2();
          break;
        case 5:
          ud2(e5);
          break;
        case 4:
          id2(e5);
          break;
        case d:
        case m2:
          md2(e5);
          break;
        case l2:
          Zu2(e5);
          break;
        case y2:
        case b2:
          Ym(e5);
      }
    }
    function ph2(e5, t3) {
      return { value: e5, source: t3, stack: Le2(t3) };
    }
    function hh2(e5, t3) {
      try {
        0;
        var n3 = t3.value, r3 = t3.source, o3 = t3.stack, a3 = o3 !== null ? o3 : "";
        if (n3 != null && n3._suppressLogging) {
          if (e5.tag === 1)
            return;
          console.error(n3);
        }
        var i3 = r3 ? $e2(r3.type) : null, s3 = i3 ? "The above error occurred in the <" + i3 + "> component:" : "The above error occurred in one of your React components:", l3 = $e2(e5.type), u3 = s3 + "\n" + a3 + "\n\n" + (l3 ? "React will try to recreate this component tree from scratch using the error boundary you provided, " + l3 + "." : "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.");
        console.error(u3);
      } catch (e6) {
        setTimeout(function() {
          throw e6;
        });
      }
    }
    eh2 = function(e5, t3, n3, r3) {
      for (var o3, a3, i3 = t3.child; i3 !== null; ) {
        if (i3.tag === 5 || i3.tag === 6)
          o3 = e5, a3 = i3.stateNode, o3.appendChild(a3);
        else if (i3.tag === 4)
          ;
        else if (i3.child !== null) {
          i3.child.return = i3, i3 = i3.child;
          continue;
        }
        if (i3 === t3)
          return;
        for (; i3.sibling === null; ) {
          if (i3.return === null || i3.return === t3)
            return;
          i3 = i3.return;
        }
        i3.sibling.return = i3.return, i3 = i3.sibling;
      }
    }, th2 = function(e5, t3, n3, r3, o3) {
      var a3 = e5.memoizedProps;
      if (a3 !== r3) {
        var i3 = function(e6, t4, n4, r4, o4, a4) {
          var i4 = a4;
          if (typeof r4.children != typeof n4.children && (typeof r4.children == "string" || typeof r4.children == "number")) {
            var s3 = "" + r4.children, l3 = js2(i4.ancestorInfo, t4);
            Cs2(null, s3, l3);
          }
          return ws2(e6, t4, n4, r4);
        }(t3.stateNode, n3, a3, r3, 0, sd2());
        t3.updateQueue = i3, i3 && sh2(t3);
      }
    }, nh2 = function(e5, t3, n3, r3) {
      n3 !== r3 && sh2(t3);
    };
    var mh2 = typeof WeakMap == "function" ? WeakMap : Map;
    function vh2(e5, t3, n3) {
      var r3 = uc2(ko2, n3);
      r3.tag = 3, r3.payload = { element: null };
      var o3 = t3.value;
      return r3.callback = function() {
        bv(o3), hh2(e5, t3);
      }, r3;
    }
    function gh2(e5, t3, n3) {
      var r3 = uc2(ko2, n3);
      r3.tag = 3;
      var o3 = e5.type.getDerivedStateFromError;
      if (typeof o3 == "function") {
        var a3 = t3.value;
        r3.payload = function() {
          return hh2(e5, t3), o3(a3);
        };
      }
      var s3 = e5.stateNode;
      return s3 !== null && typeof s3.componentDidCatch == "function" ? r3.callback = function() {
        var n4;
        Gv(e5), typeof o3 != "function" && (n4 = this, gm === null ? gm = /* @__PURE__ */ new Set([n4]) : gm.add(n4), hh2(e5, t3));
        var r4 = t3.value, a4 = t3.stack;
        this.componentDidCatch(r4, { componentStack: a4 !== null ? a4 : "" }), typeof o3 != "function" && (Do2(e5.lanes, 1) || i2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", $e2(e5.type) || "Unknown"));
      } : r3.callback = function() {
        Gv(e5);
      }, r3;
    }
    function yh2(e5, t3, n3) {
      var r3, o3 = e5.pingCache;
      if (o3 === null ? (o3 = e5.pingCache = new mh2(), r3 = /* @__PURE__ */ new Set(), o3.set(t3, r3)) : (r3 = o3.get(t3)) === void 0 && (r3 = /* @__PURE__ */ new Set(), o3.set(t3, r3)), !r3.has(n3)) {
        r3.add(n3);
        var a3 = xv.bind(null, e5, t3, n3);
        t3.then(a3, a3);
      }
    }
    function bh2(e5, t3, n3, r3, o3) {
      if (n3.flags |= mr2, n3.firstEffect = n3.lastEffect = null, r3 !== null && typeof r3 == "object" && typeof r3.then == "function") {
        var a3 = r3;
        if ((2 & n3.mode) == 0) {
          var i3 = n3.alternate;
          i3 ? (n3.updateQueue = i3.updateQueue, n3.memoizedState = i3.memoizedState, n3.lanes = i3.lanes) : (n3.updateQueue = null, n3.memoizedState = null);
        }
        var s3 = dd2(cd2.current, 1), l3 = t3;
        do {
          if (l3.tag === d && vd2(l3, s3)) {
            var u3 = l3.updateQueue;
            if (u3 === null) {
              var c3 = /* @__PURE__ */ new Set();
              c3.add(a3), l3.updateQueue = c3;
            } else
              u3.add(a3);
            if ((2 & l3.mode) == 0) {
              if (l3.flags |= ur2, n3.flags |= gr2, n3.flags &= -2981, n3.tag === 1)
                if (n3.alternate === null)
                  n3.tag = h2;
                else {
                  var f2 = uc2(ko2, 1);
                  f2.tag = ac2, cc2(n3, f2);
                }
              return void (n3.lanes = No2(n3.lanes, 1));
            }
            return yh2(e5, a3, o3), l3.flags |= vr2, void (l3.lanes = o3);
          }
          l3 = l3.return;
        } while (l3 !== null);
        r3 = new Error(($e2(n3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
      }
      rm !== 5 && (rm = 2), r3 = ph2(r3, n3);
      var p2 = t3;
      do {
        switch (p2.tag) {
          case 3:
            var m3 = r3;
            p2.flags |= vr2;
            var v3 = To2(o3);
            return p2.lanes = No2(p2.lanes, v3), void dc2(p2, vh2(p2, m3, v3));
          case 1:
            var g3 = r3, y3 = p2.type, b3 = p2.stateNode;
            if ((p2.flags & ur2) == 0 && (typeof y3.getDerivedStateFromError == "function" || b3 !== null && typeof b3.componentDidCatch == "function" && !yv(b3))) {
              p2.flags |= vr2;
              var w3 = To2(o3);
              return p2.lanes = No2(p2.lanes, w3), void dc2(p2, gh2(p2, g3, w3));
            }
        }
        p2 = p2.return;
      } while (p2 !== null);
    }
    var wh;
    wh = /* @__PURE__ */ new Set();
    var kh = typeof WeakSet == "function" ? WeakSet : Set, xh = function(e5, t3) {
      t3.props = e5.memoizedProps, t3.state = e5.memoizedState, t3.componentWillUnmount();
    };
    function Sh(e5) {
      var t3 = e5.ref;
      t3 !== null && (typeof t3 == "function" ? (tr2(null, t3, null, null), nr2() && kv(e5, rr2())) : t3.current = null);
    }
    function _h(e5, t3) {
      (tr2(null, t3, null), nr2()) && kv(e5, rr2());
    }
    function Eh(e5, t3) {
      switch (t3.tag) {
        case 0:
        case u2:
        case p:
        case g2:
          return;
        case 1:
          if (t3.flags & dr2 && e5 !== null) {
            var n3 = e5.memoizedProps, r3 = e5.memoizedState, o3 = t3.stateNode;
            t3.type !== t3.elementType || wp2 || (o3.props !== t3.memoizedProps && i2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", $e2(t3.type) || "instance"), o3.state !== t3.memoizedState && i2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", $e2(t3.type) || "instance"));
            var a3 = o3.getSnapshotBeforeUpdate(t3.elementType === t3.type ? n3 : Bu2(t3.type, n3), r3), s3 = wh;
            a3 !== void 0 || s3.has(t3.type) || (s3.add(t3.type), i2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", $e2(t3.type))), o3.__reactInternalSnapshotBeforeUpdate = a3;
          }
          return;
        case 3:
          if (t3.flags & dr2)
            Qs2(t3.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case h2:
          return;
      }
      throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ph(e5, t3, n3, r3) {
      switch (n3.tag) {
        case 0:
        case u2:
        case p:
        case g2:
          return function(e6, t4) {
            var n4 = t4.updateQueue, r4 = n4 !== null ? n4.lastEffect : null;
            if (r4 !== null) {
              var o4 = r4.next, a4 = o4;
              do {
                if ((a4.tag & e6) === e6) {
                  var s4 = a4.create;
                  a4.destroy = s4();
                  var l4 = a4.destroy;
                  l4 !== void 0 && typeof l4 != "function" && i2("An effect function must not return anything besides a function, which is used for clean-up.%s", l4 === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof l4.then == "function" ? "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching" : " You returned: " + l4);
                }
                a4 = a4.next;
              } while (a4 !== o4);
            }
          }(3, n3), void function(e6) {
            var t4 = e6.updateQueue, n4 = t4 !== null ? t4.lastEffect : null;
            if (n4 !== null) {
              var r4 = n4.next, o4 = r4;
              do {
                var a4 = o4, i3 = a4.next, s4 = a4.tag;
                (4 & s4) != 0 && (1 & s4) != 0 && (mv(e6, o4), hv(e6, o4)), o4 = i3;
              } while (o4 !== r4);
            }
          }(n3);
        case 1:
          var o3 = n3.stateNode;
          if (4 & n3.flags)
            if (t3 === null)
              n3.type !== n3.elementType || wp2 || (o3.props !== n3.memoizedProps && i2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", $e2(n3.type) || "instance"), o3.state !== n3.memoizedState && i2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", $e2(n3.type) || "instance")), o3.componentDidMount();
            else {
              var a3 = n3.elementType === n3.type ? t3.memoizedProps : Bu2(n3.type, t3.memoizedProps), s3 = t3.memoizedState;
              n3.type !== n3.elementType || wp2 || (o3.props !== n3.memoizedProps && i2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", $e2(n3.type) || "instance"), o3.state !== n3.memoizedState && i2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", $e2(n3.type) || "instance")), o3.componentDidUpdate(a3, s3, o3.__reactInternalSnapshotBeforeUpdate);
            }
          var l3 = n3.updateQueue;
          return void (l3 !== null && (n3.type !== n3.elementType || wp2 || (o3.props !== n3.memoizedProps && i2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", $e2(n3.type) || "instance"), o3.state !== n3.memoizedState && i2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", $e2(n3.type) || "instance")), gc2(0, l3, o3)));
        case 3:
          var f2 = n3.updateQueue;
          if (f2 !== null) {
            var w3 = null;
            if (n3.child !== null)
              switch (n3.child.tag) {
                case 5:
                case 1:
                  w3 = n3.child.stateNode;
              }
            gc2(0, f2, w3);
          }
          return;
        case 5:
          var k3 = n3.stateNode;
          if (t3 === null && 4 & n3.flags)
            !function(e6, t4, n4, r4) {
              Fs2(t4, n4) && e6.focus();
            }(k3, n3.type, n3.memoizedProps);
          return;
        case 6:
        case 4:
          return;
        case c2:
          var x3 = n3.memoizedProps;
          x3.onCommit;
          var S3 = x3.onRender;
          n3.stateNode.effectDuration;
          var _3 = up2();
          return void (typeof S3 == "function" && S3(n3.memoizedProps.id, t3 === null ? "mount" : "update", n3.actualDuration, n3.treeBaseDuration, n3.actualStartTime, _3, e5.memoizedInteractions));
        case d:
          return void function(e6, t4) {
            if (t4.memoizedState === null) {
              var n4 = t4.alternate;
              if (n4 !== null) {
                var r4 = n4.memoizedState;
                if (r4 !== null) {
                  var o4 = r4.dehydrated;
                  o4 !== null && function(e7) {
                    Wr2(e7);
                  }(o4);
                }
              }
            }
          }(0, n3);
        case m2:
        case h2:
        case v2:
        case 21:
        case y2:
        case b2:
          return;
      }
      throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ch(e5, t3) {
      for (var n3 = e5; ; ) {
        if (n3.tag === 5) {
          var r3 = n3.stateNode;
          t3 ? Ys2(r3) : Xs2(n3.stateNode, n3.memoizedProps);
        } else if (n3.tag === 6) {
          var o3 = n3.stateNode;
          t3 ? o3.nodeValue = "" : Gs2(o3, n3.memoizedProps);
        } else if (n3.tag !== y2 && n3.tag !== b2 || n3.memoizedState === null || n3 === e5) {
          if (n3.child !== null) {
            n3.child.return = n3, n3 = n3.child;
            continue;
          }
        } else
          ;
        if (n3 === e5)
          return;
        for (; n3.sibling === null; ) {
          if (n3.return === null || n3.return === e5)
            return;
          n3 = n3.return;
        }
        n3.sibling.return = n3.return, n3 = n3.sibling;
      }
    }
    function jh(e5) {
      var t3 = e5.ref;
      if (t3 !== null) {
        var n3, r3 = e5.stateNode;
        e5.tag, n3 = r3, typeof t3 == "function" ? t3(n3) : (t3.hasOwnProperty("current") || i2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", $e2(e5.type)), t3.current = n3);
      }
    }
    function Oh(e5) {
      var t3 = e5.ref;
      t3 !== null && (typeof t3 == "function" ? t3(null) : t3.current = null);
    }
    function Th(e5, t3, n3) {
      switch (function(e6) {
        if (Yl2 && typeof Yl2.onCommitFiberUnmount == "function")
          try {
            Yl2.onCommitFiberUnmount(Kl2, e6);
          } catch (e7) {
            Xl2 || (Xl2 = true, i2("React instrumentation encountered an error: %s", e7));
          }
      }(t3), t3.tag) {
        case 0:
        case u2:
        case f:
        case p:
        case g2:
          var r3 = t3.updateQueue;
          if (r3 !== null) {
            var o3 = r3.lastEffect;
            if (o3 !== null) {
              var a3 = o3.next, s3 = a3;
              do {
                var l3 = s3, c3 = l3.destroy, d2 = l3.tag;
                c3 !== void 0 && ((4 & d2) != 0 ? mv(t3, s3) : _h(t3, c3)), s3 = s3.next;
              } while (s3 !== a3);
            }
          }
          return;
        case 1:
          Sh(t3);
          var h3 = t3.stateNode;
          return void (typeof h3.componentWillUnmount == "function" && function(e6, t4) {
            tr2(null, xh, null, e6, t4), nr2() && kv(e6, rr2());
          }(t3, h3));
        case 5:
          return void Sh(t3);
        case 4:
          return void Mh(e5, t3);
        case v2:
        case 18:
        case 21:
          return;
      }
    }
    function Ih(e5, t3, n3) {
      for (var r3 = t3; ; )
        if (Th(e5, r3), r3.child === null || r3.tag === 4) {
          if (r3 === t3)
            return;
          for (; r3.sibling === null; ) {
            if (r3.return === null || r3.return === t3)
              return;
            r3 = r3.return;
          }
          r3.sibling.return = r3.return, r3 = r3.sibling;
        } else
          r3.child.return = r3, r3 = r3.child;
    }
    function Dh(e5) {
      e5.alternate = null, e5.child = null, e5.dependencies = null, e5.firstEffect = null, e5.lastEffect = null, e5.memoizedProps = null, e5.memoizedState = null, e5.pendingProps = null, e5.return = null, e5.updateQueue = null, e5._debugOwner = null;
    }
    function Rh(e5) {
      return e5.tag === 5 || e5.tag === 3 || e5.tag === 4;
    }
    function Nh(e5) {
      var t3, n3, r3 = function(e6) {
        for (var t4 = e6.return; t4 !== null; ) {
          if (Rh(t4))
            return t4;
          t4 = t4.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }(e5), o3 = r3.stateNode;
      switch (r3.tag) {
        case 5:
          t3 = o3, n3 = false;
          break;
        case 3:
        case 4:
          t3 = o3.containerInfo, n3 = true;
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
      16 & r3.flags && (qs2(t3), r3.flags &= -17);
      var a3 = function(e6) {
        var t4 = e6;
        e:
          for (; ; ) {
            for (; t4.sibling === null; ) {
              if (t4.return === null || Rh(t4.return))
                return null;
              t4 = t4.return;
            }
            for (t4.sibling.return = t4.return, t4 = t4.sibling; t4.tag !== 5 && t4.tag !== 6 && t4.tag !== 18; ) {
              if (2 & t4.flags)
                continue e;
              if (t4.child === null || t4.tag === 4)
                continue e;
              t4.child.return = t4, t4 = t4.child;
            }
            if (!(2 & t4.flags))
              return t4.stateNode;
          }
      }(e5);
      n3 ? Ah(e5, a3, t3) : zh(e5, a3, t3);
    }
    function Ah(e5, t3, n3) {
      var r3 = e5.tag, o3 = r3 === 5 || r3 === 6;
      if (o3) {
        var a3 = o3 ? e5.stateNode : e5.stateNode.instance;
        t3 ? function(e6, t4, n4) {
          e6.nodeType === 8 ? e6.parentNode.insertBefore(t4, n4) : e6.insertBefore(t4, n4);
        }(n3, a3, t3) : function(e6, t4) {
          var n4;
          e6.nodeType === 8 ? (n4 = e6.parentNode).insertBefore(t4, e6) : (n4 = e6).appendChild(t4), e6._reactRootContainer == null && n4.onclick === null && ys2(n4);
        }(n3, a3);
      } else if (r3 === 4)
        ;
      else {
        var i3 = e5.child;
        if (i3 !== null) {
          Ah(i3, t3, n3);
          for (var s3 = i3.sibling; s3 !== null; )
            Ah(s3, t3, n3), s3 = s3.sibling;
        }
      }
    }
    function zh(e5, t3, n3) {
      var r3 = e5.tag, o3 = r3 === 5 || r3 === 6;
      if (o3) {
        var a3 = o3 ? e5.stateNode : e5.stateNode.instance;
        t3 ? function(e6, t4, n4) {
          e6.insertBefore(t4, n4);
        }(n3, a3, t3) : function(e6, t4) {
          e6.appendChild(t4);
        }(n3, a3);
      } else if (r3 === 4)
        ;
      else {
        var i3 = e5.child;
        if (i3 !== null) {
          zh(i3, t3, n3);
          for (var s3 = i3.sibling; s3 !== null; )
            zh(s3, t3, n3), s3 = s3.sibling;
        }
      }
    }
    function Mh(e5, t3, n3) {
      for (var r3, o3, a3, i3, s3 = t3, l3 = false; ; ) {
        if (!l3) {
          var u3 = s3.return;
          e:
            for (; ; ) {
              if (u3 === null)
                throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var c3 = u3.stateNode;
              switch (u3.tag) {
                case 5:
                  r3 = c3, o3 = false;
                  break e;
                case 3:
                case 4:
                  r3 = c3.containerInfo, o3 = true;
                  break e;
              }
              u3 = u3.return;
            }
          l3 = true;
        }
        if (s3.tag === 5 || s3.tag === 6)
          Ih(e5, s3), o3 ? (a3 = r3, i3 = s3.stateNode, a3.nodeType === 8 ? a3.parentNode.removeChild(i3) : a3.removeChild(i3)) : Ks2(r3, s3.stateNode);
        else if (s3.tag === 4) {
          if (s3.child !== null) {
            r3 = s3.stateNode.containerInfo, o3 = true, s3.child.return = s3, s3 = s3.child;
            continue;
          }
        } else if (Th(e5, s3), s3.child !== null) {
          s3.child.return = s3, s3 = s3.child;
          continue;
        }
        if (s3 === t3)
          return;
        for (; s3.sibling === null; ) {
          if (s3.return === null || s3.return === t3)
            return;
          (s3 = s3.return).tag === 4 && (l3 = false);
        }
        s3.sibling.return = s3.return, s3 = s3.sibling;
      }
    }
    function Lh(e5, t3, n3) {
      Mh(e5, t3);
      var r3 = t3.alternate;
      Dh(t3), r3 !== null && Dh(r3);
    }
    function Fh(e5, t3) {
      switch (t3.tag) {
        case 0:
        case u2:
        case f:
        case p:
        case g2:
          return void function(e6, t4) {
            var n4 = t4.updateQueue, r4 = n4 !== null ? n4.lastEffect : null;
            if (r4 !== null) {
              var o4 = r4.next, a4 = o4;
              do {
                if ((a4.tag & e6) === e6) {
                  var i4 = a4.destroy;
                  a4.destroy = void 0, i4 !== void 0 && i4();
                }
                a4 = a4.next;
              } while (a4 !== o4);
            }
          }(3, t3);
        case 1:
          return;
        case 5:
          var n3 = t3.stateNode;
          if (n3 != null) {
            var r3 = t3.memoizedProps, o3 = e5 !== null ? e5.memoizedProps : r3, a3 = t3.type, i3 = t3.updateQueue;
            t3.updateQueue = null, i3 !== null && function(e6, t4, n4, r4, o4, a4) {
              yl2(e6, o4), ks2(e6, t4, n4, r4, o4);
            }(n3, i3, a3, o3, r3);
          }
          return;
        case 6:
          if (t3.stateNode === null)
            throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var s3 = t3.stateNode, l3 = t3.memoizedProps;
          e5 !== null && e5.memoizedProps;
          return void function(e6, t4, n4) {
            e6.nodeValue = n4;
          }(s3, 0, l3);
        case 3:
          var w3 = t3.stateNode;
          return void (w3.hydrate && (w3.hydrate = false, Wr2(w3.containerInfo)));
        case c2:
          return;
        case d:
          return function(e6) {
            if (e6.memoizedState !== null) {
              cm = wu2(), Ch(e6.child, true);
            }
          }(t3), void $h(t3);
        case m2:
          return void $h(t3);
        case h2:
          return;
        case v2:
        case 21:
          break;
        case y2:
        case b2:
          return void Ch(t3, t3.memoizedState !== null);
      }
      throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function $h(e5) {
      var t3 = e5.updateQueue;
      if (t3 !== null) {
        e5.updateQueue = null;
        var n3 = e5.stateNode;
        n3 === null && (n3 = e5.stateNode = new kh()), t3.forEach(function(t4) {
          var o3 = Sv.bind(null, e5, t4);
          n3.has(t4) || (t4.__reactDoNotTraceInteractions !== true && (o3 = r2.unstable_wrap(o3)), n3.add(t4), t4.then(o3, o3));
        });
      }
    }
    function Bh(e5, t3) {
      if (e5 !== null) {
        var n3 = e5.memoizedState;
        if (n3 === null || n3.dehydrated !== null) {
          var r3 = t3.memoizedState;
          return r3 !== null && r3.dehydrated === null;
        }
      }
      return false;
    }
    function Vh(e5) {
      qs2(e5.stateNode);
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Uh = Symbol.for;
      Uh("selector.component"), Uh("selector.has_pseudo_class"), Uh("selector.role"), Uh("selector.test_id"), Uh("selector.text");
    }
    var Hh = [];
    var Wh = Math.ceil, qh = o2.ReactCurrentDispatcher, Kh = o2.ReactCurrentOwner, Yh = o2.IsSomeRendererActing, Xh = 16, Gh = 32, Qh = 0, Jh = null, Zh = null, em = 0, tm = 0, nm = jl2(0), rm = 0, om = null, am = 0, im = 0, sm = 0, lm = 0, um = null, cm = 0, dm = 1 / 0;
    function fm() {
      dm = wu2() + 500;
    }
    function pm() {
      return dm;
    }
    var hm = null, mm = false, vm = null, gm = null, ym = false, bm = null, wm = 90, km = 0, xm = [], Sm = [], _m = null, Em = 0, Pm = null, Cm = 0, jm = null, Om = ko2, Tm = 0, Im = 0, Dm = false, Rm = null, Nm = false;
    function Am() {
      return (48 & Qh) != 0 ? wu2() : Om !== ko2 ? Om : Om = wu2();
    }
    function zm(e5) {
      var t3 = e5.mode;
      if ((2 & t3) == 0)
        return 1;
      if ((4 & t3) == 0)
        return ku2() === du2 ? 1 : 2;
      if (Tm === 0 && (Tm = am), Ou2.transition !== 0)
        return Im !== 0 && (Im = um !== null ? um.pendingLanes : 0), function(e6, t4) {
          var n4 = To2(po2 & ~t4);
          return n4 === 0 && (n4 = To2(po2 & ~e6)) === 0 && (n4 = To2(po2)), n4;
        }(Tm, Im);
      var n3, r3 = ku2();
      (4 & Qh) != 0 && r3 === fu2 ? n3 = Oo2(12, Tm) : n3 = Oo2(function(e6) {
        switch (e6) {
          case 99:
            return uo2;
          case 98:
            return co2;
          case 97:
          case 96:
            return 8;
          case 95:
            return 2;
          default:
            return 0;
        }
      }(r3), Tm);
      return n3;
    }
    function Mm(e5) {
      var t3, n3 = e5.mode;
      return (2 & n3) == 0 ? 1 : (4 & n3) == 0 ? ku2() === du2 ? 1 : 2 : (Tm === 0 && (Tm = am), (t3 = To2(ho2 & ~Tm)) === 0 && (t3 = To2(ho2)), t3);
    }
    function Lm(e5, t3, n3) {
      !function() {
        if (Em > 50)
          throw Em = 0, Pm = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        Cm > 50 && (Cm = 0, i2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      }(), function(e6) {
        if (Ue && (Qh & Xh) != 0 && !Hf2)
          switch (e6.tag) {
            case 0:
            case u2:
            case p:
              var t4 = Zh && $e2(Zh.type) || "Unknown", n4 = t4;
              if (!jv.has(n4))
                jv.add(n4), i2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", $e2(e6.type) || "Unknown", t4, t4);
              break;
            case 1:
              Ov || (i2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), Ov = true);
          }
      }(e5);
      var r3 = Fm(e5, t3);
      if (r3 === null)
        return function(e6) {
          var t4 = e6.tag;
          if (t4 !== 3 && t4 !== 1 && t4 !== 0 && t4 !== u2 && t4 !== f && t4 !== p && t4 !== g2)
            return;
          if ((e6.flags & pr2) != 0)
            return;
          var n4 = $e2(e6.type) || "ReactComponent";
          if (Cv !== null) {
            if (Cv.has(n4))
              return;
            Cv.add(n4);
          } else
            Cv = /* @__PURE__ */ new Set([n4]);
          if (Dm)
            ;
          else {
            var r4 = Ve2;
            try {
              Ke2(e6), i2("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", t4 === 1 ? "the componentWillUnmount method" : "a useEffect cleanup function");
            } finally {
              r4 ? Ke2(e6) : qe2();
            }
          }
        }(e5), null;
      Mo2(r3, t3, n3), r3 === Jh && (sm = No2(sm, t3), rm === 4 && Vm(r3, em));
      var o3 = ku2();
      t3 === 1 ? (8 & Qh) != 0 && (48 & Qh) == 0 ? (Lv(r3, t3), Um(r3)) : ($m(r3, n3), Lv(r3, t3), Qh === 0 && (fm(), Pu2())) : ((4 & Qh) == 0 || o3 !== fu2 && o3 !== du2 || (_m === null ? _m = /* @__PURE__ */ new Set([r3]) : _m.add(r3)), $m(r3, n3), Lv(r3, t3)), um = r3;
    }
    function Fm(e5, t3) {
      e5.lanes = No2(e5.lanes, t3);
      var n3 = e5.alternate;
      n3 !== null && (n3.lanes = No2(n3.lanes, t3)), n3 === null && (1026 & e5.flags) != 0 && Ev(e5);
      for (var r3 = e5, o3 = e5.return; o3 !== null; )
        o3.childLanes = No2(o3.childLanes, t3), (n3 = o3.alternate) !== null ? n3.childLanes = No2(n3.childLanes, t3) : (1026 & o3.flags) != 0 && Ev(e5), r3 = o3, o3 = o3.return;
      return r3.tag === 3 ? r3.stateNode : null;
    }
    function $m(e5, t3) {
      var n3 = e5.callbackNode;
      !function(e6, t4) {
        for (var n4 = e6.pendingLanes, r4 = e6.suspendedLanes, o4 = e6.pingedLanes, a4 = e6.expirationTimes, i4 = n4; i4 > 0; ) {
          var s3 = Io2(i4), l3 = 1 << s3, u3 = a4[s3];
          u3 === ko2 ? (l3 & r4) != 0 && (l3 & o4) == 0 || (a4[s3] = Eo2(l3, t4)) : u3 <= t4 && (e6.expiredLanes |= l3), i4 &= ~l3;
        }
      }(e5, t3);
      var r3 = _o2(e5, e5 === Jh ? em : 0), o3 = xo2;
      if (r3 !== 0) {
        if (n3 !== null) {
          if (e5.callbackPriority === o3)
            return;
          Eu2(n3);
        }
        var a3, i3;
        if (o3 === uo2)
          i3 = Um.bind(null, e5), vu2 === null ? (vu2 = [i3], gu2 = Zl2(au2, Cu2)) : vu2.push(i3), a3 = cu2;
        else if (o3 === 14)
          a3 = _u2(du2, Um.bind(null, e5));
        else {
          a3 = _u2(function(e6) {
            switch (e6) {
              case uo2:
              case 14:
                return 99;
              case 13:
              case 12:
              case 11:
              case co2:
                return 98;
              case 9:
              case 8:
              case 7:
              case 6:
              case 4:
              case 5:
                return 97;
              case 3:
              case 2:
              case 1:
                return 95;
              case 0:
                return 90;
              default:
                throw Error("Invalid update priority: " + e6 + ". This is a bug in React.");
            }
          }(o3), Bm.bind(null, e5));
        }
        e5.callbackPriority = o3, e5.callbackNode = a3;
      } else
        n3 !== null && (Eu2(n3), e5.callbackNode = null, e5.callbackPriority = 0);
    }
    function Bm(e5) {
      if (Om = ko2, Tm = 0, Im = 0, (48 & Qh) != 0)
        throw Error("Should not already be working.");
      var t3 = e5.callbackNode;
      if (pv() && e5.callbackNode !== t3)
        return null;
      var n3 = _o2(e5, e5 === Jh ? em : 0);
      if (n3 === 0)
        return null;
      var r3 = function(e6, t4) {
        var n4 = Qh;
        Qh |= Xh;
        var r4 = Qm();
        Jh === e6 && em === t4 || (fm(), Xm(e6, t4), Fv(e6, t4));
        var o4 = Zm(e6);
        for (; ; )
          try {
            ov();
            break;
          } catch (t5) {
            Gm(e6, t5);
          }
        return Xu2(), ev(o4), Jm(r4), Qh = n4, Zh !== null ? 0 : (Jh = null, em = 0, rm);
      }(e5, n3);
      if (Do2(am, sm))
        Xm(e5, 0);
      else if (r3 !== 0) {
        if (r3 === 2 && (Qh |= 64, e5.hydrate && (e5.hydrate = false, Qs2(e5.containerInfo)), (n3 = Po2(e5)) !== 0 && (r3 = nv(e5, n3))), r3 === 1) {
          var o3 = om;
          throw Xm(e5, 0), Vm(e5, n3), $m(e5, wu2()), o3;
        }
        var a3 = e5.current.alternate;
        e5.finishedWork = a3, e5.finishedLanes = n3, function(e6, t4, n4) {
          switch (t4) {
            case 0:
            case 1:
              throw Error("Root did not complete. This is a bug in React.");
            case 2:
            case 5:
              lv(e6);
              break;
            case 3:
              if (Vm(e6, n4), jo2(n4) && !(Bv > 0)) {
                var r4 = cm + 500 - wu2();
                if (r4 > 10) {
                  if (_o2(e6, 0) !== 0)
                    break;
                  var o4 = e6.suspendedLanes;
                  if (!Ro2(o4, n4)) {
                    Am(), Lo2(e6, o4);
                    break;
                  }
                  e6.timeoutHandle = Hs2(lv.bind(null, e6), r4);
                  break;
                }
              }
              lv(e6);
              break;
            case 4:
              if (Vm(e6, n4), function(e7) {
                return (e7 & po2) === e7;
              }(n4))
                break;
              var a4 = function(e7, t5) {
                for (var n5 = e7.eventTimes, r5 = ko2; t5 > 0; ) {
                  var o5 = Io2(t5), a5 = 1 << o5, i4 = n5[o5];
                  i4 > r5 && (r5 = i4), t5 &= ~a5;
                }
                return r5;
              }(e6, n4), i3 = a4, s3 = wu2() - i3, l3 = ((u3 = s3) < 120 ? 120 : u3 < 480 ? 480 : u3 < 1080 ? 1080 : u3 < 1920 ? 1920 : u3 < 3e3 ? 3e3 : u3 < 4320 ? 4320 : 1960 * Wh(u3 / 1960)) - s3;
              if (l3 > 10) {
                e6.timeoutHandle = Hs2(lv.bind(null, e6), l3);
                break;
              }
              lv(e6);
              break;
            default:
              throw Error("Unknown root exit status.");
          }
          var u3;
        }(e5, r3, n3);
      }
      return $m(e5, wu2()), e5.callbackNode === t3 ? Bm.bind(null, e5) : null;
    }
    function Vm(e5, t3) {
      t3 = Ao2(t3, lm), function(e6, t4) {
        e6.suspendedLanes |= t4, e6.pingedLanes &= ~t4;
        for (var n3 = e6.expirationTimes, r3 = t4; r3 > 0; ) {
          var o3 = Io2(r3), a3 = 1 << o3;
          n3[o3] = ko2, r3 &= ~a3;
        }
      }(e5, t3 = Ao2(t3, sm));
    }
    function Um(e5) {
      if ((48 & Qh) != 0)
        throw Error("Should not already be working.");
      var t3, n3;
      if (pv(), e5 === Jh && Do2(e5.expiredLanes, em) ? (n3 = nv(e5, t3 = em), Do2(am, sm) && (n3 = nv(e5, t3 = _o2(e5, t3)))) : n3 = nv(e5, t3 = _o2(e5, 0)), e5.tag !== 0 && n3 === 2 && (Qh |= 64, e5.hydrate && (e5.hydrate = false, Qs2(e5.containerInfo)), (t3 = Po2(e5)) !== 0 && (n3 = nv(e5, t3))), n3 === 1) {
        var r3 = om;
        throw Xm(e5, 0), Vm(e5, t3), $m(e5, wu2()), r3;
      }
      var o3 = e5.current.alternate;
      return e5.finishedWork = o3, e5.finishedLanes = t3, lv(e5), $m(e5, wu2()), null;
    }
    function Hm(e5, t3) {
      var n3 = Qh;
      Qh |= 1;
      try {
        return e5(t3);
      } finally {
        (Qh = n3) === 0 && (fm(), Pu2());
      }
    }
    function Wm(e5, t3) {
      var n3 = Qh;
      Qh &= -2, Qh |= 8;
      try {
        return e5(t3);
      } finally {
        (Qh = n3) === 0 && (fm(), Pu2());
      }
    }
    function qm(e5, t3) {
      var n3 = Qh;
      if ((48 & n3) != 0)
        return i2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), e5(t3);
      Qh |= 1;
      try {
        return e5 ? Su2(du2, e5.bind(null, t3)) : void 0;
      } finally {
        Qh = n3, Pu2();
      }
    }
    function Km(e5, t3) {
      Tl2(nm, tm, e5), tm = No2(tm, t3), am = No2(am, t3);
    }
    function Ym(e5) {
      tm = nm.current, Ol2(nm, e5);
    }
    function Xm(e5, t3) {
      e5.finishedWork = null, e5.finishedLanes = 0;
      var n3 = e5.timeoutHandle;
      if (n3 !== -1 && (e5.timeoutHandle = -1, Ws2(n3)), Zh !== null)
        for (var r3 = Zh.return; r3 !== null; )
          fh2(r3), r3 = r3.return;
      Jh = e5, Zh = cg(e5.current, null), em = tm = am = t3, rm = 0, om = null, im = 0, sm = 0, lm = 0, jm = null, Tu2.discardPendingWarnings();
    }
    function Gm(e5, t3) {
      for (; ; ) {
        var n3 = Zh;
        try {
          if (Xu2(), of2(), qe2(), Kh.current = null, n3 === null || n3.return === null)
            return rm = 1, om = t3, void (Zh = null);
          8 & n3.mode && pp2(n3, true), bh2(e5, n3.return, n3, t3, em), iv(n3);
        } catch (e6) {
          t3 = e6, Zh === n3 && n3 !== null ? (n3 = n3.return, Zh = n3) : n3 = Zh;
          continue;
        }
        return;
      }
    }
    function Qm() {
      var e5 = qh.current;
      return qh.current = Gf2, e5 === null ? Gf2 : e5;
    }
    function Jm(e5) {
      qh.current = e5;
    }
    function Zm(e5) {
      var t3 = r2.__interactionsRef.current;
      return r2.__interactionsRef.current = e5.memoizedInteractions, t3;
    }
    function ev(e5) {
      r2.__interactionsRef.current = e5;
    }
    function tv(e5) {
      im = No2(e5, im);
    }
    function nv(e5, t3) {
      var n3 = Qh;
      Qh |= Xh;
      var r3 = Qm();
      Jh === e5 && em === t3 || (Xm(e5, t3), Fv(e5, t3));
      for (var o3 = Zm(e5); ; )
        try {
          rv();
          break;
        } catch (t4) {
          Gm(e5, t4);
        }
      if (Xu2(), ev(o3), Qh = n3, Jm(r3), Zh !== null)
        throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Jh = null, em = 0, rm;
    }
    function rv() {
      for (; Zh !== null; )
        av(Zh);
    }
    function ov() {
      for (; Zh !== null && !hu2(); )
        av(Zh);
    }
    function av(e5) {
      var t3, n3 = e5.alternate;
      Ke2(e5), (8 & e5.mode) != 0 ? (dp2(e5), t3 = Pv(n3, e5, tm), pp2(e5, true)) : t3 = Pv(n3, e5, tm), qe2(), e5.memoizedProps = e5.pendingProps, t3 === null ? iv(e5) : Zh = t3, Kh.current = null;
    }
    function iv(e5) {
      var t3 = e5;
      do {
        var n3 = t3.alternate, r3 = t3.return;
        if ((t3.flags & mr2) == 0) {
          Ke2(t3);
          var o3 = void 0;
          if ((8 & t3.mode) == 0 ? o3 = ch2(n3, t3, tm) : (dp2(t3), o3 = ch2(n3, t3, tm), pp2(t3, false)), qe2(), o3 !== null)
            return void (Zh = o3);
          if (sv(t3), r3 !== null && (r3.flags & mr2) == 0)
            r3.firstEffect === null && (r3.firstEffect = t3.firstEffect), t3.lastEffect !== null && (r3.lastEffect !== null && (r3.lastEffect.nextEffect = t3.firstEffect), r3.lastEffect = t3.lastEffect), t3.flags > 1 && (r3.lastEffect !== null ? r3.lastEffect.nextEffect = t3 : r3.firstEffect = t3, r3.lastEffect = t3);
        } else {
          var a3 = dh2(t3);
          if (a3 !== null)
            return a3.flags &= 2047, void (Zh = a3);
          if ((8 & t3.mode) != 0) {
            pp2(t3, false);
            for (var i3 = t3.actualDuration, s3 = t3.child; s3 !== null; )
              i3 += s3.actualDuration, s3 = s3.sibling;
            t3.actualDuration = i3;
          }
          r3 !== null && (r3.firstEffect = r3.lastEffect = null, r3.flags |= mr2);
        }
        var l3 = t3.sibling;
        if (l3 !== null)
          return void (Zh = l3);
        Zh = t3 = r3;
      } while (t3 !== null);
      rm === 0 && (rm = 5);
    }
    function sv(e5) {
      if (e5.tag !== b2 && e5.tag !== y2 || e5.memoizedState === null || Do2(tm, wo2) || (4 & e5.mode) == 0) {
        var t3 = 0;
        if ((8 & e5.mode) != 0) {
          for (var n3 = e5.actualDuration, r3 = e5.selfBaseDuration, o3 = e5.alternate === null || e5.child !== e5.alternate.child, a3 = e5.child; a3 !== null; )
            t3 = No2(t3, No2(a3.lanes, a3.childLanes)), o3 && (n3 += a3.actualDuration), r3 += a3.treeBaseDuration, a3 = a3.sibling;
          if (e5.tag === d && e5.memoizedState !== null) {
            var i3 = e5.child;
            i3 !== null && (r3 -= i3.treeBaseDuration);
          }
          e5.actualDuration = n3, e5.treeBaseDuration = r3;
        } else
          for (var s3 = e5.child; s3 !== null; )
            t3 = No2(t3, No2(s3.lanes, s3.childLanes)), s3 = s3.sibling;
        e5.childLanes = t3;
      }
    }
    function lv(e5) {
      var t3 = ku2();
      return Su2(du2, uv.bind(null, e5, t3)), null;
    }
    function uv(e5, t3) {
      do {
        pv();
      } while (bm !== null);
      if (Tu2.flushLegacyContextWarning(), Tu2.flushPendingUnsafeLifecycleWarnings(), (48 & Qh) != 0)
        throw Error("Should not already be working.");
      var n3 = e5.finishedWork, r3 = e5.finishedLanes;
      if (n3 === null)
        return null;
      if (e5.finishedWork = null, e5.finishedLanes = 0, n3 === e5.current)
        throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e5.callbackNode = null;
      var o3, a3 = No2(n3.lanes, n3.childLanes);
      if (function(e6, t4) {
        var n4 = e6.pendingLanes & ~t4;
        e6.pendingLanes = t4, e6.suspendedLanes = 0, e6.pingedLanes = 0, e6.expiredLanes &= t4, e6.mutableReadLanes &= t4, e6.entangledLanes &= t4;
        for (var r4 = e6.entanglements, o4 = e6.eventTimes, a4 = e6.expirationTimes, i4 = n4; i4 > 0; ) {
          var s4 = Io2(i4), l4 = 1 << s4;
          r4[s4] = 0, o4[s4] = ko2, a4[s4] = ko2, i4 &= ~l4;
        }
      }(e5, a3), _m !== null && !function(e6) {
        return (24 & e6) != 0;
      }(a3) && _m.has(e5) && _m.delete(e5), e5 === Jh && (Jh = null, Zh = null, em = 0), n3.flags > 1 ? n3.lastEffect !== null ? (n3.lastEffect.nextEffect = n3, o3 = n3.firstEffect) : o3 = n3 : o3 = n3.firstEffect, o3 !== null) {
        var i3 = Qh;
        Qh |= Gh;
        var s3 = Zm(e5);
        Kh.current = null, Rm = $s2(e5.containerInfo), Nm = false, hm = o3;
        do {
          if (tr2(null, cv, null), nr2()) {
            if (hm === null)
              throw Error("Should be working on an effect.");
            var l3 = rr2();
            kv(hm, l3), hm = hm.nextEffect;
          }
        } while (hm !== null);
        Rm = null, cp2(), hm = o3;
        do {
          if (tr2(null, dv, null, e5, t3), nr2()) {
            if (hm === null)
              throw Error("Should be working on an effect.");
            var u3 = rr2();
            kv(hm, u3), hm = hm.nextEffect;
          }
        } while (hm !== null);
        e5.containerInfo, Si2(Ls2), qo2(Ms2), Ms2 = null, Ls2 = null, e5.current = n3, hm = o3;
        do {
          if (tr2(null, fv, null, e5, r3), nr2()) {
            if (hm === null)
              throw Error("Should be working on an effect.");
            var c3 = rr2();
            kv(hm, c3), hm = hm.nextEffect;
          }
        } while (hm !== null);
        hm = null, mu2(), ev(s3), Qh = i3;
      } else
        e5.current = n3, cp2();
      var d2 = ym;
      if (ym)
        ym = false, bm = e5, km = r3, wm = t3;
      else
        for (hm = o3; hm !== null; ) {
          var f2 = hm.nextEffect;
          hm.nextEffect = null, 8 & hm.flags && Vv(hm), hm = f2;
        }
      if ((a3 = e5.pendingLanes) !== 0) {
        if (jm !== null) {
          var p2 = jm;
          jm = null;
          for (var h3 = 0; h3 < p2.length; h3++)
            Mv(e5, p2[h3], e5.memoizedInteractions);
        }
        Lv(e5, a3);
      } else
        gm = null;
      if (d2 || $v(e5, r3), a3 === 1 ? e5 === Pm ? Em++ : (Em = 0, Pm = e5) : Em = 0, Ql2(n3.stateNode, t3), Hh.forEach(function(e6) {
        return e6();
      }), $m(e5, wu2()), mm) {
        mm = false;
        var m3 = vm;
        throw vm = null, m3;
      }
      return (8 & Qh) != 0 || Pu2(), null;
    }
    function cv() {
      for (; hm !== null; ) {
        var e5 = hm.alternate;
        Nm || Rm === null || ((8 & hm.flags) != 0 ? Er2(hm, Rm) && (Nm = true) : hm.tag === d && Bh(e5, hm) && Er2(hm, Rm) && (Nm = true));
        var t3 = hm.flags;
        (t3 & dr2) != 0 && (Ke2(hm), Eh(e5, hm), qe2()), (t3 & fr2) != 0 && (ym || (ym = true, _u2(pu2, function() {
          return pv(), null;
        }))), hm = hm.nextEffect;
      }
    }
    function dv(e5, t3) {
      for (; hm !== null; ) {
        Ke2(hm);
        var n3 = hm.flags;
        if (16 & n3 && Vh(hm), n3 & cr2) {
          var r3 = hm.alternate;
          r3 !== null && Oh(r3);
        }
        switch (1038 & n3) {
          case 2:
            Nh(hm), hm.flags &= -3;
            break;
          case 6:
            Nh(hm), hm.flags &= -3, Fh(hm.alternate, hm);
            break;
          case hr2:
            hm.flags &= -1025;
            break;
          case 1028:
            hm.flags &= -1025, Fh(hm.alternate, hm);
            break;
          case 4:
            Fh(hm.alternate, hm);
            break;
          case 8:
            Lh(e5, hm);
        }
        qe2(), hm = hm.nextEffect;
      }
    }
    function fv(e5, t3) {
      for (; hm !== null; ) {
        Ke2(hm);
        var n3 = hm.flags;
        if (36 & n3)
          Ph(e5, hm.alternate, hm);
        n3 & cr2 && jh(hm), qe2(), hm = hm.nextEffect;
      }
    }
    function pv() {
      if (wm !== 90) {
        var e5 = wm > pu2 ? pu2 : wm;
        return wm = 90, Su2(e5, gv);
      }
      return false;
    }
    function hv(e5, t3) {
      xm.push(t3, e5), ym || (ym = true, _u2(pu2, function() {
        return pv(), null;
      }));
    }
    function mv(e5, t3) {
      Sm.push(t3, e5), e5.flags |= pr2;
      var n3 = e5.alternate;
      n3 !== null && (n3.flags |= pr2), ym || (ym = true, _u2(pu2, function() {
        return pv(), null;
      }));
    }
    function vv(e5) {
      var t3 = e5.create;
      e5.destroy = t3();
    }
    function gv() {
      if (bm === null)
        return false;
      var e5 = bm, t3 = km;
      if (bm = null, km = 0, (48 & Qh) != 0)
        throw Error("Cannot flush passive effects while already rendering.");
      Dm = true;
      var n3 = Qh;
      Qh |= Gh;
      var r3 = Zm(e5), o3 = Sm;
      Sm = [];
      for (var a3 = 0; a3 < o3.length; a3 += 2) {
        var i3 = o3[a3], s3 = o3[a3 + 1], l3 = i3.destroy;
        i3.destroy = void 0, s3.flags &= -8193;
        var u3 = s3.alternate;
        if (u3 !== null && (u3.flags &= -8193), typeof l3 == "function") {
          if (Ke2(s3), tr2(null, l3, null), nr2()) {
            if (s3 === null)
              throw Error("Should be working on an effect.");
            kv(s3, rr2());
          }
          qe2();
        }
      }
      var c3 = xm;
      xm = [];
      for (var d2 = 0; d2 < c3.length; d2 += 2) {
        var f2 = c3[d2], p2 = c3[d2 + 1];
        if (Ke2(p2), tr2(null, vv, null, f2), nr2()) {
          if (p2 === null)
            throw Error("Should be working on an effect.");
          kv(p2, rr2());
        }
        qe2();
      }
      for (var h3 = e5.current.firstEffect; h3 !== null; ) {
        var m3 = h3.nextEffect;
        h3.nextEffect = null, 8 & h3.flags && Vv(h3), h3 = m3;
      }
      return ev(r3), $v(e5, t3), Dm = false, Qh = n3, Pu2(), Cm = bm === null ? 0 : Cm + 1, true;
    }
    function yv(e5) {
      return gm !== null && gm.has(e5);
    }
    var bv = function(e5) {
      mm || (mm = true, vm = e5);
    };
    function wv(e5, t3, n3) {
      cc2(e5, vh2(e5, ph2(n3, t3), 1));
      var r3 = Am(), o3 = Fm(e5, 1);
      o3 !== null && (Mo2(o3, 1, r3), $m(o3, r3), Lv(o3, 1));
    }
    function kv(e5, t3) {
      if (e5.tag !== 3)
        for (var n3 = e5.return; n3 !== null; ) {
          if (n3.tag === 3)
            return void wv(n3, e5, t3);
          if (n3.tag === 1) {
            var r3 = n3.type, o3 = n3.stateNode;
            if (typeof r3.getDerivedStateFromError == "function" || typeof o3.componentDidCatch == "function" && !yv(o3)) {
              var a3 = ph2(t3, e5);
              cc2(n3, gh2(n3, a3, 1));
              var i3 = Am(), s3 = Fm(n3, 1);
              if (s3 !== null)
                Mo2(s3, 1, i3), $m(s3, i3), Lv(s3, 1);
              else if (typeof o3.componentDidCatch == "function" && !yv(o3))
                try {
                  o3.componentDidCatch(t3, a3);
                } catch (e6) {
                }
              return;
            }
          }
          n3 = n3.return;
        }
      else
        wv(e5, e5, t3);
    }
    function xv(e5, t3, n3) {
      var r3 = e5.pingCache;
      r3 !== null && r3.delete(t3);
      var o3 = Am();
      Lo2(e5, n3), Jh === e5 && Ro2(em, n3) && (rm === 4 || rm === 3 && jo2(em) && wu2() - cm < 500 ? Xm(e5, 0) : lm = No2(lm, n3)), $m(e5, o3), Lv(e5, n3);
    }
    function Sv(e5, t3) {
      var n3;
      (n3 = e5.stateNode) !== null && n3.delete(t3), function(e6, t4) {
        t4 === 0 && (t4 = Mm(e6));
        var n4 = Am(), r3 = Fm(e6, t4);
        r3 !== null && (Mo2(r3, t4, n4), $m(r3, n4), Lv(r3, t4));
      }(e5, 0);
    }
    var _v = null;
    function Ev(e5) {
      if ((Qh & Xh) == 0 && 6 & e5.mode) {
        var t3 = e5.tag;
        if (t3 === 2 || t3 === 3 || t3 === 1 || t3 === 0 || t3 === u2 || t3 === f || t3 === p || t3 === g2) {
          var n3 = $e2(e5.type) || "ReactComponent";
          if (_v !== null) {
            if (_v.has(n3))
              return;
            _v.add(n3);
          } else
            _v = /* @__PURE__ */ new Set([n3]);
          var r3 = Ve2;
          try {
            Ke2(e5), i2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          } finally {
            r3 ? Ke2(e5) : qe2();
          }
        }
      }
    }
    var Pv, Cv = null;
    Pv = function(e5, t3, n3) {
      var r3 = yg(null, t3);
      try {
        return ih2(e5, t3, n3);
      } catch (o3) {
        if (o3 !== null && typeof o3 == "object" && typeof o3.then == "function")
          throw o3;
        if (Xu2(), of2(), fh2(t3), yg(t3, r3), 8 & t3.mode && dp2(t3), tr2(null, ih2, null, e5, t3, n3), nr2())
          throw rr2();
        throw o3;
      }
    };
    var jv, Ov = false;
    jv = /* @__PURE__ */ new Set();
    var Tv = { current: false };
    function Iv(e5) {
      if (Yh.current === true && Tv.current !== true) {
        var t3 = Ve2;
        try {
          Ke2(e5), i2("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
        } finally {
          t3 ? Ke2(e5) : qe2();
        }
      }
    }
    function Dv(e5) {
      (1 & e5.mode) != 0 && Yh.current === false && Tv.current === false && i2("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", $e2(e5.type));
    }
    var Rv = function(e5) {
      if (Qh === 0 && Yh.current === false && Tv.current === false) {
        var t3 = Ve2;
        try {
          Ke2(e5), i2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", $e2(e5.type));
        } finally {
          t3 ? Ke2(e5) : qe2();
        }
      }
    }, Nv = false;
    function Av(e5, t3) {
      return 1e3 * t3 + e5.interactionThreadID;
    }
    function zv(e5) {
      jm === null ? jm = [e5] : jm.push(e5);
    }
    function Mv(e5, t3, n3) {
      if (n3.size > 0) {
        var o3 = e5.pendingInteractionMap, a3 = o3.get(t3);
        a3 != null ? n3.forEach(function(e6) {
          a3.has(e6) || e6.__count++, a3.add(e6);
        }) : (o3.set(t3, new Set(n3)), n3.forEach(function(e6) {
          e6.__count++;
        }));
        var i3 = r2.__subscriberRef.current;
        if (i3 !== null) {
          var s3 = Av(e5, t3);
          i3.onWorkScheduled(n3, s3);
        }
      }
    }
    function Lv(e5, t3) {
      Mv(e5, t3, r2.__interactionsRef.current);
    }
    function Fv(e5, t3) {
      var n3 = /* @__PURE__ */ new Set();
      if (e5.pendingInteractionMap.forEach(function(e6, r3) {
        Do2(t3, r3) && e6.forEach(function(e7) {
          return n3.add(e7);
        });
      }), e5.memoizedInteractions = n3, n3.size > 0) {
        var o3 = r2.__subscriberRef.current;
        if (o3 !== null) {
          var a3 = Av(e5, t3);
          try {
            o3.onWorkStarted(n3, a3);
          } catch (e6) {
            _u2(du2, function() {
              throw e6;
            });
          }
        }
      }
    }
    function $v(e5, t3) {
      var n3, o3 = e5.pendingLanes;
      try {
        if ((n3 = r2.__subscriberRef.current) !== null && e5.memoizedInteractions.size > 0) {
          var a3 = Av(e5, t3);
          n3.onWorkStopped(e5.memoizedInteractions, a3);
        }
      } catch (e6) {
        _u2(du2, function() {
          throw e6;
        });
      } finally {
        var i3 = e5.pendingInteractionMap;
        i3.forEach(function(e6, t4) {
          Do2(o3, t4) || (i3.delete(t4), e6.forEach(function(e7) {
            if (e7.__count--, n3 !== null && e7.__count === 0)
              try {
                n3.onInteractionScheduledWorkCompleted(e7);
              } catch (e8) {
                _u2(du2, function() {
                  throw e8;
                });
              }
          }));
        });
      }
    }
    var Bv = 0;
    function Vv(e5) {
      e5.sibling = null, e5.stateNode = null;
    }
    var Uv = null, Hv = null, Wv = function(e5) {
      Uv = e5;
    };
    function qv(e5) {
      if (Uv === null)
        return e5;
      var t3 = Uv(e5);
      return t3 === void 0 ? e5 : t3.current;
    }
    function Kv(e5) {
      return qv(e5);
    }
    function Yv(e5) {
      if (Uv === null)
        return e5;
      var t3 = Uv(e5);
      if (t3 === void 0) {
        if (e5 != null && typeof e5.render == "function") {
          var n3 = qv(e5.render);
          if (e5.render !== n3) {
            var r3 = { $$typeof: ne2, render: n3 };
            return e5.displayName !== void 0 && (r3.displayName = e5.displayName), r3;
          }
        }
        return e5;
      }
      return t3.current;
    }
    function Xv(e5, t3) {
      if (Uv === null)
        return false;
      var n3 = e5.elementType, r3 = t3.type, o3 = false, a3 = typeof r3 == "object" && r3 !== null ? r3.$$typeof : null;
      switch (e5.tag) {
        case 1:
          typeof r3 == "function" && (o3 = true);
          break;
        case 0:
          (typeof r3 == "function" || a3 === ie2) && (o3 = true);
          break;
        case u2:
          (a3 === ne2 || a3 === ie2) && (o3 = true);
          break;
        case f:
        case p:
          (a3 === ae2 || a3 === ie2) && (o3 = true);
          break;
        default:
          return false;
      }
      if (o3) {
        var i3 = Uv(n3);
        if (i3 !== void 0 && i3 === Uv(r3))
          return true;
      }
      return false;
    }
    function Gv(e5) {
      Uv !== null && typeof WeakSet == "function" && (Hv === null && (Hv = /* @__PURE__ */ new WeakSet()), Hv.add(e5));
    }
    var Qv = function(e5, t3) {
      if (Uv !== null) {
        var n3 = t3.staleFamilies, r3 = t3.updatedFamilies;
        pv(), qm(function() {
          Zv(e5.current, r3, n3);
        });
      }
    }, Jv = function(e5, t3) {
      e5.context === Il2 && (pv(), qm(function() {
        Sg(t3, e5, null, null);
      }));
    };
    function Zv(e5, t3, n3) {
      var r3 = e5.alternate, o3 = e5.child, a3 = e5.sibling, i3 = e5.tag, s3 = e5.type, l3 = null;
      switch (i3) {
        case 0:
        case p:
        case 1:
          l3 = s3;
          break;
        case u2:
          l3 = s3.render;
      }
      if (Uv === null)
        throw new Error("Expected resolveFamily to be set during hot reload.");
      var c3 = false, d2 = false;
      if (l3 !== null) {
        var f2 = Uv(l3);
        f2 !== void 0 && (n3.has(f2) ? d2 = true : t3.has(f2) && (i3 === 1 ? d2 = true : c3 = true));
      }
      Hv !== null && (Hv.has(e5) || r3 !== null && Hv.has(r3)) && (d2 = true), d2 && (e5._debugNeedsRemount = true), (d2 || c3) && Lm(e5, 1, ko2), o3 === null || d2 || Zv(o3, t3, n3), a3 !== null && Zv(a3, t3, n3);
    }
    var eg, tg = function(e5, t3) {
      var n3 = /* @__PURE__ */ new Set(), r3 = new Set(t3.map(function(e6) {
        return e6.current;
      }));
      return ng(e5.current, r3, n3), n3;
    };
    function ng(e5, t3, n3) {
      var r3 = e5.child, o3 = e5.sibling, a3 = e5.tag, i3 = e5.type, s3 = null;
      switch (a3) {
        case 0:
        case p:
        case 1:
          s3 = i3;
          break;
        case u2:
          s3 = i3.render;
      }
      var l3 = false;
      s3 !== null && t3.has(s3) && (l3 = true), l3 ? function(e6, t4) {
        if (function(e7, t5) {
          var n5 = e7, r4 = false;
          for (; ; ) {
            if (n5.tag === 5)
              r4 = true, t5.add(n5.stateNode);
            else if (n5.child !== null) {
              n5.child.return = n5, n5 = n5.child;
              continue;
            }
            if (n5 === e7)
              return r4;
            for (; n5.sibling === null; ) {
              if (n5.return === null || n5.return === e7)
                return r4;
              n5 = n5.return;
            }
            n5.sibling.return = n5.return, n5 = n5.sibling;
          }
          return false;
        }(e6, t4))
          return;
        var n4 = e6;
        for (; ; ) {
          switch (n4.tag) {
            case 5:
              return void t4.add(n4.stateNode);
            case 4:
            case 3:
              return void t4.add(n4.stateNode.containerInfo);
          }
          if (n4.return === null)
            throw new Error("Expected to reach root first.");
          n4 = n4.return;
        }
      }(e5, n3) : r3 !== null && ng(r3, t3, n3), o3 !== null && ng(o3, t3, n3);
    }
    eg = false;
    try {
      var rg = Object.preventExtensions({});
      /* @__PURE__ */ new Map([[rg, null]]), /* @__PURE__ */ new Set([rg]);
    } catch (e5) {
      eg = true;
    }
    var og = 1;
    function ag(e5, t3, n3, r3) {
      this.tag = e5, this.key = n3, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = t3, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = r3, this.flags = 0, this.nextEffect = null, this.firstEffect = null, this.lastEffect = null, this.lanes = 0, this.childLanes = 0, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugID = og++, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = false, this._debugHookTypes = null, eg || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    var ig, sg, lg = function(e5, t3, n3, r3) {
      return new ag(e5, t3, n3, r3);
    };
    function ug(e5) {
      var t3 = e5.prototype;
      return !(!t3 || !t3.isReactComponent);
    }
    function cg(e5, t3) {
      var n3 = e5.alternate;
      n3 === null ? ((n3 = lg(e5.tag, t3, e5.key, e5.mode)).elementType = e5.elementType, n3.type = e5.type, n3.stateNode = e5.stateNode, n3._debugID = e5._debugID, n3._debugSource = e5._debugSource, n3._debugOwner = e5._debugOwner, n3._debugHookTypes = e5._debugHookTypes, n3.alternate = e5, e5.alternate = n3) : (n3.pendingProps = t3, n3.type = e5.type, n3.flags = 0, n3.nextEffect = null, n3.firstEffect = null, n3.lastEffect = null, n3.actualDuration = 0, n3.actualStartTime = -1), n3.childLanes = e5.childLanes, n3.lanes = e5.lanes, n3.child = e5.child, n3.memoizedProps = e5.memoizedProps, n3.memoizedState = e5.memoizedState, n3.updateQueue = e5.updateQueue;
      var r3 = e5.dependencies;
      switch (n3.dependencies = r3 === null ? null : { lanes: r3.lanes, firstContext: r3.firstContext }, n3.sibling = e5.sibling, n3.index = e5.index, n3.ref = e5.ref, n3.selfBaseDuration = e5.selfBaseDuration, n3.treeBaseDuration = e5.treeBaseDuration, n3._debugNeedsRemount = e5._debugNeedsRemount, n3.tag) {
        case 2:
        case 0:
        case p:
          n3.type = qv(e5.type);
          break;
        case 1:
          n3.type = Kv(e5.type);
          break;
        case u2:
          n3.type = Yv(e5.type);
      }
      return n3;
    }
    function dg(e5, t3) {
      e5.flags &= 2, e5.nextEffect = null, e5.firstEffect = null, e5.lastEffect = null;
      var n3 = e5.alternate;
      if (n3 === null)
        e5.childLanes = 0, e5.lanes = t3, e5.child = null, e5.memoizedProps = null, e5.memoizedState = null, e5.updateQueue = null, e5.dependencies = null, e5.stateNode = null, e5.selfBaseDuration = 0, e5.treeBaseDuration = 0;
      else {
        e5.childLanes = n3.childLanes, e5.lanes = n3.lanes, e5.child = n3.child, e5.memoizedProps = n3.memoizedProps, e5.memoizedState = n3.memoizedState, e5.updateQueue = n3.updateQueue, e5.type = n3.type;
        var r3 = n3.dependencies;
        e5.dependencies = r3 === null ? null : { lanes: r3.lanes, firstContext: r3.firstContext }, e5.selfBaseDuration = n3.selfBaseDuration, e5.treeBaseDuration = n3.treeBaseDuration;
      }
      return e5;
    }
    function fg(e5, t3, n3, r3, o3, a3) {
      var s3 = 2, p2 = e5;
      if (typeof e5 == "function")
        ug(e5) ? (s3 = 1, p2 = Kv(p2)) : p2 = qv(p2);
      else if (typeof e5 == "string")
        s3 = 5;
      else
        e:
          switch (e5) {
            case Q2:
              return hg(n3.children, o3, a3, t3);
            case ue2:
              s3 = 8, o3 |= 16;
              break;
            case J2:
              s3 = 8, o3 |= 1;
              break;
            case Z2:
              return function(e6, t4, n4, r4) {
                typeof e6.id != "string" && i2('Profiler must specify an "id" as a prop');
                var o4 = lg(c2, e6, r4, 8 | t4);
                return o4.elementType = Z2, o4.type = Z2, o4.lanes = n4, o4.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, o4;
              }(n3, o3, a3, t3);
            case re2:
              return function(e6, t4, n4, r4) {
                var o4 = lg(d, e6, r4, t4);
                return o4.type = re2, o4.elementType = re2, o4.lanes = n4, o4;
              }(n3, o3, a3, t3);
            case oe2:
              return function(e6, t4, n4, r4) {
                var o4 = lg(m2, e6, r4, t4);
                return o4.type = oe2, o4.elementType = oe2, o4.lanes = n4, o4;
              }(n3, o3, a3, t3);
            case ce2:
              return mg(n3, o3, a3, t3);
            case de2:
              return function(e6, t4, n4, r4) {
                var o4 = lg(b2, e6, r4, t4);
                return o4.type = de2, o4.elementType = de2, o4.lanes = n4, o4;
              }(n3, o3, a3, t3);
            default:
              if (typeof e5 == "object" && e5 !== null)
                switch (e5.$$typeof) {
                  case ee2:
                    s3 = l2;
                    break e;
                  case te2:
                    s3 = 9;
                    break e;
                  case ne2:
                    s3 = u2, p2 = Yv(p2);
                    break e;
                  case ae2:
                    s3 = f;
                    break e;
                  case ie2:
                    s3 = 16, p2 = null;
                    break e;
                  case se2:
                    s3 = g2;
                    break e;
                }
              var h3 = "";
              (e5 === void 0 || typeof e5 == "object" && e5 !== null && Object.keys(e5).length === 0) && (h3 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var v3 = r3 ? $e2(r3.type) : null;
              throw v3 && (h3 += "\n\nCheck the render method of `" + v3 + "`."), Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (e5 == null ? e5 : typeof e5) + "." + h3);
          }
      var y3 = lg(s3, n3, t3, o3);
      return y3.elementType = e5, y3.type = p2, y3.lanes = a3, y3._debugOwner = r3, y3;
    }
    function pg(e5, t3, n3) {
      var r3;
      r3 = e5._owner;
      var o3 = fg(e5.type, e5.key, e5.props, r3, t3, n3);
      return o3._debugSource = e5._source, o3._debugOwner = e5._owner, o3;
    }
    function hg(e5, t3, n3, r3) {
      var o3 = lg(7, e5, r3, t3);
      return o3.lanes = n3, o3;
    }
    function mg(e5, t3, n3, r3) {
      var o3 = lg(y2, e5, r3, t3);
      return o3.type = ce2, o3.elementType = ce2, o3.lanes = n3, o3;
    }
    function vg(e5, t3, n3) {
      var r3 = lg(6, e5, null, t3);
      return r3.lanes = n3, r3;
    }
    function gg(e5, t3, n3) {
      var r3 = e5.children !== null ? e5.children : [], o3 = lg(4, r3, e5.key, t3);
      return o3.lanes = n3, o3.stateNode = { containerInfo: e5.containerInfo, pendingChildren: null, implementation: e5.implementation }, o3;
    }
    function yg(e5, t3) {
      return e5 === null && (e5 = lg(2, null, null, 0)), e5.tag = t3.tag, e5.key = t3.key, e5.elementType = t3.elementType, e5.type = t3.type, e5.stateNode = t3.stateNode, e5.return = t3.return, e5.child = t3.child, e5.sibling = t3.sibling, e5.index = t3.index, e5.ref = t3.ref, e5.pendingProps = t3.pendingProps, e5.memoizedProps = t3.memoizedProps, e5.updateQueue = t3.updateQueue, e5.memoizedState = t3.memoizedState, e5.dependencies = t3.dependencies, e5.mode = t3.mode, e5.flags = t3.flags, e5.nextEffect = t3.nextEffect, e5.firstEffect = t3.firstEffect, e5.lastEffect = t3.lastEffect, e5.lanes = t3.lanes, e5.childLanes = t3.childLanes, e5.alternate = t3.alternate, e5.actualDuration = t3.actualDuration, e5.actualStartTime = t3.actualStartTime, e5.selfBaseDuration = t3.selfBaseDuration, e5.treeBaseDuration = t3.treeBaseDuration, e5._debugID = t3._debugID, e5._debugSource = t3._debugSource, e5._debugOwner = t3._debugOwner, e5._debugNeedsRemount = t3._debugNeedsRemount, e5._debugHookTypes = t3._debugHookTypes, e5;
    }
    function bg(e5, t3, n3) {
      switch (this.tag = t3, this.containerInfo = e5, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = -1, this.context = null, this.pendingContext = null, this.hydrate = n3, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = zo2(0), this.expirationTimes = zo2(ko2), this.pendingLanes = 0, this.suspendedLanes = 0, this.pingedLanes = 0, this.expiredLanes = 0, this.mutableReadLanes = 0, this.finishedLanes = 0, this.entangledLanes = 0, this.entanglements = zo2(0), this.mutableSourceEagerHydrationData = null, this.interactionThreadID = r2.unstable_getThreadID(), this.memoizedInteractions = /* @__PURE__ */ new Set(), this.pendingInteractionMap = /* @__PURE__ */ new Map(), t3) {
        case 1:
          this._debugRootType = "createBlockingRoot()";
          break;
        case 2:
          this._debugRootType = "createRoot()";
          break;
        case 0:
          this._debugRootType = "createLegacyRoot()";
      }
    }
    function wg(e5, t3, n3, r3) {
      var o3 = new bg(e5, t3, n3), a3 = function(e6) {
        var t4;
        return t4 = e6 === 2 ? 7 : e6 === 1 ? 3 : 0, Gl2 && (t4 |= 8), lg(3, null, null, t4);
      }(t3);
      return o3.current = a3, a3.stateNode = o3, sc2(a3), o3;
    }
    function kg(e5, t3) {
      var n3 = (0, t3._getVersion)(t3._source);
      e5.mutableSourceEagerHydrationData == null ? e5.mutableSourceEagerHydrationData = [t3, n3] : e5.mutableSourceEagerHydrationData.push(t3, n3);
    }
    function xg(e5, t3, n3) {
      var r3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: G2, key: r3 == null ? null : "" + r3, children: e5, containerInfo: t3, implementation: n3 };
    }
    function Sg(e5, t3, r3, o3) {
      !function(e6, t4) {
        if (Yl2 && typeof Yl2.onScheduleFiberRoot == "function")
          try {
            Yl2.onScheduleFiberRoot(Kl2, e6, t4);
          } catch (e7) {
            Xl2 || (Xl2 = true, i2("React instrumentation encountered an error: %s", e7));
          }
      }(t3, e5);
      var a3, s3 = t3.current, l3 = Am();
      typeof jest != "undefined" && (a3 = s3, Nv === false && n2.unstable_flushAllWithoutAsserting === void 0 && (2 & a3.mode || 4 & a3.mode) && (Nv = true, i2(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: 
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://reactjs.org/link/mock-scheduler`)), Iv(s3));
      var u3 = zm(s3), c3 = function(e6) {
        if (!e6)
          return Il2;
        var t4 = or2(e6), n3 = ql2(t4);
        if (t4.tag === 1) {
          var r4 = t4.type;
          if (Fl2(r4))
            return Ul2(t4, r4, n3);
        }
        return n3;
      }(r3);
      t3.context === null ? t3.context = c3 : t3.pendingContext = c3, Ue && Ve2 !== null && !ig && (ig = true, i2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", $e2(Ve2.type) || "Unknown"));
      var d2 = uc2(l3, u3);
      return d2.payload = { element: e5 }, (o3 = o3 === void 0 ? null : o3) !== null && (typeof o3 != "function" && i2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o3), d2.callback = o3), cc2(s3, d2), Lm(s3, u3, l3), u3;
    }
    function _g(e5) {
      var t3 = e5.current;
      return t3.child ? (t3.child.tag, t3.child.stateNode) : null;
    }
    function Eg(e5, t3) {
      var n3 = e5.memoizedState;
      n3 !== null && n3.dehydrated !== null && (n3.retryLane = function(e6, t4) {
        return e6 !== 0 && e6 < t4 ? e6 : t4;
      }(n3.retryLane, t3));
    }
    function Pg(e5, t3) {
      Eg(e5, t3);
      var n3 = e5.alternate;
      n3 && Eg(n3, t3);
    }
    function Cg(e5) {
      var t3 = function(e6) {
        var t4 = Sr2(e6);
        if (!t4)
          return null;
        for (var n3 = t4; ; ) {
          if (n3.tag === 5 || n3.tag === 6)
            return n3;
          if (n3.child && n3.tag !== 4)
            n3.child.return = n3, n3 = n3.child;
          else {
            if (n3 === t4)
              return null;
            for (; !n3.sibling; ) {
              if (!n3.return || n3.return === t4)
                return null;
              n3 = n3.return;
            }
            n3.sibling.return = n3.return, n3 = n3.sibling;
          }
        }
        return null;
      }(e5);
      return t3 === null ? null : t3.tag === v2 ? t3.stateNode.instance : t3.stateNode;
    }
    ig = false, sg = {};
    var jg = function(e5) {
      return false;
    };
    var Og, Tg, Ig, Dg, Rg, Ng, Ag, zg, Mg = function(e5, n3, r3) {
      var o3 = n3[r3], a3 = Array.isArray(e5) ? e5.slice() : t2({}, e5);
      return r3 + 1 === n3.length ? (Array.isArray(a3) ? a3.splice(o3, 1) : delete a3[o3], a3) : (a3[o3] = Mg(e5[o3], n3, r3 + 1), a3);
    }, Lg = function(e5, t3) {
      return Mg(e5, t3, 0);
    }, Fg = function(e5, n3, r3, o3) {
      var a3 = n3[o3], i3 = Array.isArray(e5) ? e5.slice() : t2({}, e5);
      o3 + 1 === n3.length ? (i3[r3[o3]] = i3[a3], Array.isArray(i3) ? i3.splice(a3, 1) : delete i3[a3]) : i3[a3] = Fg(e5[a3], n3, r3, o3 + 1);
      return i3;
    }, $g = function(e5, t3, n3) {
      if (t3.length === n3.length) {
        for (var r3 = 0; r3 < n3.length - 1; r3++)
          if (t3[r3] !== n3[r3])
            return void a2("copyWithRename() expects paths to be the same except for the deepest key");
        return Fg(e5, t3, n3, 0);
      }
      a2("copyWithRename() expects paths of the same length");
    }, Bg = function(e5, n3, r3, o3) {
      if (r3 >= n3.length)
        return o3;
      var a3 = n3[r3], i3 = Array.isArray(e5) ? e5.slice() : t2({}, e5);
      return i3[a3] = Bg(e5[a3], n3, r3 + 1, o3), i3;
    }, Vg = function(e5, t3, n3) {
      return Bg(e5, t3, 0, n3);
    }, Ug = function(e5, t3) {
      for (var n3 = e5.memoizedState; n3 !== null && t3 > 0; )
        n3 = n3.next, t3--;
      return n3;
    };
    function Hg(e5) {
      var t3 = _r2(e5);
      return t3 === null ? null : t3.stateNode;
    }
    function Wg(e5) {
      return null;
    }
    function qg() {
      return Ve2;
    }
    function Kg(e5, t3, n3) {
      this._internalRoot = function(e6, t4, n4) {
        var r3 = n4 != null && n4.hydrate === true;
        n4 != null && n4.hydrationOptions;
        var o3 = n4 != null && n4.hydrationOptions != null && n4.hydrationOptions.mutableSources || null, a3 = function(e7, t5, n5, r4) {
          return wg(e7, t5, n5);
        }(e6, t4, r3);
        if (function(e7, t5) {
          t5[ul2] = e7;
        }(a3.current, e6), e6.nodeType, $i2(e6.nodeType === Bt2 ? e6.parentNode : e6), o3)
          for (var i3 = 0; i3 < o3.length; i3++) {
            kg(a3, o3[i3]);
          }
        return a3;
      }(e5, t3, n3);
    }
    function Yg(e5) {
      return !(!e5 || e5.nodeType !== 1 && e5.nodeType !== 9 && e5.nodeType !== 11 && (e5.nodeType !== 8 || e5.nodeValue !== " react-mount-point-unstable "));
    }
    Og = function(e5, n3, r3, o3) {
      var a3 = Ug(e5, n3);
      if (a3 !== null) {
        var i3 = Vg(a3.memoizedState, r3, o3);
        a3.memoizedState = i3, a3.baseState = i3, e5.memoizedProps = t2({}, e5.memoizedProps), Lm(e5, 1, ko2);
      }
    }, Tg = function(e5, n3, r3) {
      var o3 = Ug(e5, n3);
      if (o3 !== null) {
        var a3 = Lg(o3.memoizedState, r3);
        o3.memoizedState = a3, o3.baseState = a3, e5.memoizedProps = t2({}, e5.memoizedProps), Lm(e5, 1, ko2);
      }
    }, Ig = function(e5, n3, r3, o3) {
      var a3 = Ug(e5, n3);
      if (a3 !== null) {
        var i3 = $g(a3.memoizedState, r3, o3);
        a3.memoizedState = i3, a3.baseState = i3, e5.memoizedProps = t2({}, e5.memoizedProps), Lm(e5, 1, ko2);
      }
    }, Dg = function(e5, t3, n3) {
      e5.pendingProps = Vg(e5.memoizedProps, t3, n3), e5.alternate && (e5.alternate.pendingProps = e5.pendingProps), Lm(e5, 1, ko2);
    }, Rg = function(e5, t3) {
      e5.pendingProps = Lg(e5.memoizedProps, t3), e5.alternate && (e5.alternate.pendingProps = e5.pendingProps), Lm(e5, 1, ko2);
    }, Ng = function(e5, t3, n3) {
      e5.pendingProps = $g(e5.memoizedProps, t3, n3), e5.alternate && (e5.alternate.pendingProps = e5.pendingProps), Lm(e5, 1, ko2);
    }, Ag = function(e5) {
      Lm(e5, 1, ko2);
    }, zg = function(e5) {
      jg = e5;
    }, Kg.prototype.render = function(e5) {
      var t3 = this._internalRoot;
      typeof arguments[1] == "function" && i2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var n3 = t3.containerInfo;
      if (n3.nodeType !== 8) {
        var r3 = Cg(t3.current);
        r3 && r3.parentNode !== n3 && i2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
      }
      Sg(e5, t3, null, null);
    }, Kg.prototype.unmount = function() {
      typeof arguments[0] == "function" && i2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e5 = this._internalRoot, t3 = e5.containerInfo;
      Sg(null, e5, null, function() {
        fl2(t3);
      });
    };
    var Xg, Gg = o2.ReactCurrentOwner, Qg = false;
    function Jg(e5) {
      return e5 ? e5.nodeType === 9 ? e5.documentElement : e5.firstChild : null;
    }
    function Zg(e5, t3) {
      var n3 = t3 || function(e6) {
        var t4 = Jg(e6);
        return !(!t4 || t4.nodeType !== 1 || !t4.hasAttribute(O2));
      }(e5);
      if (!n3)
        for (var r3, o3 = false; r3 = e5.lastChild; )
          !o3 && r3.nodeType === 1 && r3.hasAttribute(O2) && (o3 = true, i2("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.")), e5.removeChild(r3);
      return !n3 || t3 || Qg || (Qg = true, a2("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.")), function(e6, t4) {
        return new Kg(e6, 0, t4);
      }(e5, n3 ? { hydrate: true } : void 0);
    }
    function ey(e5, t3, n3, r3, o3) {
      Xg(n3), function(e6, t4) {
        e6 !== null && typeof e6 != "function" && i2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t4, e6);
      }(o3 === void 0 ? null : o3, "render");
      var a3, s3 = n3._reactRootContainer;
      if (s3) {
        if (a3 = s3._internalRoot, typeof o3 == "function") {
          var l3 = o3;
          o3 = function() {
            var e6 = _g(a3);
            l3.call(e6);
          };
        }
        Sg(t3, a3, e5, o3);
      } else {
        if (s3 = n3._reactRootContainer = Zg(n3, r3), a3 = s3._internalRoot, typeof o3 == "function") {
          var u3 = o3;
          o3 = function() {
            var e6 = _g(a3);
            u3.call(e6);
          };
        }
        Wm(function() {
          Sg(t3, a3, e5, o3);
        });
      }
      return _g(a3);
    }
    Xg = function(e5) {
      if (e5._reactRootContainer && e5.nodeType !== 8) {
        var t3 = Cg(e5._reactRootContainer._internalRoot.current);
        t3 && t3.parentNode !== e5 && i2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var n3 = !!e5._reactRootContainer, r3 = Jg(e5);
      !(!r3 || !ml2(r3)) && !n3 && i2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e5.nodeType === 1 && e5.tagName && e5.tagName.toUpperCase() === "BODY" && i2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    }, ar = function(e5) {
      e5.tag === d && (Lm(e5, 4, Am()), Pg(e5, 4));
    }, function(e5) {
      ir2 = e5;
    }(function(e5) {
      if (e5.tag === d) {
        var t3 = Am(), n3 = vo2;
        Lm(e5, n3, t3), Pg(e5, n3);
      }
    }), function(e5) {
      sr2 = e5;
    }(function(e5) {
      if (e5.tag === d) {
        var t3 = Am(), n3 = zm(e5);
        Lm(e5, n3, t3), Pg(e5, n3);
      }
    }), function(e5) {
      lr2 = e5;
    }(function(e5, t3) {
      try {
        return t3();
      } finally {
      }
    });
    var ty, ny, ry, oy = false;
    function ay(e5, t3) {
      var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Yg(t3))
        throw Error("Target container is not a DOM element.");
      return xg(e5, t3, null, n3);
    }
    typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || i2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Tn2 = function(e5, t3, n3) {
      switch (t3) {
        case "input":
          return void ht2(e5, n3);
        case "textarea":
          return void function(e6, t4) {
            Tt2(e6, t4);
          }(e5, n3);
        case "select":
          return void function(e6, t4) {
            var n4 = e6, r3 = t4.value;
            r3 != null && _t2(n4, !!t4.multiple, r3, false);
          }(e5, n3);
      }
    }, ty = function(e5, t3, n3, r3, o3) {
      var a3 = Qh;
      Qh |= 4;
      try {
        return Su2(fu2, e5.bind(null, t3, n3, r3, o3));
      } finally {
        (Qh = a3) === 0 && (fm(), Pu2());
      }
    }, ny = function() {
      (49 & Qh) == 0 ? (function() {
        if (_m !== null) {
          var e5 = _m;
          _m = null, e5.forEach(function(e6) {
            !function(e7) {
              e7.expiredLanes |= 24 & e7.pendingLanes;
            }(e6), $m(e6, wu2());
          });
        }
        Pu2();
      }(), pv()) : (Qh & Xh) != 0 && i2("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
    }, ry = function(e5, t3) {
      var n3 = Qh;
      Qh |= 2;
      try {
        return e5(t3);
      } finally {
        (Qh = n3) === 0 && (fm(), Pu2());
      }
    }, zn2 = Hm, Mn2 = ty, Ln2 = ny, Fn2 = ry;
    var iy = { Events: [ml2, vl2, gl2, Nn2, An2, pv, Tv] }, sy = function(e5) {
      var t3 = e5.findFiberByHostInstance, n3 = o2.ReactCurrentDispatcher;
      return function(e6) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined")
          return false;
        var t4 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (t4.isDisabled)
          return true;
        if (!t4.supportsFiber)
          return i2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), true;
        try {
          Kl2 = t4.inject(e6), Yl2 = t4;
        } catch (e7) {
          i2("React instrumentation encountered an error: %s.", e7);
        }
        return true;
      }({ bundleType: e5.bundleType, version: e5.version, rendererPackageName: e5.rendererPackageName, rendererConfig: e5.rendererConfig, overrideHookState: Og, overrideHookStateDeletePath: Tg, overrideHookStateRenamePath: Ig, overrideProps: Dg, overridePropsDeletePath: Rg, overridePropsRenamePath: Ng, setSuspenseHandler: zg, scheduleUpdate: Ag, currentDispatcherRef: n3, findHostInstanceByFiber: Hg, findFiberByHostInstance: t3 || Wg, findHostInstancesForRefresh: tg, scheduleRefresh: Qv, scheduleRoot: Jv, setRefreshHandler: Wv, getCurrentFiber: qg });
    }({ findFiberByHostInstance: hl2, bundleType: 1, version: ju2, rendererPackageName: "react-dom" });
    if (!sy && P2 && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var ly = window.location.protocol;
      /^(https?|file):$/.test(ly) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (ly === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
    }
    jd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = iy, jd.createPortal = ay, jd.findDOMNode = function(e5) {
      var t3 = Gg.current;
      return t3 !== null && t3.stateNode !== null && (t3.stateNode._warnedAboutRefsInRender || i2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", $e2(t3.type) || "A component"), t3.stateNode._warnedAboutRefsInRender = true), e5 == null ? null : e5.nodeType === 1 ? e5 : function(e6, t4) {
        var n3 = or2(e6);
        if (n3 === void 0)
          throw typeof e6.render == "function" ? Error("Unable to find node on an unmounted component.") : Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(e6));
        var r3 = _r2(n3);
        if (r3 === null)
          return null;
        if (1 & r3.mode) {
          var o3 = $e2(n3.type) || "Component";
          if (!sg[o3]) {
            sg[o3] = true;
            var a3 = Ve2;
            try {
              Ke2(r3), 1 & n3.mode ? i2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t4, t4, o3) : i2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t4, t4, o3);
            } finally {
              a3 ? Ke2(a3) : qe2();
            }
          }
        }
        return r3.stateNode;
      }(e5, "findDOMNode");
    }, jd.flushSync = qm, jd.hydrate = function(e5, t3, n3) {
      if (!Yg(t3))
        throw Error("Target container is not a DOM element.");
      return pl2(t3) && t3._reactRootContainer === void 0 && i2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?"), ey(null, e5, t3, true, n3);
    }, jd.render = function(e5, t3, n3) {
      if (!Yg(t3))
        throw Error("Target container is not a DOM element.");
      return pl2(t3) && t3._reactRootContainer === void 0 && i2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?"), ey(null, e5, t3, false, n3);
    }, jd.unmountComponentAtNode = function(e5) {
      if (!Yg(e5))
        throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      if (pl2(e5) && e5._reactRootContainer === void 0 && i2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?"), e5._reactRootContainer) {
        var t3 = Jg(e5);
        return t3 && !ml2(t3) && i2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React."), Wm(function() {
          ey(null, null, e5, false, function() {
            e5._reactRootContainer = null, fl2(e5);
          });
        }), true;
      }
      var n3 = Jg(e5), r3 = !(!n3 || !ml2(n3)), o3 = e5.nodeType === 1 && Yg(e5.parentNode) && !!e5.parentNode._reactRootContainer;
      return r3 && i2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", o3 ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component."), false;
    }, jd.unstable_batchedUpdates = Hm, jd.unstable_createPortal = function(e5, t3) {
      var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return oy || (oy = true, a2('The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.')), ay(e5, t3, n3);
    }, jd.unstable_renderSubtreeIntoContainer = function(e5, t3, n3, r3) {
      return function(e6, t4, n4, r4) {
        if (!Yg(n4))
          throw Error("Target container is not a DOM element.");
        if (e6 == null || e6._reactInternals === void 0)
          throw Error("parentComponent must be a valid React Component");
        return ey(e6, t4, n4, false, r4);
      }(e5, t3, n3, r3);
    }, jd.version = ju2;
  }(), false ? (!function e2() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE == "function") {
      if (true)
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e2);
      } catch (e4) {
        console.error(e4);
      }
    }
  }(), ht.exports = mt) : ht.exports = jd;
  var Rd = { exports: {} };
  var Nd = {};
  var Ad = Symbol.for("react.element");
  var zd = Symbol.for("react.portal");
  var Md = Symbol.for("react.fragment");
  var Ld = Symbol.for("react.strict_mode");
  var Fd = Symbol.for("react.profiler");
  var $d = Symbol.for("react.provider");
  var Bd = Symbol.for("react.context");
  var Vd = Symbol.for("react.server_context");
  var Ud = Symbol.for("react.forward_ref");
  var Hd = Symbol.for("react.suspense");
  var Wd = Symbol.for("react.suspense_list");
  var qd = Symbol.for("react.memo");
  var Kd = Symbol.for("react.lazy");
  var Yd = Symbol.for("react.offscreen");
  var Xd = Symbol.for("react.module.reference");
  function Gd(e4) {
    if (typeof e4 == "object" && e4 !== null) {
      var t2 = e4.$$typeof;
      switch (t2) {
        case Ad:
          switch (e4 = e4.type) {
            case Md:
            case Fd:
            case Ld:
            case Hd:
            case Wd:
              return e4;
            default:
              switch (e4 = e4 && e4.$$typeof) {
                case Vd:
                case Bd:
                case Ud:
                case Kd:
                case qd:
                case $d:
                  return e4;
                default:
                  return t2;
              }
          }
        case zd:
          return t2;
      }
    }
  }
  Nd.ContextConsumer = Bd, Nd.ContextProvider = $d, Nd.Element = Ad, Nd.ForwardRef = Ud, Nd.Fragment = Md, Nd.Lazy = Kd, Nd.Memo = qd, Nd.Portal = zd, Nd.Profiler = Fd, Nd.StrictMode = Ld, Nd.Suspense = Hd, Nd.SuspenseList = Wd, Nd.isAsyncMode = function() {
    return false;
  }, Nd.isConcurrentMode = function() {
    return false;
  }, Nd.isContextConsumer = function(e4) {
    return Gd(e4) === Bd;
  }, Nd.isContextProvider = function(e4) {
    return Gd(e4) === $d;
  }, Nd.isElement = function(e4) {
    return typeof e4 == "object" && e4 !== null && e4.$$typeof === Ad;
  }, Nd.isForwardRef = function(e4) {
    return Gd(e4) === Ud;
  }, Nd.isFragment = function(e4) {
    return Gd(e4) === Md;
  }, Nd.isLazy = function(e4) {
    return Gd(e4) === Kd;
  }, Nd.isMemo = function(e4) {
    return Gd(e4) === qd;
  }, Nd.isPortal = function(e4) {
    return Gd(e4) === zd;
  }, Nd.isProfiler = function(e4) {
    return Gd(e4) === Fd;
  }, Nd.isStrictMode = function(e4) {
    return Gd(e4) === Ld;
  }, Nd.isSuspense = function(e4) {
    return Gd(e4) === Hd;
  }, Nd.isSuspenseList = function(e4) {
    return Gd(e4) === Wd;
  }, Nd.isValidElementType = function(e4) {
    return typeof e4 == "string" || typeof e4 == "function" || e4 === Md || e4 === Fd || e4 === Ld || e4 === Hd || e4 === Wd || e4 === Yd || typeof e4 == "object" && e4 !== null && (e4.$$typeof === Kd || e4.$$typeof === qd || e4.$$typeof === $d || e4.$$typeof === Bd || e4.$$typeof === Ud || e4.$$typeof === Xd || e4.getModuleId !== void 0);
  }, Nd.typeOf = Gd;
  var Qd = {};
  (function() {
    var e4 = Symbol.for("react.element"), t2 = Symbol.for("react.portal"), n2 = Symbol.for("react.fragment"), r2 = Symbol.for("react.strict_mode"), o2 = Symbol.for("react.profiler"), a2 = Symbol.for("react.provider"), i2 = Symbol.for("react.context"), s2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), u2 = Symbol.for("react.suspense"), c2 = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), h2 = Symbol.for("react.module.reference");
    function m2(p2) {
      if (typeof p2 == "object" && p2 !== null) {
        var h3 = p2.$$typeof;
        switch (h3) {
          case e4:
            var m3 = p2.type;
            switch (m3) {
              case n2:
              case o2:
              case r2:
              case u2:
              case c2:
                return m3;
              default:
                var v3 = m3 && m3.$$typeof;
                switch (v3) {
                  case s2:
                  case i2:
                  case l2:
                  case f:
                  case d:
                  case a2:
                    return v3;
                  default:
                    return h3;
                }
            }
          case t2:
            return h3;
        }
      }
    }
    var v2 = i2, g2 = a2, y2 = e4, b2 = l2, w2 = n2, k2 = f, x2 = d, S2 = t2, _2 = o2, E2 = r2, P2 = u2, C2 = c2, j2 = false, O2 = false;
    Qd.ContextConsumer = v2, Qd.ContextProvider = g2, Qd.Element = y2, Qd.ForwardRef = b2, Qd.Fragment = w2, Qd.Lazy = k2, Qd.Memo = x2, Qd.Portal = S2, Qd.Profiler = _2, Qd.StrictMode = E2, Qd.Suspense = P2, Qd.SuspenseList = C2, Qd.isAsyncMode = function(e5) {
      return j2 || (j2 = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }, Qd.isConcurrentMode = function(e5) {
      return O2 || (O2 = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }, Qd.isContextConsumer = function(e5) {
      return m2(e5) === i2;
    }, Qd.isContextProvider = function(e5) {
      return m2(e5) === a2;
    }, Qd.isElement = function(t3) {
      return typeof t3 == "object" && t3 !== null && t3.$$typeof === e4;
    }, Qd.isForwardRef = function(e5) {
      return m2(e5) === l2;
    }, Qd.isFragment = function(e5) {
      return m2(e5) === n2;
    }, Qd.isLazy = function(e5) {
      return m2(e5) === f;
    }, Qd.isMemo = function(e5) {
      return m2(e5) === d;
    }, Qd.isPortal = function(e5) {
      return m2(e5) === t2;
    }, Qd.isProfiler = function(e5) {
      return m2(e5) === o2;
    }, Qd.isStrictMode = function(e5) {
      return m2(e5) === r2;
    }, Qd.isSuspense = function(e5) {
      return m2(e5) === u2;
    }, Qd.isSuspenseList = function(e5) {
      return m2(e5) === c2;
    }, Qd.isValidElementType = function(e5) {
      return typeof e5 == "string" || typeof e5 == "function" || (e5 === n2 || e5 === o2 || e5 === r2 || e5 === u2 || e5 === c2 || e5 === p || typeof e5 == "object" && e5 !== null && (e5.$$typeof === f || e5.$$typeof === d || e5.$$typeof === a2 || e5.$$typeof === i2 || e5.$$typeof === l2 || e5.$$typeof === h2 || e5.getModuleId !== void 0));
    }, Qd.typeOf = m2;
  })(), false ? Rd.exports = Nd : Rd.exports = Qd;
  function Jd(e4) {
    function t2(e5, r3, l3, u3, f2) {
      for (var p2, h3, m3, v3, w3, x3 = 0, S3 = 0, _3 = 0, E3 = 0, P3 = 0, D3 = 0, N3 = m3 = p2 = 0, z2 = 0, M2 = 0, L2 = 0, F2 = 0, $2 = l3.length, B2 = $2 - 1, V2 = "", U2 = "", H2 = "", W2 = ""; z2 < $2; ) {
        if (h3 = l3.charCodeAt(z2), z2 === B2 && S3 + E3 + _3 + x3 !== 0 && (S3 !== 0 && (h3 = S3 === 47 ? 10 : 47), E3 = _3 = x3 = 0, $2++, B2++), S3 + E3 + _3 + x3 === 0) {
          if (z2 === B2 && (0 < M2 && (V2 = V2.replace(d, "")), 0 < V2.trim().length)) {
            switch (h3) {
              case 32:
              case 9:
              case 59:
              case 13:
              case 10:
                break;
              default:
                V2 += l3.charAt(z2);
            }
            h3 = 59;
          }
          switch (h3) {
            case 123:
              for (p2 = (V2 = V2.trim()).charCodeAt(0), m3 = 1, F2 = ++z2; z2 < $2; ) {
                switch (h3 = l3.charCodeAt(z2)) {
                  case 123:
                    m3++;
                    break;
                  case 125:
                    m3--;
                    break;
                  case 47:
                    switch (h3 = l3.charCodeAt(z2 + 1)) {
                      case 42:
                      case 47:
                        e: {
                          for (N3 = z2 + 1; N3 < B2; ++N3)
                            switch (l3.charCodeAt(N3)) {
                              case 47:
                                if (h3 === 42 && l3.charCodeAt(N3 - 1) === 42 && z2 + 2 !== N3) {
                                  z2 = N3 + 1;
                                  break e;
                                }
                                break;
                              case 10:
                                if (h3 === 47) {
                                  z2 = N3 + 1;
                                  break e;
                                }
                            }
                          z2 = N3;
                        }
                    }
                    break;
                  case 91:
                    h3++;
                  case 40:
                    h3++;
                  case 34:
                  case 39:
                    for (; z2++ < B2 && l3.charCodeAt(z2) !== h3; )
                      ;
                }
                if (m3 === 0)
                  break;
                z2++;
              }
              if (m3 = l3.substring(F2, z2), p2 === 0 && (p2 = (V2 = V2.replace(c2, "").trim()).charCodeAt(0)), p2 === 64) {
                switch (0 < M2 && (V2 = V2.replace(d, "")), h3 = V2.charCodeAt(1)) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    M2 = r3;
                    break;
                  default:
                    M2 = I2;
                }
                if (F2 = (m3 = t2(r3, M2, m3, h3, f2 + 1)).length, 0 < R2 && (w3 = s2(3, m3, M2 = n2(I2, V2, L2), r3, j2, C2, F2, h3, f2, u3), V2 = M2.join(""), w3 !== void 0 && (F2 = (m3 = w3.trim()).length) === 0 && (h3 = 0, m3 = "")), 0 < F2)
                  switch (h3) {
                    case 115:
                      V2 = V2.replace(k2, i2);
                    case 100:
                    case 109:
                    case 45:
                      m3 = V2 + "{" + m3 + "}";
                      break;
                    case 107:
                      m3 = (V2 = V2.replace(g2, "$1 $2")) + "{" + m3 + "}", m3 = T2 === 1 || T2 === 2 && a2("@" + m3, 3) ? "@-webkit-" + m3 + "@" + m3 : "@" + m3;
                      break;
                    default:
                      m3 = V2 + m3, u3 === 112 && (U2 += m3, m3 = "");
                  }
                else
                  m3 = "";
              } else
                m3 = t2(r3, n2(r3, V2, L2), m3, u3, f2 + 1);
              H2 += m3, m3 = L2 = M2 = N3 = p2 = 0, V2 = "", h3 = l3.charCodeAt(++z2);
              break;
            case 125:
            case 59:
              if (1 < (F2 = (V2 = (0 < M2 ? V2.replace(d, "") : V2).trim()).length))
                switch (N3 === 0 && (p2 = V2.charCodeAt(0), p2 === 45 || 96 < p2 && 123 > p2) && (F2 = (V2 = V2.replace(" ", ":")).length), 0 < R2 && (w3 = s2(1, V2, r3, e5, j2, C2, U2.length, u3, f2, u3)) !== void 0 && (F2 = (V2 = w3.trim()).length) === 0 && (V2 = "\0\0"), p2 = V2.charCodeAt(0), h3 = V2.charCodeAt(1), p2) {
                  case 0:
                    break;
                  case 64:
                    if (h3 === 105 || h3 === 99) {
                      W2 += V2 + l3.charAt(z2);
                      break;
                    }
                  default:
                    V2.charCodeAt(F2 - 1) !== 58 && (U2 += o2(V2, p2, h3, V2.charCodeAt(2)));
                }
              L2 = M2 = N3 = p2 = 0, V2 = "", h3 = l3.charCodeAt(++z2);
          }
        }
        switch (h3) {
          case 13:
          case 10:
            S3 === 47 ? S3 = 0 : 1 + p2 === 0 && u3 !== 107 && 0 < V2.length && (M2 = 1, V2 += "\0"), 0 < R2 * A2 && s2(0, V2, r3, e5, j2, C2, U2.length, u3, f2, u3), C2 = 1, j2++;
            break;
          case 59:
          case 125:
            if (S3 + E3 + _3 + x3 === 0) {
              C2++;
              break;
            }
          default:
            switch (C2++, v3 = l3.charAt(z2), h3) {
              case 9:
              case 32:
                if (E3 + x3 + S3 === 0)
                  switch (P3) {
                    case 44:
                    case 58:
                    case 9:
                    case 32:
                      v3 = "";
                      break;
                    default:
                      h3 !== 32 && (v3 = " ");
                  }
                break;
              case 0:
                v3 = "\\0";
                break;
              case 12:
                v3 = "\\f";
                break;
              case 11:
                v3 = "\\v";
                break;
              case 38:
                E3 + S3 + x3 === 0 && (M2 = L2 = 1, v3 = "\f" + v3);
                break;
              case 108:
                if (E3 + S3 + x3 + O2 === 0 && 0 < N3)
                  switch (z2 - N3) {
                    case 2:
                      P3 === 112 && l3.charCodeAt(z2 - 3) === 58 && (O2 = P3);
                    case 8:
                      D3 === 111 && (O2 = D3);
                  }
                break;
              case 58:
                E3 + S3 + x3 === 0 && (N3 = z2);
                break;
              case 44:
                S3 + _3 + E3 + x3 === 0 && (M2 = 1, v3 += "\r");
                break;
              case 34:
              case 39:
                S3 === 0 && (E3 = E3 === h3 ? 0 : E3 === 0 ? h3 : E3);
                break;
              case 91:
                E3 + S3 + _3 === 0 && x3++;
                break;
              case 93:
                E3 + S3 + _3 === 0 && x3--;
                break;
              case 41:
                E3 + S3 + x3 === 0 && _3--;
                break;
              case 40:
                if (E3 + S3 + x3 === 0) {
                  if (p2 === 0)
                    if (2 * P3 + 3 * D3 == 533)
                      ;
                    else
                      p2 = 1;
                  _3++;
                }
                break;
              case 64:
                S3 + _3 + E3 + x3 + N3 + m3 === 0 && (m3 = 1);
                break;
              case 42:
              case 47:
                if (!(0 < E3 + x3 + _3))
                  switch (S3) {
                    case 0:
                      switch (2 * h3 + 3 * l3.charCodeAt(z2 + 1)) {
                        case 235:
                          S3 = 47;
                          break;
                        case 220:
                          F2 = z2, S3 = 42;
                      }
                      break;
                    case 42:
                      h3 === 47 && P3 === 42 && F2 + 2 !== z2 && (l3.charCodeAt(F2 + 2) === 33 && (U2 += l3.substring(F2, z2 + 1)), v3 = "", S3 = 0);
                  }
            }
            S3 === 0 && (V2 += v3);
        }
        D3 = P3, P3 = h3, z2++;
      }
      if (0 < (F2 = U2.length)) {
        if (M2 = r3, 0 < R2 && ((w3 = s2(2, U2, M2, e5, j2, C2, F2, u3, f2, u3)) !== void 0 && (U2 = w3).length === 0))
          return W2 + U2 + H2;
        if (U2 = M2.join(",") + "{" + U2 + "}", T2 * O2 != 0) {
          switch (T2 !== 2 || a2(U2, 2) || (O2 = 0), O2) {
            case 111:
              U2 = U2.replace(b2, ":-moz-$1") + U2;
              break;
            case 112:
              U2 = U2.replace(y2, "::-webkit-input-$1") + U2.replace(y2, "::-moz-$1") + U2.replace(y2, ":-ms-input-$1") + U2;
          }
          O2 = 0;
        }
      }
      return W2 + U2 + H2;
    }
    function n2(e5, t3, n3) {
      var o3 = t3.trim().split(m2);
      t3 = o3;
      var a3 = o3.length, i3 = e5.length;
      switch (i3) {
        case 0:
        case 1:
          var s3 = 0;
          for (e5 = i3 === 0 ? "" : e5[0] + " "; s3 < a3; ++s3)
            t3[s3] = r2(e5, t3[s3], n3).trim();
          break;
        default:
          var l3 = s3 = 0;
          for (t3 = []; s3 < a3; ++s3)
            for (var u3 = 0; u3 < i3; ++u3)
              t3[l3++] = r2(e5[u3] + " ", o3[s3], n3).trim();
      }
      return t3;
    }
    function r2(e5, t3, n3) {
      var r3 = t3.charCodeAt(0);
      switch (33 > r3 && (r3 = (t3 = t3.trim()).charCodeAt(0)), r3) {
        case 38:
          return t3.replace(v2, "$1" + e5.trim());
        case 58:
          return e5.trim() + t3.replace(v2, "$1" + e5.trim());
        default:
          if (0 < 1 * n3 && 0 < t3.indexOf("\f"))
            return t3.replace(v2, (e5.charCodeAt(0) === 58 ? "" : "$1") + e5.trim());
      }
      return e5 + t3;
    }
    function o2(e5, t3, n3, r3) {
      var i3 = e5 + ";", s3 = 2 * t3 + 3 * n3 + 4 * r3;
      if (s3 === 944) {
        e5 = i3.indexOf(":", 9) + 1;
        var l3 = i3.substring(e5, i3.length - 1).trim();
        return l3 = i3.substring(0, e5).trim() + l3 + ";", T2 === 1 || T2 === 2 && a2(l3, 1) ? "-webkit-" + l3 + l3 : l3;
      }
      if (T2 === 0 || T2 === 2 && !a2(i3, 1))
        return i3;
      switch (s3) {
        case 1015:
          return i3.charCodeAt(10) === 97 ? "-webkit-" + i3 + i3 : i3;
        case 951:
          return i3.charCodeAt(3) === 116 ? "-webkit-" + i3 + i3 : i3;
        case 963:
          return i3.charCodeAt(5) === 110 ? "-webkit-" + i3 + i3 : i3;
        case 1009:
          if (i3.charCodeAt(4) !== 100)
            break;
        case 969:
        case 942:
          return "-webkit-" + i3 + i3;
        case 978:
          return "-webkit-" + i3 + "-moz-" + i3 + i3;
        case 1019:
        case 983:
          return "-webkit-" + i3 + "-moz-" + i3 + "-ms-" + i3 + i3;
        case 883:
          if (i3.charCodeAt(8) === 45)
            return "-webkit-" + i3 + i3;
          if (0 < i3.indexOf("image-set(", 11))
            return i3.replace(P2, "$1-webkit-$2") + i3;
          break;
        case 932:
          if (i3.charCodeAt(4) === 45)
            switch (i3.charCodeAt(5)) {
              case 103:
                return "-webkit-box-" + i3.replace("-grow", "") + "-webkit-" + i3 + "-ms-" + i3.replace("grow", "positive") + i3;
              case 115:
                return "-webkit-" + i3 + "-ms-" + i3.replace("shrink", "negative") + i3;
              case 98:
                return "-webkit-" + i3 + "-ms-" + i3.replace("basis", "preferred-size") + i3;
            }
          return "-webkit-" + i3 + "-ms-" + i3 + i3;
        case 964:
          return "-webkit-" + i3 + "-ms-flex-" + i3 + i3;
        case 1023:
          if (i3.charCodeAt(8) !== 99)
            break;
          return "-webkit-box-pack" + (l3 = i3.substring(i3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify")) + "-webkit-" + i3 + "-ms-flex-pack" + l3 + i3;
        case 1005:
          return p.test(i3) ? i3.replace(f, ":-webkit-") + i3.replace(f, ":-moz-") + i3 : i3;
        case 1e3:
          switch (t3 = (l3 = i3.substring(13).trim()).indexOf("-") + 1, l3.charCodeAt(0) + l3.charCodeAt(t3)) {
            case 226:
              l3 = i3.replace(w2, "tb");
              break;
            case 232:
              l3 = i3.replace(w2, "tb-rl");
              break;
            case 220:
              l3 = i3.replace(w2, "lr");
              break;
            default:
              return i3;
          }
          return "-webkit-" + i3 + "-ms-" + l3 + i3;
        case 1017:
          if (i3.indexOf("sticky", 9) === -1)
            break;
        case 975:
          switch (t3 = (i3 = e5).length - 10, s3 = (l3 = (i3.charCodeAt(t3) === 33 ? i3.substring(0, t3) : i3).substring(e5.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | l3.charCodeAt(7))) {
            case 203:
              if (111 > l3.charCodeAt(8))
                break;
            case 115:
              i3 = i3.replace(l3, "-webkit-" + l3) + ";" + i3;
              break;
            case 207:
            case 102:
              i3 = i3.replace(l3, "-webkit-" + (102 < s3 ? "inline-" : "") + "box") + ";" + i3.replace(l3, "-webkit-" + l3) + ";" + i3.replace(l3, "-ms-" + l3 + "box") + ";" + i3;
          }
          return i3 + ";";
        case 938:
          if (i3.charCodeAt(5) === 45)
            switch (i3.charCodeAt(6)) {
              case 105:
                return l3 = i3.replace("-items", ""), "-webkit-" + i3 + "-webkit-box-" + l3 + "-ms-flex-" + l3 + i3;
              case 115:
                return "-webkit-" + i3 + "-ms-flex-item-" + i3.replace(S2, "") + i3;
              default:
                return "-webkit-" + i3 + "-ms-flex-line-pack" + i3.replace("align-content", "").replace(S2, "") + i3;
            }
          break;
        case 973:
        case 989:
          if (i3.charCodeAt(3) !== 45 || i3.charCodeAt(4) === 122)
            break;
        case 931:
        case 953:
          if (E2.test(e5) === true)
            return (l3 = e5.substring(e5.indexOf(":") + 1)).charCodeAt(0) === 115 ? o2(e5.replace("stretch", "fill-available"), t3, n3, r3).replace(":fill-available", ":stretch") : i3.replace(l3, "-webkit-" + l3) + i3.replace(l3, "-moz-" + l3.replace("fill-", "")) + i3;
          break;
        case 962:
          if (i3 = "-webkit-" + i3 + (i3.charCodeAt(5) === 102 ? "-ms-" + i3 : "") + i3, n3 + r3 === 211 && i3.charCodeAt(13) === 105 && 0 < i3.indexOf("transform", 10))
            return i3.substring(0, i3.indexOf(";", 27) + 1).replace(h2, "$1-webkit-$2") + i3;
      }
      return i3;
    }
    function a2(e5, t3) {
      var n3 = e5.indexOf(t3 === 1 ? ":" : "{"), r3 = e5.substring(0, t3 !== 3 ? n3 : 10);
      return n3 = e5.substring(n3 + 1, e5.length - 1), N2(t3 !== 2 ? r3 : r3.replace(_2, "$1"), n3, t3);
    }
    function i2(e5, t3) {
      var n3 = o2(t3, t3.charCodeAt(0), t3.charCodeAt(1), t3.charCodeAt(2));
      return n3 !== t3 + ";" ? n3.replace(x2, " or ($1)").substring(4) : "(" + t3 + ")";
    }
    function s2(e5, t3, n3, r3, o3, a3, i3, s3, l3, c3) {
      for (var d2, f2 = 0, p2 = t3; f2 < R2; ++f2)
        switch (d2 = D2[f2].call(u2, e5, p2, n3, r3, o3, a3, i3, s3, l3, c3)) {
          case void 0:
          case false:
          case true:
          case null:
            break;
          default:
            p2 = d2;
        }
      if (p2 !== t3)
        return p2;
    }
    function l2(e5) {
      return (e5 = e5.prefix) !== void 0 && (N2 = null, e5 ? typeof e5 != "function" ? T2 = 1 : (T2 = 2, N2 = e5) : T2 = 0), l2;
    }
    function u2(e5, n3) {
      var r3 = e5;
      if (33 > r3.charCodeAt(0) && (r3 = r3.trim()), r3 = [r3], 0 < R2) {
        var o3 = s2(-1, n3, r3, r3, j2, C2, 0, 0, 0, 0);
        o3 !== void 0 && typeof o3 == "string" && (n3 = o3);
      }
      var a3 = t2(I2, r3, n3, 0, 0);
      return 0 < R2 && ((o3 = s2(-2, a3, r3, r3, j2, C2, a3.length, 0, 0, 0)) !== void 0 && (a3 = o3)), "", O2 = 0, C2 = j2 = 1, a3;
    }
    var c2 = /^\0+/g, d = /[\0\r\f]/g, f = /: */g, p = /zoo|gra/, h2 = /([,: ])(transform)/g, m2 = /,\r+?/g, v2 = /([\t\r\n ])*\f?&/g, g2 = /@(k\w+)\s*(\S*)\s*/, y2 = /::(place)/g, b2 = /:(read-only)/g, w2 = /[svh]\w+-[tblr]{2}/, k2 = /\(\s*(.*)\s*\)/g, x2 = /([\s\S]*?);/g, S2 = /-self|flex-/g, _2 = /[^]*?(:[rp][el]a[\w-]+)[^]*/, E2 = /stretch|:\s*\w+\-(?:conte|avail)/, P2 = /([^-])(image-set\()/, C2 = 1, j2 = 1, O2 = 0, T2 = 1, I2 = [], D2 = [], R2 = 0, N2 = null, A2 = 0;
    return u2.use = function e5(t3) {
      switch (t3) {
        case void 0:
        case null:
          R2 = D2.length = 0;
          break;
        default:
          if (typeof t3 == "function")
            D2[R2++] = t3;
          else if (typeof t3 == "object")
            for (var n3 = 0, r3 = t3.length; n3 < r3; ++n3)
              e5(t3[n3]);
          else
            A2 = 0 | !!t3;
      }
      return e5;
    }, u2.set = l2, e4 !== void 0 && l2(e4), u2;
  }
  var Zd = { animationIterationCount: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 };
  function ef(e4) {
    var t2 = /* @__PURE__ */ Object.create(null);
    return function(n2) {
      return t2[n2] === void 0 && (t2[n2] = e4(n2)), t2[n2];
    };
  }
  var tf = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var nf = ef(function(e4) {
    return tf.test(e4) || e4.charCodeAt(0) === 111 && e4.charCodeAt(1) === 110 && e4.charCodeAt(2) < 91;
  });
  var rf = { exports: {} };
  var of = {};
  var af = typeof Symbol == "function" && Symbol.for;
  var sf = af ? Symbol.for("react.element") : 60103;
  var lf = af ? Symbol.for("react.portal") : 60106;
  var uf = af ? Symbol.for("react.fragment") : 60107;
  var cf = af ? Symbol.for("react.strict_mode") : 60108;
  var df = af ? Symbol.for("react.profiler") : 60114;
  var ff = af ? Symbol.for("react.provider") : 60109;
  var pf = af ? Symbol.for("react.context") : 60110;
  var hf = af ? Symbol.for("react.async_mode") : 60111;
  var mf = af ? Symbol.for("react.concurrent_mode") : 60111;
  var vf = af ? Symbol.for("react.forward_ref") : 60112;
  var gf = af ? Symbol.for("react.suspense") : 60113;
  var yf = af ? Symbol.for("react.suspense_list") : 60120;
  var bf = af ? Symbol.for("react.memo") : 60115;
  var wf = af ? Symbol.for("react.lazy") : 60116;
  var kf = af ? Symbol.for("react.block") : 60121;
  var xf = af ? Symbol.for("react.fundamental") : 60117;
  var Sf = af ? Symbol.for("react.responder") : 60118;
  var _f = af ? Symbol.for("react.scope") : 60119;
  function Ef(e4) {
    if (typeof e4 == "object" && e4 !== null) {
      var t2 = e4.$$typeof;
      switch (t2) {
        case sf:
          switch (e4 = e4.type) {
            case hf:
            case mf:
            case uf:
            case df:
            case cf:
            case gf:
              return e4;
            default:
              switch (e4 = e4 && e4.$$typeof) {
                case pf:
                case vf:
                case wf:
                case bf:
                case ff:
                  return e4;
                default:
                  return t2;
              }
          }
        case lf:
          return t2;
      }
    }
  }
  function Pf(e4) {
    return Ef(e4) === mf;
  }
  of.AsyncMode = hf, of.ConcurrentMode = mf, of.ContextConsumer = pf, of.ContextProvider = ff, of.Element = sf, of.ForwardRef = vf, of.Fragment = uf, of.Lazy = wf, of.Memo = bf, of.Portal = lf, of.Profiler = df, of.StrictMode = cf, of.Suspense = gf, of.isAsyncMode = function(e4) {
    return Pf(e4) || Ef(e4) === hf;
  }, of.isConcurrentMode = Pf, of.isContextConsumer = function(e4) {
    return Ef(e4) === pf;
  }, of.isContextProvider = function(e4) {
    return Ef(e4) === ff;
  }, of.isElement = function(e4) {
    return typeof e4 == "object" && e4 !== null && e4.$$typeof === sf;
  }, of.isForwardRef = function(e4) {
    return Ef(e4) === vf;
  }, of.isFragment = function(e4) {
    return Ef(e4) === uf;
  }, of.isLazy = function(e4) {
    return Ef(e4) === wf;
  }, of.isMemo = function(e4) {
    return Ef(e4) === bf;
  }, of.isPortal = function(e4) {
    return Ef(e4) === lf;
  }, of.isProfiler = function(e4) {
    return Ef(e4) === df;
  }, of.isStrictMode = function(e4) {
    return Ef(e4) === cf;
  }, of.isSuspense = function(e4) {
    return Ef(e4) === gf;
  }, of.isValidElementType = function(e4) {
    return typeof e4 == "string" || typeof e4 == "function" || e4 === uf || e4 === mf || e4 === df || e4 === cf || e4 === gf || e4 === yf || typeof e4 == "object" && e4 !== null && (e4.$$typeof === wf || e4.$$typeof === bf || e4.$$typeof === ff || e4.$$typeof === pf || e4.$$typeof === vf || e4.$$typeof === xf || e4.$$typeof === Sf || e4.$$typeof === _f || e4.$$typeof === kf);
  }, of.typeOf = Ef;
  var Cf = {};
  (function() {
    var e4 = typeof Symbol == "function" && Symbol.for, t2 = e4 ? Symbol.for("react.element") : 60103, n2 = e4 ? Symbol.for("react.portal") : 60106, r2 = e4 ? Symbol.for("react.fragment") : 60107, o2 = e4 ? Symbol.for("react.strict_mode") : 60108, a2 = e4 ? Symbol.for("react.profiler") : 60114, i2 = e4 ? Symbol.for("react.provider") : 60109, s2 = e4 ? Symbol.for("react.context") : 60110, l2 = e4 ? Symbol.for("react.async_mode") : 60111, u2 = e4 ? Symbol.for("react.concurrent_mode") : 60111, c2 = e4 ? Symbol.for("react.forward_ref") : 60112, d = e4 ? Symbol.for("react.suspense") : 60113, f = e4 ? Symbol.for("react.suspense_list") : 60120, p = e4 ? Symbol.for("react.memo") : 60115, h2 = e4 ? Symbol.for("react.lazy") : 60116, m2 = e4 ? Symbol.for("react.block") : 60121, v2 = e4 ? Symbol.for("react.fundamental") : 60117, g2 = e4 ? Symbol.for("react.responder") : 60118, y2 = e4 ? Symbol.for("react.scope") : 60119;
    function b2(e5) {
      if (typeof e5 == "object" && e5 !== null) {
        var f2 = e5.$$typeof;
        switch (f2) {
          case t2:
            var m3 = e5.type;
            switch (m3) {
              case l2:
              case u2:
              case r2:
              case a2:
              case o2:
              case d:
                return m3;
              default:
                var v3 = m3 && m3.$$typeof;
                switch (v3) {
                  case s2:
                  case c2:
                  case h2:
                  case p:
                  case i2:
                    return v3;
                  default:
                    return f2;
                }
            }
          case n2:
            return f2;
        }
      }
    }
    var w2 = l2, k2 = u2, x2 = s2, S2 = i2, _2 = t2, E2 = c2, P2 = r2, C2 = h2, j2 = p, O2 = n2, T2 = a2, I2 = o2, D2 = d, R2 = false;
    function N2(e5) {
      return b2(e5) === u2;
    }
    Cf.AsyncMode = w2, Cf.ConcurrentMode = k2, Cf.ContextConsumer = x2, Cf.ContextProvider = S2, Cf.Element = _2, Cf.ForwardRef = E2, Cf.Fragment = P2, Cf.Lazy = C2, Cf.Memo = j2, Cf.Portal = O2, Cf.Profiler = T2, Cf.StrictMode = I2, Cf.Suspense = D2, Cf.isAsyncMode = function(e5) {
      return R2 || (R2 = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), N2(e5) || b2(e5) === l2;
    }, Cf.isConcurrentMode = N2, Cf.isContextConsumer = function(e5) {
      return b2(e5) === s2;
    }, Cf.isContextProvider = function(e5) {
      return b2(e5) === i2;
    }, Cf.isElement = function(e5) {
      return typeof e5 == "object" && e5 !== null && e5.$$typeof === t2;
    }, Cf.isForwardRef = function(e5) {
      return b2(e5) === c2;
    }, Cf.isFragment = function(e5) {
      return b2(e5) === r2;
    }, Cf.isLazy = function(e5) {
      return b2(e5) === h2;
    }, Cf.isMemo = function(e5) {
      return b2(e5) === p;
    }, Cf.isPortal = function(e5) {
      return b2(e5) === n2;
    }, Cf.isProfiler = function(e5) {
      return b2(e5) === a2;
    }, Cf.isStrictMode = function(e5) {
      return b2(e5) === o2;
    }, Cf.isSuspense = function(e5) {
      return b2(e5) === d;
    }, Cf.isValidElementType = function(e5) {
      return typeof e5 == "string" || typeof e5 == "function" || e5 === r2 || e5 === u2 || e5 === a2 || e5 === o2 || e5 === d || e5 === f || typeof e5 == "object" && e5 !== null && (e5.$$typeof === h2 || e5.$$typeof === p || e5.$$typeof === i2 || e5.$$typeof === s2 || e5.$$typeof === c2 || e5.$$typeof === v2 || e5.$$typeof === g2 || e5.$$typeof === y2 || e5.$$typeof === m2);
    }, Cf.typeOf = b2;
  })(), false ? rf.exports = of : rf.exports = Cf;
  var jf = rf.exports;
  var Of = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
  var Tf = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
  var If = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
  var Df = {};
  function Rf(e4) {
    return jf.isMemo(e4) ? If : Df[e4.$$typeof] || Of;
  }
  Df[jf.ForwardRef] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, Df[jf.Memo] = If;
  var Nf = Object.defineProperty;
  var Af = Object.getOwnPropertyNames;
  var zf = Object.getOwnPropertySymbols;
  var Mf = Object.getOwnPropertyDescriptor;
  var Lf = Object.getPrototypeOf;
  var Ff = Object.prototype;
  var $f = function e3(t2, n2, r2) {
    if (typeof n2 != "string") {
      if (Ff) {
        var o2 = Lf(n2);
        o2 && o2 !== Ff && e3(t2, o2, r2);
      }
      var a2 = Af(n2);
      zf && (a2 = a2.concat(zf(n2)));
      for (var i2 = Rf(t2), s2 = Rf(n2), l2 = 0; l2 < a2.length; ++l2) {
        var u2 = a2[l2];
        if (!(Tf[u2] || r2 && r2[u2] || s2 && s2[u2] || i2 && i2[u2])) {
          var c2 = Mf(n2, u2);
          try {
            Nf(t2, u2, c2);
          } catch (e4) {
          }
        }
      }
    }
    return t2;
  };
  function Bf() {
    return (Bf = Object.assign || function(e4) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = arguments[t2];
        for (var r2 in n2)
          Object.prototype.hasOwnProperty.call(n2, r2) && (e4[r2] = n2[r2]);
      }
      return e4;
    }).apply(this, arguments);
  }
  var Vf = function(e4, t2) {
    for (var n2 = [e4[0]], r2 = 0, o2 = t2.length; r2 < o2; r2 += 1)
      n2.push(t2[r2], e4[r2 + 1]);
    return n2;
  };
  var Uf = function(e4) {
    return e4 !== null && typeof e4 == "object" && (e4.toString ? e4.toString() : Object.prototype.toString.call(e4)) === "[object Object]" && !Rd.exports.typeOf(e4);
  };
  var Hf = Object.freeze([]);
  var Wf = Object.freeze({});
  function qf(e4) {
    return typeof e4 == "function";
  }
  function Kf(e4) {
    return typeof e4 == "string" && e4 || e4.displayName || e4.name || "Component";
  }
  function Yf(e4) {
    return e4 && typeof e4.styledComponentId == "string";
  }
  var Xf = typeof process != "undefined" && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
  var Gf = typeof window != "undefined" && "HTMLElement" in window;
  var Qf = Boolean(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process != "undefined" && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process != "undefined" && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : true);
  var Jf = {};
  var Zf = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
  function ep() {
    for (var e4 = arguments.length <= 0 ? void 0 : arguments[0], t2 = [], n2 = 1, r2 = arguments.length; n2 < r2; n2 += 1)
      t2.push(n2 < 0 || arguments.length <= n2 ? void 0 : arguments[n2]);
    return t2.forEach(function(t3) {
      e4 = e4.replace(/%[a-z]/, t3);
    }), e4;
  }
  function tp(e4) {
    for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
      n2[r2 - 1] = arguments[r2];
    throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + e4 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : "")) : new Error(ep.apply(void 0, [Zf[e4]].concat(n2)).trim());
  }
  var np = function() {
    function e4(e5) {
      this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e5;
    }
    var t2 = e4.prototype;
    return t2.indexOfGroup = function(e5) {
      for (var t3 = 0, n2 = 0; n2 < e5; n2++)
        t3 += this.groupSizes[n2];
      return t3;
    }, t2.insertRules = function(e5, t3) {
      if (e5 >= this.groupSizes.length) {
        for (var n2 = this.groupSizes, r2 = n2.length, o2 = r2; e5 >= o2; )
          (o2 <<= 1) < 0 && tp(16, "" + e5);
        this.groupSizes = new Uint32Array(o2), this.groupSizes.set(n2), this.length = o2;
        for (var a2 = r2; a2 < o2; a2++)
          this.groupSizes[a2] = 0;
      }
      for (var i2 = this.indexOfGroup(e5 + 1), s2 = 0, l2 = t3.length; s2 < l2; s2++)
        this.tag.insertRule(i2, t3[s2]) && (this.groupSizes[e5]++, i2++);
    }, t2.clearGroup = function(e5) {
      if (e5 < this.length) {
        var t3 = this.groupSizes[e5], n2 = this.indexOfGroup(e5), r2 = n2 + t3;
        this.groupSizes[e5] = 0;
        for (var o2 = n2; o2 < r2; o2++)
          this.tag.deleteRule(n2);
      }
    }, t2.getGroup = function(e5) {
      var t3 = "";
      if (e5 >= this.length || this.groupSizes[e5] === 0)
        return t3;
      for (var n2 = this.groupSizes[e5], r2 = this.indexOfGroup(e5), o2 = r2 + n2, a2 = r2; a2 < o2; a2++)
        t3 += this.tag.getRule(a2) + "/*!sc*/\n";
      return t3;
    }, e4;
  }();
  var rp = /* @__PURE__ */ new Map();
  var op = /* @__PURE__ */ new Map();
  var ap = 1;
  var ip = function(e4) {
    if (rp.has(e4))
      return rp.get(e4);
    for (; op.has(ap); )
      ap++;
    var t2 = ap++;
    return ((0 | t2) < 0 || t2 > 1 << 30) && tp(16, "" + t2), rp.set(e4, t2), op.set(t2, e4), t2;
  };
  var sp = function(e4) {
    return op.get(e4);
  };
  var lp = function(e4, t2) {
    t2 >= ap && (ap = t2 + 1), rp.set(e4, t2), op.set(t2, e4);
  };
  var up = "style[" + Xf + '][data-styled-version="5.3.5"]';
  var cp = new RegExp("^" + Xf + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
  var dp = function(e4, t2, n2) {
    for (var r2, o2 = n2.split(","), a2 = 0, i2 = o2.length; a2 < i2; a2++)
      (r2 = o2[a2]) && e4.registerName(t2, r2);
  };
  var fp = function(e4, t2) {
    for (var n2 = (t2.textContent || "").split("/*!sc*/\n"), r2 = [], o2 = 0, a2 = n2.length; o2 < a2; o2++) {
      var i2 = n2[o2].trim();
      if (i2) {
        var s2 = i2.match(cp);
        if (s2) {
          var l2 = 0 | parseInt(s2[1], 10), u2 = s2[2];
          l2 !== 0 && (lp(u2, l2), dp(e4, u2, s2[3]), e4.getTag().insertRules(l2, r2)), r2.length = 0;
        } else
          r2.push(i2);
      }
    }
  };
  var pp = function() {
    return typeof window != "undefined" && window.__webpack_nonce__ !== void 0 ? window.__webpack_nonce__ : null;
  };
  var hp = function(e4) {
    var t2 = document.head, n2 = e4 || t2, r2 = document.createElement("style"), o2 = function(e5) {
      for (var t3 = e5.childNodes, n3 = t3.length; n3 >= 0; n3--) {
        var r3 = t3[n3];
        if (r3 && r3.nodeType === 1 && r3.hasAttribute(Xf))
          return r3;
      }
    }(n2), a2 = o2 !== void 0 ? o2.nextSibling : null;
    r2.setAttribute(Xf, "active"), r2.setAttribute("data-styled-version", "5.3.5");
    var i2 = pp();
    return i2 && r2.setAttribute("nonce", i2), n2.insertBefore(r2, a2), r2;
  };
  var mp = function() {
    function e4(e5) {
      var t3 = this.element = hp(e5);
      t3.appendChild(document.createTextNode("")), this.sheet = function(e6) {
        if (e6.sheet)
          return e6.sheet;
        for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {
          var o2 = t4[n2];
          if (o2.ownerNode === e6)
            return o2;
        }
        tp(17);
      }(t3), this.length = 0;
    }
    var t2 = e4.prototype;
    return t2.insertRule = function(e5, t3) {
      try {
        return this.sheet.insertRule(t3, e5), this.length++, true;
      } catch (e6) {
        return false;
      }
    }, t2.deleteRule = function(e5) {
      this.sheet.deleteRule(e5), this.length--;
    }, t2.getRule = function(e5) {
      var t3 = this.sheet.cssRules[e5];
      return t3 !== void 0 && typeof t3.cssText == "string" ? t3.cssText : "";
    }, e4;
  }();
  var vp = function() {
    function e4(e5) {
      var t3 = this.element = hp(e5);
      this.nodes = t3.childNodes, this.length = 0;
    }
    var t2 = e4.prototype;
    return t2.insertRule = function(e5, t3) {
      if (e5 <= this.length && e5 >= 0) {
        var n2 = document.createTextNode(t3), r2 = this.nodes[e5];
        return this.element.insertBefore(n2, r2 || null), this.length++, true;
      }
      return false;
    }, t2.deleteRule = function(e5) {
      this.element.removeChild(this.nodes[e5]), this.length--;
    }, t2.getRule = function(e5) {
      return e5 < this.length ? this.nodes[e5].textContent : "";
    }, e4;
  }();
  var gp = function() {
    function e4(e5) {
      this.rules = [], this.length = 0;
    }
    var t2 = e4.prototype;
    return t2.insertRule = function(e5, t3) {
      return e5 <= this.length && (this.rules.splice(e5, 0, t3), this.length++, true);
    }, t2.deleteRule = function(e5) {
      this.rules.splice(e5, 1), this.length--;
    }, t2.getRule = function(e5) {
      return e5 < this.length ? this.rules[e5] : "";
    }, e4;
  }();
  var yp = Gf;
  var bp = { isServer: !Gf, useCSSOMInjection: !Qf };
  var wp = function() {
    function e4(e5, t3, n2) {
      e5 === void 0 && (e5 = Wf), t3 === void 0 && (t3 = {}), this.options = Bf({}, bp, {}, e5), this.gs = t3, this.names = new Map(n2), this.server = !!e5.isServer, !this.server && Gf && yp && (yp = false, function(e6) {
        for (var t4 = document.querySelectorAll(up), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
          var o2 = t4[n3];
          o2 && o2.getAttribute(Xf) !== "active" && (fp(e6, o2), o2.parentNode && o2.parentNode.removeChild(o2));
        }
      }(this));
    }
    e4.registerId = function(e5) {
      return ip(e5);
    };
    var t2 = e4.prototype;
    return t2.reconstructWithOptions = function(t3, n2) {
      return n2 === void 0 && (n2 = true), new e4(Bf({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);
    }, t2.allocateGSInstance = function(e5) {
      return this.gs[e5] = (this.gs[e5] || 0) + 1;
    }, t2.getTag = function() {
      return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o2 = t3.target, e5 = n2 ? new gp(o2) : r2 ? new mp(o2) : new vp(o2), new np(e5)));
      var e5, t3, n2, r2, o2;
    }, t2.hasNameForId = function(e5, t3) {
      return this.names.has(e5) && this.names.get(e5).has(t3);
    }, t2.registerName = function(e5, t3) {
      if (ip(e5), this.names.has(e5))
        this.names.get(e5).add(t3);
      else {
        var n2 = /* @__PURE__ */ new Set();
        n2.add(t3), this.names.set(e5, n2);
      }
    }, t2.insertRules = function(e5, t3, n2) {
      this.registerName(e5, t3), this.getTag().insertRules(ip(e5), n2);
    }, t2.clearNames = function(e5) {
      this.names.has(e5) && this.names.get(e5).clear();
    }, t2.clearRules = function(e5) {
      this.getTag().clearGroup(ip(e5)), this.clearNames(e5);
    }, t2.clearTag = function() {
      this.tag = void 0;
    }, t2.toString = function() {
      return function(e5) {
        for (var t3 = e5.getTag(), n2 = t3.length, r2 = "", o2 = 0; o2 < n2; o2++) {
          var a2 = sp(o2);
          if (a2 !== void 0) {
            var i2 = e5.names.get(a2), s2 = t3.getGroup(o2);
            if (i2 && s2 && i2.size) {
              var l2 = Xf + ".g" + o2 + '[id="' + a2 + '"]', u2 = "";
              i2 !== void 0 && i2.forEach(function(e6) {
                e6.length > 0 && (u2 += e6 + ",");
              }), r2 += "" + s2 + l2 + '{content:"' + u2 + '"}/*!sc*/\n';
            }
          }
        }
        return r2;
      }(this);
    }, e4;
  }();
  var kp = /(a)(d)/gi;
  var xp = function(e4) {
    return String.fromCharCode(e4 + (e4 > 25 ? 39 : 97));
  };
  function Sp(e4) {
    var t2, n2 = "";
    for (t2 = Math.abs(e4); t2 > 52; t2 = t2 / 52 | 0)
      n2 = xp(t2 % 52) + n2;
    return (xp(t2 % 52) + n2).replace(kp, "$1-$2");
  }
  var _p = function(e4, t2) {
    for (var n2 = t2.length; n2; )
      e4 = 33 * e4 ^ t2.charCodeAt(--n2);
    return e4;
  };
  var Ep = function(e4) {
    return _p(5381, e4);
  };
  function Pp(e4) {
    for (var t2 = 0; t2 < e4.length; t2 += 1) {
      var n2 = e4[t2];
      if (qf(n2) && !Yf(n2))
        return false;
    }
    return true;
  }
  var Cp = Ep("5.3.5");
  var jp = function() {
    function e4(e5, t2, n2) {
      this.rules = e5, this.staticRulesId = "", this.isStatic = false, this.componentId = t2, this.baseHash = _p(Cp, t2), this.baseStyle = n2, wp.registerId(t2);
    }
    return e4.prototype.generateAndInjectStyles = function(e5, t2, n2) {
      var r2 = this.componentId, o2 = [];
      if (this.baseStyle && o2.push(this.baseStyle.generateAndInjectStyles(e5, t2, n2)), this.isStatic && !n2.hash)
        if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId))
          o2.push(this.staticRulesId);
        else {
          var a2 = Kp(this.rules, e5, t2, n2).join(""), i2 = Sp(_p(this.baseHash, a2) >>> 0);
          if (!t2.hasNameForId(r2, i2)) {
            var s2 = n2(a2, "." + i2, void 0, r2);
            t2.insertRules(r2, i2, s2);
          }
          o2.push(i2), this.staticRulesId = i2;
        }
      else {
        for (var l2 = this.rules.length, u2 = _p(this.baseHash, n2.hash), c2 = "", d = 0; d < l2; d++) {
          var f = this.rules[d];
          if (typeof f == "string")
            c2 += f, u2 = _p(u2, f + d);
          else if (f) {
            var p = Kp(f, e5, t2, n2), h2 = Array.isArray(p) ? p.join("") : p;
            u2 = _p(u2, h2 + d), c2 += h2;
          }
        }
        if (c2) {
          var m2 = Sp(u2 >>> 0);
          if (!t2.hasNameForId(r2, m2)) {
            var v2 = n2(c2, "." + m2, void 0, r2);
            t2.insertRules(r2, m2, v2);
          }
          o2.push(m2);
        }
      }
      return o2.join(" ");
    }, e4;
  }();
  var Op = /^\s*\/\/.*$/gm;
  var Tp = [":", "[", ".", "#"];
  function Ip(e4) {
    var t2, n2, r2, o2, a2 = e4 === void 0 ? Wf : e4, i2 = a2.options, s2 = i2 === void 0 ? Wf : i2, l2 = a2.plugins, u2 = l2 === void 0 ? Hf : l2, c2 = new Jd(s2), d = [], f = function(e5) {
      function t3(t4) {
        if (t4)
          try {
            e5(t4 + "}");
          } catch (e6) {
          }
      }
      return function(n3, r3, o3, a3, i3, s3, l3, u3, c3, d2) {
        switch (n3) {
          case 1:
            if (c3 === 0 && r3.charCodeAt(0) === 64)
              return e5(r3 + ";"), "";
            break;
          case 2:
            if (u3 === 0)
              return r3 + "/*|*/";
            break;
          case 3:
            switch (u3) {
              case 102:
              case 112:
                return e5(o3[0] + r3), "";
              default:
                return r3 + (d2 === 0 ? "/*|*/" : "");
            }
          case -2:
            r3.split("/*|*/}").forEach(t3);
        }
      };
    }(function(e5) {
      d.push(e5);
    }), p = function(e5, r3, a3) {
      return r3 === 0 && Tp.indexOf(a3[n2.length]) !== -1 || a3.match(o2) ? e5 : "." + t2;
    };
    function h2(e5, a3, i3, s3) {
      s3 === void 0 && (s3 = "&");
      var l3 = e5.replace(Op, ""), u3 = a3 && i3 ? i3 + " " + a3 + " { " + l3 + " }" : l3;
      return t2 = s3, n2 = a3, r2 = new RegExp("\\" + n2 + "\\b", "g"), o2 = new RegExp("(\\" + n2 + "\\b){2,}"), c2(i3 || !a3 ? "" : a3, u3);
    }
    return c2.use([].concat(u2, [function(e5, t3, o3) {
      e5 === 2 && o3.length && o3[0].lastIndexOf(n2) > 0 && (o3[0] = o3[0].replace(r2, p));
    }, f, function(e5) {
      if (e5 === -2) {
        var t3 = d;
        return d = [], t3;
      }
    }])), h2.hash = u2.length ? u2.reduce(function(e5, t3) {
      return t3.name || tp(15), _p(e5, t3.name);
    }, 5381).toString() : "", h2;
  }
  var Dp = pt.createContext();
  var Rp = Dp.Consumer;
  var Np = pt.createContext();
  var Ap = (Np.Consumer, new wp());
  var zp = Ip();
  function Mp() {
    return je.exports.useContext(Dp) || Ap;
  }
  function Lp() {
    return je.exports.useContext(Np) || zp;
  }
  function Fp(e4) {
    var t2 = je.exports.useState(e4.stylisPlugins), n2 = t2[0], r2 = t2[1], o2 = Mp(), a2 = je.exports.useMemo(function() {
      var t3 = o2;
      return e4.sheet ? t3 = e4.sheet : e4.target && (t3 = t3.reconstructWithOptions({ target: e4.target }, false)), e4.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
    }, [e4.disableCSSOMInjection, e4.sheet, e4.target]), i2 = je.exports.useMemo(function() {
      return Ip({ options: { prefix: !e4.disableVendorPrefixes }, plugins: n2 });
    }, [e4.disableVendorPrefixes, n2]);
    return je.exports.useEffect(function() {
      (function(e5, t3, n3, r3) {
        var o3 = n3 ? n3.call(r3, e5, t3) : void 0;
        if (o3 !== void 0)
          return !!o3;
        if (e5 === t3)
          return true;
        if (typeof e5 != "object" || !e5 || typeof t3 != "object" || !t3)
          return false;
        var a3 = Object.keys(e5), i3 = Object.keys(t3);
        if (a3.length !== i3.length)
          return false;
        for (var s2 = Object.prototype.hasOwnProperty.bind(t3), l2 = 0; l2 < a3.length; l2++) {
          var u2 = a3[l2];
          if (!s2(u2))
            return false;
          var c2 = e5[u2], d = t3[u2];
          if ((o3 = n3 ? n3.call(r3, c2, d, u2) : void 0) === false || o3 === void 0 && c2 !== d)
            return false;
        }
        return true;
      })(n2, e4.stylisPlugins) || r2(e4.stylisPlugins);
    }, [e4.stylisPlugins]), pt.createElement(Dp.Provider, { value: a2 }, pt.createElement(Np.Provider, { value: i2 }, true ? pt.Children.only(e4.children) : e4.children));
  }
  var $p = function() {
    function e4(e5, t2) {
      var n2 = this;
      this.inject = function(e6, t3) {
        t3 === void 0 && (t3 = zp);
        var r2 = n2.name + t3.hash;
        e6.hasNameForId(n2.id, r2) || e6.insertRules(n2.id, r2, t3(n2.rules, r2, "@keyframes"));
      }, this.toString = function() {
        return tp(12, String(n2.name));
      }, this.name = e5, this.id = "sc-keyframes-" + e5, this.rules = t2;
    }
    return e4.prototype.getName = function(e5) {
      return e5 === void 0 && (e5 = zp), this.name + e5.hash;
    }, e4;
  }();
  var Bp = /([A-Z])/;
  var Vp = /([A-Z])/g;
  var Up = /^ms-/;
  var Hp = function(e4) {
    return "-" + e4.toLowerCase();
  };
  function Wp(e4) {
    return Bp.test(e4) ? e4.replace(Vp, Hp).replace(Up, "-ms-") : e4;
  }
  var qp = function(e4) {
    return e4 == null || e4 === false || e4 === "";
  };
  function Kp(e4, t2, n2, r2) {
    if (Array.isArray(e4)) {
      for (var o2, a2 = [], i2 = 0, s2 = e4.length; i2 < s2; i2 += 1)
        (o2 = Kp(e4[i2], t2, n2, r2)) !== "" && (Array.isArray(o2) ? a2.push.apply(a2, o2) : a2.push(o2));
      return a2;
    }
    if (qp(e4))
      return "";
    if (Yf(e4))
      return "." + e4.styledComponentId;
    if (qf(e4)) {
      if (typeof (u2 = e4) != "function" || u2.prototype && u2.prototype.isReactComponent || !t2)
        return e4;
      var l2 = e4(t2);
      return Rd.exports.isElement(l2) && console.warn(Kf(e4) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), Kp(l2, t2, n2, r2);
    }
    var u2;
    return e4 instanceof $p ? n2 ? (e4.inject(n2, r2), e4.getName(r2)) : e4 : Uf(e4) ? function e5(t3, n3) {
      var r3, o3, a3 = [];
      for (var i3 in t3)
        t3.hasOwnProperty(i3) && !qp(t3[i3]) && (Array.isArray(t3[i3]) && t3[i3].isCss || qf(t3[i3]) ? a3.push(Wp(i3) + ":", t3[i3], ";") : Uf(t3[i3]) ? a3.push.apply(a3, e5(t3[i3], i3)) : a3.push(Wp(i3) + ": " + (r3 = i3, ((o3 = t3[i3]) == null || typeof o3 == "boolean" || o3 === "" ? "" : typeof o3 != "number" || o3 === 0 || r3 in Zd ? String(o3).trim() : o3 + "px") + ";")));
      return n3 ? [n3 + " {"].concat(a3, ["}"]) : a3;
    }(e4) : e4.toString();
  }
  var Yp = function(e4) {
    return Array.isArray(e4) && (e4.isCss = true), e4;
  };
  function Xp(e4) {
    for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
      n2[r2 - 1] = arguments[r2];
    return qf(e4) || Uf(e4) ? Yp(Kp(Vf(Hf, [e4].concat(n2)))) : n2.length === 0 && e4.length === 1 && typeof e4[0] == "string" ? e4 : Yp(Kp(Vf(e4, n2)));
  }
  var Gp = /invalid hook call/i;
  var Qp = /* @__PURE__ */ new Set();
  var Jp = function(e4, t2) {
    if (true) {
      var n2 = "The component " + e4 + (t2 ? ' with the id of "' + t2 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r2 = console.error;
      try {
        var o2 = true;
        console.error = function(e5) {
          if (Gp.test(e5))
            o2 = false, Qp.delete(n2);
          else {
            for (var t3 = arguments.length, a2 = new Array(t3 > 1 ? t3 - 1 : 0), i2 = 1; i2 < t3; i2++)
              a2[i2 - 1] = arguments[i2];
            r2.apply(void 0, [e5].concat(a2));
          }
        }, je.exports.useRef(), o2 && !Qp.has(n2) && (console.warn(n2), Qp.add(n2));
      } catch (e5) {
        Gp.test(e5.message) && Qp.delete(n2);
      } finally {
        console.error = r2;
      }
    }
  };
  var Zp = function(e4, t2, n2) {
    return n2 === void 0 && (n2 = Wf), e4.theme !== n2.theme && e4.theme || t2 || n2.theme;
  };
  var eh = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
  var th = /(^-|-$)/g;
  function nh(e4) {
    return e4.replace(eh, "-").replace(th, "");
  }
  var rh = function(e4) {
    return Sp(Ep(e4) >>> 0);
  };
  function oh(e4) {
    return typeof e4 == "string" && e4.charAt(0) === e4.charAt(0).toLowerCase();
  }
  var ah = function(e4) {
    return typeof e4 == "function" || typeof e4 == "object" && e4 !== null && !Array.isArray(e4);
  };
  var ih = function(e4) {
    return e4 !== "__proto__" && e4 !== "constructor" && e4 !== "prototype";
  };
  function sh(e4, t2, n2) {
    var r2 = e4[n2];
    ah(t2) && ah(r2) ? lh(r2, t2) : e4[n2] = t2;
  }
  function lh(e4) {
    for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
      n2[r2 - 1] = arguments[r2];
    for (var o2 = 0, a2 = n2; o2 < a2.length; o2++) {
      var i2 = a2[o2];
      if (ah(i2))
        for (var s2 in i2)
          ih(s2) && sh(e4, i2[s2], s2);
    }
    return e4;
  }
  var uh = pt.createContext();
  var ch = uh.Consumer;
  var dh = {};
  function fh(e4, t2, n2) {
    var r2 = Yf(e4), o2 = !oh(e4), a2 = t2.attrs, i2 = a2 === void 0 ? Hf : a2, s2 = t2.componentId, l2 = s2 === void 0 ? function(e5, t3) {
      var n3 = typeof e5 != "string" ? "sc" : nh(e5);
      dh[n3] = (dh[n3] || 0) + 1;
      var r3 = n3 + "-" + rh("5.3.5" + n3 + dh[n3]);
      return t3 ? t3 + "-" + r3 : r3;
    }(t2.displayName, t2.parentComponentId) : s2, u2 = t2.displayName, c2 = u2 === void 0 ? function(e5) {
      return oh(e5) ? "styled." + e5 : "Styled(" + Kf(e5) + ")";
    }(e4) : u2, d = t2.displayName && t2.componentId ? nh(t2.displayName) + "-" + t2.componentId : t2.componentId || l2, f = r2 && e4.attrs ? Array.prototype.concat(e4.attrs, i2).filter(Boolean) : i2, p = t2.shouldForwardProp;
    r2 && e4.shouldForwardProp && (p = t2.shouldForwardProp ? function(n3, r3, o3) {
      return e4.shouldForwardProp(n3, r3, o3) && t2.shouldForwardProp(n3, r3, o3);
    } : e4.shouldForwardProp);
    var h2, m2 = new jp(n2, d, r2 ? e4.componentStyle : void 0), v2 = m2.isStatic && i2.length === 0, g2 = function(e5, t3) {
      return function(e6, t4, n3, r3) {
        var o3 = e6.attrs, a3 = e6.componentStyle, i3 = e6.defaultProps, s3 = e6.foldedComponentIds, l3 = e6.shouldForwardProp, u3 = e6.styledComponentId, c3 = e6.target;
        je.exports.useDebugValue(u3);
        var d2 = function(e7, t5, n4) {
          e7 === void 0 && (e7 = Wf);
          var r4 = Bf({}, t5, { theme: e7 }), o4 = {};
          return n4.forEach(function(e8) {
            var t6, n5, a4, i4 = e8;
            for (t6 in qf(i4) && (i4 = i4(r4)), i4)
              r4[t6] = o4[t6] = t6 === "className" ? (n5 = o4[t6], a4 = i4[t6], n5 && a4 ? n5 + " " + a4 : n5 || a4) : i4[t6];
          }), [r4, o4];
        }(Zp(t4, je.exports.useContext(uh), i3) || Wf, t4, o3), f2 = d2[0], p2 = d2[1], h3 = function(e7, t5, n4, r4) {
          var o4 = Mp(), a4 = Lp(), i4 = t5 ? e7.generateAndInjectStyles(Wf, o4, a4) : e7.generateAndInjectStyles(n4, o4, a4);
          return je.exports.useDebugValue(i4), !t5 && r4 && r4(i4), i4;
        }(a3, r3, f2, true ? e6.warnTooManyClasses : void 0), m3 = n3, v3 = p2.$as || t4.$as || p2.as || t4.as || c3, g3 = oh(v3), y2 = p2 !== t4 ? Bf({}, t4, {}, p2) : t4, b2 = {};
        for (var w2 in y2)
          w2[0] !== "$" && w2 !== "as" && (w2 === "forwardedAs" ? b2.as = y2[w2] : (l3 ? l3(w2, nf, v3) : !g3 || nf(w2)) && (b2[w2] = y2[w2]));
        return t4.style && p2.style !== t4.style && (b2.style = Bf({}, t4.style, {}, p2.style)), b2.className = Array.prototype.concat(s3, u3, h3 !== u3 ? h3 : null, t4.className, p2.className).filter(Boolean).join(" "), b2.ref = m3, je.exports.createElement(v3, b2);
      }(h2, e5, t3, v2);
    };
    return g2.displayName = c2, (h2 = pt.forwardRef(g2)).attrs = f, h2.componentStyle = m2, h2.displayName = c2, h2.shouldForwardProp = p, h2.foldedComponentIds = r2 ? Array.prototype.concat(e4.foldedComponentIds, e4.styledComponentId) : Hf, h2.styledComponentId = d, h2.target = r2 ? e4.target : e4, h2.withComponent = function(e5) {
      var r3 = t2.componentId, o3 = function(e6, t3) {
        if (e6 == null)
          return {};
        var n3, r4, o4 = {}, a4 = Object.keys(e6);
        for (r4 = 0; r4 < a4.length; r4++)
          n3 = a4[r4], t3.indexOf(n3) >= 0 || (o4[n3] = e6[n3]);
        return o4;
      }(t2, ["componentId"]), a3 = r3 && r3 + "-" + (oh(e5) ? e5 : nh(Kf(e5)));
      return fh(e5, Bf({}, o3, { attrs: f, componentId: a3 }), n2);
    }, Object.defineProperty(h2, "defaultProps", { get: function() {
      return this._foldedDefaultProps;
    }, set: function(t3) {
      this._foldedDefaultProps = r2 ? lh({}, e4.defaultProps, t3) : t3;
    } }), Jp(c2, d), h2.warnTooManyClasses = function(e5, t3) {
      var n3 = {}, r3 = false;
      return function(o3) {
        if (!r3 && (n3[o3] = true, Object.keys(n3).length >= 200)) {
          var a3 = t3 ? ' with the id of "' + t3 + '"' : "";
          console.warn("Over 200 classes were generated for component " + e5 + a3 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r3 = true, n3 = {};
        }
      };
    }(c2, d), h2.toString = function() {
      return "." + h2.styledComponentId;
    }, o2 && $f(h2, e4, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), h2;
  }
  var ph = function(e4) {
    return function e5(t2, n2, r2) {
      if (r2 === void 0 && (r2 = Wf), !Rd.exports.isValidElementType(n2))
        return tp(1, String(n2));
      var o2 = function() {
        return t2(n2, r2, Xp.apply(void 0, arguments));
      };
      return o2.withConfig = function(o3) {
        return e5(t2, n2, Bf({}, r2, {}, o3));
      }, o2.attrs = function(o3) {
        return e5(t2, n2, Bf({}, r2, { attrs: Array.prototype.concat(r2.attrs, o3).filter(Boolean) }));
      }, o2;
    }(fh, e4);
  };
  ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e4) {
    ph[e4] = ph(e4);
  });
  var hh = function() {
    function e4(e5, t3) {
      this.rules = e5, this.componentId = t3, this.isStatic = Pp(e5), wp.registerId(this.componentId + 1);
    }
    var t2 = e4.prototype;
    return t2.createStyles = function(e5, t3, n2, r2) {
      var o2 = r2(Kp(this.rules, t3, n2, r2).join(""), ""), a2 = this.componentId + e5;
      n2.insertRules(a2, a2, o2);
    }, t2.removeStyles = function(e5, t3) {
      t3.clearRules(this.componentId + e5);
    }, t2.renderStyles = function(e5, t3, n2, r2) {
      e5 > 2 && wp.registerId(this.componentId + e5), this.removeStyles(e5, n2), this.createStyles(e5, t3, n2, r2);
    }, e4;
  }();
  var mh = function() {
    function e4() {
      var e5 = this;
      this._emitSheetCSS = function() {
        var t3 = e5.instance.toString();
        if (!t3)
          return "";
        var n2 = pp();
        return "<style " + [n2 && 'nonce="' + n2 + '"', Xf + '="true"', 'data-styled-version="5.3.5"'].filter(Boolean).join(" ") + ">" + t3 + "</style>";
      }, this.getStyleTags = function() {
        return e5.sealed ? tp(2) : e5._emitSheetCSS();
      }, this.getStyleElement = function() {
        var t3;
        if (e5.sealed)
          return tp(2);
        var n2 = ((t3 = {})[Xf] = "", t3["data-styled-version"] = "5.3.5", t3.dangerouslySetInnerHTML = { __html: e5.instance.toString() }, t3), r2 = pp();
        return r2 && (n2.nonce = r2), [pt.createElement("style", Bf({}, n2, { key: "sc-0-0" }))];
      }, this.seal = function() {
        e5.sealed = true;
      }, this.instance = new wp({ isServer: true }), this.sealed = false;
    }
    var t2 = e4.prototype;
    return t2.collectStyles = function(e5) {
      return this.sealed ? tp(2) : pt.createElement(Fp, { sheet: this.instance }, e5);
    }, t2.interleaveWithNodeStream = function(e5) {
      return tp(3);
    }, e4;
  }();
  var vh = { StyleSheet: wp, masterSheet: Ap };
  typeof navigator != "undefined" && navigator.product === "ReactNative" && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), typeof window != "undefined" && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, window["__styled-components-init__"] === 1 && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
  var gh = Object.freeze({ __proto__: null, default: ph, ServerStyleSheet: mh, StyleSheetConsumer: Rp, StyleSheetContext: Dp, StyleSheetManager: Fp, ThemeConsumer: ch, ThemeContext: uh, ThemeProvider: function(e4) {
    var t2 = je.exports.useContext(uh), n2 = je.exports.useMemo(function() {
      return function(e5, t3) {
        if (!e5)
          return tp(14);
        if (qf(e5)) {
          var n3 = e5(t3);
          return n3 !== null && !Array.isArray(n3) && typeof n3 == "object" ? n3 : tp(7);
        }
        return Array.isArray(e5) || typeof e5 != "object" ? tp(8) : t3 ? Bf({}, t3, {}, e5) : e5;
      }(e4.theme, t2);
    }, [e4.theme, t2]);
    return e4.children ? pt.createElement(uh.Provider, { value: n2 }, e4.children) : null;
  }, __PRIVATE__: vh, createGlobalStyle: function(e4) {
    for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
      n2[r2 - 1] = arguments[r2];
    var o2 = Xp.apply(void 0, [e4].concat(n2)), a2 = "sc-global-" + rh(JSON.stringify(o2)), i2 = new hh(o2, a2);
    function s2(e5) {
      var t3 = Mp(), n3 = Lp(), r3 = je.exports.useContext(uh), s3 = je.exports.useRef(t3.allocateGSInstance(a2)).current;
      return pt.Children.count(e5.children) && console.warn("The global style component " + a2 + " was given child JSX. createGlobalStyle does not render children."), o2.some(function(e6) {
        return typeof e6 == "string" && e6.indexOf("@import") !== -1;
      }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t3.server && l2(s3, e5, t3, r3, n3), je.exports.useLayoutEffect(function() {
        if (!t3.server)
          return l2(s3, e5, t3, r3, n3), function() {
            return i2.removeStyles(s3, t3);
          };
      }, [s3, e5, t3, r3, n3]), null;
    }
    function l2(e5, t3, n3, r3, o3) {
      if (i2.isStatic)
        i2.renderStyles(e5, Jf, n3, o3);
      else {
        var a3 = Bf({}, t3, { theme: Zp(t3, r3, s2.defaultProps) });
        i2.renderStyles(e5, a3, n3, o3);
      }
    }
    return Jp(a2), pt.memo(s2);
  }, css: Xp, isStyledComponent: Yf, keyframes: function(e4) {
    typeof navigator != "undefined" && navigator.product === "ReactNative" && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
    for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
      n2[r2 - 1] = arguments[r2];
    var o2 = Xp.apply(void 0, [e4].concat(n2)).join(""), a2 = rh(o2);
    return new $p(a2, o2);
  }, useTheme: function() {
    return je.exports.useContext(uh);
  }, version: "5.3.5", withTheme: function(e4) {
    var t2 = pt.forwardRef(function(t3, n2) {
      var r2 = je.exports.useContext(uh), o2 = e4.defaultProps, a2 = Zp(t3, r2, o2);
      return a2 === void 0 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "' + Kf(e4) + '"'), pt.createElement(e4, Bf({}, t3, { theme: a2, ref: n2 }));
    });
    return $f(t2, e4), t2.displayName = "WithTheme(" + Kf(e4) + ")", t2;
  } });
  var yh = m(gh);
  !function(e4, t2) {
    var n2, r2 = Object.create, o2 = Object.defineProperty, a2 = Object.defineProperties, i2 = Object.getOwnPropertyDescriptor, s2 = Object.getOwnPropertyDescriptors, l2 = Object.getOwnPropertyNames, u2 = Object.getOwnPropertySymbols, c2 = Object.getPrototypeOf, d = Object.prototype.hasOwnProperty, f = Object.prototype.propertyIsEnumerable, p = (e5, t3, n3) => t3 in e5 ? o2(e5, t3, { enumerable: true, configurable: true, writable: true, value: n3 }) : e5[t3] = n3, h2 = (e5, t3) => {
      for (var n3 in t3 || (t3 = {}))
        d.call(t3, n3) && p(e5, n3, t3[n3]);
      if (u2)
        for (var n3 of u2(t3))
          f.call(t3, n3) && p(e5, n3, t3[n3]);
      return e5;
    }, m2 = (e5, t3) => a2(e5, s2(t3)), v2 = (e5) => o2(e5, "__esModule", { value: true }), y2 = (e5, t3) => {
      var n3 = {};
      for (var r3 in e5)
        d.call(e5, r3) && t3.indexOf(r3) < 0 && (n3[r3] = e5[r3]);
      if (e5 != null && u2)
        for (var r3 of u2(e5))
          t3.indexOf(r3) < 0 && f.call(e5, r3) && (n3[r3] = e5[r3]);
      return n3;
    }, b2 = (e5, t3) => function() {
      return t3 || (0, e5[Object.keys(e5)[0]])((t3 = { exports: {} }).exports, t3), t3.exports;
    }, w2 = (e5) => ((e6, t3, n3) => {
      if (t3 && typeof t3 == "object" || typeof t3 == "function")
        for (let r3 of l2(t3))
          d.call(e6, r3) || r3 === "default" || o2(e6, r3, { get: () => t3[r3], enumerable: !(n3 = i2(t3, r3)) || n3.enumerable });
      return e6;
    })(v2(o2(e5 != null ? r2(c2(e5)) : {}, "default", e5 && e5.__esModule && "default" in e5 ? { get: () => e5.default, enumerable: true } : { value: e5, enumerable: true })), e5), k2 = (e5, t3, n3) => (p(e5, typeof t3 != "symbol" ? t3 + "" : t3, n3), n3), x2 = b2({ "../node_modules/queue-microtask/index.js"(e5, t3) {
      var n3;
      t3.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(window) : (e6) => (n3 || (n3 = Promise.resolve())).then(e6).catch((e7) => setTimeout(() => {
        throw e7;
      }, 0));
    } }), S2 = b2({ "../node_modules/polished/lib/internalHelpers/_curry.js"(e5, t3) {
      function n3(e6, t4, r3) {
        return function() {
          var o3 = r3.concat(Array.prototype.slice.call(arguments));
          return o3.length >= t4 ? e6.apply(this, o3) : n3(e6, t4, o3);
        };
      }
      e5.__esModule = true, e5.default = function(e6) {
        return n3(e6, e6.length, []);
      }, t3.exports = e5.default;
    } }), _2 = b2({ "../node_modules/polished/lib/internalHelpers/_guard.js"(e5, t3) {
      e5.__esModule = true, e5.default = void 0;
      var n3 = function(e6, t4, n4) {
        return Math.max(e6, Math.min(t4, n4));
      };
      e5.default = n3, t3.exports = e5.default;
    } }), E2 = b2({ "../node_modules/polished/lib/internalHelpers/_hslToRgb.js"(e5, t3) {
      function n3(e6) {
        return Math.round(255 * e6);
      }
      function r3(e6, t4, r4) {
        return n3(e6) + "," + n3(t4) + "," + n3(r4);
      }
      e5.__esModule = true, e5.default = void 0;
      var o3 = function(e6, t4, n4, o4) {
        if (o4 === void 0 && (o4 = r3), t4 === 0)
          return o4(n4, n4, n4);
        var a3 = (e6 % 360 + 360) % 360 / 60, i3 = (1 - Math.abs(2 * n4 - 1)) * t4, s3 = i3 * (1 - Math.abs(a3 % 2 - 1)), l3 = 0, u3 = 0, c3 = 0;
        a3 >= 0 && a3 < 1 ? (l3 = i3, u3 = s3) : a3 >= 1 && a3 < 2 ? (l3 = s3, u3 = i3) : a3 >= 2 && a3 < 3 ? (u3 = i3, c3 = s3) : a3 >= 3 && a3 < 4 ? (u3 = s3, c3 = i3) : a3 >= 4 && a3 < 5 ? (l3 = s3, c3 = i3) : a3 >= 5 && a3 < 6 && (l3 = i3, c3 = s3);
        var d2 = n4 - i3 / 2;
        return o4(l3 + d2, u3 + d2, c3 + d2);
      };
      e5.default = o3, t3.exports = e5.default;
    } }), P2 = b2({ "../node_modules/polished/lib/internalHelpers/_nameToHex.js"(e5, t3) {
      e5.__esModule = true, e5.default = void 0;
      var n3 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "639", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
      var r3 = function(e6) {
        if (typeof e6 != "string")
          return e6;
        var t4 = e6.toLowerCase();
        return n3[t4] ? "#" + n3[t4] : e6;
      };
      e5.default = r3, t3.exports = e5.default;
    } }), C2 = b2({ "../node_modules/polished/lib/internalHelpers/_errors.js"(e5, t3) {
      function n3(e6) {
        if (e6 === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e6;
      }
      function r3(e6) {
        var t4 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
        return r3 = function(e7) {
          if (e7 === null || (n4 = e7, Function.toString.call(n4).indexOf("[native code]") === -1))
            return e7;
          var n4;
          if (typeof e7 != "function")
            throw new TypeError("Super expression must either be null or a function");
          if (t4 !== void 0) {
            if (t4.has(e7))
              return t4.get(e7);
            t4.set(e7, r4);
          }
          function r4() {
            return o3(e7, arguments, s3(this).constructor);
          }
          return r4.prototype = Object.create(e7.prototype, { constructor: { value: r4, enumerable: false, writable: true, configurable: true } }), i3(r4, e7);
        }, r3(e6);
      }
      function o3(e6, t4, n4) {
        return (o3 = a3() ? Reflect.construct : function(e7, t5, n5) {
          var r4 = [null];
          r4.push.apply(r4, t5);
          var o4 = new (Function.bind.apply(e7, r4))();
          return n5 && i3(o4, n5.prototype), o4;
        }).apply(null, arguments);
      }
      function a3() {
        if (typeof Reflect == "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy == "function")
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (e6) {
          return false;
        }
      }
      function i3(e6, t4) {
        return (i3 = Object.setPrototypeOf || function(e7, t5) {
          return e7.__proto__ = t5, e7;
        })(e6, t4);
      }
      function s3(e6) {
        return (s3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e7) {
          return e7.__proto__ || Object.getPrototypeOf(e7);
        })(e6);
      }
      e5.__esModule = true, e5.default = void 0;
      var l3 = { 1: "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n", 2: "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n", 3: "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n", 4: "Couldn't generate valid rgb string from %s, it returned %s.\n\n", 5: "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n", 6: "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n", 7: "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n", 8: "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n", 9: "Please provide a number of steps to the modularScale helper.\n\n", 10: "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n", 11: 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n', 12: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n', 13: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n', 14: 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n', 15: 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n', 16: "You must provide a template to this method.\n\n", 17: "You passed an unsupported selector state to this method.\n\n", 18: "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n", 19: "fromSize and toSize must be provided as stringified numbers with the same units.\n\n", 20: "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n", 21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n", 22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n", 23: "fontFace expects a name of a font-family.\n\n", 24: "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n", 25: "fontFace expects localFonts to be an array.\n\n", 26: "fontFace expects fileFormats to be an array.\n\n", 27: "radialGradient requries at least 2 color-stops to properly render.\n\n", 28: "Please supply a filename to retinaImage() as the first argument.\n\n", 29: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n", 30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n", 31: "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n", 32: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n", 33: "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n", 34: "borderRadius expects a radius value as a string or number as the second argument.\n\n", 35: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n', 36: "Property must be a string value.\n\n", 37: "Syntax Error at %s.\n\n", 38: "Formula contains a function that needs parentheses at %s.\n\n", 39: "Formula is missing closing parenthesis at %s.\n\n", 40: "Formula has too many closing parentheses at %s.\n\n", 41: "All values in a formula must have the same unit or be unitless.\n\n", 42: "Please provide a number of steps to the modularScale helper.\n\n", 43: "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n", 44: "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n", 45: "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n", 46: "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n", 47: "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n", 48: "fromSize and toSize must be provided as stringified numbers with the same units.\n\n", 49: "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n", 50: "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n", 51: "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n", 52: "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n", 53: "fontFace expects localFonts to be an array.\n\n", 54: "fontFace expects fileFormats to be an array.\n\n", 55: "fontFace expects a name of a font-family.\n\n", 56: "linearGradient requries at least 2 color-stops to properly render.\n\n", 57: "radialGradient requries at least 2 color-stops to properly render.\n\n", 58: "Please supply a filename to retinaImage() as the first argument.\n\n", 59: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n", 60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n", 61: "Property must be a string value.\n\n", 62: "borderRadius expects a radius value as a string or number as the second argument.\n\n", 63: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n', 64: "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n", 65: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n", 66: "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n", 67: "You must provide a template to this method.\n\n", 68: "You passed an unsupported selector state to this method.\n\n", 69: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n', 70: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n', 71: 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n', 72: 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n', 73: "Please provide a valid CSS variable.\n\n", 74: "CSS variable not found and no default was provided.\n\n", 75: "important requires a valid style object, got a %s instead.\n\n", 76: "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n", 77: 'remToPx expects a value in "rem" but you provided it in "%s".\n\n', 78: 'base must be set in "px" or "%" but you set it in "%s".\n' };
      function u3() {
        for (var e6 = arguments.length, t4 = new Array(e6), n4 = 0; n4 < e6; n4++)
          t4[n4] = arguments[n4];
        var r4, o4 = t4[0], a4 = [];
        for (r4 = 1; r4 < t4.length; r4 += 1)
          a4.push(t4[r4]);
        return a4.forEach(function(e7) {
          o4 = o4.replace(/%[a-z]/, e7);
        }), o4;
      }
      var c3 = function(e6) {
        var t4, r4;
        function o4(t5) {
          for (var r5 = arguments.length, o5 = new Array(r5 > 1 ? r5 - 1 : 0), a4 = 1; a4 < r5; a4++)
            o5[a4 - 1] = arguments[a4];
          return n3(e6.call(this, u3.apply(void 0, [l3[t5]].concat(o5))) || this);
        }
        return r4 = e6, (t4 = o4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), o4;
      }(r3(Error));
      e5.default = c3, t3.exports = e5.default;
    } }), j2 = b2({ "../node_modules/polished/lib/color/parseToRgb.js"(e5, t3) {
      e5.__esModule = true, e5.default = function(e6) {
        if (typeof e6 != "string")
          throw new o3.default(3);
        var t4 = (0, r3.default)(e6);
        if (t4.match(i3))
          return { red: parseInt("" + t4[1] + t4[2], 16), green: parseInt("" + t4[3] + t4[4], 16), blue: parseInt("" + t4[5] + t4[6], 16) };
        if (t4.match(s3)) {
          var a4 = parseFloat((parseInt("" + t4[7] + t4[8], 16) / 255).toFixed(2));
          return { red: parseInt("" + t4[1] + t4[2], 16), green: parseInt("" + t4[3] + t4[4], 16), blue: parseInt("" + t4[5] + t4[6], 16), alpha: a4 };
        }
        if (t4.match(l3))
          return { red: parseInt("" + t4[1] + t4[1], 16), green: parseInt("" + t4[2] + t4[2], 16), blue: parseInt("" + t4[3] + t4[3], 16) };
        if (t4.match(u3)) {
          var h3 = parseFloat((parseInt("" + t4[4] + t4[4], 16) / 255).toFixed(2));
          return { red: parseInt("" + t4[1] + t4[1], 16), green: parseInt("" + t4[2] + t4[2], 16), blue: parseInt("" + t4[3] + t4[3], 16), alpha: h3 };
        }
        var m3 = c3.exec(t4);
        if (m3)
          return { red: parseInt("" + m3[1], 10), green: parseInt("" + m3[2], 10), blue: parseInt("" + m3[3], 10) };
        var v3 = d2.exec(t4.substring(0, 50));
        if (v3)
          return { red: parseInt("" + v3[1], 10), green: parseInt("" + v3[2], 10), blue: parseInt("" + v3[3], 10), alpha: parseFloat("" + v3[4]) };
        var g2 = f2.exec(t4);
        if (g2) {
          var y3 = parseInt("" + g2[1], 10), b3 = parseInt("" + g2[2], 10) / 100, w3 = parseInt("" + g2[3], 10) / 100, k3 = "rgb(" + (0, n3.default)(y3, b3, w3) + ")", x3 = c3.exec(k3);
          if (!x3)
            throw new o3.default(4, t4, k3);
          return { red: parseInt("" + x3[1], 10), green: parseInt("" + x3[2], 10), blue: parseInt("" + x3[3], 10) };
        }
        var S3 = p2.exec(t4.substring(0, 50));
        if (S3) {
          var _3 = parseInt("" + S3[1], 10), E3 = parseInt("" + S3[2], 10) / 100, P3 = parseInt("" + S3[3], 10) / 100, C3 = "rgb(" + (0, n3.default)(_3, E3, P3) + ")", j3 = c3.exec(C3);
          if (!j3)
            throw new o3.default(4, t4, C3);
          return { red: parseInt("" + j3[1], 10), green: parseInt("" + j3[2], 10), blue: parseInt("" + j3[3], 10), alpha: parseFloat("" + S3[4]) };
        }
        throw new o3.default(5);
      };
      var n3 = a3(E2()), r3 = a3(P2()), o3 = a3(C2());
      function a3(e6) {
        return e6 && e6.__esModule ? e6 : { default: e6 };
      }
      var i3 = /^#[a-fA-F0-9]{6}$/, s3 = /^#[a-fA-F0-9]{8}$/, l3 = /^#[a-fA-F0-9]{3}$/, u3 = /^#[a-fA-F0-9]{4}$/, c3 = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i, d2 = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i, f2 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, p2 = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
      t3.exports = e5.default;
    } }), O2 = b2({ "../node_modules/polished/lib/internalHelpers/_reduceHexValue.js"(e5, t3) {
      e5.__esModule = true, e5.default = void 0;
      var n3 = function(e6) {
        return e6.length === 7 && e6[1] === e6[2] && e6[3] === e6[4] && e6[5] === e6[6] ? "#" + e6[1] + e6[3] + e6[5] : e6;
      };
      e5.default = n3, t3.exports = e5.default;
    } }), T2 = b2({ "../node_modules/polished/lib/internalHelpers/_numberToHex.js"(e5, t3) {
      e5.__esModule = true, e5.default = void 0;
      var n3 = function(e6) {
        var t4 = e6.toString(16);
        return t4.length === 1 ? "0" + t4 : t4;
      };
      e5.default = n3, t3.exports = e5.default;
    } }), I2 = b2({ "../node_modules/polished/lib/color/rgb.js"(e5, t3) {
      e5.__esModule = true, e5.default = function(e6, t4, a4) {
        if (typeof e6 == "number" && typeof t4 == "number" && typeof a4 == "number")
          return (0, n3.default)("#" + (0, r3.default)(e6) + (0, r3.default)(t4) + (0, r3.default)(a4));
        if (typeof e6 == "object" && t4 === void 0 && a4 === void 0)
          return (0, n3.default)("#" + (0, r3.default)(e6.red) + (0, r3.default)(e6.green) + (0, r3.default)(e6.blue));
        throw new o3.default(6);
      };
      var n3 = a3(O2()), r3 = a3(T2()), o3 = a3(C2());
      function a3(e6) {
        return e6 && e6.__esModule ? e6 : { default: e6 };
      }
      t3.exports = e5.default;
    } }), D2 = b2({ "../node_modules/polished/lib/color/rgba.js"(e5, t3) {
      e5.__esModule = true, e5.default = function(e6, t4, a4, i3) {
        if (typeof e6 == "string" && typeof t4 == "number") {
          var s3 = (0, n3.default)(e6);
          return "rgba(" + s3.red + "," + s3.green + "," + s3.blue + "," + t4 + ")";
        }
        if (typeof e6 == "number" && typeof t4 == "number" && typeof a4 == "number" && typeof i3 == "number")
          return i3 >= 1 ? (0, r3.default)(e6, t4, a4) : "rgba(" + e6 + "," + t4 + "," + a4 + "," + i3 + ")";
        if (typeof e6 == "object" && t4 === void 0 && a4 === void 0 && i3 === void 0)
          return e6.alpha >= 1 ? (0, r3.default)(e6.red, e6.green, e6.blue) : "rgba(" + e6.red + "," + e6.green + "," + e6.blue + "," + e6.alpha + ")";
        throw new o3.default(7);
      };
      var n3 = a3(j2()), r3 = a3(I2()), o3 = a3(C2());
      function a3(e6) {
        return e6 && e6.__esModule ? e6 : { default: e6 };
      }
      t3.exports = e5.default;
    } }), R2 = b2({ "../node_modules/polished/lib/color/transparentize.js"(e5, t3) {
      e5.__esModule = true, e5.default = void 0;
      var n3 = i3(S2()), r3 = i3(_2()), o3 = i3(D2()), a3 = i3(j2());
      function i3(e6) {
        return e6 && e6.__esModule ? e6 : { default: e6 };
      }
      function s3() {
        return s3 = Object.assign || function(e6) {
          for (var t4 = 1; t4 < arguments.length; t4++) {
            var n4 = arguments[t4];
            for (var r4 in n4)
              Object.prototype.hasOwnProperty.call(n4, r4) && (e6[r4] = n4[r4]);
          }
          return e6;
        }, s3.apply(this, arguments);
      }
      function l3(e6, t4) {
        if (t4 === "transparent")
          return t4;
        var n4 = (0, a3.default)(t4), i4 = typeof n4.alpha == "number" ? n4.alpha : 1, l4 = s3({}, n4, { alpha: (0, r3.default)(0, 1, +(100 * i4 - 100 * parseFloat(e6)).toFixed(2) / 100) });
        return (0, o3.default)(l4);
      }
      var u3 = (0, n3.default)(l3);
      e5.default = u3, t3.exports = e5.default;
    } }), N2 = b2({ "../node_modules/react-error-boundary/dist/react-error-boundary.umd.js"(e5, t3) {
      var n3, r3;
      n3 = e5, r3 = function(e6, t4) {
        function n4(e7) {
          if (e7 && e7.__esModule)
            return e7;
          var t5 = /* @__PURE__ */ Object.create(null);
          return e7 && Object.keys(e7).forEach(function(n5) {
            if (n5 !== "default") {
              var r5 = Object.getOwnPropertyDescriptor(e7, n5);
              Object.defineProperty(t5, n5, r5.get ? r5 : { enumerable: true, get: function() {
                return e7[n5];
              } });
            }
          }), t5.default = e7, Object.freeze(t5);
        }
        var r4 = n4(t4);
        function o3(e7, t5) {
          return (o3 = Object.setPrototypeOf || function(e8, t6) {
            return e8.__proto__ = t6, e8;
          })(e7, t5);
        }
        var a3 = { error: null }, i3 = function(e7) {
          var t5, n5;
          function i4() {
            for (var t6, n6 = arguments.length, r5 = new Array(n6), o4 = 0; o4 < n6; o4++)
              r5[o4] = arguments[o4];
            return (t6 = e7.call.apply(e7, [this].concat(r5)) || this).state = a3, t6.updatedWithError = false, t6.resetErrorBoundary = function() {
              for (var e8, n7 = arguments.length, r6 = new Array(n7), o5 = 0; o5 < n7; o5++)
                r6[o5] = arguments[o5];
              t6.props.onReset == null || (e8 = t6.props).onReset.apply(e8, r6), t6.reset();
            }, t6;
          }
          n5 = e7, (t5 = i4).prototype = Object.create(n5.prototype), t5.prototype.constructor = t5, o3(t5, n5), i4.getDerivedStateFromError = function(e8) {
            return { error: e8 };
          };
          var s3 = i4.prototype;
          return s3.reset = function() {
            this.updatedWithError = false, this.setState(a3);
          }, s3.componentDidCatch = function(e8, t6) {
            var n6, r5;
            (n6 = (r5 = this.props).onError) == null || n6.call(r5, e8, t6);
          }, s3.componentDidMount = function() {
            this.state.error !== null && (this.updatedWithError = true);
          }, s3.componentDidUpdate = function(e8) {
            var t6, n6, r5, o4, a4 = this.state.error, i5 = this.props.resetKeys;
            a4 === null || this.updatedWithError ? a4 !== null && ((r5 = e8.resetKeys) === void 0 && (r5 = []), (o4 = i5) === void 0 && (o4 = []), r5.length !== o4.length || r5.some(function(e9, t7) {
              return !Object.is(e9, o4[t7]);
            })) && ((t6 = (n6 = this.props).onResetKeysChange) == null || t6.call(n6, e8.resetKeys, i5), this.reset()) : this.updatedWithError = true;
          }, s3.render = function() {
            var e8 = this.state.error, t6 = this.props, n6 = t6.fallbackRender, o4 = t6.FallbackComponent, a4 = t6.fallback;
            if (e8 !== null) {
              var i5 = { error: e8, resetErrorBoundary: this.resetErrorBoundary };
              if (r4.isValidElement(a4))
                return a4;
              if (typeof n6 == "function")
                return n6(i5);
              if (o4)
                return r4.createElement(o4, i5);
              throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
            }
            return this.props.children;
          }, i4;
        }(r4.Component);
        e6.ErrorBoundary = i3, e6.useErrorHandler = function(e7) {
          var t5 = r4.useState(null), n5 = t5[0], o4 = t5[1];
          if (e7 != null)
            throw e7;
          if (n5 != null)
            throw n5;
          return o4;
        }, e6.withErrorBoundary = function(e7, t5) {
          var n5 = function(n6) {
            return r4.createElement(i3, t5, r4.createElement(e7, n6));
          }, o4 = e7.displayName || e7.name || "Unknown";
          return n5.displayName = "withErrorBoundary(" + o4 + ")", n5;
        }, Object.defineProperty(e6, "__esModule", { value: true });
      }, typeof e5 == "object" && t3 !== void 0 ? r3(e5, je.exports) : r3((n3 = typeof globalThis != "undefined" ? globalThis : n3 || self).ReactErrorBoundary = {}, n3.React);
    } }), A2 = b2({ "../node_modules/jiff/lib/lcs.js"(e5) {
      function t3(e6, t4, n3, r3, o3, a3) {
        return t4[o3 + r3] === n3[a3 + r3] ? { value: e6[a3 + 1][o3 + 1].value, type: 0 } : e6[a3][o3 + 1].value < e6[a3 + 1][o3].value ? { value: e6[a3][o3 + 1].value + 1, type: -1 } : { value: e6[a3 + 1][o3].value + 1, type: 1 };
      }
      e5.compare = function(e6, n3) {
        for (var r3 = e6.length, o3 = n3.length, a3 = function(e7, t4) {
          var n4 = 0, r4 = Math.min(e7.length, t4.length);
          for (; n4 < r4 && e7[n4] === t4[n4]; )
            ++n4;
          return n4;
        }(e6, n3), i3 = a3 < r3 && a3 < o3 ? function(e7, t4) {
          var n4 = e7.length - 1, r4 = t4.length - 1, o4 = Math.min(n4, r4), a4 = 0;
          for (; a4 < o4 && e7[n4 - a4] === t4[r4 - a4]; )
            ++a4;
          return a4;
        }(e6, n3) : 0, s3 = i3 + a3 - 1, l3 = function(e7, t4) {
          var n4, r4, o4, a4 = [];
          for (o4 = a4[t4] = [], r4 = 0; r4 < e7; ++r4)
            o4[r4] = { value: e7 - r4, type: -1 };
          for (n4 = 0; n4 < t4; ++n4)
            a4[n4] = [], a4[n4][e7] = { value: t4 - n4, type: 1 };
          return a4[t4][e7] = { value: 0, type: 0 }, a4;
        }(r3 -= s3, o3 -= s3), u3 = r3 - 1; u3 >= 0; --u3)
          for (var c3 = o3 - 1; c3 >= 0; --c3)
            l3[c3][u3] = t3(l3, e6, n3, a3, u3, c3);
        return { prefix: a3, matrix: l3, suffix: i3 };
      }, e5.reduce = function(e6, t4, n3) {
        var r3, o3, a3, i3, s3 = n3.matrix, l3 = n3.prefix;
        for (r3 = 0; r3 < l3; ++r3)
          t4 = e6(t4, 0, r3, r3);
        a3 = r3, l3 = s3.length, r3 = 0, o3 = 0;
        for (; r3 < l3; )
          switch (i3 = s3[r3][o3].type, t4 = e6(t4, i3, r3 + a3, o3 + a3), i3) {
            case 0:
              ++r3, ++o3;
              break;
            case -1:
              ++o3;
              break;
            case 1:
              ++r3;
          }
        for (r3 += a3, o3 += a3, l3 = n3.suffix, a3 = 0; a3 < l3; ++a3)
          t4 = e6(t4, 0, r3 + a3, o3 + a3);
        return t4;
      }, e5.REMOVE = -1, e5.ADD = 1, e5.EQUAL = 0;
    } }), z2 = b2({ "../node_modules/jiff/lib/array.js"(e5) {
      e5.cons = function(e6, t3) {
        var n3 = t3.length, r3 = new Array(n3 + 1);
        r3[0] = e6;
        for (var o3 = 0; o3 < n3; ++o3)
          r3[o3 + 1] = t3[o3];
        return r3;
      }, e5.tail = function(e6) {
        for (var t3 = e6.length - 1, n3 = new Array(t3), r3 = 0; r3 < t3; ++r3)
          n3[r3] = e6[r3 + 1];
        return n3;
      }, e5.map = function(e6, t3) {
        for (var n3 = new Array(t3.length), r3 = 0; r3 < t3.length; ++r3)
          n3[r3] = e6(t3[r3]);
        return n3;
      };
    } }), M2 = b2({ "../node_modules/jiff/lib/jsonPointerParse.js"(e5, t3) {
      t3.exports = function(e6, t4) {
        var r3, o3, a3, i3;
        r3 = e6.charAt(0) === "/" ? 1 : 0, o3 = "", n3.lastIndex = r3;
        for (; a3 = n3.exec(e6); )
          if (i3 = a3[0], o3 += e6.slice(r3, n3.lastIndex - i3.length), r3 = n3.lastIndex, i3 === "/") {
            if (t4(o3) === false)
              return e6;
            o3 = "";
          } else
            o3 += i3 === "~1" ? "/" : "~";
        return o3 += e6.slice(r3), t4(o3), e6;
      };
      var n3 = /\/|~1|~0/g;
    } }), L2 = b2({ "../node_modules/jiff/lib/jsonPointer.js"(e5) {
      var t3 = M2();
      e5.find = function(e6, r4, o4, a4) {
        if (typeof r4 != "string")
          return;
        if (r4 === "")
          return { target: e6, key: void 0 };
        if (r4 === n3)
          return { target: e6, key: "" };
        var i4, s4 = e6, l4 = a4 !== void 0;
        return t3(r4, function(t4) {
          if (e6 == null)
            return s4 = null, false;
          i4 = Array.isArray(e6) ? l4 ? function(e7, t5, n4, r5) {
            var o5 = t5;
            if (o5 < 0)
              throw new Error("array index out of bounds " + o5);
            if (r5 !== void 0 && typeof e7 == "function" && (o5 = e7(t5, n4, r5)) < 0)
              throw new Error("could not find patch context " + r5);
            return o5;
          }(o4, u3(t4), e6, a4) : t4 === "-" ? t4 : u3(t4) : t4, s4 = e6, e6 = e6[i4];
        }), s4 === null ? void 0 : { target: s4, key: i4 };
      }, e5.join = function(e6) {
        return e6.join(n3);
      }, e5.absolute = function(e6) {
        return e6[0] === n3 ? e6 : n3 + e6;
      }, e5.parse = function(e6) {
        var n4 = [];
        return t3(e6, n4.push.bind(n4)), n4;
      }, e5.contains = function(e6, t4) {
        return t4.indexOf(e6) === 0 && t4[e6.length] === n3;
      }, e5.encodeSegment = function(e6) {
        return e6.replace(a3, "~0").replace(r3, "~1");
      }, e5.decodeSegment = function(e6) {
        return e6.replace(o3, n3).replace(i3, "~");
      }, e5.parseArrayIndex = u3, e5.isValidArrayIndex = l3;
      var n3 = "/", r3 = /\//g, o3 = /~1/g, a3 = /~/g, i3 = /~0/g;
      var s3 = /^(0|[1-9]\d*)$/;
      function l3(e6) {
        return s3.test(e6);
      }
      function u3(e6) {
        if (l3(e6))
          return +e6;
        throw new SyntaxError("invalid array index " + e6);
      }
    } }), F2 = b2({ "../node_modules/jiff/lib/clone.js"(e5, t3) {
      function n3(e6) {
        return e6 == null || typeof e6 != "object" ? e6 : Array.isArray(e6) ? function(e7) {
          for (var t4 = e7.length, r3 = new Array(t4), o3 = 0; o3 < t4; ++o3)
            r3[o3] = n3(e7[o3]);
          return r3;
        }(e6) : function(e7) {
          for (var t4, r3 = Object.keys(e7), o3 = {}, a3 = 0, i3 = r3.length; a3 < i3; ++a3)
            o3[t4 = r3[a3]] = n3(e7[t4]);
          return o3;
        }(e6);
      }
      t3.exports = n3;
    } }), $2 = b2({ "../node_modules/jiff/lib/deepEquals.js"(e5, t3) {
      function n3(e6, t4) {
        return e6 === t4 || (Array.isArray(e6) && Array.isArray(t4) ? function(e7, t5) {
          if (e7.length !== t5.length)
            return false;
          for (var r3 = 0; r3 < e7.length; ++r3)
            if (!n3(e7[r3], t5[r3]))
              return false;
          return true;
        }(e6, t4) : typeof e6 == "object" && typeof t4 == "object" && function(e7, t5) {
          if (e7 === null && t5 !== null || e7 !== null && t5 === null)
            return false;
          var r3 = Object.keys(e7), o3 = Object.keys(t5);
          if (r3.length !== o3.length)
            return false;
          for (var a3, i3 = 0; i3 < r3.length; ++i3)
            if (!((a3 = r3[i3]) in t5) || !n3(e7[a3], t5[a3]))
              return false;
          return true;
        }(e6, t4));
      }
      t3.exports = n3;
    } }), B2 = b2({ "../node_modules/jiff/lib/commutePaths.js"(e5, t3) {
      var n3 = L2();
      function r3(e6, t4, n4, r4, o4) {
        var a3 = t4.length - 1, i3 = +t4[a3], s3 = +r4[a3], l3 = r4.slice();
        return i3 > s3 || (e6.op === "add" || e6.op === "copy" ? l3[a3] = Math.max(0, s3 - o4) : e6.op === "remove" && (l3[a3] = Math.max(0, s3 + o4))), l3;
      }
      function o3(e6) {
        return e6.op === "remove" ? { op: e6.op, path: e6.path } : e6.op === "copy" || e6.op === "move" ? { op: e6.op, path: e6.path, from: e6.from } : { op: e6.op, path: e6.path, value: e6.value };
      }
      t3.exports = function(e6, t4) {
        var a3 = n3.parse(e6.path), i3 = n3.parse(t4.path), s3 = function(e7, t5) {
          var n4 = e7.length, r4 = t5.length;
          if (n4 === 0 || r4 === 0 || n4 < 2 && r4 < 2)
            return [];
          var o4 = n4 === r4 ? n4 - 1 : Math.min(n4, r4), a4 = 0;
          for (; a4 < o4 && e7[a4] === t5[a4]; )
            ++a4;
          return e7.slice(0, a4);
        }(a3, i3), l3 = function(e7, t5, r4) {
          return n3.isValidArrayIndex(e7[r4]) && n3.isValidArrayIndex(t5[r4]);
        }(a3, i3, s3.length), u3 = o3(e6), c3 = o3(t4);
        return s3.length !== 0 || l3 ? l3 ? function(e7, t5, o4, a4) {
          if (t5.length === a4.length)
            return function(e8, t6, r4, o5) {
              var a5, i4 = t6.length - 1, s4 = +t6[i4], l4 = +o5[i4];
              s4 < l4 ? e8.op === "add" || e8.op === "copy" ? ((a5 = o5.slice())[i4] = Math.max(0, l4 - 1), r4.path = n3.absolute(n3.join(a5))) : e8.op === "remove" && ((a5 = o5.slice())[i4] = l4 + 1, r4.path = n3.absolute(n3.join(a5))) : r4.op === "add" || r4.op === "copy" ? ((a5 = t6.slice())[i4] = s4 + 1, e8.path = n3.absolute(n3.join(a5))) : s4 > l4 && r4.op === "remove" && ((a5 = t6.slice())[i4] = Math.max(0, s4 - 1), e8.path = n3.absolute(n3.join(a5)));
              return [r4, e8];
            }(e7, t5, o4, a4);
          t5.length > a4.length ? (t5 = r3(o4, a4, e7, t5, -1), e7.path = n3.absolute(n3.join(t5))) : (a4 = r3(e7, t5, o4, a4, 1), o4.path = n3.absolute(n3.join(a4)));
          return [o4, e7];
        }(u3, a3, c3, i3) : function(e7, t5, n4, r4) {
          if (e7.path === n4.path)
            throw new TypeError("cannot commute " + e7.op + "," + n4.op + " with identical object paths");
          return [n4, e7];
        }(u3, 0, c3) : [c3, u3];
      };
    } }), V2 = b2({ "../node_modules/jiff/lib/TestFailedError.js"(e5, t3) {
      function n3(e6) {
        Error.call(this), this.name = this.constructor.name, this.message = e6, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
      }
      t3.exports = n3, n3.prototype = Object.create(Error.prototype), n3.prototype.constructor = n3;
    } }), U2 = b2({ "../node_modules/jiff/lib/InvalidPatchOperationError.js"(e5, t3) {
      function n3(e6) {
        Error.call(this), this.name = this.constructor.name, this.message = e6, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
      }
      t3.exports = n3, n3.prototype = Object.create(Error.prototype), n3.prototype.constructor = n3;
    } }), H2 = b2({ "../node_modules/jiff/lib/PatchNotInvertibleError.js"(e5, t3) {
      function n3(e6) {
        Error.call(this), this.name = this.constructor.name, this.message = e6, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
      }
      t3.exports = n3, n3.prototype = Object.create(Error.prototype), n3.prototype.constructor = n3;
    } }), W2 = b2({ "../node_modules/jiff/lib/patches.js"(e5) {
      var t3 = L2(), n3 = F2(), r3 = $2(), o3 = B2(), a3 = z2(), i3 = V2(), s3 = U2(), l3 = H2(), u3 = t3.find, c3 = t3.parseArrayIndex;
      function d2(e6, t4) {
        var n4 = e6.target;
        if (Array.isArray(n4))
          if (e6.key === "-")
            n4.push(t4);
          else {
            if (e6.key > n4.length)
              throw new s3("target of add outside of array bounds");
            n4.splice(e6.key, 0, t4);
          }
        else {
          if (!v3(n4))
            throw new s3("target of add must be an object or array " + e6.key);
          n4[e6.key] = t4;
        }
      }
      function f2(e6, t4) {
        if (e6.path === t4.path && t4.op === "remove")
          throw new TypeError("Can't commute add,remove -> remove,add for same path");
        return o3(e6, t4);
      }
      function p2(e6) {
        var t4, n4 = e6.target;
        if (Array.isArray(n4))
          return (t4 = n4.splice(c3(e6.key), 1))[0];
        if (v3(n4))
          return t4 = n4[e6.key], delete n4[e6.key], t4;
        throw new s3("target of remove must be an object or array");
      }
      function h3(e6) {
        return e6 === void 0 || e6.target == null && e6.key !== void 0;
      }
      function m3(e6) {
        return e6.key !== void 0 && e6.target[e6.key] === void 0;
      }
      function v3(e6) {
        return e6 !== null && typeof e6 == "object";
      }
      e5.test = { apply: function(e6, t4, n4) {
        var o4, a4, s4 = u3(e6, t4.path, n4.findContext, t4.context), l4 = s4.target;
        Array.isArray(l4) ? (o4 = c3(s4.key), a4 = l4[o4]) : a4 = s4.key === void 0 ? s4.target : s4.target[s4.key];
        if (!r3(a4, t4.value))
          throw new i3("test failed " + JSON.stringify(t4));
        return e6;
      }, inverse: function(e6, t4) {
        return e6.push(t4), 1;
      }, commute: function(e6, t4) {
        if (e6.path === t4.path && t4.op === "remove")
          throw new TypeError("Can't commute test,remove -> remove,test for same path");
        if (t4.op === "test" || t4.op === "replace")
          return [t4, e6];
        return o3(e6, t4);
      } }, e5.add = { apply: function(e6, t4, r4) {
        var o4 = u3(e6, t4.path, r4.findContext, t4.context);
        if (h3(o4))
          throw new s3("path does not exist " + t4.path);
        if (t4.value === void 0)
          throw new s3("missing value");
        var a4 = n3(t4.value);
        if (o4.key === void 0)
          return a4;
        return d2(o4, a4), e6;
      }, inverse: function(e6, t4) {
        var n4 = t4.context;
        n4 !== void 0 && (n4 = { before: n4.before, after: a3.cons(t4.value, n4.after) });
        return e6.push({ op: "test", path: t4.path, value: t4.value, context: n4 }), e6.push({ op: "remove", path: t4.path, context: n4 }), 1;
      }, commute: f2 }, e5.remove = { apply: function(e6, t4, n4) {
        var r4 = u3(e6, t4.path, n4.findContext, t4.context);
        if (h3(r4) || r4.target[r4.key] === void 0)
          throw new s3("path does not exist " + t4.path);
        return p2(r4), e6;
      }, inverse: function(e6, t4, n4, r4) {
        var o4 = r4[n4 - 1];
        if (o4 === void 0 || o4.op !== "test" || o4.path !== t4.path)
          throw new l3("cannot invert remove w/o test");
        var i4 = o4.context;
        i4 !== void 0 && (i4 = { before: i4.before, after: a3.tail(i4.after) });
        return e6.push({ op: "add", path: o4.path, value: o4.value, context: i4 }), 2;
      }, commute: function(e6, t4) {
        if (e6.path === t4.path && t4.op === "remove")
          return [t4, e6];
        return o3(e6, t4);
      } }, e5.replace = { apply: function(e6, t4, r4) {
        var o4 = u3(e6, t4.path, r4.findContext, t4.context);
        if (h3(o4) || m3(o4))
          throw new s3("path does not exist " + t4.path);
        if (t4.value === void 0)
          throw new s3("missing value");
        var a4 = n3(t4.value);
        if (o4.key === void 0)
          return a4;
        var i4 = o4.target;
        Array.isArray(i4) ? i4[c3(o4.key)] = a4 : i4[o4.key] = a4;
        return e6;
      }, inverse: function(e6, t4, n4, r4) {
        var o4 = r4[n4 - 1];
        if (o4 === void 0 || o4.op !== "test" || o4.path !== t4.path)
          throw new l3("cannot invert replace w/o test");
        var i4 = o4.context;
        i4 !== void 0 && (i4 = { before: i4.before, after: a3.cons(o4.value, a3.tail(i4.after)) });
        return e6.push({ op: "test", path: o4.path, value: t4.value }), e6.push({ op: "replace", path: o4.path, value: o4.value }), 2;
      }, commute: function(e6, t4) {
        if (e6.path === t4.path && t4.op === "remove")
          throw new TypeError("Can't commute replace,remove -> remove,replace for same path");
        if (t4.op === "test" || t4.op === "replace")
          return [t4, e6];
        return o3(e6, t4);
      } }, e5.move = { apply: function(e6, n4, r4) {
        if (t3.contains(n4.path, n4.from))
          throw new s3("move.from cannot be ancestor of move.path");
        var o4 = u3(e6, n4.path, r4.findContext, n4.context), a4 = u3(e6, n4.from, r4.findContext, n4.fromContext);
        return d2(o4, p2(a4)), e6;
      }, inverse: function(e6, t4) {
        return e6.push({ op: "move", path: t4.from, context: t4.fromContext, from: t4.path, fromContext: t4.context }), 1;
      }, commute: function(e6, t4) {
        if (e6.path === t4.path && t4.op === "remove")
          throw new TypeError("Can't commute move,remove -> move,replace for same path");
        return o3(e6, t4);
      } }, e5.copy = { apply: function(e6, t4, r4) {
        var o4 = u3(e6, t4.path, r4.findContext, t4.context), a4 = u3(e6, t4.from, r4.findContext, t4.fromContext);
        if (h3(a4) || m3(a4))
          throw new s3("copy.from must exist");
        var i4, l4 = a4.target;
        i4 = Array.isArray(l4) ? l4[c3(a4.key)] : l4[a4.key];
        return d2(o4, n3(i4)), e6;
      }, inverse: function(e6, t4) {
        throw new l3("cannot invert " + t4.op);
      }, commute: f2 };
    } }), q2 = b2({ "../node_modules/jiff/lib/jsonPatch.js"(e5) {
      var t3 = W2(), n3 = F2(), r3 = U2();
      e5.apply = function(e6, t4, r4) {
        return a3(e6, n3(t4), r4);
      }, e5.applyInPlace = a3, e5.clone = n3, e5.isValidObject = i3, e5.defaultHash = function(e6) {
        return i3(e6) || function(e7) {
          return Object.prototype.toString.call(e7) === "[object Array]";
        }(e6) ? JSON.stringify(e6) : e6;
      };
      var o3 = {};
      function a3(e6, n4, a4) {
        if (a4 || (a4 = o3), !Array.isArray(e6))
          return n4;
        for (var i4, s3, l3 = 0; l3 < e6.length; ++l3) {
          if (s3 = e6[l3], (i4 = t3[s3.op]) === void 0)
            throw new r3("invalid op " + JSON.stringify(s3));
          n4 = i4.apply(n4, s3, a4);
        }
        return n4;
      }
      function i3(e6) {
        return e6 !== null && Object.prototype.toString.call(e6) === "[object Object]";
      }
    } }), K2 = b2({ "../node_modules/jiff/lib/inverse.js"(e5, t3) {
      var n3 = W2();
      function r3(e6, t4, r4, o3) {
        var a3 = n3[t4.op];
        return a3 !== void 0 && typeof a3.inverse == "function" ? a3.inverse(e6, t4, r4, o3) : 1;
      }
      t3.exports = function(e6) {
        var t4, n4, o3 = [];
        for (t4 = e6.length - 1; t4 >= 0; t4 -= n4)
          n4 = r3(o3, e6[t4], t4, e6);
        return o3;
      };
    } }), Y2 = b2({ "../node_modules/jiff/jiff.js"(e5) {
      var t3 = A2(), n3 = z2(), r3 = q2(), o3 = K2(), a3 = L2().encodeSegment;
      e5.diff = function(e6, t4, n4) {
        return l3(e6, t4, "", function(e7, t5) {
          return typeof e7 == "object" ? { patch: t5, hash: u3(d2, e7.hash, s3), makeContext: u3(d2, e7.makeContext, c3), invertible: !(e7.invertible === false) } : { patch: t5, hash: u3(d2, e7, s3), makeContext: c3, invertible: true };
        }(n4, [])).patch;
      }, e5.patch = r3.apply, e5.patchInPlace = r3.applyInPlace, e5.inverse = o3, e5.clone = r3.clone, e5.InvalidPatchOperationError = U2(), e5.TestFailedError = V2(), e5.PatchNotInvertibleError = H2();
      var i3 = r3.isValidObject, s3 = r3.defaultHash;
      function l3(e6, r4, o4, s4) {
        return Array.isArray(e6) && Array.isArray(r4) ? function(e7, r5, o5, a4) {
          var i4 = n3.map(a4.hash, e7), s5 = n3.map(a4.hash, r5), u4 = t3.compare(i4, s5);
          return function(e8, n4, r6, o6, a5) {
            var i5 = 0;
            return t3.reduce(function(o7, a6, s6, u5) {
              var c4, d3, f2 = o7.patch, p2 = r6 + "/" + (u5 + i5);
              return a6 === t3.REMOVE ? (c4 = f2[f2.length - 1], d3 = o7.makeContext(u5, e8), o7.invertible && f2.push({ op: "test", path: p2, value: e8[u5], context: d3 }), c4 !== void 0 && c4.op === "add" && c4.path === p2 ? (c4.op = "replace", c4.context = d3) : f2.push({ op: "remove", path: p2, context: d3 }), i5 -= 1) : a6 === t3.ADD ? (f2.push({ op: "add", path: p2, value: n4[s6], context: o7.makeContext(u5, e8) }), i5 += 1) : l3(e8[u5], n4[s6], p2, o7), o7;
            }, o6, a5);
          }(e7, r5, o5, a4, u4);
        }(e6, r4, o4, s4) : i3(e6) && i3(r4) ? function(e7, t4, n4, r5) {
          var o5, i4, s5 = Object.keys(t4), u4 = r5.patch;
          for (o5 = s5.length - 1; o5 >= 0; --o5) {
            i4 = s5[o5];
            var c4 = n4 + "/" + a3(i4);
            e7[i4] !== void 0 ? l3(e7[i4], t4[i4], c4, r5) : u4.push({ op: "add", path: c4, value: t4[i4] });
          }
          for (s5 = Object.keys(e7), o5 = s5.length - 1; o5 >= 0; --o5)
            if (t4[i4 = s5[o5]] === void 0) {
              var d3 = n4 + "/" + a3(i4);
              r5.invertible && u4.push({ op: "test", path: d3, value: e7[i4] }), u4.push({ op: "remove", path: d3 });
            }
          return r5;
        }(e6, r4, o4, s4) : function(e7, t4, n4, r5) {
          e7 !== t4 && (r5.invertible && r5.patch.push({ op: "test", path: n4, value: e7 }), r5.patch.push({ op: "replace", path: n4, value: t4 }));
          return r5;
        }(e6, r4, o4, s4);
      }
      function u3(e6, t4, n4) {
        return e6(t4) ? t4 : n4;
      }
      function c3() {
      }
      function d2(e6) {
        return typeof e6 == "function";
      }
    } }), X2 = b2({ "../node_modules/json-touch-patch/lib/utils/pluck.js"(e5, t3) {
      t3.exports = function(e6, t4) {
        for (var n3 = 0, r3 = t4.length - 1; n3 < r3; n3++) {
          if (!e6[t4[n3]])
            return null;
          e6 = e6[t4[n3]];
        }
        return e6;
      };
    } }), G2 = b2({ "../node_modules/json-touch-patch/lib/utils/toKeys.js"(e5, t3) {
      function n3(e6) {
        return e6 === "~0" ? "~" : "/";
      }
      t3.exports = function(e6) {
        var t4 = e6.split("/");
        if (e6.indexOf("~") === -1)
          return t4;
        for (var r3 = 0, o3 = t4.length; r3 < o3; r3++)
          t4[r3].indexOf("~") !== -1 && (t4[r3] = t4[r3].replace(/~[01]/g, n3));
        return t4;
      };
    } }), Q2 = b2({ "../node_modules/json-touch-patch/lib/get.js"(e5, t3) {
      var n3 = X2(), r3 = G2();
      t3.exports = function(e6, t4) {
        var o3 = r3(t4), a3 = o3[o3.length - 1], i3 = n3(e6, o3);
        return i3 ? i3[a3] : void 0;
      };
    } }), J2 = b2({ "../node_modules/json-touch-patch/lib/utils/deepEqual.js"(e5, t3) {
      t3.exports = function e6(t4, n3) {
        if (t4 === n3)
          return true;
        if (!t4 || !n3 || typeof t4 != "object" || typeof n3 != "object")
          return false;
        if (t4.length !== n3.length)
          return false;
        if (Array.isArray(t4)) {
          if (!Array.isArray(n3))
            return false;
          for (var r3 = 0, o3 = t4.length; r3 < o3; r3++)
            if (!e6(t4[r3], n3[r3]))
              return false;
          return true;
        }
        var a3 = Object.keys(t4);
        if (a3.length !== Object.keys(n3).length)
          return false;
        for (var i3 = 0, s3 = a3.length; i3 < s3; i3++) {
          var l3 = a3[i3];
          if (!e6(t4[l3], n3[l3]))
            return false;
        }
        return true;
      };
    } }), Z2 = b2({ "../node_modules/json-touch-patch/lib/utils/toArrayIndex.js"(e5, t3) {
      t3.exports = function(e6, t4) {
        if (t4 === "-")
          return e6.length;
        for (var n3 = 0, r3 = t4.length; n3 < r3; n3++) {
          var o3 = t4.charCodeAt(n3);
          if (57 < o3 || o3 < 48)
            return 1 / 0;
        }
        return +t4;
      };
    } }), ee2 = b2({ "../node_modules/json-touch-patch/lib/add.js"(e5, t3) {
      var n3 = J2(), r3 = X2(), o3 = Z2(), a3 = G2();
      t3.exports = function(e6, t4, i3, s3) {
        if (i3 === void 0)
          return "[op:add] require value, but got undefined";
        var l3 = a3(t4), u3 = l3[l3.length - 1], c3 = r3(e6, l3);
        if (c3 === null)
          return "[op:add] path not found: " + t4;
        if (Array.isArray(c3)) {
          var d2 = o3(c3, u3);
          if (c3.length < d2)
            return "[op:add] invalid array index: " + t4;
          s3(e6, l3).splice(d2, 0, i3);
        } else
          n3(c3[u3], i3) || (s3(e6, l3)[u3] = i3);
      };
    } }), te2 = b2({ "../node_modules/json-touch-patch/lib/remove.js"(e5, t3) {
      var n3 = X2(), r3 = Z2(), o3 = G2();
      t3.exports = function(e6, t4, a3) {
        var i3 = o3(t4), s3 = i3[i3.length - 1], l3 = n3(e6, i3);
        if (l3 === null)
          return "[op:remove] path not found: " + t4;
        if (Array.isArray(l3)) {
          var u3 = r3(l3, s3);
          if (l3.length <= u3)
            return "[op:remove] invalid array index: " + t4;
          a3(e6, i3).splice(u3, 1);
        } else
          delete a3(e6, i3)[s3];
      };
    } }), ne2 = b2({ "../node_modules/json-touch-patch/lib/replace.js"(e5, t3) {
      var n3 = J2(), r3 = X2(), o3 = Z2(), a3 = G2();
      t3.exports = function(e6, t4, i3, s3) {
        if (i3 === void 0)
          return "[op:replace] require value, but got undefined";
        var l3 = a3(t4), u3 = l3[l3.length - 1], c3 = r3(e6, l3);
        if (c3 === null)
          return "[op:replace] path not found: " + t4;
        if (Array.isArray(c3)) {
          var d2 = o3(c3, u3);
          if (c3.length <= d2)
            return "[op:replace] invalid array index: " + t4;
          n3(c3[d2], i3) || s3(e6, l3).splice(d2, 1, i3);
        } else
          n3(c3[u3], i3) || (s3(e6, l3)[u3] = i3);
      };
    } }), re2 = b2({ "../node_modules/json-touch-patch/lib/move.js"(e5, t3) {
      var n3 = ee2(), r3 = X2(), o3 = Z2(), a3 = G2();
      t3.exports = function(e6, t4, i3, s3) {
        if (i3 !== t4) {
          var l3 = a3(t4), u3 = l3[l3.length - 1], c3 = r3(e6, l3);
          if (c3 === null)
            return "[op:move] path not found: " + t4;
          var d2 = void 0;
          if (Array.isArray(c3)) {
            var f2 = o3(c3, u3);
            if (c3.length <= f2)
              return "[op:move] invalid array index: " + i3;
            d2 = c3[f2], s3(e6, l3).splice(f2, 1);
          } else
            d2 = c3[u3], delete s3(e6, l3)[u3];
          return n3(e6, i3, d2, s3);
        }
      };
    } }), oe2 = b2({ "../node_modules/json-touch-patch/lib/copy.js"(e5, t3) {
      var n3 = X2(), r3 = G2(), o3 = ee2();
      t3.exports = function(e6, t4, a3, i3) {
        var s3 = r3(t4), l3 = s3[s3.length - 1], u3 = n3(e6, s3);
        return u3 === null ? "[op:copy] path not found: " + t4 : o3(e6, a3, u3[l3], i3);
      };
    } }), ae2 = b2({ "../node_modules/json-touch-patch/lib/test.js"(e5, t3) {
      var n3 = J2(), r3 = X2(), o3 = G2();
      t3.exports = function(e6, t4, a3) {
        var i3 = o3(t4), s3 = i3[i3.length - 1], l3 = r3(e6, i3);
        return l3 === null ? "[op:test] path not found: " + t4 : n3(l3[s3], a3) ? void 0 : "[op:test] not matched: " + JSON.stringify(l3[s3]) + " " + JSON.stringify(a3);
      };
    } }), ie2 = b2({ "../node_modules/json-touch-patch/lib/utils/shallowCopy.js"(e5, t3) {
      t3.exports = function(e6) {
        if (!e6 || typeof e6 != "object")
          return e6;
        if (Array.isArray(e6)) {
          for (var t4 = e6.length, n3 = new Array(t4), r3 = 0; r3 < t4; r3++)
            n3[r3] = e6[r3];
          return n3;
        }
        for (var o3 = Object.keys(e6), a3 = {}, i3 = 0, s3 = o3.length; i3 < s3; i3++) {
          var l3 = o3[i3];
          a3[l3] = e6[l3];
        }
        return a3;
      };
    } }), se2 = b2({ "../node_modules/json-touch-patch/lib/utils/createAPI.js"(e5, t3) {
      var n3 = Q2(), r3 = ee2(), o3 = te2(), a3 = ne2(), i3 = re2(), s3 = oe2(), l3 = ae2(), u3 = J2(), c3 = ie2(), d2 = G2();
      t3.exports = function(e6, t4) {
        return { get: function(t5) {
          return n3(e6, t5);
        }, add: function(n4, o4) {
          return r3(e6, n4, o4, t4);
        }, remove: function(n4) {
          return o3(e6, n4, t4);
        }, replace: function(n4, r4) {
          return a3(e6, n4, r4, t4);
        }, move: function(n4, r4) {
          return i3(e6, n4, r4, t4);
        }, copy: function(n4, r4) {
          return s3(e6, n4, r4, t4);
        }, test: function(t5, n4) {
          return l3(e6, t5, n4);
        }, deepEqual: u3, shallowCopy: c3, toKeys: d2 };
      };
    } }), le2 = b2({ "../node_modules/json-touch-patch/lib/utils/exit.js"(e5, t3) {
      t3.exports = function(e6, t4, n3, r3) {
        return r3.error = n3, r3.partial ? t4[""] : e6;
      };
    } }), ue2 = b2({ "../node_modules/json-touch-patch/lib/utils/toBoolean.js"(e5, t3) {
      t3.exports = function(e6) {
        return !!e6;
      };
    } }), ce2 = b2({ "../node_modules/json-touch-patch/lib/utils/throwException.js"(e5, t3) {
      t3.exports = function(e6) {
        if (e6)
          throw new TypeError(e6);
      };
    } }), de2 = b2({ "../node_modules/json-touch-patch/lib/utils/pluckWithShallowCopy.js"(e5, t3) {
      var n3 = ie2();
      t3.exports = function(e6, t4) {
        for (var r3 = 0, o3 = t4.length - 1; r3 < o3; r3++)
          e6 = e6[t4[r3]] = n3(e6[t4[r3]]);
        return e6;
      };
    } }), fe2 = b2({ "../node_modules/json-touch-patch/lib/utils/pluckWithCachedShallowCopy.js"(e5, t3) {
      var n3 = ie2();
      function r3(e6, t4, r4) {
        var o3 = e6[t4];
        return r4.has(o3) || (o3 = n3(o3), r4.add(o3)), o3;
      }
      t3.exports = function(e6, t4, n4) {
        for (var o3 = 0, a3 = t4.length - 1; o3 < a3; o3++)
          e6 = e6[t4[o3]] = r3(e6, t4[o3], n4);
        return e6;
      };
    } }), pe2 = b2({ "../node_modules/json-touch-patch/lib/patch.js"(e5, t3) {
      var n3 = se2(), r3 = le2(), o3 = ue2(), a3 = ce2(), i3 = de2(), s3 = fe2(), l3 = ee2(), u3 = te2(), c3 = ne2(), d2 = re2(), f2 = oe2(), p2 = ae2(), h3 = window.Set || function() {
        var e6 = [];
        return e6.has = function(e7) {
          return this.indexOf(e7) !== -1;
        }, e6.add = function(e7) {
          this.push(e7);
        }, e6;
      };
      t3.exports = function(e6, t4, m3) {
        if (t4.length === 0)
          return e6;
        for (var v3, g2 = (m3 = m3 || {}).strict ? a3 : o3, y3 = t4.length === 1 ? i3 : function(e7) {
          return function(t5, n4) {
            return s3(t5, n4, e7);
          };
        }(new h3()), b3 = { "": e6 }, w3 = 0, k3 = t4.length; w3 < k3; w3++) {
          var x3 = t4[w3];
          switch (x3.op) {
            case "add":
              if (g2(l3(b3, "" + x3.path, x3.value, y3)))
                return r3(e6, b3, x3, m3);
              break;
            case "remove":
              if (g2(u3(b3, "" + x3.path, y3)))
                return r3(e6, b3, x3, m3);
              break;
            case "replace":
              if (g2(c3(b3, "" + x3.path, x3.value, y3)))
                return r3(e6, b3, x3, m3);
              break;
            case "move":
              if (g2(d2(b3, "" + x3.from, "" + x3.path, y3)))
                return r3(e6, b3, x3, m3);
              break;
            case "copy":
              if (g2(f2(b3, "" + x3.from, "" + x3.path, y3)))
                return r3(e6, b3, x3, m3);
              break;
            case "test":
              if (g2(p2(b3, "" + x3.path, x3.value)))
                return r3(e6, b3, x3, m3);
              break;
            default:
              if (!m3.custom || !m3.custom[x3.op])
                return g2("[op:" + x3.op + "] unknown"), r3(e6, b3, x3, m3);
              if (v3 = v3 || n3(b3, y3), g2(m3.custom[x3.op](v3, x3, w3, t4)))
                return r3(e6, b3, x3, m3);
          }
        }
        return b3[""];
      };
    } }), he2 = b2({ "../node_modules/json-touch-patch/lib/index.js"(e5, t3) {
      t3.exports = pe2();
    } });
    function me2() {
      return n2;
    }
    function ve2(e5, t3, n3 = []) {
      if (typeof e5 == "object" && e5)
        for (const [r3, o3] of Object.entries(e5))
          ve2(o3, t3, [...n3, r3]);
      else {
        if (e5 == null)
          return;
        t3(e5, n3);
      }
    }
    ((e5, t3) => {
      for (var n3 in v2(e5), t3)
        o2(e5, n3, { get: t3[n3], enumerable: true });
    })(t2, { ToolbarDropdownSelect: () => Vk, ToolbarIconButton: () => cc2, ToolbarSwitchSelect: () => Fk, default: () => Hk });
    var ge2 = w2(g), ye2 = { log: console.log, warn: console.warn, error: console.error, trace: console.trace }, be2 = Pe2("Theatre_Project"), we2 = Pe2("Theatre_Sheet"), ke2 = Pe2("Theatre_SheetTemplate"), xe2 = Pe2("Theatre_SheetObject"), Se2 = Pe2("Theatre_SheetObjectTemplate"), _e2 = Pe2("Theatre_Sheet_PublicAPI"), Ee2 = Pe2("Theatre_SheetObject_PublicAPI");
    function Pe2(e5) {
      return (t3) => typeof t3 == "object" && !!t3 && t3.type === e5;
    }
    var Ce2 = 0, Oe2 = w2(g), Te2 = w2(g), Ie2 = typeof window == "object" && window && window.Object === Object && window, De2 = typeof self == "object" && self && self.Object === Object && self, Re2 = Ie2 || De2 || Function("return this")(), Ne2 = Re2.Symbol, Ae2 = Object.prototype, ze2 = Ae2.hasOwnProperty, Me2 = Ae2.toString, Le2 = Ne2 ? Ne2.toStringTag : void 0;
    var Fe2 = function(e5) {
      var t3 = ze2.call(e5, Le2), n3 = e5[Le2];
      try {
        e5[Le2] = void 0;
        var r3 = true;
      } catch (e6) {
      }
      var o3 = Me2.call(e5);
      return r3 && (t3 ? e5[Le2] = n3 : delete e5[Le2]), o3;
    }, $e2 = Object.prototype.toString;
    var Be2 = function(e5) {
      return $e2.call(e5);
    }, Ve2 = Ne2 ? Ne2.toStringTag : void 0;
    var Ue = function(e5) {
      return e5 == null ? e5 === void 0 ? "[object Undefined]" : "[object Null]" : Ve2 && Ve2 in Object(e5) ? Fe2(e5) : Be2(e5);
    };
    var He2 = function(e5) {
      return e5 != null && typeof e5 == "object";
    };
    var We2 = function(e5) {
      return typeof e5 == "symbol" || He2(e5) && Ue(e5) == "[object Symbol]";
    };
    var qe2 = function(e5, t3) {
      for (var n3 = -1, r3 = e5 == null ? 0 : e5.length, o3 = Array(r3); ++n3 < r3; )
        o3[n3] = t3(e5[n3], n3, e5);
      return o3;
    }, Ke2 = Array.isArray, Ye2 = Ne2 ? Ne2.prototype : void 0, Xe2 = Ye2 ? Ye2.toString : void 0;
    var Ge2 = function e5(t3) {
      if (typeof t3 == "string")
        return t3;
      if (Ke2(t3))
        return qe2(t3, e5) + "";
      if (We2(t3))
        return Xe2 ? Xe2.call(t3) : "";
      var n3 = t3 + "";
      return n3 == "0" && 1 / t3 == -Infinity ? "-0" : n3;
    }, Qe2 = /\s/;
    var Je2 = function(e5) {
      for (var t3 = e5.length; t3-- && Qe2.test(e5.charAt(t3)); )
        ;
      return t3;
    }, Ze2 = /^\s+/;
    var et2 = function(e5) {
      return e5 ? e5.slice(0, Je2(e5) + 1).replace(Ze2, "") : e5;
    };
    var tt2 = function(e5) {
      var t3 = typeof e5;
      return e5 != null && (t3 == "object" || t3 == "function");
    }, nt2 = /^[-+]0x[0-9a-f]+$/i, rt2 = /^0b[01]+$/i, ot2 = /^0o[0-7]+$/i, at2 = parseInt;
    var it2 = function(e5) {
      if (typeof e5 == "number")
        return e5;
      if (We2(e5))
        return NaN;
      if (tt2(e5)) {
        var t3 = typeof e5.valueOf == "function" ? e5.valueOf() : e5;
        e5 = tt2(t3) ? t3 + "" : t3;
      }
      if (typeof e5 != "string")
        return e5 === 0 ? e5 : +e5;
      e5 = et2(e5);
      var n3 = rt2.test(e5);
      return n3 || ot2.test(e5) ? at2(e5.slice(2), n3 ? 2 : 8) : nt2.test(e5) ? NaN : +e5;
    }, st2 = 1 / 0;
    var lt2 = function(e5) {
      return e5 ? (e5 = it2(e5)) === st2 || e5 === -1 / 0 ? 17976931348623157e292 * (e5 < 0 ? -1 : 1) : e5 == e5 ? e5 : 0 : e5 === 0 ? e5 : 0;
    };
    var ut2 = function(e5) {
      var t3 = lt2(e5), n3 = t3 % 1;
      return t3 == t3 ? n3 ? t3 - n3 : t3 : 0;
    };
    var ct2 = function(e5) {
      return e5;
    };
    var dt2 = function(e5) {
      if (!tt2(e5))
        return false;
      var t3 = Ue(e5);
      return t3 == "[object Function]" || t3 == "[object GeneratorFunction]" || t3 == "[object AsyncFunction]" || t3 == "[object Proxy]";
    }, ft2 = Re2["__core-js_shared__"], pt2 = function() {
      var e5 = /[^.]+$/.exec(ft2 && ft2.keys && ft2.keys.IE_PROTO || "");
      return e5 ? "Symbol(src)_1." + e5 : "";
    }();
    var mt2 = function(e5) {
      return !!pt2 && pt2 in e5;
    }, vt2 = Function.prototype.toString;
    var gt2 = function(e5) {
      if (e5 != null) {
        try {
          return vt2.call(e5);
        } catch (e6) {
        }
        try {
          return e5 + "";
        } catch (e6) {
        }
      }
      return "";
    }, yt2 = /^\[object .+?Constructor\]$/, bt2 = Function.prototype, wt2 = Object.prototype, kt2 = bt2.toString, xt2 = wt2.hasOwnProperty, St2 = RegExp("^" + kt2.call(xt2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var _t2 = function(e5) {
      return !(!tt2(e5) || mt2(e5)) && (dt2(e5) ? St2 : yt2).test(gt2(e5));
    };
    var Et2 = function(e5, t3) {
      return e5 == null ? void 0 : e5[t3];
    };
    var Pt2 = function(e5, t3) {
      var n3 = Et2(e5, t3);
      return _t2(n3) ? n3 : void 0;
    }, Ct2 = Pt2(Re2, "WeakMap");
    var jt2 = function(e5, t3, n3) {
      switch (n3.length) {
        case 0:
          return e5.call(t3);
        case 1:
          return e5.call(t3, n3[0]);
        case 2:
          return e5.call(t3, n3[0], n3[1]);
        case 3:
          return e5.call(t3, n3[0], n3[1], n3[2]);
      }
      return e5.apply(t3, n3);
    };
    var Ot2 = function() {
    };
    var Tt2 = function(e5, t3) {
      var n3 = -1, r3 = e5.length;
      for (t3 || (t3 = Array(r3)); ++n3 < r3; )
        t3[n3] = e5[n3];
      return t3;
    }, It2 = Date.now;
    var Dt2 = function(e5) {
      var t3 = 0, n3 = 0;
      return function() {
        var r3 = It2(), o3 = 16 - (r3 - n3);
        if (n3 = r3, o3 > 0) {
          if (++t3 >= 800)
            return arguments[0];
        } else
          t3 = 0;
        return e5.apply(void 0, arguments);
      };
    };
    var Rt2 = function(e5) {
      return function() {
        return e5;
      };
    }, Nt2 = function() {
      try {
        var e5 = Pt2(Object, "defineProperty");
        return e5({}, "", {}), e5;
      } catch (e6) {
      }
    }(), At2 = Nt2, zt2 = At2 ? function(e5, t3) {
      return At2(e5, "toString", { configurable: true, enumerable: false, value: Rt2(t3), writable: true });
    } : ct2, Mt2 = Dt2(zt2);
    var Lt2 = function(e5, t3, n3, r3) {
      for (var o3 = e5.length, a3 = n3 + (r3 ? 1 : -1); r3 ? a3-- : ++a3 < o3; )
        if (t3(e5[a3], a3, e5))
          return a3;
      return -1;
    };
    var Ft2 = function(e5) {
      return e5 != e5;
    };
    var $t2 = function(e5, t3, n3) {
      for (var r3 = n3 - 1, o3 = e5.length; ++r3 < o3; )
        if (e5[r3] === t3)
          return r3;
      return -1;
    };
    var Bt2 = function(e5, t3, n3) {
      return t3 == t3 ? $t2(e5, t3, n3) : Lt2(e5, Ft2, n3);
    };
    var Vt2 = function(e5, t3) {
      return !!(e5 == null ? 0 : e5.length) && Bt2(e5, t3, 0) > -1;
    }, Ut2 = /^(?:0|[1-9]\d*)$/;
    var Ht2 = function(e5, t3) {
      var n3 = typeof e5;
      return !!(t3 = t3 == null ? 9007199254740991 : t3) && (n3 == "number" || n3 != "symbol" && Ut2.test(e5)) && e5 > -1 && e5 % 1 == 0 && e5 < t3;
    };
    var Wt2 = function(e5, t3, n3) {
      t3 == "__proto__" && At2 ? At2(e5, t3, { configurable: true, enumerable: true, value: n3, writable: true }) : e5[t3] = n3;
    };
    var qt2 = function(e5, t3) {
      return e5 === t3 || e5 != e5 && t3 != t3;
    }, Kt2 = Object.prototype.hasOwnProperty;
    var Yt2 = function(e5, t3, n3) {
      var r3 = e5[t3];
      Kt2.call(e5, t3) && qt2(r3, n3) && (n3 !== void 0 || t3 in e5) || Wt2(e5, t3, n3);
    }, Xt2 = Math.max;
    var Gt2 = function(e5, t3, n3) {
      return t3 = Xt2(t3 === void 0 ? e5.length - 1 : t3, 0), function() {
        for (var r3 = arguments, o3 = -1, a3 = Xt2(r3.length - t3, 0), i3 = Array(a3); ++o3 < a3; )
          i3[o3] = r3[t3 + o3];
        o3 = -1;
        for (var s3 = Array(t3 + 1); ++o3 < t3; )
          s3[o3] = r3[o3];
        return s3[t3] = n3(i3), jt2(e5, this, s3);
      };
    };
    var Qt2 = function(e5, t3) {
      return Mt2(Gt2(e5, t3, ct2), e5 + "");
    };
    var Jt2 = function(e5) {
      return typeof e5 == "number" && e5 > -1 && e5 % 1 == 0 && e5 <= 9007199254740991;
    };
    var Zt2 = function(e5) {
      return e5 != null && Jt2(e5.length) && !dt2(e5);
    };
    var en2 = function(e5, t3, n3) {
      if (!tt2(n3))
        return false;
      var r3 = typeof t3;
      return !!(r3 == "number" ? Zt2(n3) && Ht2(t3, n3.length) : r3 == "string" && t3 in n3) && qt2(n3[t3], e5);
    }, tn = Object.prototype;
    var nn2 = function(e5) {
      var t3 = e5 && e5.constructor;
      return e5 === (typeof t3 == "function" && t3.prototype || tn);
    };
    var rn2 = function(e5, t3) {
      for (var n3 = -1, r3 = Array(e5); ++n3 < e5; )
        r3[n3] = t3(n3);
      return r3;
    };
    var on2 = function(e5) {
      return He2(e5) && Ue(e5) == "[object Arguments]";
    }, an2 = Object.prototype, sn2 = an2.hasOwnProperty, ln2 = an2.propertyIsEnumerable, un2 = on2(function() {
      return arguments;
    }()) ? on2 : function(e5) {
      return He2(e5) && sn2.call(e5, "callee") && !ln2.call(e5, "callee");
    }, cn2 = un2;
    var dn2 = function() {
      return false;
    }, fn2 = t2 && !t2.nodeType && t2, pn2 = fn2 && e4 && !e4.nodeType && e4, hn2 = pn2 && pn2.exports === fn2 ? Re2.Buffer : void 0, mn2 = (hn2 ? hn2.isBuffer : void 0) || dn2, vn2 = {};
    vn2["[object Float32Array]"] = vn2["[object Float64Array]"] = vn2["[object Int8Array]"] = vn2["[object Int16Array]"] = vn2["[object Int32Array]"] = vn2["[object Uint8Array]"] = vn2["[object Uint8ClampedArray]"] = vn2["[object Uint16Array]"] = vn2["[object Uint32Array]"] = true, vn2["[object Arguments]"] = vn2["[object Array]"] = vn2["[object ArrayBuffer]"] = vn2["[object Boolean]"] = vn2["[object DataView]"] = vn2["[object Date]"] = vn2["[object Error]"] = vn2["[object Function]"] = vn2["[object Map]"] = vn2["[object Number]"] = vn2["[object Object]"] = vn2["[object RegExp]"] = vn2["[object Set]"] = vn2["[object String]"] = vn2["[object WeakMap]"] = false;
    var gn2 = function(e5) {
      return He2(e5) && Jt2(e5.length) && !!vn2[Ue(e5)];
    };
    var yn2 = function(e5) {
      return function(t3) {
        return e5(t3);
      };
    }, bn2 = t2 && !t2.nodeType && t2, wn2 = bn2 && e4 && !e4.nodeType && e4, kn2 = wn2 && wn2.exports === bn2 && Ie2.process, xn2 = function() {
      try {
        var e5 = wn2 && wn2.require && wn2.require("util").types;
        return e5 || kn2 && kn2.binding && kn2.binding("util");
      } catch (e6) {
      }
    }(), Sn2 = xn2 && xn2.isTypedArray, _n2 = Sn2 ? yn2(Sn2) : gn2, En2 = Object.prototype.hasOwnProperty;
    var Pn2 = function(e5, t3) {
      var n3 = Ke2(e5), r3 = !n3 && cn2(e5), o3 = !n3 && !r3 && mn2(e5), a3 = !n3 && !r3 && !o3 && _n2(e5), i3 = n3 || r3 || o3 || a3, s3 = i3 ? rn2(e5.length, String) : [], l3 = s3.length;
      for (var u3 in e5)
        !t3 && !En2.call(e5, u3) || i3 && (u3 == "length" || o3 && (u3 == "offset" || u3 == "parent") || a3 && (u3 == "buffer" || u3 == "byteLength" || u3 == "byteOffset") || Ht2(u3, l3)) || s3.push(u3);
      return s3;
    };
    var Cn2 = function(e5, t3) {
      return function(n3) {
        return e5(t3(n3));
      };
    }, jn2 = Cn2(Object.keys, Object), On2 = Object.prototype.hasOwnProperty;
    var Tn2 = function(e5) {
      if (!nn2(e5))
        return jn2(e5);
      var t3 = [];
      for (var n3 in Object(e5))
        On2.call(e5, n3) && n3 != "constructor" && t3.push(n3);
      return t3;
    };
    var In2 = function(e5) {
      return Zt2(e5) ? Pn2(e5) : Tn2(e5);
    }, Dn2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Rn2 = /^\w*$/;
    var Nn2 = function(e5, t3) {
      if (Ke2(e5))
        return false;
      var n3 = typeof e5;
      return !(n3 != "number" && n3 != "symbol" && n3 != "boolean" && e5 != null && !We2(e5)) || (Rn2.test(e5) || !Dn2.test(e5) || t3 != null && e5 in Object(t3));
    }, An2 = Pt2(Object, "create");
    var zn2 = function() {
      this.__data__ = An2 ? An2(null) : {}, this.size = 0;
    };
    var Mn2 = function(e5) {
      var t3 = this.has(e5) && delete this.__data__[e5];
      return this.size -= t3 ? 1 : 0, t3;
    }, Ln2 = Object.prototype.hasOwnProperty;
    var Fn2 = function(e5) {
      var t3 = this.__data__;
      if (An2) {
        var n3 = t3[e5];
        return n3 === "__lodash_hash_undefined__" ? void 0 : n3;
      }
      return Ln2.call(t3, e5) ? t3[e5] : void 0;
    }, $n2 = Object.prototype.hasOwnProperty;
    var Bn2 = function(e5) {
      var t3 = this.__data__;
      return An2 ? t3[e5] !== void 0 : $n2.call(t3, e5);
    };
    var Vn2 = function(e5, t3) {
      var n3 = this.__data__;
      return this.size += this.has(e5) ? 0 : 1, n3[e5] = An2 && t3 === void 0 ? "__lodash_hash_undefined__" : t3, this;
    };
    function Un2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.clear(); ++t3 < n3; ) {
        var r3 = e5[t3];
        this.set(r3[0], r3[1]);
      }
    }
    Un2.prototype.clear = zn2, Un2.prototype.delete = Mn2, Un2.prototype.get = Fn2, Un2.prototype.has = Bn2, Un2.prototype.set = Vn2;
    var Hn2 = Un2;
    var Wn2 = function() {
      this.__data__ = [], this.size = 0;
    };
    var qn2 = function(e5, t3) {
      for (var n3 = e5.length; n3--; )
        if (qt2(e5[n3][0], t3))
          return n3;
      return -1;
    }, Kn2 = Array.prototype.splice;
    var Yn2 = function(e5) {
      var t3 = this.__data__, n3 = qn2(t3, e5);
      return !(n3 < 0) && (n3 == t3.length - 1 ? t3.pop() : Kn2.call(t3, n3, 1), --this.size, true);
    };
    var Xn2 = function(e5) {
      var t3 = this.__data__, n3 = qn2(t3, e5);
      return n3 < 0 ? void 0 : t3[n3][1];
    };
    var Gn2 = function(e5) {
      return qn2(this.__data__, e5) > -1;
    };
    var Qn2 = function(e5, t3) {
      var n3 = this.__data__, r3 = qn2(n3, e5);
      return r3 < 0 ? (++this.size, n3.push([e5, t3])) : n3[r3][1] = t3, this;
    };
    function Jn2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.clear(); ++t3 < n3; ) {
        var r3 = e5[t3];
        this.set(r3[0], r3[1]);
      }
    }
    Jn2.prototype.clear = Wn2, Jn2.prototype.delete = Yn2, Jn2.prototype.get = Xn2, Jn2.prototype.has = Gn2, Jn2.prototype.set = Qn2;
    var Zn2 = Jn2, er2 = Pt2(Re2, "Map");
    var tr2 = function() {
      this.size = 0, this.__data__ = { hash: new Hn2(), map: new (er2 || Zn2)(), string: new Hn2() };
    };
    var nr2 = function(e5) {
      var t3 = typeof e5;
      return t3 == "string" || t3 == "number" || t3 == "symbol" || t3 == "boolean" ? e5 !== "__proto__" : e5 === null;
    };
    var rr2 = function(e5, t3) {
      var n3 = e5.__data__;
      return nr2(t3) ? n3[typeof t3 == "string" ? "string" : "hash"] : n3.map;
    };
    var or2 = function(e5) {
      var t3 = rr2(this, e5).delete(e5);
      return this.size -= t3 ? 1 : 0, t3;
    };
    var ar = function(e5) {
      return rr2(this, e5).get(e5);
    };
    var ir2 = function(e5) {
      return rr2(this, e5).has(e5);
    };
    var sr2 = function(e5, t3) {
      var n3 = rr2(this, e5), r3 = n3.size;
      return n3.set(e5, t3), this.size += n3.size == r3 ? 0 : 1, this;
    };
    function lr2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.clear(); ++t3 < n3; ) {
        var r3 = e5[t3];
        this.set(r3[0], r3[1]);
      }
    }
    lr2.prototype.clear = tr2, lr2.prototype.delete = or2, lr2.prototype.get = ar, lr2.prototype.has = ir2, lr2.prototype.set = sr2;
    var ur2 = lr2;
    function cr2(e5, t3) {
      if (typeof e5 != "function" || t3 != null && typeof t3 != "function")
        throw new TypeError("Expected a function");
      var n3 = function() {
        var r3 = arguments, o3 = t3 ? t3.apply(this, r3) : r3[0], a3 = n3.cache;
        if (a3.has(o3))
          return a3.get(o3);
        var i3 = e5.apply(this, r3);
        return n3.cache = a3.set(o3, i3) || a3, i3;
      };
      return n3.cache = new (cr2.Cache || ur2)(), n3;
    }
    cr2.Cache = ur2;
    var dr2 = cr2;
    var fr2 = function(e5) {
      var t3 = dr2(e5, function(e6) {
        return n3.size === 500 && n3.clear(), e6;
      }), n3 = t3.cache;
      return t3;
    }, pr2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, hr2 = /\\(\\)?/g, mr2 = fr2(function(e5) {
      var t3 = [];
      return e5.charCodeAt(0) === 46 && t3.push(""), e5.replace(pr2, function(e6, n3, r3, o3) {
        t3.push(r3 ? o3.replace(hr2, "$1") : n3 || e6);
      }), t3;
    }), vr2 = mr2;
    var gr2 = function(e5) {
      return e5 == null ? "" : Ge2(e5);
    };
    var yr2 = function(e5, t3) {
      return Ke2(e5) ? e5 : Nn2(e5, t3) ? [e5] : vr2(gr2(e5));
    };
    var br2 = function(e5) {
      if (typeof e5 == "string" || We2(e5))
        return e5;
      var t3 = e5 + "";
      return t3 == "0" && 1 / e5 == -Infinity ? "-0" : t3;
    };
    var wr2 = function(e5, t3) {
      for (var n3 = 0, r3 = (t3 = yr2(t3, e5)).length; e5 != null && n3 < r3; )
        e5 = e5[br2(t3[n3++])];
      return n3 && n3 == r3 ? e5 : void 0;
    };
    var kr2 = function(e5, t3, n3) {
      var r3 = e5 == null ? void 0 : wr2(e5, t3);
      return r3 === void 0 ? n3 : r3;
    };
    var xr2 = function(e5, t3) {
      for (var n3 = -1, r3 = t3.length, o3 = e5.length; ++n3 < r3; )
        e5[o3 + n3] = t3[n3];
      return e5;
    }, Sr2 = Ne2 ? Ne2.isConcatSpreadable : void 0;
    var _r2 = function(e5) {
      return Ke2(e5) || cn2(e5) || !!(Sr2 && e5 && e5[Sr2]);
    };
    var Er2 = function e5(t3, n3, r3, o3, a3) {
      var i3 = -1, s3 = t3.length;
      for (r3 || (r3 = _r2), a3 || (a3 = []); ++i3 < s3; ) {
        var l3 = t3[i3];
        n3 > 0 && r3(l3) ? n3 > 1 ? e5(l3, n3 - 1, r3, o3, a3) : xr2(a3, l3) : o3 || (a3[a3.length] = l3);
      }
      return a3;
    }, Pr2 = Cn2(Object.getPrototypeOf, Object), Cr2 = Function.prototype, jr2 = Object.prototype, Or2 = Cr2.toString, Tr2 = jr2.hasOwnProperty, Ir2 = Or2.call(Object);
    var Dr2 = function(e5) {
      if (!He2(e5) || Ue(e5) != "[object Object]")
        return false;
      var t3 = Pr2(e5);
      if (t3 === null)
        return true;
      var n3 = Tr2.call(t3, "constructor") && t3.constructor;
      return typeof n3 == "function" && n3 instanceof n3 && Or2.call(n3) == Ir2;
    }, Rr2 = Re2.isFinite, Nr2 = Math.min;
    var Ar2 = function(e5) {
      var t3 = Math[e5];
      return function(e6, n3) {
        if (e6 = it2(e6), (n3 = n3 == null ? 0 : Nr2(ut2(n3), 292)) && Rr2(e6)) {
          var r3 = (gr2(e6) + "e").split("e"), o3 = t3(r3[0] + "e" + (+r3[1] + n3));
          return +((r3 = (gr2(o3) + "e").split("e"))[0] + "e" + (+r3[1] - n3));
        }
        return t3(e6);
      };
    };
    var zr2 = function(e5, t3, n3) {
      return e5 == e5 && (n3 !== void 0 && (e5 = e5 <= n3 ? e5 : n3), t3 !== void 0 && (e5 = e5 >= t3 ? e5 : t3)), e5;
    };
    var Mr2 = function(e5, t3, n3) {
      return n3 === void 0 && (n3 = t3, t3 = void 0), n3 !== void 0 && (n3 = (n3 = it2(n3)) == n3 ? n3 : 0), t3 !== void 0 && (t3 = (t3 = it2(t3)) == t3 ? t3 : 0), zr2(it2(e5), t3, n3);
    };
    var Lr2 = function() {
      this.__data__ = new Zn2(), this.size = 0;
    };
    var Fr2 = function(e5) {
      var t3 = this.__data__, n3 = t3.delete(e5);
      return this.size = t3.size, n3;
    };
    var $r2 = function(e5) {
      return this.__data__.get(e5);
    };
    var Br2 = function(e5) {
      return this.__data__.has(e5);
    };
    var Vr2 = function(e5, t3) {
      var n3 = this.__data__;
      if (n3 instanceof Zn2) {
        var r3 = n3.__data__;
        if (!er2 || r3.length < 199)
          return r3.push([e5, t3]), this.size = ++n3.size, this;
        n3 = this.__data__ = new ur2(r3);
      }
      return n3.set(e5, t3), this.size = n3.size, this;
    };
    function Ur2(e5) {
      var t3 = this.__data__ = new Zn2(e5);
      this.size = t3.size;
    }
    Ur2.prototype.clear = Lr2, Ur2.prototype.delete = Fr2, Ur2.prototype.get = $r2, Ur2.prototype.has = Br2, Ur2.prototype.set = Vr2;
    var Hr2 = Ur2;
    var Wr2 = function(e5, t3) {
      for (var n3 = -1, r3 = e5 == null ? 0 : e5.length, o3 = 0, a3 = []; ++n3 < r3; ) {
        var i3 = e5[n3];
        t3(i3, n3, e5) && (a3[o3++] = i3);
      }
      return a3;
    };
    var qr2 = function() {
      return [];
    }, Kr2 = Object.prototype.propertyIsEnumerable, Yr2 = Object.getOwnPropertySymbols, Xr2 = Yr2 ? function(e5) {
      return e5 == null ? [] : (e5 = Object(e5), Wr2(Yr2(e5), function(t3) {
        return Kr2.call(e5, t3);
      }));
    } : qr2;
    var Gr2 = function(e5, t3, n3) {
      var r3 = t3(e5);
      return Ke2(e5) ? r3 : xr2(r3, n3(e5));
    };
    var Qr2 = function(e5) {
      return Gr2(e5, In2, Xr2);
    }, Jr2 = Pt2(Re2, "DataView"), Zr2 = Pt2(Re2, "Promise"), eo2 = Pt2(Re2, "Set"), to2 = "[object Map]", no2 = "[object Promise]", ro2 = "[object Set]", oo2 = "[object WeakMap]", ao2 = "[object DataView]", io2 = gt2(Jr2), so2 = gt2(er2), lo2 = gt2(Zr2), uo2 = gt2(eo2), co2 = gt2(Ct2), fo2 = Ue;
    (Jr2 && fo2(new Jr2(new ArrayBuffer(1))) != ao2 || er2 && fo2(new er2()) != to2 || Zr2 && fo2(Zr2.resolve()) != no2 || eo2 && fo2(new eo2()) != ro2 || Ct2 && fo2(new Ct2()) != oo2) && (fo2 = function(e5) {
      var t3 = Ue(e5), n3 = t3 == "[object Object]" ? e5.constructor : void 0, r3 = n3 ? gt2(n3) : "";
      if (r3)
        switch (r3) {
          case io2:
            return ao2;
          case so2:
            return to2;
          case lo2:
            return no2;
          case uo2:
            return ro2;
          case co2:
            return oo2;
        }
      return t3;
    });
    var po2 = fo2, ho2 = Re2.Uint8Array;
    var mo2 = function(e5) {
      return this.__data__.set(e5, "__lodash_hash_undefined__"), this;
    };
    var vo2 = function(e5) {
      return this.__data__.has(e5);
    };
    function go2(e5) {
      var t3 = -1, n3 = e5 == null ? 0 : e5.length;
      for (this.__data__ = new ur2(); ++t3 < n3; )
        this.add(e5[t3]);
    }
    go2.prototype.add = go2.prototype.push = mo2, go2.prototype.has = vo2;
    var yo2 = go2;
    var bo2 = function(e5, t3) {
      for (var n3 = -1, r3 = e5 == null ? 0 : e5.length; ++n3 < r3; )
        if (t3(e5[n3], n3, e5))
          return true;
      return false;
    };
    var wo2 = function(e5, t3) {
      return e5.has(t3);
    };
    var ko2 = function(e5, t3, n3, r3, o3, a3) {
      var i3 = 1 & n3, s3 = e5.length, l3 = t3.length;
      if (s3 != l3 && !(i3 && l3 > s3))
        return false;
      var u3 = a3.get(e5), c3 = a3.get(t3);
      if (u3 && c3)
        return u3 == t3 && c3 == e5;
      var d2 = -1, f2 = true, p2 = 2 & n3 ? new yo2() : void 0;
      for (a3.set(e5, t3), a3.set(t3, e5); ++d2 < s3; ) {
        var h3 = e5[d2], m3 = t3[d2];
        if (r3)
          var v3 = i3 ? r3(m3, h3, d2, t3, e5, a3) : r3(h3, m3, d2, e5, t3, a3);
        if (v3 !== void 0) {
          if (v3)
            continue;
          f2 = false;
          break;
        }
        if (p2) {
          if (!bo2(t3, function(e6, t4) {
            if (!wo2(p2, t4) && (h3 === e6 || o3(h3, e6, n3, r3, a3)))
              return p2.push(t4);
          })) {
            f2 = false;
            break;
          }
        } else if (h3 !== m3 && !o3(h3, m3, n3, r3, a3)) {
          f2 = false;
          break;
        }
      }
      return a3.delete(e5), a3.delete(t3), f2;
    };
    var xo2 = function(e5) {
      var t3 = -1, n3 = Array(e5.size);
      return e5.forEach(function(e6, r3) {
        n3[++t3] = [r3, e6];
      }), n3;
    };
    var So2 = function(e5) {
      var t3 = -1, n3 = Array(e5.size);
      return e5.forEach(function(e6) {
        n3[++t3] = e6;
      }), n3;
    }, _o2 = Ne2 ? Ne2.prototype : void 0, Eo2 = _o2 ? _o2.valueOf : void 0;
    var Po2 = function(e5, t3, n3, r3, o3, a3, i3) {
      switch (n3) {
        case "[object DataView]":
          if (e5.byteLength != t3.byteLength || e5.byteOffset != t3.byteOffset)
            return false;
          e5 = e5.buffer, t3 = t3.buffer;
        case "[object ArrayBuffer]":
          return !(e5.byteLength != t3.byteLength || !a3(new ho2(e5), new ho2(t3)));
        case "[object Boolean]":
        case "[object Date]":
        case "[object Number]":
          return qt2(+e5, +t3);
        case "[object Error]":
          return e5.name == t3.name && e5.message == t3.message;
        case "[object RegExp]":
        case "[object String]":
          return e5 == t3 + "";
        case "[object Map]":
          var s3 = xo2;
        case "[object Set]":
          var l3 = 1 & r3;
          if (s3 || (s3 = So2), e5.size != t3.size && !l3)
            return false;
          var u3 = i3.get(e5);
          if (u3)
            return u3 == t3;
          r3 |= 2, i3.set(e5, t3);
          var c3 = ko2(s3(e5), s3(t3), r3, o3, a3, i3);
          return i3.delete(e5), c3;
        case "[object Symbol]":
          if (Eo2)
            return Eo2.call(e5) == Eo2.call(t3);
      }
      return false;
    }, Co2 = Object.prototype.hasOwnProperty;
    var jo2 = function(e5, t3, n3, r3, o3, a3) {
      var i3 = 1 & n3, s3 = Qr2(e5), l3 = s3.length;
      if (l3 != Qr2(t3).length && !i3)
        return false;
      for (var u3 = l3; u3--; ) {
        var c3 = s3[u3];
        if (!(i3 ? c3 in t3 : Co2.call(t3, c3)))
          return false;
      }
      var d2 = a3.get(e5), f2 = a3.get(t3);
      if (d2 && f2)
        return d2 == t3 && f2 == e5;
      var p2 = true;
      a3.set(e5, t3), a3.set(t3, e5);
      for (var h3 = i3; ++u3 < l3; ) {
        var m3 = e5[c3 = s3[u3]], v3 = t3[c3];
        if (r3)
          var g2 = i3 ? r3(v3, m3, c3, t3, e5, a3) : r3(m3, v3, c3, e5, t3, a3);
        if (!(g2 === void 0 ? m3 === v3 || o3(m3, v3, n3, r3, a3) : g2)) {
          p2 = false;
          break;
        }
        h3 || (h3 = c3 == "constructor");
      }
      if (p2 && !h3) {
        var y3 = e5.constructor, b3 = t3.constructor;
        y3 == b3 || !("constructor" in e5) || !("constructor" in t3) || typeof y3 == "function" && y3 instanceof y3 && typeof b3 == "function" && b3 instanceof b3 || (p2 = false);
      }
      return a3.delete(e5), a3.delete(t3), p2;
    }, Oo2 = "[object Arguments]", To2 = "[object Array]", Io2 = "[object Object]", Do2 = Object.prototype.hasOwnProperty;
    var Ro2 = function(e5, t3, n3, r3, o3, a3) {
      var i3 = Ke2(e5), s3 = Ke2(t3), l3 = i3 ? To2 : po2(e5), u3 = s3 ? To2 : po2(t3), c3 = (l3 = l3 == Oo2 ? Io2 : l3) == Io2, d2 = (u3 = u3 == Oo2 ? Io2 : u3) == Io2, f2 = l3 == u3;
      if (f2 && mn2(e5)) {
        if (!mn2(t3))
          return false;
        i3 = true, c3 = false;
      }
      if (f2 && !c3)
        return a3 || (a3 = new Hr2()), i3 || _n2(e5) ? ko2(e5, t3, n3, r3, o3, a3) : Po2(e5, t3, l3, n3, r3, o3, a3);
      if (!(1 & n3)) {
        var p2 = c3 && Do2.call(e5, "__wrapped__"), h3 = d2 && Do2.call(t3, "__wrapped__");
        if (p2 || h3) {
          var m3 = p2 ? e5.value() : e5, v3 = h3 ? t3.value() : t3;
          return a3 || (a3 = new Hr2()), o3(m3, v3, n3, r3, a3);
        }
      }
      return !!f2 && (a3 || (a3 = new Hr2()), jo2(e5, t3, n3, r3, o3, a3));
    };
    var No2 = function e5(t3, n3, r3, o3, a3) {
      return t3 === n3 || (t3 == null || n3 == null || !He2(t3) && !He2(n3) ? t3 != t3 && n3 != n3 : Ro2(t3, n3, r3, o3, e5, a3));
    };
    var Ao2 = function(e5, t3, n3, r3) {
      var o3 = n3.length, a3 = o3, i3 = !r3;
      if (e5 == null)
        return !a3;
      for (e5 = Object(e5); o3--; ) {
        var s3 = n3[o3];
        if (i3 && s3[2] ? s3[1] !== e5[s3[0]] : !(s3[0] in e5))
          return false;
      }
      for (; ++o3 < a3; ) {
        var l3 = (s3 = n3[o3])[0], u3 = e5[l3], c3 = s3[1];
        if (i3 && s3[2]) {
          if (u3 === void 0 && !(l3 in e5))
            return false;
        } else {
          var d2 = new Hr2();
          if (r3)
            var f2 = r3(u3, c3, l3, e5, t3, d2);
          if (!(f2 === void 0 ? No2(c3, u3, 3, r3, d2) : f2))
            return false;
        }
      }
      return true;
    };
    var zo2 = function(e5) {
      return e5 == e5 && !tt2(e5);
    };
    var Mo2 = function(e5) {
      for (var t3 = In2(e5), n3 = t3.length; n3--; ) {
        var r3 = t3[n3], o3 = e5[r3];
        t3[n3] = [r3, o3, zo2(o3)];
      }
      return t3;
    };
    var Lo2 = function(e5, t3) {
      return function(n3) {
        return n3 != null && (n3[e5] === t3 && (t3 !== void 0 || e5 in Object(n3)));
      };
    };
    var Fo2 = function(e5) {
      var t3 = Mo2(e5);
      return t3.length == 1 && t3[0][2] ? Lo2(t3[0][0], t3[0][1]) : function(n3) {
        return n3 === e5 || Ao2(n3, e5, t3);
      };
    };
    var $o2 = function(e5, t3) {
      return e5 != null && t3 in Object(e5);
    };
    var Bo2 = function(e5, t3, n3) {
      for (var r3 = -1, o3 = (t3 = yr2(t3, e5)).length, a3 = false; ++r3 < o3; ) {
        var i3 = br2(t3[r3]);
        if (!(a3 = e5 != null && n3(e5, i3)))
          break;
        e5 = e5[i3];
      }
      return a3 || ++r3 != o3 ? a3 : !!(o3 = e5 == null ? 0 : e5.length) && Jt2(o3) && Ht2(i3, o3) && (Ke2(e5) || cn2(e5));
    };
    var Vo2 = function(e5, t3) {
      return e5 != null && Bo2(e5, t3, $o2);
    };
    var Uo2 = function(e5, t3) {
      return Nn2(e5) && zo2(t3) ? Lo2(br2(e5), t3) : function(n3) {
        var r3 = kr2(n3, e5);
        return r3 === void 0 && r3 === t3 ? Vo2(n3, e5) : No2(t3, r3, 3);
      };
    };
    var Ho2 = function(e5) {
      return function(t3) {
        return t3 == null ? void 0 : t3[e5];
      };
    };
    var Wo2 = function(e5) {
      return function(t3) {
        return wr2(t3, e5);
      };
    };
    var qo2 = function(e5) {
      return Nn2(e5) ? Ho2(br2(e5)) : Wo2(e5);
    };
    var Ko2 = function(e5) {
      return typeof e5 == "function" ? e5 : e5 == null ? ct2 : typeof e5 == "object" ? Ke2(e5) ? Uo2(e5[0], e5[1]) : Fo2(e5) : qo2(e5);
    };
    var Yo2 = function(e5, t3, n3, r3) {
      for (var o3 = -1, a3 = e5 == null ? 0 : e5.length; ++o3 < a3; ) {
        var i3 = e5[o3];
        t3(r3, i3, n3(i3), e5);
      }
      return r3;
    };
    var Xo2 = function(e5) {
      return function(t3, n3, r3) {
        for (var o3 = -1, a3 = Object(t3), i3 = r3(t3), s3 = i3.length; s3--; ) {
          var l3 = i3[e5 ? s3 : ++o3];
          if (n3(a3[l3], l3, a3) === false)
            break;
        }
        return t3;
      };
    }();
    var Go2 = function(e5, t3) {
      return e5 && Xo2(e5, t3, In2);
    };
    var Qo2 = function(e5, t3) {
      return function(n3, r3) {
        if (n3 == null)
          return n3;
        if (!Zt2(n3))
          return e5(n3, r3);
        for (var o3 = n3.length, a3 = t3 ? o3 : -1, i3 = Object(n3); (t3 ? a3-- : ++a3 < o3) && r3(i3[a3], a3, i3) !== false; )
          ;
        return n3;
      };
    }(Go2);
    var Jo2 = function(e5, t3, n3, r3) {
      return Qo2(e5, function(e6, o3, a3) {
        t3(r3, e6, n3(e6), a3);
      }), r3;
    };
    var Zo2 = function(e5, t3) {
      return function(n3, r3) {
        var o3 = Ke2(n3) ? Yo2 : Jo2, a3 = t3 ? t3() : {};
        return o3(n3, e5, Ko2(r3), a3);
      };
    }, ea2 = function() {
      return Re2.Date.now();
    }, ta2 = Math.max, na2 = Math.min;
    var ra2 = function(e5, t3, n3) {
      var r3, o3, a3, i3, s3, l3, u3 = 0, c3 = false, d2 = false, f2 = true;
      if (typeof e5 != "function")
        throw new TypeError("Expected a function");
      function p2(t4) {
        var n4 = r3, a4 = o3;
        return r3 = o3 = void 0, u3 = t4, i3 = e5.apply(a4, n4);
      }
      function h3(e6) {
        return u3 = e6, s3 = setTimeout(v3, t3), c3 ? p2(e6) : i3;
      }
      function m3(e6) {
        var n4 = e6 - l3;
        return l3 === void 0 || n4 >= t3 || n4 < 0 || d2 && e6 - u3 >= a3;
      }
      function v3() {
        var e6 = ea2();
        if (m3(e6))
          return g2(e6);
        s3 = setTimeout(v3, function(e7) {
          var n4 = t3 - (e7 - l3);
          return d2 ? na2(n4, a3 - (e7 - u3)) : n4;
        }(e6));
      }
      function g2(e6) {
        return s3 = void 0, f2 && r3 ? p2(e6) : (r3 = o3 = void 0, i3);
      }
      function y3() {
        var e6 = ea2(), n4 = m3(e6);
        if (r3 = arguments, o3 = this, l3 = e6, n4) {
          if (s3 === void 0)
            return h3(l3);
          if (d2)
            return clearTimeout(s3), s3 = setTimeout(v3, t3), p2(l3);
        }
        return s3 === void 0 && (s3 = setTimeout(v3, t3)), i3;
      }
      return t3 = it2(t3) || 0, tt2(n3) && (c3 = !!n3.leading, a3 = (d2 = "maxWait" in n3) ? ta2(it2(n3.maxWait) || 0, t3) : a3, f2 = "trailing" in n3 ? !!n3.trailing : f2), y3.cancel = function() {
        s3 !== void 0 && clearTimeout(s3), u3 = 0, r3 = l3 = o3 = s3 = void 0;
      }, y3.flush = function() {
        return s3 === void 0 ? i3 : g2(ea2());
      }, y3;
    };
    var oa2 = function(e5, t3, n3) {
      for (var r3 = -1, o3 = e5 == null ? 0 : e5.length; ++r3 < o3; )
        if (n3(t3, e5[r3]))
          return true;
      return false;
    };
    var aa2 = function(e5) {
      var t3 = e5 == null ? 0 : e5.length;
      return t3 ? e5[t3 - 1] : void 0;
    }, ia2 = Math.max;
    var sa2 = function(e5, t3, n3) {
      var r3 = e5 == null ? 0 : e5.length;
      if (!r3)
        return -1;
      var o3 = n3 == null ? 0 : ut2(n3);
      return o3 < 0 && (o3 = ia2(r3 + o3, 0)), Lt2(e5, Ko2(t3), o3);
    }, la2 = Math.max, ua2 = Math.min;
    var ca2 = function(e5, t3, n3) {
      var r3 = e5 == null ? 0 : e5.length;
      if (!r3)
        return -1;
      var o3 = r3 - 1;
      return n3 !== void 0 && (o3 = ut2(n3), o3 = n3 < 0 ? la2(r3 + o3, 0) : ua2(o3, r3 - 1)), Lt2(e5, Ko2(t3), o3, true);
    };
    var da2 = function(e5, t3) {
      var n3 = -1, r3 = Zt2(e5) ? Array(e5.length) : [];
      return Qo2(e5, function(e6, o3, a3) {
        r3[++n3] = t3(e6, o3, a3);
      }), r3;
    }, fa2 = Math.max, pa2 = Math.min;
    var ha2 = function(e5, t3, n3) {
      return e5 >= pa2(t3, n3) && e5 < fa2(t3, n3);
    };
    var ma2 = function(e5, t3, n3) {
      return t3 = lt2(t3), n3 === void 0 ? (n3 = t3, t3 = 0) : n3 = lt2(n3), e5 = it2(e5), ha2(e5, t3, n3);
    };
    var va2 = function(e5) {
      return typeof e5 == "number" && e5 == ut2(e5);
    }, ga2 = Zo2(function(e5, t3, n3) {
      Wt2(e5, n3, t3);
    }), ya = ga2;
    var ba = function(e5, t3) {
      var n3 = {};
      return t3 = Ko2(t3), Go2(e5, function(e6, r3, o3) {
        Wt2(n3, r3, t3(e6, r3, o3));
      }), n3;
    };
    var wa = function(e5, t3, n3, r3) {
      if (!tt2(e5))
        return e5;
      for (var o3 = -1, a3 = (t3 = yr2(t3, e5)).length, i3 = a3 - 1, s3 = e5; s3 != null && ++o3 < a3; ) {
        var l3 = br2(t3[o3]), u3 = n3;
        if (l3 === "__proto__" || l3 === "constructor" || l3 === "prototype")
          return e5;
        if (o3 != i3) {
          var c3 = s3[l3];
          (u3 = r3 ? r3(c3, l3, s3) : void 0) === void 0 && (u3 = tt2(c3) ? c3 : Ht2(t3[o3 + 1]) ? [] : {});
        }
        Yt2(s3, l3, u3), s3 = s3[l3];
      }
      return e5;
    };
    var ka2 = function(e5, t3) {
      var n3 = e5.length;
      for (e5.sort(t3); n3--; )
        e5[n3] = e5[n3].value;
      return e5;
    };
    var xa2 = function(e5, t3) {
      if (e5 !== t3) {
        var n3 = e5 !== void 0, r3 = e5 === null, o3 = e5 == e5, a3 = We2(e5), i3 = t3 !== void 0, s3 = t3 === null, l3 = t3 == t3, u3 = We2(t3);
        if (!s3 && !u3 && !a3 && e5 > t3 || a3 && i3 && l3 && !s3 && !u3 || r3 && i3 && l3 || !n3 && l3 || !o3)
          return 1;
        if (!r3 && !a3 && !u3 && e5 < t3 || u3 && n3 && o3 && !r3 && !a3 || s3 && n3 && o3 || !i3 && o3 || !l3)
          return -1;
      }
      return 0;
    };
    var Sa2 = function(e5, t3, n3) {
      for (var r3 = -1, o3 = e5.criteria, a3 = t3.criteria, i3 = o3.length, s3 = n3.length; ++r3 < i3; ) {
        var l3 = xa2(o3[r3], a3[r3]);
        if (l3)
          return r3 >= s3 ? l3 : l3 * (n3[r3] == "desc" ? -1 : 1);
      }
      return e5.index - t3.index;
    };
    var _a2 = function(e5, t3, n3) {
      t3 = t3.length ? qe2(t3, function(e6) {
        return Ke2(e6) ? function(t4) {
          return wr2(t4, e6.length === 1 ? e6[0] : e6);
        } : e6;
      }) : [ct2];
      var r3 = -1;
      t3 = qe2(t3, yn2(Ko2));
      var o3 = da2(e5, function(e6, n4, o4) {
        return { criteria: qe2(t3, function(t4) {
          return t4(e6);
        }), index: ++r3, value: e6 };
      });
      return ka2(o3, function(e6, t4) {
        return Sa2(e6, t4, n3);
      });
    };
    var Ea2 = function(e5, t3, n3, r3) {
      for (var o3 = n3 - 1, a3 = e5.length; ++o3 < a3; )
        if (r3(e5[o3], t3))
          return o3;
      return -1;
    }, Pa2 = Array.prototype.splice;
    var Ca2 = function(e5, t3, n3, r3) {
      var o3 = r3 ? Ea2 : Bt2, a3 = -1, i3 = t3.length, s3 = e5;
      for (e5 === t3 && (t3 = Tt2(t3)), n3 && (s3 = qe2(e5, yn2(n3))); ++a3 < i3; )
        for (var l3 = 0, u3 = t3[a3], c3 = n3 ? n3(u3) : u3; (l3 = o3(s3, c3, l3, r3)) > -1; )
          s3 !== e5 && Pa2.call(s3, l3, 1), Pa2.call(e5, l3, 1);
      return e5;
    };
    var ja2 = Qt2(function(e5, t3) {
      return e5 && e5.length && t3 && t3.length ? Ca2(e5, t3) : e5;
    }), Oa2 = Ar2("round");
    var Ta2 = function(e5, t3, n3) {
      return e5 == null ? e5 : wa(e5, t3, n3);
    }, Ia2 = Qt2(function(e5, t3) {
      if (e5 == null)
        return [];
      var n3 = t3.length;
      return n3 > 1 && en2(e5, t3[0], t3[1]) ? t3 = [] : n3 > 2 && en2(t3[0], t3[1], t3[2]) && (t3 = [t3[0]]), _a2(e5, Er2(t3, 1), []);
    }), Da2 = eo2 && 1 / So2(new eo2([, -0]))[1] == 1 / 0 ? function(e5) {
      return new eo2(e5);
    } : Ot2;
    var Ra2 = function(e5, t3, n3) {
      var r3 = -1, o3 = Vt2, a3 = e5.length, i3 = true, s3 = [], l3 = s3;
      if (n3)
        i3 = false, o3 = oa2;
      else if (a3 >= 200) {
        var u3 = t3 ? null : Da2(e5);
        if (u3)
          return So2(u3);
        i3 = false, o3 = wo2, l3 = new yo2();
      } else
        l3 = t3 ? [] : s3;
      e:
        for (; ++r3 < a3; ) {
          var c3 = e5[r3], d2 = t3 ? t3(c3) : c3;
          if (c3 = n3 || c3 !== 0 ? c3 : 0, i3 && d2 == d2) {
            for (var f2 = l3.length; f2--; )
              if (l3[f2] === d2)
                continue e;
            t3 && l3.push(d2), s3.push(c3);
          } else
            o3(l3, d2, n3) || (l3 !== s3 && l3.push(d2), s3.push(c3));
        }
      return s3;
    };
    var Na2 = function(e5) {
      return e5 && e5.length ? Ra2(e5) : [];
    }, Aa2 = w2(x2()), za2 = w2(je.exports), Ma2 = w2(ht.exports), La2 = { log: console.log };
    function Fa2(e5, t3, n3) {
      const r3 = (0, za2.useCallback)(e5, t3), o3 = (0, za2.useRef)(null);
      o3.current ? o3.current.set(r3) : o3.current = new Oe2.Box(r3);
      return function(e6, t4) {
        const n4 = function(e7) {
          const [, t5] = (0, za2.useState)(0);
          return (0, za2.useCallback)(() => {
            e7 && La2.log(e7, "forceUpdate", { trace: new Error() }), t5((e8) => e8 + 1);
          }, []);
        }(t4), r4 = (0, za2.useRef)(void 0);
        r4.current || (Ba++, r4.current = { queueItem: { debugLabel: t4, order: Ba, runUpdate: () => {
          r4.current.unmounted || n4();
        } }, unmounted: false });
        const o4 = (0, za2.useCallback)(() => {
          var e7;
          e7 = r4.current.queueItem, Wa2(e7), Ka2();
        }, []);
        (0, za2.useLayoutEffect)(() => {
          const t5 = e6.changesWithoutValues().tap(() => {
            o4();
          });
          return a3.current !== e6.getValue() && o4(), t5;
        }, [e6]), (0, za2.useLayoutEffect)(() => function() {
          r4.current.unmounted = true, qa2(r4.current.queueItem);
        }, []);
        const a3 = (0, za2.useRef)(void 0), i3 = r4.current.queueItem;
        Ua2.has(i3) && Va[0] !== r4.current.queueItem || (qa2(i3), a3.current = e6.getValue());
        return a3.current;
      }((0, za2.useMemo)(() => (0, Te2.prism)(() => o3.current.derivation.getValue()()), []), n3);
    }
    var $a2 = (e5, t3) => Fa2(() => (0, Te2.val)(e5), [e5], t3), Ba = 0, Va = [], Ua2 = /* @__PURE__ */ new Set(), Ha2 = false, Wa2 = (e5) => {
      if (!Ua2.has(e5))
        if (Ua2.add(e5), Va.length === 0)
          Va.push(e5);
        else {
          const t3 = sa2(Va, (t4) => t4.order >= e5.order);
          if (t3 === -1)
            Va.push(e5);
          else {
            Va[t3].order > e5.order && Va.splice(t3, 0, e5);
          }
        }
    }, qa2 = (e5) => {
      if (!Ua2.has(e5))
        return;
      Ua2.delete(e5);
      const t3 = sa2(Va, (t4) => t4 === e5);
      Va.splice(t3, 1);
    };
    function Ka2() {
      Ha2 || (Ha2 = true, (0, Aa2.default)(() => {
        let e5 = 0;
        for (; Va.length > 0; ) {
          if (e5++, e5 === 4) {
            setTimeout(Ka2, 1);
            break;
          }
          (0, Ma2.unstable_batchedUpdates)(() => {
            for (const e6 of Va)
              e6.runUpdate();
          }, 1);
        }
        Ha2 = false;
      }));
    }
    var Ya2 = w2(g), Xa2 = w2(je.exports), Ga2 = w2(yh), Qa2 = w2(je.exports), Ja2 = w2(yh);
    function Za2() {
      return Za2 = Object.assign || function(e5) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var n3 = arguments[t3];
          for (var r3 in n3)
            Object.prototype.hasOwnProperty.call(n3, r3) && (e5[r3] = n3[r3]);
        }
        return e5;
      }, Za2.apply(this, arguments);
    }
    function ei2(e5) {
      if (e5 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e5;
    }
    function ti2(e5, t3) {
      return (ti2 = Object.setPrototypeOf || function(e6, t4) {
        return e6.__proto__ = t4, e6;
      })(e5, t3);
    }
    function ni2(e5) {
      return (ni2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e6) {
        return e6.__proto__ || Object.getPrototypeOf(e6);
      })(e5);
    }
    function ri2() {
      if (typeof Reflect == "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy == "function")
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (e5) {
        return false;
      }
    }
    function oi2(e5, t3, n3) {
      return (oi2 = ri2() ? Reflect.construct : function(e6, t4, n4) {
        var r3 = [null];
        r3.push.apply(r3, t4);
        var o3 = new (Function.bind.apply(e6, r3))();
        return n4 && ti2(o3, n4.prototype), o3;
      }).apply(null, arguments);
    }
    function ai2(e5) {
      var t3 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return ai2 = function(e6) {
        if (e6 === null || (n3 = e6, Function.toString.call(n3).indexOf("[native code]") === -1))
          return e6;
        var n3;
        if (typeof e6 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (t3 !== void 0) {
          if (t3.has(e6))
            return t3.get(e6);
          t3.set(e6, r3);
        }
        function r3() {
          return oi2(e6, arguments, ni2(this).constructor);
        }
        return r3.prototype = Object.create(e6.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), ti2(r3, e6);
      }, ai2(e5);
    }
    var ii2 = { 1: "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n", 2: "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n", 3: "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n", 4: "Couldn't generate valid rgb string from %s, it returned %s.\n\n", 5: "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n", 6: "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n", 7: "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n", 8: "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n", 9: "Please provide a number of steps to the modularScale helper.\n\n", 10: "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n", 11: 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n', 12: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n', 13: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n', 14: 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n', 15: 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n', 16: "You must provide a template to this method.\n\n", 17: "You passed an unsupported selector state to this method.\n\n", 18: "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n", 19: "fromSize and toSize must be provided as stringified numbers with the same units.\n\n", 20: "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n", 21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n", 22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n", 23: "fontFace expects a name of a font-family.\n\n", 24: "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n", 25: "fontFace expects localFonts to be an array.\n\n", 26: "fontFace expects fileFormats to be an array.\n\n", 27: "radialGradient requries at least 2 color-stops to properly render.\n\n", 28: "Please supply a filename to retinaImage() as the first argument.\n\n", 29: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n", 30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n", 31: "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n", 32: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n", 33: "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n", 34: "borderRadius expects a radius value as a string or number as the second argument.\n\n", 35: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n', 36: "Property must be a string value.\n\n", 37: "Syntax Error at %s.\n\n", 38: "Formula contains a function that needs parentheses at %s.\n\n", 39: "Formula is missing closing parenthesis at %s.\n\n", 40: "Formula has too many closing parentheses at %s.\n\n", 41: "All values in a formula must have the same unit or be unitless.\n\n", 42: "Please provide a number of steps to the modularScale helper.\n\n", 43: "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n", 44: "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n", 45: "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n", 46: "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n", 47: "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n", 48: "fromSize and toSize must be provided as stringified numbers with the same units.\n\n", 49: "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n", 50: "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n", 51: "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n", 52: "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n", 53: "fontFace expects localFonts to be an array.\n\n", 54: "fontFace expects fileFormats to be an array.\n\n", 55: "fontFace expects a name of a font-family.\n\n", 56: "linearGradient requries at least 2 color-stops to properly render.\n\n", 57: "radialGradient requries at least 2 color-stops to properly render.\n\n", 58: "Please supply a filename to retinaImage() as the first argument.\n\n", 59: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n", 60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n", 61: "Property must be a string value.\n\n", 62: "borderRadius expects a radius value as a string or number as the second argument.\n\n", 63: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n', 64: "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n", 65: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n", 66: "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n", 67: "You must provide a template to this method.\n\n", 68: "You passed an unsupported selector state to this method.\n\n", 69: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n', 70: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n', 71: 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n', 72: 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n', 73: "Please provide a valid CSS variable.\n\n", 74: "CSS variable not found and no default was provided.\n\n", 75: "important requires a valid style object, got a %s instead.\n\n", 76: "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n", 77: 'remToPx expects a value in "rem" but you provided it in "%s".\n\n', 78: 'base must be set in "px" or "%" but you set it in "%s".\n' };
    function si2() {
      for (var e5 = arguments.length, t3 = new Array(e5), n3 = 0; n3 < e5; n3++)
        t3[n3] = arguments[n3];
      var r3, o3 = t3[0], a3 = [];
      for (r3 = 1; r3 < t3.length; r3 += 1)
        a3.push(t3[r3]);
      return a3.forEach(function(e6) {
        o3 = o3.replace(/%[a-z]/, e6);
      }), o3;
    }
    var li2 = function(e5) {
      var t3, n3;
      function r3(t4) {
        for (var n4 = arguments.length, r4 = new Array(n4 > 1 ? n4 - 1 : 0), o3 = 1; o3 < n4; o3++)
          r4[o3 - 1] = arguments[o3];
        return ei2(e5.call(this, si2.apply(void 0, [ii2[t4]].concat(r4))) || this);
      }
      return n3 = e5, (t3 = r3).prototype = Object.create(n3.prototype), t3.prototype.constructor = t3, ti2(t3, n3), r3;
    }(ai2(Error));
    var ui2 = ["Top", "Right", "Bottom", "Left"];
    function ci2(e5, t3) {
      if (!e5)
        return t3.toLowerCase();
      var n3 = e5.split("-");
      if (n3.length > 1)
        return n3.splice(1, 0, t3), n3.reduce(function(e6, t4) {
          return "" + e6 + ((n4 = t4).charAt(0).toUpperCase() + n4.slice(1));
          var n4;
        });
      var r3 = e5.replace(/([a-z])([A-Z])/g, "$1" + t3 + "$2");
      return e5 === r3 ? "" + e5 + t3 : r3;
    }
    function di2(e5, t3) {
      for (var n3 = {}, r3 = 0; r3 < t3.length; r3 += 1)
        (t3[r3] || t3[r3] === 0) && (n3[ci2(e5, ui2[r3])] = t3[r3]);
      return n3;
    }
    function fi2(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      var o3 = n3[0], a3 = n3[1], i3 = a3 === void 0 ? o3 : a3, s3 = n3[2], l3 = s3 === void 0 ? o3 : s3, u3 = n3[3], c3 = u3 === void 0 ? i3 : u3, d2 = [o3, i3, l3, c3];
      return di2(e5, d2);
    }
    function pi2(e5) {
      return Math.round(255 * e5);
    }
    function hi2(e5, t3, n3) {
      return pi2(e5) + "," + pi2(t3) + "," + pi2(n3);
    }
    function mi2(e5, t3, n3, r3) {
      if (r3 === void 0 && (r3 = hi2), t3 === 0)
        return r3(n3, n3, n3);
      var o3 = (e5 % 360 + 360) % 360 / 60, a3 = (1 - Math.abs(2 * n3 - 1)) * t3, i3 = a3 * (1 - Math.abs(o3 % 2 - 1)), s3 = 0, l3 = 0, u3 = 0;
      o3 >= 0 && o3 < 1 ? (s3 = a3, l3 = i3) : o3 >= 1 && o3 < 2 ? (s3 = i3, l3 = a3) : o3 >= 2 && o3 < 3 ? (l3 = a3, u3 = i3) : o3 >= 3 && o3 < 4 ? (l3 = i3, u3 = a3) : o3 >= 4 && o3 < 5 ? (s3 = i3, u3 = a3) : o3 >= 5 && o3 < 6 && (s3 = a3, u3 = i3);
      var c3 = n3 - a3 / 2;
      return r3(s3 + c3, l3 + c3, u3 + c3);
    }
    var vi2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "639", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
    var gi2 = /^#[a-fA-F0-9]{6}$/, yi2 = /^#[a-fA-F0-9]{8}$/, bi2 = /^#[a-fA-F0-9]{3}$/, wi2 = /^#[a-fA-F0-9]{4}$/, ki2 = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i, xi2 = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i, Si2 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, _i2 = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
    function Ei2(e5) {
      if (typeof e5 != "string")
        throw new li2(3);
      var t3 = function(e6) {
        if (typeof e6 != "string")
          return e6;
        var t4 = e6.toLowerCase();
        return vi2[t4] ? "#" + vi2[t4] : e6;
      }(e5);
      if (t3.match(gi2))
        return { red: parseInt("" + t3[1] + t3[2], 16), green: parseInt("" + t3[3] + t3[4], 16), blue: parseInt("" + t3[5] + t3[6], 16) };
      if (t3.match(yi2)) {
        var n3 = parseFloat((parseInt("" + t3[7] + t3[8], 16) / 255).toFixed(2));
        return { red: parseInt("" + t3[1] + t3[2], 16), green: parseInt("" + t3[3] + t3[4], 16), blue: parseInt("" + t3[5] + t3[6], 16), alpha: n3 };
      }
      if (t3.match(bi2))
        return { red: parseInt("" + t3[1] + t3[1], 16), green: parseInt("" + t3[2] + t3[2], 16), blue: parseInt("" + t3[3] + t3[3], 16) };
      if (t3.match(wi2)) {
        var r3 = parseFloat((parseInt("" + t3[4] + t3[4], 16) / 255).toFixed(2));
        return { red: parseInt("" + t3[1] + t3[1], 16), green: parseInt("" + t3[2] + t3[2], 16), blue: parseInt("" + t3[3] + t3[3], 16), alpha: r3 };
      }
      var o3 = ki2.exec(t3);
      if (o3)
        return { red: parseInt("" + o3[1], 10), green: parseInt("" + o3[2], 10), blue: parseInt("" + o3[3], 10) };
      var a3 = xi2.exec(t3.substring(0, 50));
      if (a3)
        return { red: parseInt("" + a3[1], 10), green: parseInt("" + a3[2], 10), blue: parseInt("" + a3[3], 10), alpha: parseFloat("" + a3[4]) };
      var i3 = Si2.exec(t3);
      if (i3) {
        var s3 = "rgb(" + mi2(parseInt("" + i3[1], 10), parseInt("" + i3[2], 10) / 100, parseInt("" + i3[3], 10) / 100) + ")", l3 = ki2.exec(s3);
        if (!l3)
          throw new li2(4, t3, s3);
        return { red: parseInt("" + l3[1], 10), green: parseInt("" + l3[2], 10), blue: parseInt("" + l3[3], 10) };
      }
      var u3 = _i2.exec(t3.substring(0, 50));
      if (u3) {
        var c3 = "rgb(" + mi2(parseInt("" + u3[1], 10), parseInt("" + u3[2], 10) / 100, parseInt("" + u3[3], 10) / 100) + ")", d2 = ki2.exec(c3);
        if (!d2)
          throw new li2(4, t3, c3);
        return { red: parseInt("" + d2[1], 10), green: parseInt("" + d2[2], 10), blue: parseInt("" + d2[3], 10), alpha: parseFloat("" + u3[4]) };
      }
      throw new li2(5);
    }
    function Pi2(e5) {
      return function(e6) {
        var t3, n3 = e6.red / 255, r3 = e6.green / 255, o3 = e6.blue / 255, a3 = Math.max(n3, r3, o3), i3 = Math.min(n3, r3, o3), s3 = (a3 + i3) / 2;
        if (a3 === i3)
          return e6.alpha !== void 0 ? { hue: 0, saturation: 0, lightness: s3, alpha: e6.alpha } : { hue: 0, saturation: 0, lightness: s3 };
        var l3 = a3 - i3, u3 = s3 > 0.5 ? l3 / (2 - a3 - i3) : l3 / (a3 + i3);
        switch (a3) {
          case n3:
            t3 = (r3 - o3) / l3 + (r3 < o3 ? 6 : 0);
            break;
          case r3:
            t3 = (o3 - n3) / l3 + 2;
            break;
          default:
            t3 = (n3 - r3) / l3 + 4;
        }
        return t3 *= 60, e6.alpha !== void 0 ? { hue: t3, saturation: u3, lightness: s3, alpha: e6.alpha } : { hue: t3, saturation: u3, lightness: s3 };
      }(Ei2(e5));
    }
    var Ci2 = function(e5) {
      return e5.length === 7 && e5[1] === e5[2] && e5[3] === e5[4] && e5[5] === e5[6] ? "#" + e5[1] + e5[3] + e5[5] : e5;
    };
    function ji2(e5) {
      var t3 = e5.toString(16);
      return t3.length === 1 ? "0" + t3 : t3;
    }
    function Oi2(e5) {
      return ji2(Math.round(255 * e5));
    }
    function Ti2(e5, t3, n3) {
      return Ci2("#" + Oi2(e5) + Oi2(t3) + Oi2(n3));
    }
    function Ii2(e5, t3, n3) {
      return mi2(e5, t3, n3, Ti2);
    }
    function Di2(e5, t3, n3) {
      if (typeof e5 == "number" && typeof t3 == "number" && typeof n3 == "number")
        return Ci2("#" + ji2(e5) + ji2(t3) + ji2(n3));
      if (typeof e5 == "object" && t3 === void 0 && n3 === void 0)
        return Ci2("#" + ji2(e5.red) + ji2(e5.green) + ji2(e5.blue));
      throw new li2(6);
    }
    function Ri2(e5, t3, n3, r3) {
      if (typeof e5 == "string" && typeof t3 == "number") {
        var o3 = Ei2(e5);
        return "rgba(" + o3.red + "," + o3.green + "," + o3.blue + "," + t3 + ")";
      }
      if (typeof e5 == "number" && typeof t3 == "number" && typeof n3 == "number" && typeof r3 == "number")
        return r3 >= 1 ? Di2(e5, t3, n3) : "rgba(" + e5 + "," + t3 + "," + n3 + "," + r3 + ")";
      if (typeof e5 == "object" && t3 === void 0 && n3 === void 0 && r3 === void 0)
        return e5.alpha >= 1 ? Di2(e5.red, e5.green, e5.blue) : "rgba(" + e5.red + "," + e5.green + "," + e5.blue + "," + e5.alpha + ")";
      throw new li2(7);
    }
    function Ni2(e5) {
      if (typeof e5 != "object")
        throw new li2(8);
      if (function(e6) {
        return typeof e6.red == "number" && typeof e6.green == "number" && typeof e6.blue == "number" && typeof e6.alpha == "number";
      }(e5))
        return Ri2(e5);
      if (function(e6) {
        return typeof e6.red == "number" && typeof e6.green == "number" && typeof e6.blue == "number" && (typeof e6.alpha != "number" || e6.alpha === void 0);
      }(e5))
        return Di2(e5);
      if (function(e6) {
        return typeof e6.hue == "number" && typeof e6.saturation == "number" && typeof e6.lightness == "number" && typeof e6.alpha == "number";
      }(e5))
        return function(e6, t3, n3, r3) {
          if (typeof e6 == "number" && typeof t3 == "number" && typeof n3 == "number" && typeof r3 == "number")
            return r3 >= 1 ? Ii2(e6, t3, n3) : "rgba(" + mi2(e6, t3, n3) + "," + r3 + ")";
          if (typeof e6 == "object" && t3 === void 0 && n3 === void 0 && r3 === void 0)
            return e6.alpha >= 1 ? Ii2(e6.hue, e6.saturation, e6.lightness) : "rgba(" + mi2(e6.hue, e6.saturation, e6.lightness) + "," + e6.alpha + ")";
          throw new li2(2);
        }(e5);
      if (function(e6) {
        return typeof e6.hue == "number" && typeof e6.saturation == "number" && typeof e6.lightness == "number" && (typeof e6.alpha != "number" || e6.alpha === void 0);
      }(e5))
        return function(e6, t3, n3) {
          if (typeof e6 == "number" && typeof t3 == "number" && typeof n3 == "number")
            return Ii2(e6, t3, n3);
          if (typeof e6 == "object" && t3 === void 0 && n3 === void 0)
            return Ii2(e6.hue, e6.saturation, e6.lightness);
          throw new li2(1);
        }(e5);
      throw new li2(8);
    }
    function Ai2(e5, t3, n3) {
      return function() {
        var r3 = n3.concat(Array.prototype.slice.call(arguments));
        return r3.length >= t3 ? e5.apply(this, r3) : Ai2(e5, t3, r3);
      };
    }
    function zi2(e5) {
      return Ai2(e5, e5.length, []);
    }
    function Mi2(e5, t3, n3) {
      return Math.max(e5, Math.min(t3, n3));
    }
    function Li2(e5, t3) {
      if (t3 === "transparent")
        return t3;
      var n3 = Pi2(t3);
      return Ni2(Za2({}, n3, { lightness: Mi2(0, 1, n3.lightness - parseFloat(e5)) }));
    }
    var Fi2 = zi2(Li2);
    function $i2(e5, t3) {
      if (t3 === "transparent")
        return t3;
      var n3 = Pi2(t3);
      return Ni2(Za2({}, n3, { lightness: Mi2(0, 1, n3.lightness + parseFloat(e5)) }));
    }
    var Bi2 = zi2($i2);
    function Vi2(e5, t3) {
      if (t3 === "transparent")
        return t3;
      var n3 = Ei2(t3);
      return Ri2(Za2({}, n3, { alpha: Mi2(0, 1, +(100 * (typeof n3.alpha == "number" ? n3.alpha : 1) - 100 * parseFloat(e5)).toFixed(2) / 100) }));
    }
    var Ui2 = zi2(Vi2), Hi2 = ["absolute", "fixed", "relative", "static", "sticky"];
    function Wi2(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      return Hi2.indexOf(e5) >= 0 && e5 ? Za2({}, fi2.apply(void 0, [""].concat(n3)), { position: e5 }) : fi2.apply(void 0, ["", e5].concat(n3));
    }
    var qi2 = w2(yh).css`
  #pointer-root & {
    pointer-events: none;
  }
  #pointer-root.normal & {
    pointer-events: auto;
  }
`, Ki2 = { panel: { bg: "#282b2f", head: { title: { color: "#bbb" }, punctuation: { color: "#808080" } }, body: { compoudThing: { label: { get color() {
      return Bi2(0.6, Ki2.panel.bg);
    } } } } } }, Yi2 = w2(yh), Xi2 = { get outlinePanel() {
      return 1;
    }, get propsPanel() {
      return Xi2.outlinePanel;
    }, get sequenceEditorPanel() {
      return this.outlinePanel - 1;
    }, get toolbar() {
      return this.outlinePanel + 1;
    }, get pluginPanes() {
      return this.sequenceEditorPanel - 1;
    } }, Gi2 = Ki2.panel.bg, Qi2 = Yi2.default.span`
  white-space: nowrap;
`, Ji2 = Yi2.default.span`
  white-space: nowrap;
  color: ${Ki2.panel.head.punctuation.color};
`, Zi2 = Yi2.default.div`
  background: ${Gi2};
  flex-grow: 1;
  overflow-y: scroll;
  padding: 0;
`, es2 = Yi2.default.div`
  height: ${20}px;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  padding: 0 10px;
  position: relative;
  color: #adadadb3;
  border-bottom: 1px solid rgb(0 0 0 / 13%);
  background-color: #25272b;
  font-size: 10px;
  font-weight: 500;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
`, ts2 = w2(g), ns2 = w2(je.exports), rs2 = w2(yh), os2 = w2(je.exports), as2 = w2(je.exports), is2 = w2(je.exports), ss2 = w2(je.exports), ls2 = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, us2 = ss2.default.createContext && ss2.default.createContext(ls2), cs2 = function() {
      return cs2 = Object.assign || function(e5) {
        for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++)
          for (var o3 in t3 = arguments[n3])
            Object.prototype.hasOwnProperty.call(t3, o3) && (e5[o3] = t3[o3]);
        return e5;
      }, cs2.apply(this, arguments);
    };
    function ds2(e5) {
      return e5 && e5.map(function(e6, t3) {
        return is2.default.createElement(e6.tag, cs2({ key: t3 }, e6.attr), ds2(e6.child));
      });
    }
    function fs2(e5) {
      return function(t3) {
        return is2.default.createElement(ps2, cs2({ attr: cs2({}, e5.attr) }, t3), ds2(e5.child));
      };
    }
    function ps2(e5) {
      var t3 = function(t4) {
        var n3, r3 = e5.attr, o3 = e5.size, a3 = e5.title, i3 = function(e6, t5) {
          var n4 = {};
          for (var r4 in e6)
            Object.prototype.hasOwnProperty.call(e6, r4) && t5.indexOf(r4) < 0 && (n4[r4] = e6[r4]);
          if (e6 != null && typeof Object.getOwnPropertySymbols == "function") {
            var o4 = 0;
            for (r4 = Object.getOwnPropertySymbols(e6); o4 < r4.length; o4++)
              t5.indexOf(r4[o4]) < 0 && Object.prototype.propertyIsEnumerable.call(e6, r4[o4]) && (n4[r4[o4]] = e6[r4[o4]]);
          }
          return n4;
        }(e5, ["attr", "size", "title"]), s3 = o3 || t4.size || "1em";
        return t4.className && (n3 = t4.className), e5.className && (n3 = (n3 ? n3 + " " : "") + e5.className), is2.default.createElement("svg", cs2({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, t4.attr, r3, i3, { className: n3, style: cs2(cs2({ color: e5.color || t4.color }, t4.style), e5.style), height: s3, width: s3, xmlns: "http://www.w3.org/2000/svg" }), a3 && is2.default.createElement("title", null, a3), e5.children);
      };
      return us2 !== void 0 ? is2.default.createElement(us2.Consumer, null, function(e6) {
        return t3(e6);
      }) : t3(ls2);
    }
    function hs2(e5) {
      return fs2({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" } }] })(e5);
    }
    function ms2(e5) {
      return fs2({ tag: "svg", attr: { viewBox: "0 0 8 16" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M5.5 3L7 4.5 3.25 8 7 11.5 5.5 13l-5-5 5-5z" } }] })(e5);
    }
    function vs2(e5) {
      return fs2({ tag: "svg", attr: { viewBox: "0 0 8 16" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M7.5 8l-5 5L1 11.5 4.75 8 1 4.5 2.5 3l5 5z" } }] })(e5);
    }
    function gs2(e5) {
      return fs2({ tag: "svg", attr: { version: "1.1", viewBox: "0 0 32 32" }, child: [{ tag: "path", attr: { d: "M16.957 6.062l-5.808 1.88 12.58 4.070v8.027l-8.383 2.711-7.074-2.287v-7.863l6.836 2.213 5.808-1.879-12.598-4.077-3.622 1.172v13.036l10.649 3.445 11.958-3.869v-13.23z" } }] })(e5);
    }
    function ys2(e5) {
      return fs2({ tag: "svg", attr: { fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 5l7 7-7 7" } }] })(e5);
    }
    function bs2(e5) {
      return fs2({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "none" }, child: [{ tag: "path", attr: { d: "M6 9.65685L7.41421 11.0711L11.6569 6.82843L15.8995 11.0711L17.3137 9.65685L11.6569 4L6 9.65685Z", fill: "currentColor" } }, { tag: "path", attr: { d: "M6 14.4433L7.41421 13.0291L11.6569 17.2717L15.8995 13.0291L17.3137 14.4433L11.6569 20.1001L6 14.4433Z", fill: "currentColor" } }] })(e5);
    }
    function ws2(e5) {
      return fs2({ tag: "svg", attr: { viewBox: "0 0 16 16", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M14 3v1H2V3h12zm-1 3v1H6V6h7zm0 3v1H5V9h8zm0 3v1H5v-1h8z" } }, { tag: "path", attr: { d: "M5 4h1v9H5z" } }] })(e5);
    }
    function ks2(e5) {
      return fs2({ tag: "svg", attr: { viewBox: "0 0 16 16", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M14 10.44l-.413.56H2.393L2 10.46 7.627 5h.827L14 10.44z" } }] })(e5);
    }
    var xs2 = w2(yh), Ss2 = () => {
    }, _s2 = xs2.default.li`
  margin: 0;
  padding: 0;
  list-style: none;
  display: flex;
  justify-content: flex-start;
  flex-direction: column;
  align-items: flex-start;
`, Es2 = xs2.default.div``, Ps2 = (0, xs2.default)(Es2)`
  padding-left: calc(4px + var(--depth) * 16px);
  padding-right: 8px;
  height: 28px;
  box-sizing: border-box;
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  pointer-events: none;
  white-space: nowrap;

  color: rgba(255, 255, 255, 0.75);
  --item-bg: ${"#3e4447"};
  --item-border-color: ${"#34343e"};

  &.descendant-is-selected {
    color: rgba(255, 255, 255, 0.9);

    --item-bg: #2e4244ed;
    --item-border-color: #254355;
  }

  &:hover {
    color: #fff;

    --item-bg: #1e5866;
    --item-border-color: #152f42;
  }

  &.selected {
    color: rgba(255, 255, 255, 0.9);

    --item-bg: #1e5866;
    --item-border-color: #152f42;
  }
`, Cs2 = xs2.css`
  font-weight: 500;
  font-size: 11px;
  & {
  }
`, js2 = xs2.default.span`
  ${Cs2};

  padding: 2px 8px;
  ${qi2};
  position: relative;
  display: flex;
  height: 17px;
  align-items: center;

  background-color: var(--item-bg);

  &:after {
    border: 1px solid var(--item-border-color);
    position: absolute;
    inset: 0px;
    display: block;
    content: ' ';
    z-index: -1;
    pointer-events: none;
    border-radius: 2px;
    box-sizing: border-box;
    box-shadow: 0px 3px 4px -1px rgba(0, 0, 0, 0.48);
  }

  // hit-zone
  &:before {
    position: absolute;
    inset: -1px -20px;
    display: block;
    content: ' ';
    z-index: 0;
    ${qi2};
  }
`, Os2 = xs2.default.span`
  width: 18px;
  box-sizing: border-box;
  height: 18px;
  margin-right: 4px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  opacity: 0.99;

  &:after {
    display: block;
    content: ' ';
    position: absolute;
    inset: 0px;
    z-index: -1;
    background-color: var(--item-bg);
    opacity: 0.6;
    border-radius: 2px;
  }
`, Ts2 = xs2.default.span`
  font-size: 9px;
  position: relative;
  display: block;
  transform: rotateZ(${(e5) => e5.isOpen ? 90 : 0}deg);
`, Is2 = xs2.default.ul`
  margin: 0;
  padding: 0;
  list-style: none;
`, Ds2 = ({ label: e5, children: t3, depth: n3, select: r3, selectionStatus: o3, labelDecoration: a3 }) => {
      const i3 = t3 !== void 0;
      return as2.default.createElement(_s2, { style: { "--depth": n3 } }, as2.default.createElement(Ps2, { className: o3, onClick: r3 != null ? r3 : Ss2 }, as2.default.createElement(Os2, null, i3 ? as2.default.createElement(Ts2, { isOpen: true }, as2.default.createElement(vs2, null)) : as2.default.createElement(gs2, null)), as2.default.createElement(js2, null, as2.default.createElement("span", null, e5)), a3), i3 && as2.default.createElement(Is2, null, t3));
    }, Rs2 = w2(g), Ns2 = () => {
      var e5;
      const t3 = (0, Rs2.val)(me2().projectsP), n3 = ((e5 = (0, Rs2.val)(me2().atomP.historic.panels.outlinePanel.selection)) != null ? e5 : []).map((e6) => {
        const n4 = t3[e6.projectId];
        if (!n4)
          return;
        if (e6.type === "Project")
          return n4;
        if (!(0, Rs2.val)(n4.sheetTemplatesP[e6.sheetId]))
          return;
        const r3 = As2(n4, e6.sheetId);
        if (!r3)
          return;
        if (e6.type === "Sheet")
          return r3;
        const o3 = (0, Rs2.val)(r3.objectsP[e6.objectKey]);
        return o3 || void 0;
      });
      return Na2(n3.filter((e6) => e6 !== void 0));
    }, As2 = (e5, t3) => {
      const n3 = me2().atomP.historic.projects.stateByProjectId[e5.address.projectId], r3 = (0, Rs2.val)(n3.stateBySheetId[t3].selectedInstanceId), o3 = (0, Rs2.val)(e5.sheetTemplatesP[t3]);
      if (o3) {
        if (r3)
          return (0, Rs2.val)(o3.instancesP[r3]);
        {
          const e6 = (0, Rs2.val)(o3.instancesP);
          return e6[Object.keys(e6)[0]];
        }
      }
    };
    var zs2 = w2(je.exports), Ms2 = w2(g), Ls2 = w2(je.exports), Fs2 = w2(yh), $s2 = w2(je.exports), Bs2 = w2(yh), Vs2 = w2(g), Us2 = w2(je.exports), Hs2 = w2(yh), Ws2 = w2(je.exports), qs2 = ({ sheetObject: e5, depth: t3 }) => {
      const n3 = Fa2(() => Ns2(), []);
      return Ws2.default.createElement(Ds2, { select: () => {
        me2().transaction(({ stateEditors: t4 }) => {
          t4.studio.historic.panels.outline.selection.set([e5]);
        });
      }, label: e5.address.objectKey, depth: t3, selectionStatus: n3.includes(e5) ? "selected" : "not-selected" });
    };
    Hs2.default.li`
  color: ${(e5) => e5.isSelected ? "white" : "hsl(1, 1%, 80%)"};
`;
    var Ks2 = ({ sheet: e5, depth: t3 }) => Fa2(() => {
      const n3 = (0, Vs2.val)(e5.objectsP), r3 = Object.entries(n3);
      return Us2.default.createElement(Us2.default.Fragment, null, r3.map(([e6, n4]) => Us2.default.createElement(qs2, { depth: t3, key: "objectPath(" + e6 + ")", sheetObject: n4 })));
    }, [e5, t3]), Ys2 = Bs2.default.div`
  display: flex;
`;
    Bs2.default.li`
  color: ${(e5) => e5.isSelected ? "white" : "hsl(1, 1%, 80%)"};
`;
    var Xs2 = Bs2.default.div``, Gs2 = ({ sheet: e5, depth: t3 }) => {
      const n3 = (0, $s2.useCallback)(() => {
        me2().transaction(({ stateEditors: t4 }) => {
          t4.studio.historic.panels.outline.selection.set([e5]);
        });
      }, [e5]);
      return Fa2(() => {
        const r3 = Ns2();
        return $s2.default.createElement(Ds2, { depth: t3, select: n3, selectionStatus: r3.some((t4) => t4 === e5) ? "selected" : r3.some((t4) => t4.type === "Theatre_SheetObject" && t4.sheet === e5) ? "descendant-is-selected" : "not-selected", label: $s2.default.createElement(Ys2, null, e5.address.sheetId, ": ", e5.address.sheetInstanceId) }, $s2.default.createElement(Xs2, null, $s2.default.createElement(Ks2, { depth: t3 + 1, sheet: e5, key: "objectList" + e5.address.sheetInstanceId })));
      }, [t3]);
    };
    Fs2.default.div`
  display: flex;
`, Fs2.default.li`
  color: ${(e5) => e5.isSelected ? "white" : "hsl(1, 1%, 80%)"};
`, Fs2.default.div``;
    var Qs2 = ({ sheetId: e5, depth: t3, project: n3 }) => Fa2(() => {
      const r3 = (0, Ms2.val)(n3.sheetTemplatesP[e5]);
      if (!r3)
        return Ls2.default.createElement(Ls2.default.Fragment, null);
      const o3 = (0, Ms2.val)(r3.instancesP);
      return Ls2.default.createElement(Ls2.default.Fragment, null, Object.entries(o3).map(([e6, n4]) => Ls2.default.createElement(Gs2, { key: n4.address.sheetInstanceId, sheet: n4, depth: t3 })));
    }, [t3, e5, n3]), Js2 = ({ project: e5, depth: t3 }) => Fa2(() => {
      if (!e5)
        return null;
      const n3 = function(e6) {
        return Object.keys((0, Rs2.val)(e6.sheetTemplatesP));
      }(e5);
      return zs2.default.createElement(zs2.default.Fragment, null, n3.map((n4) => zs2.default.createElement(Qs2, { depth: t3, sheetId: n4, key: `sheet-${n4}`, project: e5 })));
    }, [e5, t3]), Zs2 = w2(g), el2 = w2(yh).default.div`
  color: #ff6363;
  margin-left: 11px;
  background: #4c282d;
  padding: 2px 8px;
  border-radius: 2px;
  font-size: 10px;
  box-shadow: 0 2px 8px -4px black;
`, tl2 = ({ depth: e5, project: t3 }) => {
      const n3 = Fa2(() => Ns2(), []), r3 = Fa2(() => {
        const e6 = t3.address.projectId, n4 = (0, Zs2.val)(me2().atomP.ephemeral.coreByProject[e6].loadingState);
        return (n4 == null ? void 0 : n4.type) === "browserStateIsNotBasedOnDiskState";
      }, [t3]), o3 = (0, os2.useCallback)(() => {
        me2().transaction(({ stateEditors: e6 }) => {
          e6.studio.historic.panels.outline.selection.set([t3]);
        });
      }, [t3]);
      return os2.default.createElement(Ds2, { depth: e5, label: t3.address.projectId, labelDecoration: r3 ? os2.default.createElement(el2, null, "Has Conflicts") : null, children: os2.default.createElement(Js2, { project: t3, depth: e5 + 1 }), selectionStatus: n3.includes(t3) ? "selected" : n3.some((e6) => e6.address.projectId === t3.address.projectId) ? "descendant-is-selected" : "not-selected", select: o3 });
    }, nl2 = rs2.default.ul`
  list-style: none;
  margin: 0;
  padding: 0;
  padding-right: 4px;
`, rl2 = (e5) => Fa2(() => {
      const e6 = (0, ts2.val)(me2().projectsP);
      return ns2.default.createElement(nl2, null, Object.keys(e6).map((t3) => {
        const n3 = e6[t3];
        return ns2.default.createElement(tl2, { depth: 0, project: n3, key: `projectListItem-${t3}` });
      }));
    }, []), ol2 = w2(yh), al2 = w2(je.exports), il2 = w2(je.exports);
    function sl2(e5) {
      const t3 = (0, il2.useMemo)(() => {
        let t4 = e5;
        return { get current() {
          return t4;
        }, set current(e6) {
          t4 = e6, r3(e6);
        } };
      }, []), [n3, r3] = (0, il2.useState)(() => e5);
      return [t3, n3];
    }
    var ll2 = w2(je.exports), ul2 = w2(je.exports), cl2 = w2(je.exports), dl2 = w2(je.exports), fl2 = w2(je.exports), pl2 = w2(je.exports), hl2 = w2(je.exports), ml2 = w2(je.exports), vl2 = w2(je.exports), gl2 = function(e5) {
      (0, vl2.useEffect)(e5, []);
    }, yl2 = function(e5) {
      var t3 = (0, ml2.useRef)(e5);
      t3.current = e5, gl2(function() {
        return function() {
          return t3.current();
        };
      });
    }, bl2 = function(e5) {
      var t3 = (0, hl2.useRef)(0), n3 = (0, hl2.useState)(e5), r3 = n3[0], o3 = n3[1], a3 = (0, hl2.useCallback)(function(e6) {
        cancelAnimationFrame(t3.current), t3.current = requestAnimationFrame(function() {
          o3(e6);
        });
      }, []);
      return yl2(function() {
        cancelAnimationFrame(t3.current);
      }), [r3, a3];
    };
    var wl2 = typeof window != "undefined", kl2 = function(e5, t3) {
      e5 === void 0 && (e5 = 1 / 0), t3 === void 0 && (t3 = 1 / 0);
      var n3 = bl2({ width: wl2 ? window.innerWidth : e5, height: wl2 ? window.innerHeight : t3 }), r3 = n3[0], o3 = n3[1];
      return (0, pl2.useEffect)(function() {
        if (wl2) {
          var e6 = function() {
            o3({ width: window.innerWidth, height: window.innerHeight });
          };
          return function(e7) {
            for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
              t4[n4 - 1] = arguments[n4];
            e7 && e7.addEventListener && e7.addEventListener.apply(e7, t4);
          }(window, "resize", e6), function() {
            !function(e7) {
              for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
                t4[n4 - 1] = arguments[n4];
              e7 && e7.removeEventListener && e7.removeEventListener.apply(e7, t4);
            }(window, "resize", e6);
          };
        }
      }, []), r3;
    }, xl2 = w2(je.exports);
    function Sl2(e5) {
      const [t3, n3] = (0, xl2.useState)(null);
      return (0, xl2.useLayoutEffect)(() => (e5 && n3(e5.getBoundingClientRect()), () => {
        n3(null);
      }), [e5]), t3;
    }
    var _l2 = (0, w2(je.exports).createContext)({}), El2 = w2(je.exports);
    var Pl2 = (e5) => {
      var t3;
      const n3 = e5.children(), [r3, o3] = sl2(null), a3 = n3.props.style ? h2({}, n3.props.style) : {};
      a3.position = "absolute";
      const i3 = Sl2(o3), s3 = Sl2(e5.target), l3 = kl2(), [u3, c3] = (0, fl2.useState)({});
      return (0, fl2.useLayoutEffect)(() => {
        if (!i3 || !o3 || !s3)
          return;
        const t4 = {};
        let n4 = "bottom", r4 = 0, a4 = 0;
        s3.bottom + i3.height + 8 < l3.height ? (n4 = "bottom", r4 = s3.bottom + 8, t4.top = "0px") : s3.top > i3.height + 8 ? (n4 = "top", r4 = s3.top - (i3.height + 8), t4.bottom = "0px", t4.transform = "rotateZ(180deg)") : n4 = "overlay";
        let u4 = 0;
        if (n4 !== "overlay") {
          const e6 = s3.left + s3.width / 2;
          e6 < i3.width / 2 ? (a4 = 8, u4 = Math.max(e6 - 8, 8)) : e6 + i3.width / 2 > l3.width ? (a4 = l3.width - (8 + i3.width), u4 = Math.min(e6 - a4, i3.width - 8)) : (a4 = e6 - i3.width / 2, u4 = i3.width / 2), t4.left = u4 + "px";
        }
        const d2 = a4, f2 = r4;
        return o3.style.left = d2 + "px", o3.style.top = f2 + "px", c3(t4), e5.onPointerOutside ? function(e6, t5, n5) {
          const r5 = e6.getBoundingClientRect(), o4 = (e7) => {
            (e7.clientX < r5.left - t5 || e7.clientX > r5.left + r5.width + t5 || e7.clientY < r5.top - t5 || e7.clientY > r5.top + r5.height + t5) && n5(e7);
          };
          return window.addEventListener("mousemove", o4), () => {
            window.removeEventListener("mousemove", o4);
          };
        }(o3, e5.onPointerOutside.threshold, e5.onPointerOutside.callback) : void 0;
      }, [i3, o3, e5.target, s3, l3]), function(e6, t4) {
        (0, El2.useEffect)(() => {
          if (!e6)
            return;
          const n4 = (n5) => {
            n5.composedPath().includes(e6) || t4(n5);
          };
          return window.addEventListener("mousedown", n4, { capture: true }), () => {
            window.removeEventListener("mousedown", n4, { capture: true });
          };
        }, [e6, t4]);
      }(o3, (t3 = e5.onClickOutside) != null ? t3 : Ss2), dl2.default.createElement(_l2.Provider, { value: u3 }, (0, fl2.cloneElement)(n3, { ref: r3, style: a3 }));
    }, Cl2 = w2(ht.exports), jl2 = w2(g), Ol2 = w2(je.exports), Tl2 = (0, Ol2.createContext)(null), Il2 = 0, Dl2 = ({ children: e5 }) => {
      const t3 = (0, Ol2.useMemo)(() => new jl2.Box(-1), []), n3 = t3.derivation, r3 = (0, Ol2.useMemo)(() => {
        let e6;
        return (n4, r4) => {
          const o3 = e6 !== void 0;
          e6 !== void 0 && (clearTimeout(e6), e6 = void 0), r4 === 0 || o3 ? t3.set(n4) : e6 = setTimeout(() => {
            t3.set(n4), e6 = void 0;
          }, r4);
        };
      }, []);
      return Ol2.default.createElement(Tl2.Provider, { value: { cur: n3, set: r3 } }, e5);
    };
    function Rl2(e5, t3, n3) {
      return t3 in e5 ? Object.defineProperty(e5, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e5[t3] = n3, e5;
    }
    function Nl2(e5, t3) {
      var n3 = Object.keys(e5);
      if (Object.getOwnPropertySymbols) {
        var r3 = Object.getOwnPropertySymbols(e5);
        t3 && (r3 = r3.filter(function(t4) {
          return Object.getOwnPropertyDescriptor(e5, t4).enumerable;
        })), n3.push.apply(n3, r3);
      }
      return n3;
    }
    function Al2(e5) {
      for (var t3 = 1; t3 < arguments.length; t3++) {
        var n3 = arguments[t3] != null ? arguments[t3] : {};
        t3 % 2 ? Nl2(Object(n3), true).forEach(function(t4) {
          Rl2(e5, t4, n3[t4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(n3)) : Nl2(Object(n3)).forEach(function(t4) {
          Object.defineProperty(e5, t4, Object.getOwnPropertyDescriptor(n3, t4));
        });
      }
      return e5;
    }
    function zl2(e5, t3) {
      if (e5 == null)
        return {};
      var n3, r3, o3 = {}, a3 = Object.keys(e5);
      for (r3 = 0; r3 < a3.length; r3++)
        n3 = a3[r3], t3.indexOf(n3) >= 0 || (o3[n3] = e5[n3]);
      return o3;
    }
    var Ml2 = w2(je.exports), Ll2 = (0, w2(je.exports).createContext)({});
    function Fl2(e5, t3, n3) {
      return t3 in e5 ? Object.defineProperty(e5, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e5[t3] = n3, e5;
    }
    function $l2(e5, t3) {
      var n3 = Object.keys(e5);
      if (Object.getOwnPropertySymbols) {
        var r3 = Object.getOwnPropertySymbols(e5);
        t3 && (r3 = r3.filter(function(t4) {
          return Object.getOwnPropertyDescriptor(e5, t4).enumerable;
        })), n3.push.apply(n3, r3);
      }
      return n3;
    }
    function Bl2(e5) {
      for (var t3 = 1; t3 < arguments.length; t3++) {
        var n3 = arguments[t3] != null ? arguments[t3] : {};
        t3 % 2 ? $l2(Object(n3), true).forEach(function(t4) {
          Fl2(e5, t4, n3[t4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(n3)) : $l2(Object(n3)).forEach(function(t4) {
          Object.defineProperty(e5, t4, Object.getOwnPropertyDescriptor(n3, t4));
        });
      }
      return e5;
    }
    function Vl2(e5, t3) {
      if (e5 == null)
        return {};
      var n3, r3, o3 = {}, a3 = Object.keys(e5);
      for (r3 = 0; r3 < a3.length; r3++)
        n3 = a3[r3], t3.indexOf(n3) >= 0 || (o3[n3] = e5[n3]);
      return o3;
    }
    function Ul2(e5, t3) {
      (t3 == null || t3 > e5.length) && (t3 = e5.length);
      for (var n3 = 0, r3 = new Array(t3); n3 < t3; n3++)
        r3[n3] = e5[n3];
      return r3;
    }
    function Hl2(e5, t3) {
      var n3;
      if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
        if (Array.isArray(e5) || (n3 = function(e6, t4) {
          if (e6) {
            if (typeof e6 == "string")
              return Ul2(e6, t4);
            var n4 = Object.prototype.toString.call(e6).slice(8, -1);
            return n4 === "Object" && e6.constructor && (n4 = e6.constructor.name), n4 === "Map" || n4 === "Set" ? Array.from(e6) : n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? Ul2(e6, t4) : void 0;
          }
        }(e5)) || t3 && e5 && typeof e5.length == "number") {
          n3 && (e5 = n3);
          var r3 = 0;
          return function() {
            return r3 >= e5.length ? { done: true } : { done: false, value: e5[r3++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      return (n3 = e5[Symbol.iterator]()).next.bind(n3);
    }
    var Wl2 = w2(je.exports);
    var ql2 = function(e5, t3, n3) {
      n3 === void 0 && (n3 = t3.children);
      var r3 = (0, Wl2.useContext)(Ll2);
      return r3.useCreateElement ? r3.useCreateElement(e5, t3, n3) : typeof e5 == "string" && function(e6) {
        return typeof e6 == "function";
      }(n3) ? (t3.children, n3(Vl2(t3, ["children"]))) : (0, Wl2.createElement)(e5, t3, n3);
    };
    function Kl2(e5, t3, n3) {
      return t3 in e5 ? Object.defineProperty(e5, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e5[t3] = n3, e5;
    }
    function Yl2(e5, t3) {
      var n3 = Object.keys(e5);
      if (Object.getOwnPropertySymbols) {
        var r3 = Object.getOwnPropertySymbols(e5);
        t3 && (r3 = r3.filter(function(t4) {
          return Object.getOwnPropertyDescriptor(e5, t4).enumerable;
        })), n3.push.apply(n3, r3);
      }
      return n3;
    }
    function Xl2(e5) {
      for (var t3 = 1; t3 < arguments.length; t3++) {
        var n3 = arguments[t3] != null ? arguments[t3] : {};
        t3 % 2 ? Yl2(Object(n3), true).forEach(function(t4) {
          Kl2(e5, t4, n3[t4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(n3)) : Yl2(Object(n3)).forEach(function(t4) {
          Object.defineProperty(e5, t4, Object.getOwnPropertyDescriptor(n3, t4));
        });
      }
      return e5;
    }
    function Gl2(e5, t3) {
      (t3 == null || t3 > e5.length) && (t3 = e5.length);
      for (var n3 = 0, r3 = new Array(t3); n3 < t3; n3++)
        r3[n3] = e5[n3];
      return r3;
    }
    function Ql2(e5, t3) {
      var n3;
      if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
        if (Array.isArray(e5) || (n3 = function(e6, t4) {
          if (e6) {
            if (typeof e6 == "string")
              return Gl2(e6, t4);
            var n4 = Object.prototype.toString.call(e6).slice(8, -1);
            return n4 === "Object" && e6.constructor && (n4 = e6.constructor.name), n4 === "Map" || n4 === "Set" ? Array.from(e6) : n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? Gl2(e6, t4) : void 0;
          }
        }(e5)) || t3 && e5 && typeof e5.length == "number") {
          n3 && (e5 = n3);
          var r3 = 0;
          return function() {
            return r3 >= e5.length ? { done: true } : { done: false, value: e5[r3++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      return (n3 = e5[Symbol.iterator]()).next.bind(n3);
    }
    function Jl2(e5) {
      var t3;
      if (!function(e6) {
        return typeof e6 == "object" && e6 != null;
      }(e5))
        return false;
      var n3 = Object.getPrototypeOf(e5);
      return n3 == null || ((t3 = n3.constructor) === null || t3 === void 0 ? void 0 : t3.toString()) === Object.toString();
    }
    function Zl2(e5, t3) {
      for (var n3 = {}, r3 = {}, o3 = 0, a3 = Object.keys(e5); o3 < a3.length; o3++) {
        var i3 = a3[o3];
        t3.indexOf(i3) >= 0 ? n3[i3] = e5[i3] : r3[i3] = e5[i3];
      }
      return [n3, r3];
    }
    function eu2(e5, t3) {
      if (t3 === void 0 && (t3 = []), !Jl2(e5.state))
        return Zl2(e5, t3);
      var n3 = Zl2(e5, [].concat(t3, ["state"])), r3 = n3[0], o3 = n3[1], a3 = r3.state, i3 = function(e6, t4) {
        if (e6 == null)
          return {};
        var n4, r4, o4 = {}, a4 = Object.keys(e6);
        for (r4 = 0; r4 < a4.length; r4++)
          n4 = a4[r4], t4.indexOf(n4) >= 0 || (o4[n4] = e6[n4]);
        return o4;
      }(r3, ["state"]);
      return [Xl2(Xl2({}, a3), i3), o3];
    }
    function tu2(e5, t3) {
      if (e5 === t3)
        return true;
      if (!e5)
        return false;
      if (!t3)
        return false;
      if (typeof e5 != "object")
        return false;
      if (typeof t3 != "object")
        return false;
      var n3 = Object.keys(e5), r3 = Object.keys(t3), o3 = n3.length;
      if (r3.length !== o3)
        return false;
      for (var a3 = 0, i3 = n3; a3 < i3.length; a3++) {
        var s3 = i3[a3];
        if (e5[s3] !== t3[s3])
          return false;
      }
      return true;
    }
    function nu2(e5) {
      return e5.name === "normalizePropsAreEqualInner" ? e5 : function(t3, n3) {
        return Jl2(t3.state) && Jl2(n3.state) ? e5(Xl2(Xl2({}, t3.state), t3), Xl2(Xl2({}, n3.state), n3)) : e5(t3, n3);
      };
    }
    function ru2(e5) {
      var t3, n3 = e5.as, r3 = e5.useHook, o3 = e5.memo, a3 = e5.propsAreEqual, i3 = a3 === void 0 ? r3 == null ? void 0 : r3.unstable_propsAreEqual : a3, s3 = e5.keys, l3 = s3 === void 0 ? (r3 == null ? void 0 : r3.__keys) || [] : s3, u3 = e5.useCreateElement, c3 = u3 === void 0 ? ql2 : u3, d2 = function(e6, t4) {
        var o4 = e6.as, a4 = o4 === void 0 ? n3 : o4, i4 = Vl2(e6, ["as"]);
        if (r3) {
          var s4, u4 = eu2(i4, l3), d3 = u4[0], f2 = u4[1], p2 = r3(d3, Bl2({ ref: t4 }, f2)), h3 = p2.wrapElement, m3 = Vl2(p2, ["wrapElement"]), v3 = ((s4 = a4.render) === null || s4 === void 0 ? void 0 : s4.__keys) || a4.__keys, g2 = v3 && eu2(i4, v3)[0], y3 = g2 ? Bl2(Bl2({}, m3), g2) : m3, b3 = c3(a4, y3);
          return h3 ? h3(b3) : b3;
        }
        return c3(a4, Bl2({ ref: t4 }, i4));
      };
      return r3 && (d2.displayName = r3.name.replace(/^(unstable_)?use/, "")), t3 = d2, d2 = (0, Ml2.forwardRef)(t3), o3 && (d2 = function(e6, t4) {
        return (0, Ml2.memo)(e6, t4);
      }(d2, i3 && nu2(i3))), d2.__keys = l3, d2.unstable_propsAreEqual = nu2(i3 || tu2), d2;
    }
    w2(je.exports);
    var ou2 = w2(je.exports);
    function au2(e5, t3) {
      (0, ou2.useDebugValue)(e5);
      var n3 = (0, ou2.useContext)(Ll2);
      return n3[e5] != null ? n3[e5] : t3;
    }
    var iu2 = w2(je.exports);
    var su2 = w2(je.exports);
    function lu2(e5) {
      var t3, n3, r3, o3 = (r3 = e5.compose, Array.isArray(r3) ? r3 : r3 !== void 0 ? [r3] : []), a3 = function(t4, n4) {
        if (e5.useOptions && (t4 = e5.useOptions(t4, n4)), e5.name && (t4 = function(e6, t5, n5) {
          t5 === void 0 && (t5 = {}), n5 === void 0 && (n5 = {});
          var r5 = "use" + e6 + "Options";
          (0, su2.useDebugValue)(r5);
          var o4 = au2(r5);
          return o4 ? Bl2(Bl2({}, t5), o4(t5, n5)) : t5;
        }(e5.name, t4, n4)), e5.compose)
          for (var r4, a4 = Hl2(o3); !(r4 = a4()).done; ) {
            t4 = r4.value.__useOptions(t4, n4);
          }
        return t4;
      }, i3 = function(t4, n4, r4) {
        if (t4 === void 0 && (t4 = {}), n4 === void 0 && (n4 = {}), r4 === void 0 && (r4 = false), r4 || (t4 = a3(t4, n4)), e5.useProps && (n4 = e5.useProps(t4, n4)), e5.name && (n4 = function(e6, t5, n5) {
          t5 === void 0 && (t5 = {}), n5 === void 0 && (n5 = {});
          var r5 = "use" + e6 + "Props";
          (0, iu2.useDebugValue)(r5);
          var o4 = au2(r5);
          return o4 ? o4(t5, n5) : n5;
        }(e5.name, t4, n4)), e5.compose)
          if (e5.useComposeOptions && (t4 = e5.useComposeOptions(t4, n4)), e5.useComposeProps)
            n4 = e5.useComposeProps(t4, n4);
          else
            for (var i4, s4 = Hl2(o3); !(i4 = s4()).done; ) {
              n4 = (0, i4.value)(t4, n4, true);
            }
        var l3 = {}, u3 = n4 || {};
        for (var c3 in u3)
          u3[c3] !== void 0 && (l3[c3] = u3[c3]);
        return l3;
      };
      i3.__useOptions = a3;
      var s3 = o3.reduce(function(e6, t4) {
        return e6.push.apply(e6, t4.__keys || []), e6;
      }, []);
      return i3.__keys = [].concat(s3, ((t3 = e5.useState) === null || t3 === void 0 ? void 0 : t3.__keys) || [], e5.keys || []), i3.unstable_propsAreEqual = e5.propsAreEqual || ((n3 = o3[0]) === null || n3 === void 0 ? void 0 : n3.unstable_propsAreEqual) || tu2, e5.name && Object.defineProperty(i3, "name", { value: "use" + e5.name }), i3;
    }
    w2(je.exports);
    var uu2 = w2(je.exports);
    function cu2(e5, t3) {
      t3 === void 0 && (t3 = null), e5 && (typeof e5 == "function" ? e5(t3) : e5.current = t3);
    }
    function du2(e5, t3) {
      return (0, uu2.useMemo)(function() {
        return e5 == null && t3 == null ? null : function(n3) {
          cu2(e5, n3), cu2(t3, n3);
        };
      }, [e5, t3]);
    }
    var fu2 = ["button", "color", "file", "image", "reset", "submit"];
    function pu2(e5) {
      if (e5.tagName === "BUTTON")
        return true;
      if (e5.tagName === "INPUT") {
        var t3 = e5;
        return fu2.indexOf(t3.type) !== -1;
      }
      return false;
    }
    function hu2(e5) {
      for (var t3, n3 = [], r3 = Ql2(e5); !(t3 = r3()).done; ) {
        var o3 = t3.value;
        Array.isArray(o3) ? n3.push.apply(n3, hu2(o3)) : n3.push(o3);
      }
      return n3;
    }
    function mu2(e5) {
      var t3;
      if (e5) {
        for (var n3 = arguments.length, r3 = new Array(n3 > 1 ? n3 - 1 : 0), o3 = 1; o3 < n3; o3++)
          r3[o3 - 1] = arguments[o3];
        var a3 = hu2(r3.map(function(e6) {
          return [e6, "\n"];
        }));
        (t3 = console).warn.apply(t3, a3.slice(0, -1));
        try {
          throw Error(a3.join(""));
        } catch (e6) {
        }
      }
    }
    w2(je.exports), w2(je.exports);
    var vu2, gu2 = w2(je.exports);
    function yu2(e5) {
      return e5 ? e5.ownerDocument || e5 : document;
    }
    try {
      vu2 = window;
    } catch (e5) {
    }
    var bu2, wu2, ku2 = (wu2 = bu2 && yu2(bu2).defaultView || vu2, Boolean(wu2 !== void 0 && wu2.document && wu2.document.createElement)), xu2 = w2(je.exports), Su2 = ku2 ? xu2.useLayoutEffect : xu2.useEffect;
    function _u2(e5) {
      var t3 = (0, gu2.useRef)(e5);
      return Su2(function() {
        t3.current = e5;
      }), t3;
    }
    function Eu2(e5, t3) {
      return e5 === t3 || e5.contains(t3);
    }
    function Pu2(e5) {
      var t3 = function(e6) {
        var t4 = yu2(e6).activeElement;
        return t4 != null && t4.nodeName ? t4 : null;
      }(e5);
      if (!t3)
        return false;
      if (Eu2(e5, t3))
        return true;
      var n3 = t3.getAttribute("aria-activedescendant");
      return !!n3 && (n3 === e5.id || !!e5.querySelector("#" + n3));
    }
    function Cu2(e5) {
      return !!ku2 && window.navigator.userAgent.indexOf(e5) !== -1;
    }
    var ju2 = lu2({ name: "Role", keys: ["unstable_system"], propsAreEqual: function(e5, t3) {
      var n3 = e5.unstable_system, r3 = zl2(e5, ["unstable_system"]), o3 = t3.unstable_system, a3 = zl2(t3, ["unstable_system"]);
      return !(n3 !== o3 && !tu2(n3, o3)) && tu2(r3, a3);
    } });
    ru2({ as: "div", useHook: ju2 });
    var Ou2 = w2(je.exports), Tu2 = Cu2("Mac") && !Cu2("Chrome") && (Cu2("Safari") || Cu2("Firefox"));
    function Iu2(e5) {
      !Pu2(e5) && function(e6) {
        return function(e7, t3) {
          return "matches" in e7 ? e7.matches(t3) : "msMatchesSelector" in e7 ? e7.msMatchesSelector(t3) : e7.webkitMatchesSelector(t3);
        }(e6, "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])") && function(e7) {
          var t3 = e7;
          return t3.offsetWidth > 0 || t3.offsetHeight > 0 || e7.getClientRects().length > 0;
        }(e6);
      }(e5) && e5.focus();
    }
    function Du2(e5, t3, n3, r3) {
      return e5 ? t3 && !n3 ? -1 : void 0 : t3 ? r3 : r3 || 0;
    }
    function Ru2(e5, t3) {
      return (0, Ou2.useCallback)(function(n3) {
        var r3;
        (r3 = e5.current) === null || r3 === void 0 || r3.call(e5, n3), n3.defaultPrevented || t3 && (n3.stopPropagation(), n3.preventDefault());
      }, [e5, t3]);
    }
    var Nu2 = lu2({ name: "Tabbable", compose: ju2, keys: ["disabled", "focusable"], useOptions: function(e5, t3) {
      return Al2({ disabled: t3.disabled }, e5);
    }, useProps: function(e5, t3) {
      var n3 = t3.ref, r3 = t3.tabIndex, o3 = t3.onClickCapture, a3 = t3.onMouseDownCapture, i3 = t3.onMouseDown, s3 = t3.onKeyPressCapture, l3 = t3.style, u3 = zl2(t3, ["ref", "tabIndex", "onClickCapture", "onMouseDownCapture", "onMouseDown", "onKeyPressCapture", "style"]), c3 = (0, Ou2.useRef)(null), d2 = _u2(o3), f2 = _u2(a3), p2 = _u2(i3), h3 = _u2(s3), m3 = !!e5.disabled && !e5.focusable, v3 = (0, Ou2.useState)(true), g2 = v3[0], y3 = v3[1], b3 = (0, Ou2.useState)(true), w3 = b3[0], k3 = b3[1], x3 = e5.disabled ? Al2({ pointerEvents: "none" }, l3) : l3;
      Su2(function() {
        var e6 = c3.current;
        e6 ? (function(e7) {
          return e7.tagName === "BUTTON" || e7.tagName === "INPUT" || e7.tagName === "SELECT" || e7.tagName === "TEXTAREA" || e7.tagName === "A";
        }(e6) || y3(false), function(e7) {
          return e7.tagName === "BUTTON" || e7.tagName === "INPUT" || e7.tagName === "SELECT" || e7.tagName === "TEXTAREA";
        }(e6) || k3(false)) : mu2(true, "Can't determine if the element is a native tabbable element because `ref` wasn't passed to the component.", "See https://reakit.io/docs/tabbable");
      }, []);
      var S3 = Ru2(d2, e5.disabled), _3 = Ru2(f2, e5.disabled), E3 = Ru2(h3, e5.disabled), P3 = (0, Ou2.useCallback)(function(e6) {
        var t4;
        (t4 = p2.current) === null || t4 === void 0 || t4.call(p2, e6);
        var n4 = e6.currentTarget;
        if (!e6.defaultPrevented && Tu2 && !function(e7) {
          return !Eu2(e7.currentTarget, e7.target);
        }(e6) && pu2(n4)) {
          var r4 = requestAnimationFrame(function() {
            n4.removeEventListener("mouseup", o4, true), Iu2(n4);
          }), o4 = function() {
            cancelAnimationFrame(r4), Iu2(n4);
          };
          n4.addEventListener("mouseup", o4, { once: true, capture: true });
        }
      }, []);
      return Al2({ ref: du2(c3, n3), style: x3, tabIndex: Du2(m3, g2, w3, r3), disabled: !(!m3 || !w3) || void 0, "aria-disabled": !!e5.disabled || void 0, onClickCapture: S3, onMouseDownCapture: _3, onMouseDown: P3, onKeyPressCapture: E3 }, u3);
    } });
    ru2({ as: "div", useHook: Nu2 });
    var Au2 = w2(je.exports);
    var zu2 = lu2({ name: "Clickable", compose: Nu2, keys: ["unstable_clickOnEnter", "unstable_clickOnSpace"], useOptions: function(e5) {
      var t3 = e5.unstable_clickOnEnter, n3 = t3 === void 0 || t3, r3 = e5.unstable_clickOnSpace;
      return Al2({ unstable_clickOnEnter: n3, unstable_clickOnSpace: r3 === void 0 || r3 }, zl2(e5, ["unstable_clickOnEnter", "unstable_clickOnSpace"]));
    }, useProps: function(e5, t3) {
      var n3 = t3.onKeyDown, r3 = t3.onKeyUp, o3 = zl2(t3, ["onKeyDown", "onKeyUp"]), a3 = (0, Au2.useState)(false), i3 = a3[0], s3 = a3[1], l3 = _u2(n3), u3 = _u2(r3), c3 = (0, Au2.useCallback)(function(t4) {
        var n4;
        if ((n4 = l3.current) === null || n4 === void 0 || n4.call(l3, t4), !t4.defaultPrevented && !e5.disabled && !t4.metaKey && function(e6) {
          return e6.target === e6.currentTarget;
        }(t4)) {
          var r4 = e5.unstable_clickOnEnter && t4.key === "Enter", o4 = e5.unstable_clickOnSpace && t4.key === " ";
          if (r4 || o4) {
            if (function(e6) {
              var t5 = e6.currentTarget;
              return !!e6.isTrusted && (pu2(t5) || t5.tagName === "INPUT" || t5.tagName === "TEXTAREA" || t5.tagName === "A" || t5.tagName === "SELECT");
            }(t4))
              return;
            t4.preventDefault(), r4 ? t4.currentTarget.click() : o4 && s3(true);
          }
        }
      }, [e5.disabled, e5.unstable_clickOnEnter, e5.unstable_clickOnSpace]), d2 = (0, Au2.useCallback)(function(t4) {
        var n4;
        if ((n4 = u3.current) === null || n4 === void 0 || n4.call(u3, t4), !t4.defaultPrevented && !e5.disabled && !t4.metaKey) {
          var r4 = e5.unstable_clickOnSpace && t4.key === " ";
          i3 && r4 && (s3(false), t4.currentTarget.click());
        }
      }, [e5.disabled, e5.unstable_clickOnSpace, i3]);
      return Al2({ "data-active": i3 || void 0, onKeyDown: c3, onKeyUp: d2 }, o3);
    } });
    ru2({ as: "button", memo: true, useHook: zu2 });
    var Mu2 = w2(je.exports), Lu2 = lu2({ name: "Button", compose: zu2, keys: [], useProps: function(e5, t3) {
      var n3 = t3.ref, r3 = zl2(t3, ["ref"]), o3 = (0, Mu2.useRef)(null), a3 = (0, Mu2.useState)(void 0), i3 = a3[0], s3 = a3[1], l3 = (0, Mu2.useState)("button"), u3 = l3[0], c3 = l3[1];
      return (0, Mu2.useEffect)(function() {
        var e6 = o3.current;
        e6 ? pu2(e6) || (e6.tagName !== "A" && s3("button"), c3(void 0)) : mu2(true, "Can't determine whether the element is a native button because `ref` wasn't passed to the component", "See https://reakit.io/docs/button");
      }, []), Al2({ ref: du2(o3, n3), role: i3, type: u3 }, r3);
    } }), Fu2 = ru2({ as: "button", memo: true, useHook: Lu2 }), $u2 = ru2({ as: "div", useHook: lu2({ name: "Group", compose: ju2, keys: [], useProps: function(e5, t3) {
      return Al2({ role: "group" }, t3);
    } }) });
    w2(ht.exports);
    var Bu2 = w2(je.exports);
    w2(ht.exports);
    var Vu2, Uu2 = (0, Bu2.createContext)(ku2 ? document.body : null);
    function Hu2(e5, t3) {
      const n3 = e5.enabled !== false, [r3, o3] = (() => {
        const e6 = (0, Ol2.useMemo)(() => Il2++, []), { cur: t4, set: n4 } = (0, Ol2.useContext)(Tl2), [r4, o4] = sl2(false), a4 = (0, Ol2.useCallback)((t5, r5) => {
          n4(t5 ? e6 : -1, r5);
        }, []);
        return (0, Ol2.useEffect)(() => t4.changesWithoutValues().tap(() => {
          const n5 = t4.getValue() === e6;
          r4.current !== n5 && (r4.current = n5);
        }), [t4, e6]), [o4, a4];
      })(), [a3, i3] = sl2(null);
      (0, ul2.useEffect)(() => {
        if (!n3)
          return;
        const t4 = a3.current;
        if (!t4)
          return;
        const r4 = () => {
          var t5;
          return o3(true, (t5 = e5.enterDelay) != null ? t5 : 400);
        }, i4 = () => {
          var t5;
          return o3(false, (t5 = e5.exitDelay) != null ? t5 : 200);
        };
        return t4.addEventListener("mouseenter", r4), t4.addEventListener("mouseleave", i4), () => {
          t4.removeEventListener("mouseenter", r4), t4.removeEventListener("mouseleave", i4);
        };
      }, [a3, n3, e5.enterDelay, e5.exitDelay]);
      const s3 = (0, ll2.useContext)(Uu2);
      return [n3 && r3 && i3 ? (0, Cl2.createPortal)(cl2.default.createElement(Pl2, { children: t3, target: i3, onClickOutside: Ss2 }), s3) : cl2.default.createElement(cl2.default.Fragment, null), a3, r3];
    }
    typeof window != "undefined" && (Vu2 = { get passive() {
    } }, window.addEventListener("testPassive", null, Vu2), window.removeEventListener("testPassive", null, Vu2)), typeof window != "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints);
    var Wu2 = function(e5) {
      return function(t3) {
        e5.forEach(function(e6) {
          typeof e6 == "function" ? e6(t3) : e6 != null && (e6.current = t3);
        });
      };
    }, qu2 = w2(yh), Ku2 = w2(yh), Yu2 = w2(je.exports), Xu2 = w2(yh), Gu2 = w2(je.exports), Qu2 = w2(yh), Ju2 = Qu2.default.div`
  position: absolute;
  width: 0;
  height: 0;
  color: var(--popover-arrow-color);
  pointer-events: none;
`, Zu2 = Qu2.default.div`
  width: 12px;
  height: 8px;
  position: absolute;
  left: -7px;
  top: -8px;
  text-align: center;
  line-height: 0;
`, ec2 = Qu2.default.path`
  fill: var(--popover-bg);
`, tc2 = Qu2.default.path`
  fill: var(--popover-inner-stroke);
`, nc2 = Qu2.default.path`
  fill: var(--popover-outer-stroke);
`, rc2 = (0, Gu2.forwardRef)(({ className: e5 }, t3) => {
      const n3 = (0, Gu2.useContext)(_l2);
      return Gu2.default.createElement(Ju2, { className: e5, ref: t3, style: h2({}, n3) }, Gu2.default.createElement(Zu2, null, Gu2.default.createElement("svg", { width: "12", height: "8", viewBox: "0 0 12 8", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Gu2.default.createElement(nc2, { d: "M6 0L0 6H12L6 0Z" }), Gu2.default.createElement(tc2, { d: "M6 1.5L0 7.5H12L6 1.5Z" }), Gu2.default.createElement(ec2, { d: "M6 3L0 9H12L6 3Z" }))));
    }), oc2 = Ui2(0.05, "#2a2a31"), ac2 = Xu2.default.div`
  position: absolute;
  --popover-bg: ${oc2};
  --popover-inner-stroke: #505159;
  --popover-outer-stroke: #111;

  background: var(--popover-bg);

  color: white;
  padding: 0;
  margin: 0;
  cursor: default;
  ${qi2};
  border-radius: 3px;
  z-index: 10000;
  border: 1px solid var(--popover-inner-stroke);
  box-shadow: 0 0 0 1px var(--popover-outer-stroke), 0 6px 8px -4px black;
  backdrop-filter: blur(8px);

  & a {
    color: inherit;
  }
`, ic2 = Yu2.default.forwardRef(({ children: e5, className: t3 }, n3) => Yu2.default.createElement(ac2, { className: t3, ref: n3 }, Yu2.default.createElement(rc2, null), e5)), sc2 = (0, Ku2.default)(ic2)`
  padding: 1em;
  max-width: 240px;
  pointer-events: none !important;
  --popover-outer-stroke: transparent;
  --popover-inner-stroke: #45464d;
`, lc2 = (0, qu2.default)(sc2)`
  padding: 6px;
`, uc2 = ol2.default.button`
  ${qi2};
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 600;
  width: 24px;
  height: 24px;
  outline: none;

  color: rgba(255, 255, 255, 0.75);
  background-color: rgb(47, 49, 53);

  &:hover {
    color: #fff;

    background-color: rgba(28, 30, 32, 0.95);
    &:after {
      border-color: rgba(90, 90, 90, 1);
    }
  }

  &.selected {
    color: #fff;

    background-color: rgba(17, 18, 20, 0.95);
    &:after {
      border-color: rgb(43, 43, 43);
    }
  }

  &:before {
    border: 1px solid rgb(62, 62, 62);
    position: absolute;
    inset: -1px;
    display: block;
    content: ' ';
    z-index: -1;
    pointer-events: none;
    border-radius: 2px;
    box-sizing: border-box;
    box-shadow: 0px 3px 4px -3px rgba(0, 0, 0, 0.49);
  }

  border: 0;
`, cc2 = al2.default.forwardRef((e5, t3) => {
      var n3 = e5, { title: r3 } = n3, o3 = y2(n3, ["title"]);
      const [a3, i3] = Hu2({ enabled: typeof r3 == "string" }, () => al2.default.createElement(lc2, null, r3));
      return al2.default.createElement(al2.default.Fragment, null, a3, al2.default.createElement(uc2, h2({ ref: Wu2([i3, t3]) }, o3)), " ");
    }), dc2 = w2(g), fc2 = (0, w2(yh).default)(sc2)`
  --popover-outer-stroke: #e11c1c;
  --popover-inner-stroke: #2c1c1c;
  --popover-bg: #2c1c1c;
  pointer-events: none !important;
`, pc2 = Ja2.default.div`
  background-color: transparent;
  pointer-events: none;
  position: absolute;
  left: 0;
  top: 12px;
  bottom: 0px;
  right: 0;
  z-index: ${Xi2.outlinePanel};

  &:before {
    display: block;
    content: ' ';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    width: 40px;
    ${qi2};
  }
  &:hover:before {
    top: -12px;
    width: 300px;
  }
`, hc2 = Ja2.default.div`
  margin-left: 12px;
  position: relative;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
`, mc2 = Ja2.default.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  transform: translateX(-100%);
  pointer-events: none;

  ${pc2}:hover & {
    transform: translateX(0);
  }
`, vc2 = "32px", gc2 = (0, Ja2.default)(cc2)`
  ${pc2}:hover & {
    background-color: rgba(36, 38, 42, 0.95);
    &:after {
      border-color: rgba(255, 255, 255, 0.22);
    }
    color: white;
  }
`;
    Ja2.default.div`
  margin: 0 12px;
  color: #ffffffc2;
  font-weight: 500;
  font-size: 10px;
  user-select: none;
  position: relative;
  display: none;
  background-color: rgba(60, 60, 60, 0.2);
  height: 24px;
  ${pc2}:hover & {
    display: block;
  }

  &:after {
    position: absolute;
    inset: 4px 0px;
    display: block;
    content: ' ';
    pointer-events: none;
    z-index: -1;
    background-color: #69777947;
    border-radius: 0 2px 2px 0;
  }
`;
    var yc2 = Ja2.default.div`
  ${qi2};
  position: absolute;
  top: ${vc2};
  left: 8px;
  height: auto;
  max-height: calc(100% - ${vc2});
  overflow-y: scroll;
  overflow-x: hidden;
  padding: 0;
  user-select: none;
`, bc2 = Ja2.default.div`
  color: white;
  width: 14px;
  height: 14px;
  background: #d00;
  border-radius: 4px;
  text-align: center;
  line-height: 14px;
  font-weight: 600;
  font-size: 8px;
  position: relative;
  left: -6px;
  top: -11px;
  margin-right: -14px;
  box-shadow: 0 4px 6px -4px #00000059;
`, wc2 = (e5) => {
      const t3 = Fa2(() => {
        const e6 = (0, dc2.val)(me2().atomP.ephemeral.coreByProject);
        return Object.entries(e6).map(([e7, t4]) => ({ projectId: e7, state: t4 })).filter(({ state: e7 }) => e7.loadingState.type === "browserStateIsNotBasedOnDiskState");
      }, []), [n3, r3] = Hu2({ enabled: t3.length > 0, enterDelay: t3.length > 0 ? 0 : 200 }, () => t3.length > 0 ? Qa2.default.createElement(fc2, null, t3.length === 1 ? `There is a state conflict in project "${t3[0].projectId}". Select the project in the outline below in order to fix it.` : `There are ${t3.length} projects that have state conflicts. They are highlighted in the outline below. `) : Qa2.default.createElement(sc2, null, "Outline"));
      return Qa2.default.createElement(pc2, null, Qa2.default.createElement(hc2, null, n3, Qa2.default.createElement(gc2, { ref: r3 }, Qa2.default.createElement(ws2, null)), t3.length > 0 ? Qa2.default.createElement(bc2, null, t3.length) : null), Qa2.default.createElement(mc2, null, Qa2.default.createElement(yc2, null, Qa2.default.createElement(rl2, null))));
    }, kc2 = w2(je.exports), xc2 = w2(yh), Sc2 = w2(je.exports), _c2 = w2(g), Ec2 = w2(je.exports), Pc2 = w2(je.exports);
    function Cc2(e5, t3) {
      return t3.length === 0 ? e5 : kr2(e5, t3);
    }
    var jc2, Oc2 = w2(g), Tc2 = w2(je.exports), Ic2 = w2(je.exports), Dc2 = w2(yh), Rc2 = { defaultState: { color: Ui2(0.85, "#C4C4C4") }, withStaticOverride: { color: Ui2(0.85, "#C4C4C4") } }, Nc2 = Dc2.default.div`
  width: 16px;
  margin: 0 0px 0 2px;
  display: flex;
  justify-content: center;
  align-items: center;

  color: ${(e5) => e5.hasStaticOverride ? Rc2.withStaticOverride.color : Rc2.defaultState.color};
`, Ac2 = Dc2.default.rect`
  fill: currentColor;
`, zc2 = () => Ic2.default.createElement("svg", { width: "5", height: "5", viewBox: "0 0 5 5", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Ic2.default.createElement(Ac2, { width: "5", height: "5" })), Mc2 = (e5) => Ic2.default.createElement(Nc2, { hasStaticOverride: e5.hasStaticOverride }, Ic2.default.createElement(zc2, null)), Lc2 = w2(je.exports), Fc2 = w2(yh), $c2 = Fc2.default.div`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 16px;
  margin: 0 0px 0 2px;
  position: relative;
  z-index: 0;
  opacity: 0.7;

  &:after {
    position: absolute;
    left: -14px;
    right: -14px;
    top: -2px;
    bottom: -2px;
    content: ' ';
    display: none;
    z-index: -1;
    background: ${Ui2(0.2, "black")};
  }

  &:hover {
    opacity: 1;
    &:after {
      display: block;
    }
  }
`, Bc2 = Fc2.default.div`
  background: none;
  position: relative;
  border: 0;
  transition: transform 0.1s ease-out;
  z-index: 0;
  outline: none;
  cursor: pointer;

  &:after {
    display: none;
    ${$c2}:hover & {
      display: block;
    }
    position: absolute;
    left: -4px;
    right: -4px;
    top: -4px;
    bottom: -4px;
    content: ' ';
    z-index: -1;
  }
`, Vc2 = "#555", Uc2 = "#e0c917", Hc2 = (0, Fc2.default)(Bc2)`
  &:hover {
    color: #e0c917;
  }
  color: ${(e5) => e5.isOn ? Uc2 : Vc2};
`, Wc2 = Fc2.css`
  pointer-events: none !important;
`, qc2 = (0, Fc2.default)(Bc2)`
  color: ${(e5) => e5.available ? Uc2 : Vc2};

  ${(e5) => e5.available ? qi2 : Wc2};
`, Kc2 = (0, Fc2.default)(qc2)`
  transform: translateX(2px);
  ${$c2}:hover & {
    transform: translateX(-7px);
  }
`, Yc2 = (0, Fc2.default)(qc2)`
  transform: translateX(-2px);

  ${$c2}:hover & {
    transform: translateX(7px);
  }
`;
    !function(e5) {
      const t3 = Fc2.default.g`
    stroke-width: 1;
    ${qc2}:hover & path {
      stroke-width: 3;
    }
  `;
      e5.Prev = () => Lc2.default.createElement("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Lc2.default.createElement(t3, { transform: "translate(6 3)" }, Lc2.default.createElement("path", { d: "M4 1L1 4L4 7", stroke: "currentColor" }))), e5.Next = () => Lc2.default.createElement("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Lc2.default.createElement(t3, { transform: "translate(1 3)" }, Lc2.default.createElement("path", { d: "M1 1L4 4L1 7", stroke: "currentColor" })));
      const n3 = Fc2.default.g`
    stroke-width: 0;
    ${Hc2}:hover & path {
      stroke: currentColor;
      stroke-width: 2;
    }
  `;
      e5.Cur = () => Lc2.default.createElement("svg", { width: "8", height: "12", viewBox: "0 0 8 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Lc2.default.createElement(n3, { transform: "translate(1 4)" }, Lc2.default.createElement("path", { d: "M3 0L6 3L3 6L0 3L3 0Z", fill: "currentColor" })));
    }(jc2 || (jc2 = {}));
    var Xc2 = (e5) => Lc2.default.createElement($c2, null, Lc2.default.createElement(Kc2, { available: !!e5.prev, onClick: () => {
      e5.prev && e5.jumpToPosition(e5.prev.position);
    } }, Lc2.default.createElement(jc2.Prev, null)), Lc2.default.createElement(Hc2, { isOn: !!e5.cur, onClick: () => {
      e5.toggleKeyframeOnCurrentPosition();
    } }, Lc2.default.createElement(jc2.Cur, null)), Lc2.default.createElement(Yc2, { available: !!e5.next, onClick: () => {
      e5.next && e5.jumpToPosition(e5.next.position);
    } }, Lc2.default.createElement(jc2.Next, null)));
    function Gc2(e5, t3, n3) {
      return Fa2(() => {
        var r3;
        const o3 = (0, Oc2.getPointerParts)(e5).path, a3 = t3.getValueByPointer(e5), i3 = Oc2.prism.memo("callbacks", () => {
          let t4 = null;
          return { temporarilySetValue(n4) {
            t4 || (t4 = me2().scrub()), t4.capture((t5) => {
              t5.set(e5, n4);
            });
          }, discardTemporaryValue() {
            t4 && (t4.discard(), t4 = null);
          }, permenantlySetValue(n4) {
            t4 ? (t4.capture((t5) => {
              t5.set(e5, n4);
            }), t4.commit(), t4 = null) : me2().transaction((t5) => {
              t5.set(e5, n4);
            });
          } };
        }, []), s3 = (0, Oc2.val)(kr2(me2().atomP.ephemeral.projects.stateByProjectId[t3.address.projectId].stateBySheetId[t3.address.sheetId].stateByObjectKey[t3.address.objectKey].valuesBeingScrubbed, (0, Oc2.getPointerParts)(e5).path)) === true, l3 = [], u3 = m2(h2({}, i3), { value: a3, beingScrubbed: s3, contextMenuItems: l3, controlIndicators: Tc2.default.createElement(Tc2.default.Fragment, null) }), c3 = n3.type === "number";
        if (c3) {
          const n4 = Cc2((0, Oc2.val)(t3.template.getMapOfValidSequenceTracks_forStudio()), o3);
          if (typeof n4 == "string") {
            l3.push({ label: "Make static", callback: () => {
              me2().transaction(({ stateEditors: n5 }) => {
                const r4 = m2(h2({}, t3.address), { pathToProp: o3 });
                n5.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsStatic(m2(h2({}, r4), { value: t3.getValueByPointer(e5) }));
              });
            } });
            const a4 = n4, i4 = Oc2.prism.sub("lcr", () => {
              const e6 = (0, Oc2.val)(t3.template.project.pointers.historic.sheetsById[t3.address.sheetId].sequence.tracksByObject[t3.address.objectKey].trackData[a4]);
              if (!e6 || e6.keyframes.length === 0)
                return {};
              const n5 = (0, Oc2.val)(t3.sheet.getSequence().positionDerivation), r4 = e6.keyframes.findIndex((e7) => e7.position >= n5);
              if (r4 === -1)
                return { prev: aa2(e6.keyframes) };
              const o4 = e6.keyframes[r4];
              return o4.position === n5 ? { prev: r4 > 0 ? e6.keyframes[r4 - 1] : void 0, cur: o4, next: r4 === e6.keyframes.length - 1 ? void 0 : e6.keyframes[r4 + 1] } : { next: o4, prev: r4 > 0 ? e6.keyframes[r4 - 1] : void 0 };
            }, [a4]);
            let s4;
            s4 = u3.beingScrubbed ? "Sequenced_OnKeyframe_BeingScrubbed" : i4.cur ? "Sequenced_OnKeyframe" : ((r3 = i4.prev) == null ? void 0 : r3.connectedRight) === true ? "Sequenced_BeingInterpolated" : "Sequened_NotBeingInterpolated";
            const c4 = Tc2.default.createElement(Xc2, m2(h2({}, i4), { jumpToPosition: (e6) => {
              t3.sheet.getSequence().position = e6;
            }, toggleKeyframeOnCurrentPosition: () => {
              i4.cur ? me2().transaction((t4) => {
                t4.unset(e5);
              }) : me2().transaction((t4) => {
                t4.set(e5, u3.value);
              });
            } }));
            return m2(h2({}, u3), { type: "Sequenced", shade: s4, nearbyKeyframes: i4, controlIndicators: c4 });
          }
        }
        l3.push({ label: "Reset to default", callback: () => {
          me2().transaction(({ unset: t4 }) => {
            t4(e5);
          });
        } }), c3 && l3.push({ label: "Sequence", callback: () => {
          me2().transaction(({ stateEditors: e6 }) => {
            const n4 = m2(h2({}, t3.address), { pathToProp: o3 });
            e6.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(n4);
          });
        } });
        if (Cc2((0, Oc2.val)(t3.template.getStaticValues()), o3) !== void 0) {
          return m2(h2({}, u3), { type: "Static", shade: u3.beingScrubbed ? "Static_BeingScrubbed" : "Static", controlIndicators: Tc2.default.createElement(Mc2, { hasStaticOverride: true }) });
        }
        return m2(h2({}, u3), { type: "Default", shade: "Default", controlIndicators: Tc2.default.createElement(Mc2, { hasStaticOverride: false }) });
      }, []);
    }
    var Qc2 = w2(g), Jc2 = w2(je.exports), Zc2 = w2(R2()), ed2 = w2(je.exports), td2 = w2(je.exports), nd2 = w2(ht.exports), rd2 = w2(yh), od2 = w2(je.exports), ad2 = w2(yh), id2 = ad2.default.li`
  height: ${26}px;
  padding: 0 12px;
  margin: 0;
  display: flex;
  align-items: center;
  font-size: 11px;
  font-weight: 400;
  position: relative;
  pointer-events: ${(e5) => e5.enabled ? "auto" : "none"};
  color: ${(e5) => e5.enabled ? "white" : "#AAA"};

  &:after {
    position: absolute;
    inset: 2px 1px;
    display: block;
    content: ' ';
    pointer-events: none;
    z-index: -1;
    border-radius: 3px;
  }

  &:hover:after {
    background-color: rgba(63, 174, 191, 0.75);
  }
`, sd2 = ad2.default.span``, ld2 = (e5) => od2.default.createElement(id2, { onClick: e5.enabled ? e5.onClick : Ss2, enabled: e5.enabled }, od2.default.createElement(sd2, null, e5.label)), ud2 = w2(je.exports);
    var cd2 = rd2.default.ul`
  position: absolute;
  min-width: ${190}px;
  z-index: 10000;
  background: ${(0, Zc2.default)(0.2, "#111")};
  backdrop-filter: blur(2px);
  color: white;
  list-style-type: none;
  padding: 2px 0;
  margin: 0;
  border-radius: 1px;
  cursor: default;
  ${qi2};
  border-radius: 3px;
`, dd2 = (e5) => {
      const [t3, n3] = (0, td2.useState)(null), r3 = Sl2(t3), o3 = kl2();
      (0, td2.useLayoutEffect)(() => {
        if (!r3 || !t3)
          return;
        const n4 = r3.width / 2, a4 = 13, i4 = { left: e5.rightClickPoint.clientX - n4, top: e5.rightClickPoint.clientY - a4 };
        i4.left < 0 ? i4.left = 0 : i4.left + r3.width > o3.width && (i4.left = o3.width - r3.width), i4.top < 0 ? i4.top = 0 : i4.top + r3.height > o3.height && (i4.top = o3.height - r3.height), t3.style.left = i4.left + "px", t3.style.top = i4.top + "px";
        const s3 = (t4) => {
          (t4.clientX < i4.left - 20 || t4.clientX > i4.left + r3.width + 20 || t4.clientY < i4.top - 20 || t4.clientY > i4.top + r3.height + 20) && e5.onRequestClose();
        };
        return window.addEventListener("mousemove", s3), () => {
          window.removeEventListener("mousemove", s3);
        };
      }, [r3, t3, e5.rightClickPoint, o3, e5.onRequestClose]);
      const a3 = (0, ed2.useContext)(Uu2);
      !function(e6) {
        const t4 = (0, ud2.useRef)(e6);
        t4.current = e6, (0, ud2.useEffect)(() => {
          const e7 = (e8) => t4.current(e8);
          return window.addEventListener("keydown", e7), () => {
            window.removeEventListener("keydown", e7);
          };
        }, []);
      }((t4) => {
        t4.key === "Escape" && e5.onRequestClose();
      });
      const i3 = Array.isArray(e5.items) ? e5.items : e5.items();
      return (0, nd2.createPortal)(td2.default.createElement(cd2, { ref: n3 }, i3.map((t4, n4) => td2.default.createElement(ld2, { key: `item-${n4}`, label: t4.label, enabled: t4.enabled !== false, onClick: (n5) => {
        t4.callback && t4.callback(n5), e5.onRequestClose();
      } }))), a3);
    }, fd2 = w2(je.exports), pd2 = (e5) => {
      const [t3, n3] = (0, fd2.useState)({ isOpen: false }), r3 = (0, fd2.useCallback)(() => n3({ isOpen: false }), []);
      return (0, fd2.useEffect)(() => {
        if (!e5)
          return void n3({ isOpen: false });
        const t4 = (e6) => {
          n3({ isOpen: true, event: e6 }), e6.preventDefault(), e6.stopPropagation();
        };
        return e5.addEventListener("contextmenu", t4), () => {
          e5.removeEventListener("contextmenu", t4);
        };
      }, [e5]), [t3, r3];
    }, hd2 = Jc2.default.createElement(Jc2.default.Fragment, null);
    function md2(e5, t3) {
      const [n3, r3] = pd2(e5);
      return [n3.isOpen ? Jc2.default.createElement(dd2, { items: t3.items, rightClickPoint: n3.event, onRequestClose: r3 }) : hd2, r3, n3.isOpen];
    }
    var vd2 = w2(je.exports), gd2 = w2(yh), yd2 = "calc(var(--left-pad) + var(--depth) * var(--step))", bd2 = Ui2(0.05, "#282b2f"), wd2 = gd2.css`
  &:after,
  &:before {
    position: absolute;
    display: block;
    content: ' ';
    z-index: -1;
    box-sizing: content-box;
  }

  &:after {
    inset: 0px 0 1px calc(-2px + var(--left-pad) + var(--depth) * var(--step));
    background-color: ${bd2};
  }

  &:before {
    height: 2px;
    right: 0;
    bottom: 0px;
    left: calc(-2px + var(--left-pad) + var(--depth) * var(--step));
    background-color: ${Ui2(0.2, bd2)};
  }
`, kd2 = gd2.css`
  font-weight: 300;
  font-size: 11px;
  color: #9a9a9a;
  text-shadow: 0.5px 0.5px 2px rgba(0, 0, 0, 0.3);
`, xd2 = gd2.default.div`
  display: flex;
  height: 30px;
  justify-content: flex-start;
  align-items: stretch;
  --right-width: 60%;
  position: relative;
  ${qi2};

  ${wd2};
`, Sd2 = gd2.default.div`
  box-sizing: border-box;
  padding-left: ${yd2};
  padding-right: 4px;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: stretch;
  gap: 4px;
  flex-grow: 0;
  flex-shrink: 0;
  width: calc(100% - var(--right-width));
`, _d2 = gd2.default.div`
  text-align: left;
  flex: 1 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  user-select: none;
  cursor: default;

  ${kd2};
  &:hover {
    color: white;
  }
`, Ed2 = gd2.default.div`
  flex-basis: 8px;
  flex: 0 0;
  display: flex;
  align-items: center;
`, Pd2 = gd2.default.div`
  display: flex;
  align-items: center;
  justify-content: stretch;
  padding: 0 8px 0 2px;
  box-sizing: border-box;
  height: 100%;
  width: var(--right-width);
  flex-shrink: 0;
  flex-grow: 0;
`, Cd = ({ propConfig: e5, pointerToProp: t3, stuff: n3, children: r3 }) => {
      var o3;
      const a3 = (o3 = e5.label) != null ? o3 : aa2((0, Qc2.getPointerParts)(t3).path), [i3, s3] = sl2(null), [l3] = md2(s3, { items: n3.contextMenuItems });
      return n3.shade, vd2.default.createElement(xd2, null, l3, vd2.default.createElement(Sd2, null, vd2.default.createElement(Ed2, null, n3.controlIndicators), vd2.default.createElement(_d2, { ref: i3, title: ["obj", "props", ...(0, Qc2.getPointerParts)(t3).path].join(".") }, a3)), vd2.default.createElement(Pd2, null, r3));
    }, jd2 = w2(yh), Od2 = w2(yh).default.input.attrs({ type: "checkbox" })`
  outline: none;
`, Td2 = (0, jd2.default)(Od2)`
  margin-left: 6px;
`, Id2 = ({ propConfig: e5, pointerToProp: t3, obj: n3 }) => {
      const r3 = Gc2(t3, n3, e5), o3 = (0, Pc2.useCallback)((e6) => {
        r3.permenantlySetValue(Boolean(e6.target.checked));
      }, [e5, t3, n3]);
      return Pc2.default.createElement(Cd, h2({}, { stuff: r3, propConfig: e5, pointerToProp: t3 }), Pc2.default.createElement(Td2, { checked: r3.value, onChange: o3 }));
    };
    function Dd2(e5) {
      return e5.type === "compound" || e5.type === "enum";
    }
    var Rd2 = w2(g), Nd2 = w2(je.exports), Ad2 = w2(yh), zd2 = Ad2.default.div`
  --step: 8px;
  --left-pad: 0px;
  ${qi2};
`, Md2 = Ad2.default.div`
  height: 30px;
  display: flex;
  align-items: stretch;
  position: relative;

  ${wd2};
`, Ld2 = Ad2.default.div`
  padding-left: ${yd2};
  display: flex;
  align-items: center;
`, Fd2 = Ad2.default.div`
  margin-left: 4px;
  cursor: default;
  height: 100%;
  display: flex;
  align-items: center;
  user-select: none;
  &:hover {
    /* color: white; */
  }

  ${() => kd2};
`, $d2 = Ui2(0.05, "#282b2f"), Bd2 = Ad2.default.div`
  /* background: ${({ depth: e5 }) => Fi2(0.03 * e5, $d2)}; */
  /* padding: ${(e5) => e5.lastSubIsComposite ? 0 : "4px"} 0; */
`, Vd2 = ({ pointerToProp: e5, obj: t3, propConfig: n3, depth: r3 }) => {
      var o3;
      const a3 = (o3 = n3.label) != null ? o3 : aa2((0, Rd2.getPointerParts)(e5).path), i3 = Object.entries(n3.props), s3 = i3.filter(([e6, t4]) => Dd2(t4)), l3 = i3.filter(([e6, t4]) => !Dd2(t4)), [u3, c3] = sl2(null), d2 = s3.length > 0;
      return Nd2.default.createElement(zd2, null, Nd2.default.createElement(Md2, { style: { "--depth": r3 - 1 } }, Nd2.default.createElement(Ld2, null, Nd2.default.createElement(Mc2, { hasStaticOverride: false }), Nd2.default.createElement(Fd2, { ref: u3 }, a3 || "Props"))), Nd2.default.createElement(Bd2, { style: { "--depth": r3 }, depth: r3, lastSubIsComposite: d2 }, [...l3, ...s3].map(([n4, o4]) => Nd2.default.createElement(Ef2, { key: "prop-" + n4, propConfig: o4, pointerToProp: e5[n4], obj: t3, depth: r3 + 1 }))));
    }, Ud2 = w2(je.exports), Hd2 = w2(yh), Wd2 = () => {
    }, qd2 = [], Kd2 = w2(je.exports);
    function Yd2(e5) {
      const t3 = document.createElement("div");
      t3.style.cssText = "\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 9999999;", t3.style.cursor = e5, document.body.appendChild(t3);
      return () => {
        document.body.removeChild(t3);
      };
    }
    var Xd2 = class extends Kd2.default.PureComponent {
      constructor(e5) {
        super(e5), k2(this, "s"), k2(this, "mode", "notDragging"), k2(this, "getDeltas"), k2(this, "relinquishCursorLock", Wd2), k2(this, "disableUnwantedClick", (e6) => {
          this.s.dragHappened && (this.props.dontBlockMouseDown || this.mode === "notDragging" || (e6.stopPropagation(), e6.preventDefault()), this.s.dragHappened = false);
        }), k2(this, "dragStartHandler", (e6) => {
          if (e6.button !== 0)
            return;
          if ((this.props.onDragStart && this.props.onDragStart(e6)) === false)
            return;
          this.props.dontBlockMouseDown || (e6.stopPropagation(), e6.preventDefault()), this.mode = "dragStartCalled";
          const { screenX: t3, screenY: n3 } = e6;
          this.s.startPos = { x: t3, y: n3 }, this.s.dragHappened = false, this.addDragListeners();
        }), k2(this, "dragEndHandler", () => {
          this.removeDragListeners(), this.mode = "notDragging", this.props.onDragEnd && this.props.onDragEnd(this.s.dragHappened), this.relinquishCursorLock(), this.relinquishCursorLock = Wd2;
        }), k2(this, "dragHandler", (e6) => {
          !this.s.dragHappened && this.props.lockCursorTo && (this.relinquishCursorLock = Yd2(this.props.lockCursorTo)), this.s.dragHappened || (this.s.dragHappened = true), this.mode = "dragging";
          const t3 = this.getDeltas(e6);
          this.props.onDrag(t3[0], t3[1], e6);
        }), this.s = { dragHappened: false, startPos: { x: 0, y: 0 } }, e5.shouldReturnMovement ? this.getDeltas = this.getMovements : this.getDeltas = this.getDistances;
      }
      render() {
        return this.props.enabled !== false ? Kd2.default.cloneElement(this.props.children, { onMouseDown: this.dragStartHandler, onClickCapture: this.disableUnwantedClick }) : this.props.children;
      }
      addDragListeners() {
        document.addEventListener("mousemove", this.dragHandler), document.addEventListener("mouseup", this.dragEndHandler);
      }
      removeDragListeners() {
        document.removeEventListener("mousemove", this.dragHandler), document.removeEventListener("mouseup", this.dragEndHandler);
      }
      UNSAFE_componentWillReceiveProps(e5) {
        e5.lockCursorTo !== this.props.lockCursorTo && this.s.dragHappened && (this.relinquishCursorLock(), this.relinquishCursorLock = Wd2, e5.lockCursorTo && (this.relinquishCursorLock = Yd2(e5.lockCursorTo)));
      }
      getDistances(e5) {
        const { startPos: t3 } = this.s;
        return [e5.screenX - t3.x, e5.screenY - t3.y];
      }
      getMovements(e5) {
        return [e5.movementX, e5.movementY];
      }
      componentWillUnmount() {
        this.mode !== "notDragging" && (this.relinquishCursorLock(), this.relinquishCursorLock = Wd2, this.removeDragListeners(), this.props.onDragEnd && this.props.onDragEnd(this.mode === "dragging"), this.mode = "notDragging");
      }
    }, Gd2 = Hd2.default.div`
  height: 100%;
  width: 100%;
  position: relative;
  z-index: 0;
  box-sizing: border-box;
  display: flex;
  align-items: center;

  &:after {
    position: absolute;
    inset: 1px 0 2px;
    display: block;
    content: ' ';
    background-color: transparent;
    border: 1px solid transparent;
    z-index: -2;
    box-sizing: border-box;
    border-radius: 1px;
  }

  &:hover,
  &.dragging,
  &.editingViaKeyboard {
    &:after {
      background-color: #10101042;
      border-color: #00000059;
    }
  }
`, Qd2 = Hd2.default.input`
  background: transparent;
  border: 1px solid transparent;
  color: rgba(255, 255, 255, 0.9);
  padding: 1px 6px;
  font: inherit;
  outline: none;
  cursor: ew-resize;
  text-align: left;
  width: 100%;
  height: calc(100% - 4px);
  border-radius: 2px;

  &:focus {
    cursor: text;
  }
`, Jd2 = Hd2.default.div`
  position: absolute;
  inset: 3px 2px 4px;
  transform: scale(var(--percentage), 1);
  transform-origin: top left;
  background-color: #2d5561;
  z-index: -1;
  border-radius: 2px;
  pointer-events: none;

  ${Gd2}.dragging &, ${Gd2}.noFocus:hover & {
    background-color: #338198;
  }
`, Zd2 = (e5) => true;
    var ef2 = (e5) => {
      var t3;
      const [n3, r3] = (0, Ud2.useState)({ mode: "noFocus" }), o3 = (t3 = e5.isValid) != null ? t3 : Zd2, a3 = (0, Ud2.useRef)({ state: n3, props: e5 });
      a3.current = { state: n3, props: e5 };
      const i3 = (0, Ud2.useRef)(null), s3 = (0, Ud2.useRef)(null), l3 = (0, Ud2.useMemo)(() => {
        const t4 = () => {
          const e6 = a3.current.state, t5 = parseFloat(e6.currentEditedValueInString);
          isFinite(t5) && o3(t5) ? e6.valueBeforeEditing === t5 ? a3.current.props.discardTemporaryValue() : a3.current.props.permenantlySetValue(t5) : a3.current.props.discardTemporaryValue();
        }, n4 = () => {
          const e6 = a3.current.props.value;
          r3({ mode: "editingViaKeyboard", currentEditedValueInString: String(e6), valueBeforeEditing: e6 }), setTimeout(() => {
            i3.current.focus(), i3.current.setSelectionRange(0, 100);
          });
        };
        let l4;
        return { inputChange: (e6) => {
          const t5 = e6.target, { value: n5 } = t5, i4 = a3.current.state;
          r3(m2(h2({}, i4), { currentEditedValueInString: n5 }));
          const s4 = parseFloat(n5);
          isFinite(s4) && o3(s4) && a3.current.props.temporarilySetValue(s4);
        }, onBlur: () => {
          a3.current.state.mode === "editingViaKeyboard" && (t4(), r3({ mode: "noFocus" })), e5.onBlur && e5.onBlur();
        }, transitionToDraggingMode: () => {
          var e6;
          const t5 = a3.current.props.value;
          l4 = (e6 = i3.current) == null ? void 0 : e6.getBoundingClientRect().width, r3({ mode: "dragging", valueBeforeDragging: t5, currentDraggingValue: t5 }), s3.current = document.body.style.cursor;
        }, onInputKeyDown: (e6) => {
          e6.key === "Escape" ? (a3.current.props.discardTemporaryValue(), i3.current.blur()) : e6.key !== "Enter" && e6.key !== "Tab" || (t4(), i3.current.blur());
        }, onClick: (e6) => {
          if (a3.current.state.mode === "noFocus") {
            i3.current.focus(), e6.preventDefault(), e6.stopPropagation();
          } else
            e6.stopPropagation();
        }, onFocus: () => {
          a3.current.state.mode === "noFocus" ? n4() : a3.current.state.mode;
        }, onDragEnd: (e6) => {
          if (e6) {
            const e7 = a3.current.state, t5 = e7.currentDraggingValue;
            e7.valueBeforeDragging === t5 ? a3.current.props.discardTemporaryValue() : a3.current.props.permenantlySetValue(t5), r3({ mode: "noFocus" });
          } else
            a3.current.props.discardTemporaryValue(), r3({ mode: "noFocus" }), i3.current.focus(), i3.current.setSelectionRange(0, 100);
        }, onDrag: (t5, n5) => {
          const o4 = a3.current.state;
          let i4 = o4.valueBeforeDragging + e5.nudge({ deltaX: t5, deltaFraction: t5 / l4, magnitude: 1 });
          e5.range && (i4 = Mr2(i4, e5.range[0], e5.range[1])), r3(m2(h2({}, o4), { currentDraggingValue: i4 })), a3.current.props.temporarilySetValue(i4);
        } };
      }, [a3, r3, i3]);
      let u3 = n3.mode !== "editingViaKeyboard" ? (c3 = e5.value, isNaN(c3) ? "NaN" : va2(c3) ? c3.toFixed(0) : Oa2(c3, 3).toString()) : n3.currentEditedValueInString;
      var c3;
      typeof u3 == "number" && isNaN(u3) && (u3 = "NaN");
      const d2 = [i3];
      e5.inputRef && d2.push(e5.inputRef);
      const f2 = Ud2.default.createElement(Qd2, { key: "input", type: "text", onChange: l3.inputChange, value: u3, onBlur: l3.onBlur, onKeyDown: l3.onInputKeyDown, onClick: l3.onClick, onFocus: l3.onFocus, ref: Wu2(d2), onMouseDown: (e6) => {
        e6.stopPropagation();
      }, onDoubleClick: (e6) => {
        e6.preventDefault(), e6.stopPropagation();
      } }), { range: p2 } = e5, v3 = parseFloat(u3), g2 = p2 ? Ud2.default.createElement(Jd2, { style: { "--percentage": Mr2((v3 - p2[0]) / (p2[1] - p2[0]), 0, 1) } }) : null;
      return Ud2.default.createElement(Gd2, { className: e5.className + " " + a3.current.state.mode }, Ud2.default.createElement(Xd2, { key: "draggableArea", onDragStart: l3.transitionToDraggingMode, onDragEnd: l3.onDragEnd, onDrag: l3.onDrag, enabled: a3.current.state.mode !== "editingViaKeyboard", lockCursorTo: "ew-resize" }, f2), g2);
    }, tf2 = w2(je.exports), nf2 = ({ propConfig: e5, pointerToProp: t3, obj: n3 }) => {
      const r3 = Gc2(t3, n3, e5), o3 = (0, tf2.useCallback)((t4) => e5.nudgeFn(m2(h2({}, t4), { config: e5 })), [e5]);
      return tf2.default.createElement(Cd, h2({}, { stuff: r3, propConfig: e5, pointerToProp: t3 }), tf2.default.createElement(ef2, { value: r3.value, temporarilySetValue: r3.temporarilySetValue, discardTemporaryValue: r3.discardTemporaryValue, permenantlySetValue: r3.permenantlySetValue, range: e5.range, nudge: o3 }));
    }, rf2 = w2(je.exports), of2 = w2(je.exports), af2 = w2(yh), sf2 = af2.default.form`
  display: flex;
  flex-direction: row;
  align-items: stretch;
  vertical-align: middle;
  justify-content: stretch;
  height: 24px;
  width: 100%;
`, lf2 = af2.default.label`
  padding: 0 0.5em;
  background: transparent;
  /* background: #373748; */
  display: flex;
  align-items: center;
  justify-content: center;
  flex-grow: 1;
  color: #a7a7a7;
  border: 1px solid transparent;
  box-sizing: border-box;
  border-right-width: 0px;

  & + &:last-child {
    border-right-width: 1px;
  }

  ${sf2}:hover > & {
    border-color: #1c2123;
    /* background-color: #373748; */
    /* color: ${Fi2(0.1, "white")}; */
  }

  &&:hover {
    background-color: #464654;
  }

  &&[data-checked='true'] {
    color: white;
    background: #3f3f4c;
  }
`, uf2 = af2.default.input`
  position: absolute;
  opacity: 0;
  pointer-events: none;
  width: 0;
  height: 0;
`, cf2 = ({ value: e5, onChange: t3, options: n3 }) => {
      const r3 = (0, of2.useCallback)((e6) => {
        t3(String(e6.target.value));
      }, [t3]);
      return of2.default.createElement(sf2, { role: "radiogroup" }, Object.keys(n3).map((t4, o3) => of2.default.createElement(lf2, { key: "label-" + o3, "data-checked": e5 === t4 }, n3[t4], of2.default.createElement(uf2, { type: "radio", checked: e5 === t4, value: t4, onChange: r3, name: "switchbox" }))));
    }, df2 = w2(je.exports), ff2 = w2(yh), pf2 = ff2.default.div`
  width: 100%;
  position: relative;
`, hf2 = ff2.default.div`
  position: absolute;
  right: 0px;
  top: 0;
  bottom: 0;
  width: 1.5em;
  font-size: 14px;
  display: flex;
  align-items: center;
  color: #6b7280;
  pointer-events: none;
`, mf2 = ff2.default.select`
  background-color: transparent;
  box-sizing: border-box;
  border: 1px solid transparent;
  color: rgba(255, 255, 255, 0.85);
  padding: 1px 6px;
  font: inherit;
  outline: none;
  text-align: left;
  width: 100%;
  height: calc(100% - 4px);
  border-radius: 2px;

  color-adjust: exact;
  appearance: none;

  &:hover,
  &:focus {
    background-color: #10101042;
    border-color: #00000059;
  }
`, vf2 = ({ value: e5, onChange: t3, options: n3, className: r3 }) => {
      const o3 = (0, df2.useCallback)((e6) => {
        t3(String(e6.target.value));
      }, [t3]);
      return df2.default.createElement(pf2, null, df2.default.createElement(mf2, { className: r3, value: e5, onChange: o3 }, Object.keys(n3).map((e6, t4) => df2.default.createElement("option", { key: "option-" + t4, value: e6 }, n3[e6]))), df2.default.createElement(hf2, null, df2.default.createElement(bs2, null)));
    }, gf2 = ({ propConfig: e5, pointerToProp: t3, obj: n3 }) => {
      const r3 = Gc2(t3, n3, e5), o3 = (0, rf2.useCallback)((e6) => {
        r3.permenantlySetValue(e6);
      }, [e5, t3, n3]);
      return rf2.default.createElement(Cd, h2({}, { stuff: r3, propConfig: e5, pointerToProp: t3 }), e5.as === "menu" ? rf2.default.createElement(vf2, { value: r3.value, onChange: o3, options: e5.options }) : rf2.default.createElement(cf2, { value: r3.value, onChange: o3, options: e5.options }));
    }, yf2 = w2(je.exports), bf2 = w2(yh), wf2 = w2(je.exports), kf2 = bf2.default.input.attrs({ type: "text" })`
  background: transparent;
  border: 1px solid transparent;
  color: rgba(255, 255, 255, 0.9);
  padding: 1px 6px;
  font: inherit;
  outline: none;
  cursor: text;
  text-align: left;
  width: 100%;
  height: calc(100% - 4px);
  border-radius: 2px;
  border: 1px solid transparent;
  box-sizing: border-box;

  &:hover {
    background-color: #10101042;
    border-color: #00000059;
  }

  &:hover,
  &:focus {
    cursor: text;
    background-color: #10101042;
    border-color: #00000059;
  }
`, xf2 = (e5) => true;
    var Sf2 = (e5) => {
      var t3;
      const [n3, r3] = (0, wf2.useState)({ mode: "noFocus" }), o3 = (t3 = e5.isValid) != null ? t3 : xf2, a3 = (0, wf2.useRef)({ state: n3, props: e5 });
      a3.current = { state: n3, props: e5 };
      const i3 = (0, wf2.useRef)(null), s3 = (0, wf2.useMemo)(() => {
        const t4 = () => {
          const e6 = a3.current.state, t5 = e6.currentEditedValueInString;
          o3(t5) ? e6.valueBeforeEditing === t5 ? a3.current.props.discardTemporaryValue() : a3.current.props.permenantlySetValue(t5) : a3.current.props.discardTemporaryValue();
        }, n4 = () => {
          const e6 = a3.current.props.value;
          r3({ mode: "editingViaKeyboard", currentEditedValueInString: String(e6), valueBeforeEditing: e6 }), setTimeout(() => {
            i3.current.focus();
          });
        };
        return { inputChange: (e6) => {
          const t5 = e6.target, { value: n5 } = t5, i4 = a3.current.state;
          r3(m2(h2({}, i4), { currentEditedValueInString: n5 })), o3(n5) && a3.current.props.temporarilySetValue(n5);
        }, onBlur: () => {
          a3.current.state.mode === "editingViaKeyboard" && (t4(), r3({ mode: "noFocus" })), e5.onBlur && e5.onBlur();
        }, onInputKeyDown: (e6) => {
          e6.key === "Escape" ? (a3.current.props.discardTemporaryValue(), i3.current.blur()) : e6.key !== "Enter" && e6.key !== "Tab" || (t4(), i3.current.blur());
        }, onClick: (e6) => {
          if (a3.current.state.mode === "noFocus") {
            i3.current.focus(), e6.preventDefault(), e6.stopPropagation();
          } else
            e6.stopPropagation();
        }, onFocus: () => {
          a3.current.state.mode === "noFocus" ? n4() : a3.current.state.mode;
        } };
      }, [a3, r3, i3]);
      let l3 = n3.mode !== "editingViaKeyboard" ? e5.value : n3.currentEditedValueInString;
      const u3 = [i3];
      e5.inputRef && u3.push(e5.inputRef);
      const c3 = wf2.default.createElement(kf2, { key: "input", type: "text", onChange: s3.inputChange, value: l3, onBlur: s3.onBlur, onKeyDown: s3.onInputKeyDown, onClick: s3.onClick, onFocus: s3.onFocus, ref: Wu2(u3), onMouseDown: (e6) => {
        e6.stopPropagation();
      }, onDoubleClick: (e6) => {
        e6.preventDefault(), e6.stopPropagation();
      } });
      return c3;
    }, _f2 = { compound: Vd2, number: nf2, string: ({ propConfig: e5, pointerToProp: t3, obj: n3 }) => {
      const r3 = Gc2(t3, n3, e5);
      return yf2.default.createElement(Cd, h2({}, { stuff: r3, propConfig: e5, pointerToProp: t3 }), yf2.default.createElement(Sf2, { value: r3.value, temporarilySetValue: r3.temporarilySetValue, discardTemporaryValue: r3.discardTemporaryValue, permenantlySetValue: r3.permenantlySetValue }));
    }, enum: () => Ec2.default.createElement(Ec2.default.Fragment, null), boolean: Id2, stringLiteral: gf2 }, Ef2 = (e5) => {
      var t3;
      const n3 = (t3 = e5.propConfig) != null ? t3 : ((e6, t4) => {
        const n4 = t4.template.config.props, r4 = (0, _c2.getPointerParts)(e6).path;
        let o3 = n4;
        for (; r4.length !== 0; ) {
          const e7 = r4.shift();
          if (typeof e7 != "string")
            throw typeof e7 == "number" ? new Error("Number indexes are not implemented yet. @todo") : new Error("getPropTypeConfigByPath() is called with an invalid path.");
          if (o3.type === "compound") {
            if (o3 = o3.props[e7], !o3)
              throw new Error("getPropTypeConfigByPath() is called with an invalid path.");
          } else {
            if (o3.type !== "enum")
              throw new Error("getPropTypeConfigByPath() is called with an invalid path.");
            if (o3 = o3.cases[e7], !o3)
              throw new Error("getPropTypeConfigByPath() is called with an invalid path.");
          }
        }
        return o3;
      })(e5.pointerToProp, e5.obj), r3 = _f2[n3.type];
      return Ec2.default.createElement(r3, { obj: e5.obj, depth: e5.depth, pointerToProp: e5.pointerToProp, propConfig: n3 });
    }, Pf2 = ({ objects: e5 }) => {
      const t3 = e5[0], n3 = (0, Sc2.useMemo)(() => JSON.stringify(t3.address), [t3]);
      return Sc2.default.createElement(Ef2, { key: n3, obj: t3, pointerToProp: t3.propsP, propConfig: t3.template.config, depth: 1 });
    }, Cf2 = w2(je.exports), jf2 = w2(ht.exports);
    function Of2(e5, t3) {
      const [n3, r3] = (0, Cf2.useState)({ isOpen: false }), o3 = (0, Cf2.useCallback)((e6, t4) => {
        r3({ isOpen: true, clickPoint: { clientX: e6.clientX, clientY: e6.clientY }, target: t4 });
      }, []), a3 = (0, Cf2.useCallback)(() => {
        r3({ isOpen: false });
      }, []), i3 = (0, Cf2.useCallback)(() => {
        e5.closeOnClickOutside !== false && a3();
      }, [e5.closeOnClickOutside]), s3 = (0, Cf2.useContext)(Uu2), l3 = (0, Cf2.useMemo)(() => {
        var t4;
        if (e5.closeWhenPointerIsDistant !== false)
          return { threshold: (t4 = e5.pointerDistanceThreshold) != null ? t4 : 100, callback: a3 };
      }, [e5.closeWhenPointerIsDistant]);
      return [n3.isOpen ? (0, jf2.createPortal)(Cf2.default.createElement(Pl2, { children: t3, target: n3.target, onClickOutside: i3, onPointerOutside: l3 }), s3) : Cf2.default.createElement(Cf2.default.Fragment, null), o3, a3, n3.isOpen];
    }
    var Tf2 = w2(je.exports), If2 = w2(yh), Df2 = w2(je.exports), Rf2 = w2(yh);
    function Nf2() {
      return ((e5 = 21) => {
        let t3 = "", n3 = crypto.getRandomValues(new Uint8Array(e5));
        for (; e5--; ) {
          let r3 = 63 & n3[e5];
          t3 += r3 < 36 ? r3.toString(36) : r3 < 62 ? (r3 - 26).toString(36).toUpperCase() : r3 < 63 ? "_" : "-";
        }
        return t3;
      })(16);
    }
    var Af2 = w2(yh).default.button`
  text-align: center;
  padding: 8px;
  border-radius: 2px;
  border: 1px solid #627b7b87;
  background-color: #4b787d3d;
  color: #eaeaea;
  font-weight: 400;
  display: block;
  appearance: none;
  flex-grow: 1;
  cursor: ${(e5) => e5.disabled ? "none" : "pointer"};
  opacity: ${(e5) => e5.disabled ? 0.4 : 1};

  &:hover {
    background-color: #7dc1c878;
    border-color: #9ebcbf;
  }
`, zf2 = Rf2.default.div`
  padding: 8px 10px;
  position: relative;
  background-color: #6d232352;
  &:before {
    position: absolute;
    content: ' ';
    display: block;
    left: 0;
    top: 0;
    bottom: 0;
    width: 2px;
    background-color: #ff000070;
  }
`, Mf2 = Rf2.default.div`
  margin-bottom: 1em;
  & a {
    color: inherit;
  }
`, Lf2 = Rf2.default.div`
  display: flex;
  gap: 8px;
`, Ff2 = ({ projectId: e5, loadingState: t3 }) => {
      const [n3, r3] = Hu2({}, () => Df2.default.createElement(sc2, null, "The browser's state will override the disk state.")), [o3, a3] = Hu2({}, () => Df2.default.createElement(sc2, null, "The disk's state will override the browser's state."));
      return Df2.default.createElement(zf2, null, Df2.default.createElement(Mf2, null, "Browser state is not based on disk state.", " ", Df2.default.createElement("a", { href: "https://docs.theatrejs.com/in-depth/#exporting", target: "_blank" }, "Learn more.")), Df2.default.createElement(Lf2, null, n3, Df2.default.createElement(Af2, { onClick: () => {
        me2().transaction(({ drafts: n4, stateEditors: r4 }) => {
          r4.coreByProject.historic.revisionHistory.add({ projectId: e5, revision: t3.onDiskState.revisionHistory[0] }), r4.coreByProject.historic.revisionHistory.add({ projectId: e5, revision: Nf2() }), n4.ephemeral.coreByProject[e5].loadingState = { type: "loaded" };
        });
      }, ref: r3 }, "Use browser's state"), o3, Df2.default.createElement(Af2, { onClick: () => {
        me2().transaction(({ drafts: n4 }) => {
          n4.historic.coreByProject[e5] = t3.onDiskState, n4.ephemeral.coreByProject[e5].loadingState = { type: "loaded" };
        });
      }, ref: a3 }, "Use disk state")));
    }, $f2 = ({ projectId: e5 }) => {
      const t3 = $a2(me2().atomP.ephemeral.coreByProject[e5].loadingState);
      return t3 && t3.type === "browserStateIsNotBasedOnDiskState" ? Df2.default.createElement(Ff2, { loadingState: t3, projectId: e5 }) : null;
    }, Bf2 = If2.default.div`
  background-color: ${bd2};
`, Vf2 = If2.default.div`
  padding: 8px 10px;
  display: flex;
  flex-direction: column;
  align-items: stretch;
`, Uf2 = (0, If2.default)(ic2)`
  width: 280px;
  padding: 1em;
`, Hf2 = ({ projects: e5 }) => {
      const t3 = e5[0], n3 = t3.address.projectId, [r3, o3] = (0, Tf2.useState)(false), a3 = (0, Tf2.useCallback)(() => {
        const e6 = JSON.stringify(me2().createContentOfSaveFile(t3.address.projectId), null, 2), n4 = new File([e6], "state.json", { type: "application/json" }), r4 = URL.createObjectURL(n4), a4 = document.createElement("a");
        a4.href = r4, a4.target = "_blank", a4.setAttribute("download", "state.json"), a4.rel = "noopener", a4.click(), o3(true), setTimeout(() => {
          o3(false);
        }, 2e3), setTimeout(() => {
          URL.revokeObjectURL(r4);
        }, 4e4);
      }, []), [i3, s3] = Of2({ pointerDistanceThreshold: 50 }, () => Tf2.default.createElement(Uf2, null, "This will create a JSON file with the state of your project. You can commit this file to your git repo and include it in your production bundle.", Tf2.default.createElement("a", { href: "https://docs.theatrejs.com/in-depth/#exporting", target: "_blank" }, "Here is a quick guide on how to export to production.")));
      return Tf2.default.createElement(Tf2.default.Fragment, null, i3, Tf2.default.createElement(Bf2, null, Tf2.default.createElement($f2, { projectId: n3 }), Tf2.default.createElement(Vf2, null, Tf2.default.createElement(Af2, { onMouseEnter: (e6) => s3(e6, e6.target), onClick: r3 ? void 0 : a3, disabled: r3 }, r3 ? "(Exported)" : `Export ${n3} to JSON`))));
    }, Wf2 = xc2.default.div`
  background-color: transparent;
  pointer-events: none;
  position: fixed;
  left: 0;
  right: 0;
  top: 12px;
  bottom: 0px;
  z-index: ${Xi2.propsPanel};

  &:before {
    display: block;
    content: ' ';
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    width: 20px;
    ${qi2};
  }
`, qf2 = xc2.default.div`
  position: absolute;
  top: 0;
  right: 0;
  width: 260px;
  bottom: 0;
  /* transform: translateX(100%); */
  /* pointer-events: none; */

  ${Wf2}:hover & {
    transform: translateX(0);
  }
`, Kf2 = xc2.default.div`
  margin: 0 10px;
  color: #ffffffc2;
  font-weight: 500;
  font-size: 10px;
  user-select: none;
  ${qi2};
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`, Yf2 = "32px", Xf2 = xc2.default.div`
  height: ${Yf2};
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;

  &:after {
    position: absolute;
    inset: 1px 0px;
    display: block;
    content: ' ';
    pointer-events: none;
    z-index: -1;
    background-color: #262c2dd1;
    /* border-radius: 2px 0 0 2px; */
  }
`, Gf2 = xc2.default.div`
  ${qi2};
  position: absolute;
  top: ${Yf2};
  left: 0;
  right: 0;
  height: auto;
  max-height: calc(100% - ${Yf2});
  overflow-y: scroll;
  padding: 0;
  user-select: none;
`, Qf2 = (e5) => Fa2(() => {
      const e6 = Ns2(), t3 = e6.find(xe2);
      if (t3)
        return kc2.default.createElement(Wf2, null, kc2.default.createElement(qf2, null, kc2.default.createElement(Xf2, null, kc2.default.createElement(Kf2, { title: `${t3.sheet.address.sheetId}: ${t3.sheet.address.sheetInstanceId} > ${t3.address.objectKey}` }, kc2.default.createElement(Qi2, null, t3.sheet.address.sheetId, " "), kc2.default.createElement(Ji2, null, ":", "\xA0"), kc2.default.createElement(Qi2, null, t3.sheet.address.sheetInstanceId, " "), kc2.default.createElement(Ji2, null, "\xA0", ">", "\xA0"), kc2.default.createElement(Qi2, null, t3.address.objectKey))), kc2.default.createElement(Gf2, null, kc2.default.createElement(Pf2, { objects: [t3] }))));
      const n3 = e6.find(be2);
      return n3 ? kc2.default.createElement(Wf2, null, kc2.default.createElement(qf2, null, kc2.default.createElement(Xf2, null, kc2.default.createElement(Kf2, { title: `${n3.address.projectId}` }, kc2.default.createElement(Qi2, null, n3.address.projectId, " "))), kc2.default.createElement(Gf2, null, kc2.default.createElement(Hf2, { projects: [n3] })))) : kc2.default.createElement(kc2.default.Fragment, null);
    }, []), Jf2 = w2(je.exports), Zf2 = w2(je.exports), ep2 = w2(yh), tp2 = w2(g), np2 = w2(je.exports);
    var rp2 = w2(je.exports), op2 = (e5, t3) => {
      const n3 = e5.left / t3.width, r3 = (e5.left + e5.width) / t3.width, o3 = e5.top / t3.height, a3 = (e5.height + e5.top) / t3.height;
      return { edges: { left: n3 <= 0.5 ? { from: "screenLeft", distance: n3 } : { from: "screenRight", distance: 1 - n3 }, right: r3 <= 0.5 ? { from: "screenLeft", distance: r3 } : { from: "screenRight", distance: 1 - r3 }, top: o3 <= 0.5 ? { from: "screenTop", distance: o3 } : { from: "screenBottom", distance: 1 - o3 }, bottom: a3 <= 0.5 ? { from: "screenTop", distance: a3 } : { from: "screenBottom", distance: 1 - a3 } } };
    }, ap2 = rp2.default.createContext(null), ip2 = () => (0, rp2.useContext)(ap2), sp2 = ({ panelId: e5, children: t3, defaultPosition: n3, minDims: r3 }) => {
      const o3 = kl2(800, 200), [a3, i3] = function() {
        const [e6, t4] = (0, np2.useState)(false);
        return [e6, (0, np2.useMemo)(() => {
          const e7 = /* @__PURE__ */ new Set();
          return () => {
            const n4 = () => {
              e7.delete(n4), t4(e7.size > 0);
            };
            return e7.add(n4), t4(true), n4;
          };
        }, [])];
      }(), { stuff: s3 } = Fa2(() => {
        var t4;
        const { edges: s4 } = (t4 = (0, tp2.val)(me2().atomP.historic.panelPositions[e5])) != null ? t4 : n3, l3 = Math.floor(o3.width * (s4.left.from === "screenLeft" ? s4.left.distance : 1 - s4.left.distance)), u3 = Math.floor(o3.width * (s4.right.from === "screenLeft" ? s4.right.distance : 1 - s4.right.distance)), c3 = Math.floor(o3.height * (s4.top.from === "screenTop" ? s4.top.distance : 1 - s4.top.distance)), d2 = Math.floor(o3.height * (s4.bottom.from === "screenTop" ? s4.bottom.distance : 1 - s4.bottom.distance));
        return { stuff: { dims: { width: Math.max(u3 - l3, r3.width), left: l3, top: c3, height: Math.max(d2 - c3, r3.height) }, panelId: e5, minDims: r3, boundsHighlighted: a3, addBoundsHighlightLock: i3 } };
      }, [e5, o3, a3, i3]);
      return rp2.default.createElement(ap2.Provider, { value: s3 }, t3);
    }, lp2 = w2(je.exports), up2 = w2(je.exports), cp2 = w2(yh), dp2 = cp2.default.div`
  pointer-events: auto;
  &.normal {
    pointer-events: none;
  }
`, fp2 = cp2.default.div`
  position: absolute;
  inset: 0;
  pointer-events: none;

  #pointer-root:not(.normal) > & {
    pointer-events: auto;
  }
`, pp2 = (0, up2.createContext)({}), hp2 = (e5, t3, n3) => {
      const r3 = (0, up2.useContext)(pp2);
      (0, up2.useLayoutEffect)(() => {
        if (e5)
          return r3.getLock(t3, n3);
      }, [e5, t3, n3]);
    }, mp2 = (e5) => {
      var t3, n3, r3, o3;
      const [a3, i3] = (0, up2.useState)([]), s3 = (0, up2.useMemo)(() => ({ getLock: (e6, t4) => {
        const n4 = { className: e6, cursor: t4 };
        i3((e7) => [...e7, n4]);
        return () => {
          i3((e7) => e7.filter((e8) => e8 !== n4));
        };
      } }), []);
      return up2.default.createElement(pp2.Provider, { value: s3 }, up2.default.createElement(dp2, { id: "pointer-root", className: ((n3 = (t3 = a3[0]) == null ? void 0 : t3.className) != null ? n3 : "normal") + " " + e5.className }, up2.default.createElement(fp2, { style: { cursor: (o3 = (r3 = a3[0]) == null ? void 0 : r3.cursor) != null ? o3 : "" } }, e5.children)));
    };
    function vp2(e5, t3) {
      const n3 = (0, lp2.useRef)(t3);
      n3.current = t3;
      const [r3, o3] = sl2("notDragging");
      hp2(o3 === "dragging" && typeof t3.lockCursorTo == "string", "dragging", t3.lockCursorTo);
      const a3 = (0, lp2.useRef)({ dragHappened: false, startPos: { x: 0, y: 0 } });
      return (0, lp2.useLayoutEffect)(() => {
        if (!e5)
          return;
        const t4 = (e6) => {
          a3.current.dragHappened || (a3.current.dragHappened = true), r3.current = "dragging";
          const t5 = ((e7) => {
            const { startPos: t6 } = a3.current;
            return [e7.screenX - t6.x, e7.screenY - t6.y];
          })(e6);
          n3.current.onDrag(t5[0], t5[1], e6);
        }, o4 = () => {
          i3(), r3.current = "notDragging", n3.current.onDragEnd && n3.current.onDragEnd(a3.current.dragHappened);
        }, i3 = () => {
          document.removeEventListener("mousemove", t4), document.removeEventListener("mouseup", o4);
        }, s3 = (e6) => {
          n3.current.disabled || a3.current.dragHappened && (n3.current.dontBlockMouseDown || r3.current === "notDragging" || (e6.stopPropagation(), e6.preventDefault()), a3.current.dragHappened = false);
        }, l3 = (e6) => {
          const i4 = n3.current;
          if (i4.disabled === true)
            return;
          if (e6.button !== 0)
            return;
          if ((i4.onDragStart && i4.onDragStart(e6)) === false)
            return;
          i4.dontBlockMouseDown || (e6.stopPropagation(), e6.preventDefault()), r3.current = "dragStartCalled";
          const { screenX: s4, screenY: l4 } = e6;
          a3.current.startPos = { x: s4, y: l4 }, a3.current.dragHappened = false, document.addEventListener("mousemove", t4), document.addEventListener("mouseup", o4);
        }, u3 = (e6) => {
          l3(e6);
        };
        return e5.addEventListener("mousedown", u3), e5.addEventListener("click", s3), () => {
          i3(), e5.removeEventListener("mousedown", u3), e5.removeEventListener("click", s3), r3.current !== "notDragging" && n3.current.onDragEnd && n3.current.onDragEnd(r3.current === "dragging"), r3.current = "notDragging";
        };
      }, [e5]), [o3 === "dragging"];
    }
    var gp2 = w2(je.exports), yp2 = w2(yh).default.div`
  cursor: move;
`, bp2 = (e5) => {
      const t3 = ip2(), n3 = (0, gp2.useRef)(t3);
      n3.current = t3;
      const [r3, o3] = sl2(null);
      vp2(o3, (0, gp2.useMemo)(() => {
        let e6, r4, o4 = n3.current;
        return { lockCursorTo: "move", onDragStart() {
          if (o4 = n3.current, r4) {
            const e7 = r4;
            r4 = void 0, e7();
          }
          r4 = t3.addBoundsHighlightLock();
        }, onDrag(t4, n4) {
          const r5 = m2(h2({}, o4.dims), { top: o4.dims.top + n4, left: o4.dims.left + t4 }), a4 = op2(r5, { width: window.innerWidth, height: window.innerHeight });
          e6 == null || e6.discard(), e6 = me2().tempTransaction(({ stateEditors: e7 }) => {
            e7.studio.historic.panelPositions.setPanelPosition({ position: a4, panelId: o4.panelId });
          });
        }, onDragEnd(t4) {
          if (r4) {
            const e7 = r4;
            r4 = void 0, e7();
          }
          t4 ? e6 == null || e6.commit() : e6 == null || e6.discard(), e6 = void 0;
        } };
      }, []));
      const [a3, i3] = (0, gp2.useMemo)(() => {
        let e6;
        return [function() {
          if (e6) {
            const t4 = e6;
            e6 = void 0, t4();
          }
          e6 = t3.addBoundsHighlightLock();
        }, function() {
          if (e6) {
            const t4 = e6;
            e6 = void 0, t4();
          }
        }];
      }, []);
      return gp2.default.createElement(yp2, m2(h2({}, e5), { ref: r3, onMouseEnter: a3, onMouseLeave: i3 }));
    }, wp2 = w2(je.exports), kp2 = w2(yh), xp2 = w2(je.exports), Sp2 = w2(yh), _p2 = w2(je.exports), Ep2 = w2(yh), Pp2 = Ep2.default.div`
  position: absolute;
  z-index: 10;
  ${qi2};
  &:after {
    position: absolute;
    top: -2px;
    right: -2px;
    bottom: -2px;
    left: -2px;
    display: block;
    content: ' ';
  }

  opacity: 0;
  background-color: #478698;

  &.isHighlighted {
    opacity: 0.7;
  }

  &.isDragging {
    opacity: 1;
    /* background-color: ${Bi2(0.2, "#478698")}; */
  }

  &:hover {
    opacity: 1;
  }
`, Cp2 = (0, Ep2.default)(Pp2)`
  left: 0;
  right: 0;
  height: 1px;
`, jp2 = (0, Ep2.default)(Cp2)`
  top: 0;
`, Op2 = (0, Ep2.default)(Cp2)`
  bottom: 0;
`, Tp2 = (0, Ep2.default)(Pp2)`
  top: 0;
  bottom: 0;
  width: 1px;
`, Ip2 = (0, Ep2.default)(Tp2)`
  left: 0;
`, Dp2 = (0, Ep2.default)(Tp2)`
  right: 0;
`, Rp2 = (0, Ep2.default)(Pp2)`
  width: 8px;
  height: 8px;
`, Np2 = { Top: jp2, TopLeft: (0, Ep2.default)(Rp2)`
  top: 0;
  left: 0;
`, TopRight: (0, Ep2.default)(Rp2)`
  top: 0;
  right: 0;
`, Bottom: Op2, BottomLeft: (0, Ep2.default)(Rp2)`
  bottom: 0;
  left: 0;
`, BottomRight: (0, Ep2.default)(Rp2)`
  bottom: 0;
  right: 0;
`, Left: Ip2, Right: Dp2 }, Ap2 = { Top: "ns-resize", Bottom: "ns-resize", Left: "ew-resize", Right: "ew-resize", TopLeft: "nw-resize", TopRight: "ne-resize", BottomLeft: "sw-resize", BottomRight: "se-resize" }, zp2 = ({ which: e5 }) => {
      const t3 = ip2(), n3 = (0, _p2.useRef)(t3);
      n3.current = t3;
      const [r3, o3] = (0, _p2.useState)(false), [a3, i3] = sl2(null);
      vp2(i3, (0, _p2.useMemo)(() => {
        let r4, a4, i4 = n3.current;
        return { lockCursorTo: Ap2[e5], onDragStart() {
          if (i4 = n3.current, o3(true), a4) {
            const e6 = a4;
            a4 = void 0, e6();
          }
          a4 = t3.addBoundsHighlightLock();
        }, onDrag(t4, n4) {
          const o4 = h2({}, i4.dims);
          if (e5.startsWith("Bottom"))
            o4.height = Math.max(o4.height + n4, i4.minDims.height);
          else if (e5.startsWith("Top")) {
            const e6 = o4.top + o4.height, t5 = Math.min(e6 - i4.minDims.height, o4.top + n4), r5 = e6 - t5;
            o4.height = r5, o4.top = t5;
          }
          if (e5.endsWith("Left")) {
            const e6 = o4.left + o4.width, n5 = Math.min(e6 - i4.minDims.width, o4.left + t4), r5 = e6 - n5;
            o4.width = r5, o4.left = n5;
          } else
            e5.endsWith("Right") && (o4.width = Math.max(o4.width + t4, i4.minDims.width));
          const a5 = op2(o4, { width: window.innerWidth, height: window.innerHeight });
          r4 == null || r4.discard(), r4 = me2().tempTransaction(({ stateEditors: e6 }) => {
            e6.studio.historic.panelPositions.setPanelPosition({ position: a5, panelId: i4.panelId });
          });
        }, onDragEnd(e6) {
          if (a4) {
            const e7 = a4;
            a4 = void 0, e7();
          }
          o3(false), e6 ? r4 == null || r4.commit() : r4 == null || r4.discard(), r4 = void 0;
        } };
      }, [e5]));
      const s3 = Np2[e5], l3 = e5.length <= 6;
      return _p2.default.createElement(s3, { ref: a3, className: [r3 ? "isDragging" : "", t3.boundsHighlighted && l3 ? "isHighlighted" : ""].join(" "), style: { cursor: Ap2[e5] } });
    };
    Sp2.default.div``;
    var Mp2 = (e5) => xp2.default.createElement(xp2.default.Fragment, null, xp2.default.createElement(zp2, { which: "Bottom" }), xp2.default.createElement(zp2, { which: "Top" }), xp2.default.createElement(zp2, { which: "Left" }), xp2.default.createElement(zp2, { which: "Right" }), xp2.default.createElement(zp2, { which: "TopLeft" }), xp2.default.createElement(zp2, { which: "TopRight" }), xp2.default.createElement(zp2, { which: "BottomLeft" }), xp2.default.createElement(zp2, { which: "BottomRight" })), Lp2 = kp2.default.div`
  position: absolute;
  user-select: none;
  box-sizing: border-box;
  ${qi2};
  /* box-shadow: 1px 2px 10px -5px black; */

  z-index: 1000;
`, Fp2 = wp2.default.forwardRef((e5, t3) => {
      const n3 = ip2(), r3 = e5, { style: o3, children: a3 } = r3, i3 = y2(r3, ["style", "children"]);
      return wp2.default.createElement(Lp2, m2(h2({ ref: t3 }, i3), { style: h2({ width: n3.dims.width + "px", height: n3.dims.height + "px", top: n3.dims.top + "px", left: n3.dims.left + "px" }, o3 != null ? o3 : {}) }), wp2.default.createElement(Mp2, null), a3);
    }), $p2 = w2(N2()), Bp2 = { edges: { left: { from: "screenLeft", distance: 0.3 }, right: { from: "screenRight", distance: 0.3 }, top: { from: "screenTop", distance: 0.3 }, bottom: { from: "screenBottom", distance: 0.3 } } }, Vp2 = { width: 300, height: 300 }, Up2 = (0, ep2.default)(Fp2)`
  overflow-y: hidden;
  display: flex;
  flex-direction: column;

  box-shadow: 0px 5px 12px -4px rgb(0 0 0 / 22%);
  z-index: ${Xi2.pluginPanes};
`, Hp2 = ep2.default.div`
  width: 100%;
`, Wp2 = ep2.default.div`
  display: flex;
  align-items: center;
  opacity: 1;
  position: absolute;
  right: 4px;
  top: 0;
  bottom: 0;
`, qp2 = ep2.default.button`
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 2px;
  font-size: 11px;
  height: 10px;
  width: 18px;
  color: #adadadb3;
  background: transparent;
  border: none;
  cursor: pointer;
  &:hover {
    color: white;
  }
`, Kp2 = (0, ep2.default)(Zi2)`
  position: relative;
  overflow: hidden;

  &:after {
    z-index: 10;
    position: absolute;
    inset: 0;
    display: block;
    content: ' ';
    pointer-events: none;

    #pointer-root:not(.normal) & {
      pointer-events: auto;
    }
  }
`, Yp2 = ep2.default.div`
  padding: 12px;

  & > pre {
    border: 1px solid #ff62624f;
    background-color: rgb(255 0 0 / 5%);
    margin: 8px 0;
    padding: 8px;
    font-family: monospace;
    overflow: scroll;
    color: #ff9896;
  }
`, Xp2 = (e5) => Zf2.default.createElement(Yp2, null, "An Error occured rendering this pane. Open the console for more info.", Zf2.default.createElement("pre", null, JSON.stringify({ message: e5.error.message, stack: e5.error.stack }, null, 2))), Gp2 = ({ paneInstance: e5 }) => {
      const t3 = e5.definition.component, n3 = (0, Zf2.useCallback)(() => {
        me2().paneManager.destroyPane(e5.instanceId);
      }, [e5]);
      return Zf2.default.createElement(Up2, null, Zf2.default.createElement(bp2, null, Zf2.default.createElement(es2, null, Zf2.default.createElement(Wp2, null, Zf2.default.createElement(qp2, { onClick: n3, title: "Close Pane" }, Zf2.default.createElement(hs2, null))), Zf2.default.createElement(Hp2, null, e5.instanceId))), Zf2.default.createElement(Kp2, null, Zf2.default.createElement($p2.ErrorBoundary, { FallbackComponent: Xp2 }, Zf2.default.createElement(t3, { paneId: e5.instanceId }))));
    }, Qp2 = ({ paneInstance: e5 }) => Zf2.default.createElement(sp2, { panelId: `pane-${e5.instanceId}`, defaultPosition: Bp2, minDims: Vp2 }, Zf2.default.createElement(Gp2, { paneInstance: e5 })), Jp2 = w2(g), Zp2 = (e5, t3) => {
      const n3 = Jp2.prism.memo(e5, () => new Jp2.Atom(t3), []);
      return n3.setState(t3), n3;
    }, eh2 = w2(g), th2 = w2(je.exports), nh2 = w2(yh), rh2 = w2(je.exports), oh2 = w2(yh), ah2 = w2(g), ih2 = w2(je.exports), sh2 = w2(yh), lh2 = w2(je.exports), uh2 = w2(yh), ch2 = w2(je.exports), dh2 = w2(yh), fh2 = w2(je.exports), ph2 = w2(yh), hh2 = ph2.default.li`
  --depth: ${(e5) => e5.depth};
  margin: 0;
  padding: 0;
  list-style: none;
`, mh2 = ph2.default.div`
  border-bottom: 1px solid #7695b705;
`, vh2 = (0, ph2.default)(mh2)`
  padding-left: calc(16px + var(--depth) * 20px);

  display: flex;
  align-items: stretch;
  color: ${Ki2.panel.body.compoudThing.label.color};

  box-sizing: border-box;

  ${(e5) => e5.isSelected && "background: blue"};
`, gh2 = ph2.default.span`
  ${kd2};
  overflow-x: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  padding-right: 4px;
  line-height: 26px;
  flex-wrap: nowrap;
`, bh2 = ph2.default.span`
  width: 12px;
  margin-right: 8px;
  font-size: 9px;
  display: flex;
  align-items: center;

  transform: rotateZ(${(e5) => e5.isOpen ? 90 : 0}deg);
`, wh = ph2.default.ul`
  margin: 0;
  padding: 0;
  list-style: none;
`, kh = ({ leaf: e5, label: t3, children: n3, isSelectable: r3, isSelected: o3, toggleSelect: a3 }) => {
      const i3 = Array.isArray(n3) && n3.length > 0;
      return fh2.default.createElement(hh2, { depth: e5.depth }, fh2.default.createElement(vh2, { style: { height: e5.nodeHeight + "px" }, isSelectable: r3 === true, isSelected: o3 === true, onClick: a3, isEven: e5.n % 2 == 0 }, fh2.default.createElement(bh2, { isOpen: true }, fh2.default.createElement(ys2, null)), fh2.default.createElement(gh2, null, t3)), i3 && fh2.default.createElement(wh, null, n3));
    }, xh = w2(je.exports), Sh = w2(yh), _h = (e5) => JSON.stringify(e5);
    var Eh = w2(g), Ph = w2(je.exports), Ch = w2(yh), jh = w2(g), Oh = w2(je.exports), Th = w2(yh), Ih = w2(g), Dh = w2(je.exports), Rh = w2(yh), Nh = w2(je.exports), Ah = w2(je.exports);
    function zh(e5) {
      const [t3, n3] = (0, Nh.useState)(false);
      return function(e6, t4) {
        const n4 = (0, Ah.useRef)({ combo: e6, listener: t4 });
        n4.current = { combo: e6, listener: t4 }, (0, Ah.useEffect)(() => {
          function e7(e8) {
            e8.key === n4.current.combo && n4.current.listener({ down: true, event: e8 });
          }
          function t5(e8) {
            e8.key === n4.current.combo && n4.current.listener({ down: false, event: e8 });
          }
          function r3(e8) {
            n4.current.listener({ down: false, event: void 0 });
          }
          return document.addEventListener("keydown", e7), document.addEventListener("keyup", t5), window.addEventListener("blur", r3), () => {
            document.removeEventListener("keydown", e7), document.removeEventListener("keyup", t5), window.removeEventListener("blur", r3);
          };
        }, []);
      }(e5, ({ down: e6 }) => {
        n3(e6);
      }), t3;
    }
    var Mh = w2(g), Lh = w2(je.exports);
    var Fh = w2(g);
    function $h(e5, t3, n3) {
      const r3 = (0, Fh.getPointerParts)(t3((0, Fh.pointer)({ root: {}, path: [] }))).path;
      Ta2(e5, r3, n3);
    }
    var Bh, Vh = w2(g), Uh = w2(je.exports), Hh = w2(yh), Wh = Hh.default.div`
  cursor: ${(e5) => e5.isShiftDown ? "cell" : "default"};
`;
    !function(e5) {
      const t3 = { primitiveProp(e6, t4, n4, r3) {
        const { sheetObject: o3, trackId: a3 } = t4, i3 = (0, Vh.val)(me2().atomP.historic.coreByProject[o3.address.projectId].sheetsById[o3.address.sheetId].sequence.tracksByObject[o3.address.objectKey].trackData[a3]);
        i3.keyframes.filter((e7) => e7.position >= n4.positions[0] && e7.position <= n4.positions[1]);
        for (const e7 of i3.keyframes)
          if (!(e7.position <= n4.positions[0])) {
            if (e7.position >= n4.positions[1])
              break;
            $h(r3, (t5) => t5.byObjectKey[o3.address.objectKey].byTrackId[a3].byKeyframeId[e7.id], true);
          }
      } };
      function n3(e6, r3, o3, a3) {
        if (o3.ys[0] > r3.top + r3.heightIncludingChildren || r3.top > o3.ys[1])
          return;
        const i3 = t3[r3.type];
        i3 ? i3(e6, r3, o3, a3) : ((e7, t4, r4, o4) => {
          if ("children" in t4)
            for (const a4 of t4.children)
              n3(e7, a4, r4, o4);
        })(e6, r3, o3, a3);
      }
      e5.boundsToSelection = function(e6, t4) {
        const r3 = (0, Vh.val)(e6.tree.sheet), o3 = { type: "DopeSheetSelection", byObjectKey: {}, getDragHandlers(t5) {
          let n4, a4;
          return { onDragStart() {
            a4 = (0, Vh.val)(e6.scaledSpace.toUnitSpace);
          }, onDrag(e7, i3, s3) {
            let l3 = a4(e7);
            n4 && (n4.discard(), n4 = void 0);
            const u3 = s3.composedPath().find((e8) => e8 instanceof Element && e8 !== t5.domNode && e8.hasAttribute("data-pos"));
            if (u3) {
              const e8 = parseFloat(u3.getAttribute("data-pos"));
              isFinite(e8) && (l3 = e8 - t5.positionAtStartOfDrag);
            }
            n4 = me2().tempTransaction(({ stateEditors: e8 }) => {
              const n5 = e8.coreByProject.historic.sheetsById.sequence.transformKeyframes;
              for (const e9 of Object.keys(o3.byObjectKey)) {
                const { byTrackId: a5 } = o3.byObjectKey[e9];
                for (const o4 of Object.keys(a5)) {
                  const { byKeyframeId: i4 } = a5[o4];
                  n5({ trackId: o4, keyframeIds: Object.keys(i4), translate: l3, scale: 1, origin: 0, snappingFunction: r3.getSequence().closestGridPosition, objectKey: e9, projectId: t5.projectId, sheetId: t5.sheetId });
                }
              }
            });
          }, onDragEnd(e7) {
            e7 ? n4 && n4.commit() : n4 && n4.discard(), n4 = void 0;
          } };
        }, delete() {
          me2().transaction(({ stateEditors: e7 }) => {
            const t5 = e7.coreByProject.historic.sheetsById.sequence.deleteKeyframes;
            for (const e8 of Object.keys(o3.byObjectKey)) {
              const { byTrackId: n4 } = o3.byObjectKey[e8];
              for (const o4 of Object.keys(n4)) {
                const { byKeyframeId: a4 } = n4[o4];
                t5(m2(h2({}, r3.address), { objectKey: e8, trackId: o4, keyframeIds: Object.keys(a4) }));
              }
            }
          });
        } };
        t4 = Kh(t4);
        const a3 = (0, Vh.val)(e6.tree);
        return n3(e6, a3, t4, o3), o3;
      };
    }(Bh || (Bh = {}));
    var qh = Hh.default.div`
  position: absolute;
  background: rgba(255, 255, 255, 0.1);
  border: 1px dashed rgba(255, 255, 255, 0.4);
  box-size: border-box;
`, Kh = (e5) => ({ positions: [...e5.positions].sort((e6, t3) => e6 - t3), ys: [...e5.ys].sort((e6, t3) => e6 - t3) }), Yh = ({ state: e5, layoutP: t3 }) => {
      const n3 = function(e6) {
        const t4 = (0, Lh.useMemo)(() => new Mh.Atom(e6), []);
        return (0, Lh.useLayoutEffect)(() => {
          t4.setState(e6);
        }, [e6]), t4;
      }(e5);
      return Fa2(() => {
        const e6 = (0, Vh.val)(n3.pointer), r3 = Kh(e6), o3 = (0, Vh.val)(t3.scaledSpace.fromUnitSpace), a3 = r3.positions.map(o3), i3 = r3.ys[0], s3 = r3.ys[1] - r3.ys[0], l3 = a3[0], u3 = a3[1] - a3[0];
        return Uh.default.createElement(qh, { style: { top: i3 + "px", height: s3 + "px", left: l3 + "px", width: u3 + "px" } });
      }, [t3, n3]);
    }, Xh = ({ layoutP: e5, children: t3 }) => {
      const [n3, r3] = sl2(null), o3 = zh("Shift"), a3 = function(e6, t4) {
        const [n4, r4] = sl2(null);
        return vp2(t4, (0, Uh.useMemo)(() => ({ dontBlockMouseDown: true, lockCursorTo: "cell", onDragStart(r5) {
          if (!r5.shiftKey || r5.target instanceof HTMLInputElement)
            return false;
          const o4 = t4.getBoundingClientRect(), a4 = r5.clientX - o4.left, i3 = (0, Vh.val)(e6.scaledSpace.toUnitSpace)(a4);
          n4.current = { positions: [i3, i3], ys: [r5.clientY - o4.top, r5.clientY - o4.top] }, (0, Vh.val)(e6.selectionAtom).setState({ current: void 0 });
        }, onDrag(r5, o4, a4) {
          n4.current;
          const i3 = t4.getBoundingClientRect(), s3 = a4.clientX - i3.left, l3 = (0, Vh.val)(e6.scaledSpace.toUnitSpace)(s3);
          n4.current = { positions: [n4.current.positions[0], l3], ys: [n4.current.ys[0], a4.clientY - i3.top] };
          const u3 = Bh.boundsToSelection(e6, n4.current);
          (0, Vh.val)(e6.selectionAtom).setState({ current: u3 });
        }, onDragEnd(e7) {
          n4.current = null;
        } }), [e6, t4, n4])), r4;
      }(e5, r3);
      return (0, Uh.useRef)(a3).current = a3, Uh.default.createElement(Wh, { ref: n3, isShiftDown: o3 }, a3 && Uh.default.createElement(Yh, { state: a3, layoutP: e5 }), t3);
    }, Gh = w2(g), Qh = w2(je.exports), Jh = w2(yh), Zh = w2(je.exports), em = w2(yh).default.div`
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  overflow-x: hidden;
  overflow-y: scroll;
  z-index: ${() => Qy.scrollableArea};

  &::-webkit-scrollbar {
    display: none;
  }
`, tm = (0, Zh.createContext)(Wd2), nm = (e5) => {
      const t3 = (0, Zh.useRef)(null), n3 = (0, Zh.useCallback)((e6) => {
      }, []);
      return Zh.default.createElement(tm.Provider, { value: n3 }, Zh.default.createElement(em, { ref: t3 }, e5.children));
    }, rm = Jh.default.div`
  position: absolute;

  right: 0;
  overflow-x: scroll;
  overflow-y: hidden;
  ${qi2};

  // hide the scrollbar on Gecko
  scrollbar-width: none;

  // hide the scrollbar on Webkit/Blink
  &::-webkit-scrollbar {
    display: none;
  }
`, om = Jh.default.div`
  position: absolute;
`, am = Qh.default.memo(({ layoutP: e5, children: t3, height: n3 }) => {
      const { width: r3, unitSpaceToScaledSpaceMultiplier: o3 } = Fa2(() => ({ width: (0, Gh.val)(e5.rightDims.width), unitSpaceToScaledSpaceMultiplier: (0, Gh.val)(e5.scaledSpace.fromUnitSpace)(1) }), [e5]), [a3, i3] = sl2(null);
      return function(e6, t4) {
        (0, Zh.useContext)(tm), (0, Qh.useLayoutEffect)(() => {
          if (!t4)
            return;
          const n4 = (n5) => {
            if (Math.abs(n5.deltaY) < Math.abs(n5.deltaX)) {
              n5.preventDefault(), n5.stopPropagation();
              const t5 = (0, Gh.val)(e6.scaledSpace.toUnitSpace)(1 * n5.deltaX), r6 = (0, Gh.val)(e6.clippedSpace.range), o4 = ba(r6, (e7) => e7 + t5);
              (0, Gh.val)(e6.clippedSpace.setRange)(o4);
            } else {
              if (n5.ctrlKey) {
                n5.preventDefault(), n5.stopPropagation();
                const o4 = n5.clientX - t4.getBoundingClientRect().left, a4 = (0, Gh.val)(e6.clippedSpace.toUnitSpace)(o4), i4 = (0, Gh.val)(e6.clippedSpace.range), s3 = 1 + 0.03 * im(n5.deltaY, [-50, 50]), l3 = ba(i4, (e7) => (e7 - a4) * s3 + a4), u3 = (0, Gh.val)(e6.sheet).getSequence().length, c3 = u3 + 0.25 * u3;
                (0, Gh.val)(e6.clippedSpace.setRange)((r5 = [0, c3], ba(l3, (e7) => im(e7, r5))));
              } else if (n5.shiftKey) {
                n5.preventDefault(), n5.stopPropagation();
                const t5 = (0, Gh.val)(e6.sheet).getSequence().length, r6 = (0, Gh.val)(e6.clippedSpace.range), o4 = (r6.end - r6.start) / t5, a4 = 0.05 * im(n5.deltaY, [-50, 50]) * o4, i4 = ba(r6, (e7) => e7 + a4);
                (0, Gh.val)(e6.clippedSpace.setRange)(i4);
              }
              var r5;
            }
          }, r4 = { capture: true, passive: false };
          return t4.addEventListener("wheel", n4, r4), () => {
            t4.removeEventListener("wheel", n4, r4);
          };
        }, [t4, e6]);
      }(e5, i3), function(e6, t4) {
        const n4 = (0, Qh.useMemo)(() => {
          let n5, r5, o4 = 0;
          const a4 = (0, Gh.val)(e6.seeker.setIsSeeking);
          return { onDrag(e7, t5, a5) {
            const i4 = r5(e7);
            let s3 = Mr2(o4 + i4, 0, n5.length);
            const l3 = a5.composedPath().find((e8) => e8 instanceof Element && e8.hasAttribute("data-pos"));
            if (l3) {
              const e8 = parseFloat(l3.getAttribute("data-pos"));
              isFinite(e8) && (s3 = e8);
            }
            n5.position = s3;
          }, onDragStart(i4) {
            if (i4.target instanceof HTMLInputElement)
              return false;
            if (i4.shiftKey || i4.altKey || i4.ctrlKey || i4.metaKey)
              return false;
            if (i4.composedPath().some((e7) => e7 instanceof HTMLElement && e7.draggable === true))
              return false;
            const s3 = i4.clientX - t4.getBoundingClientRect().left, l3 = Mr2((0, Gh.val)(e6.clippedSpace.toUnitSpace)(s3), 0, 1 / 0);
            n5 = (0, Gh.val)(e6.sheet).getSequence(), n5.position = l3, o4 = l3, r5 = (0, Gh.val)(e6.scaledSpace.toUnitSpace), a4(true);
          }, onDragEnd() {
            a4(false);
          } };
        }, [e6, t4]), [r4] = vp2(t4, n4);
        hp2(r4, "draggingPositionInSequenceEditor", "ew-resize");
      }(e5, i3), function(e6, t4) {
        (0, Qh.useLayoutEffect)(() => {
          if (!t4)
            return;
          const n4 = (0, Gh.prism)(() => {
            const t5 = (0, Gh.val)(e6.clippedSpace.range);
            return (0, Gh.val)(e6.scaledSpace.fromUnitSpace)(t5.start);
          }), r4 = () => {
            const e7 = n4.getValue();
            t4.scrollLeft = e7;
          }, o4 = n4.changesWithoutValues().tap(r4);
          r4();
          const a4 = setTimeout(r4, 100);
          return () => {
            clearTimeout(a4), o4();
          };
        }, [e6, t4]);
      }(e5, i3), Qh.default.createElement(rm, { ref: a3, style: { width: r3 + "px", height: n3 + "px", "--unitSpaceToScaledSpaceMultiplier": o3 } }, Qh.default.createElement(om, { style: { left: (0, Gh.val)(e5.scaledSpace.leftPadding) + "px" } }, t3));
    });
    function im(e5, [t3, n3]) {
      return Math.max(Math.min(e5, n3), t3);
    }
    var sm, lm, um = w2(je.exports), cm = w2(yh), dm = w2(je.exports), fm = w2(yh), pm = w2(je.exports), hm = w2(yh), mm = w2(g), vm = w2(je.exports), gm = w2(g), ym = w2(je.exports), bm = w2(yh), wm = w2(je.exports), km = w2(yh), xm = w2(g), Sm = w2(je.exports), _m = w2(je.exports), Em = w2(yh), Pm = w2(g), Cm = w2(je.exports), jm = w2(yh), Om = w2(g), Tm = w2(g), Im = (0, Tm.prism)(() => {
      const [e5, t3] = Tm.prism.state("pos", null);
      return Tm.prism.effect("setupListeners", () => {
        const e6 = (e7) => {
          t3(e7);
        };
        return document.addEventListener("mousemove", e6), () => {
          document.removeEventListener("mousemove", e6);
        };
      }, []), e5;
    }), Dm = Im, Rm = w2(je.exports);
    (lm = sm || (sm = {}))[lm.hidden = 0] = "hidden", lm[lm.locked = 1] = "locked", lm[lm.snapped = 2] = "snapped", lm[lm.free = 3] = "free";
    var Nm = (0, Rm.createContext)(null), Am = 0, zm = (e5, t3) => {
      const { getLock: n3 } = (0, Rm.useContext)(Nm), r3 = (0, Rm.useRef)();
      (0, Rm.useLayoutEffect)(() => {
        if (e5)
          return r3.current = n3(), () => {
            r3.current.unlock();
          };
      }, [e5]), (0, Rm.useLayoutEffect)(() => {
        e5 && r3.current.set(t3);
      }, [t3]);
    }, Mm = "data-theatre-lock-framestamp-to", Lm = (e5) => (0, Om.prism)(() => {
      const t3 = (0, Om.val)(e5.rightDims), n3 = (0, Om.val)(e5.clippedSpace.toUnitSpace);
      (0, Om.val)(e5.scaledSpace.leftPadding);
      const r3 = (0, Om.val)(Dm);
      if (!r3)
        return [-1, 0];
      for (const e6 of r3.composedPath()) {
        if (!(e6 instanceof HTMLElement || e6 instanceof SVGElement))
          break;
        if (e6.hasAttribute(Mm)) {
          const t4 = e6.getAttribute(Mm);
          if (typeof t4 != "string")
            continue;
          if (t4 === "hide")
            return [-1, 0];
          const n4 = parseFloat(t4);
          if (isFinite(n4) && n4 >= 0)
            return [n4, 2];
        }
      }
      const { clientX: o3, clientY: a3 } = r3, { screenX: i3, screenY: s3, width: l3, height: u3 } = t3;
      if (ma2(o3, i3, i3 + l3) && ma2(a3, s3, s3 + u3)) {
        return [n3(o3 - i3), 3];
      }
      return [-1, 0];
    }), Fm = ({ children: e5, layoutP: t3 }) => {
      const n3 = (0, Rm.useMemo)(() => new Om.Atom({ list: [] }), []), r3 = (0, Rm.useMemo)(() => (0, Om.prism)(() => {
        const e6 = Om.prism.memo("p", () => Lm(t3), [t3]).getValue(), r4 = (0, Om.val)(n3.pointer.list);
        return r4.length > 0 ? aa2(r4).position : e6;
      }), [t3]), o3 = (0, Rm.useCallback)(() => {
        const e6 = Am++;
        n3.reduceState(["list"], (t4) => [...t4, { id: e6, position: [-1, 0] }]);
        return { set: (t4) => {
          n3.reduceState(["list"], (n4) => {
            const r4 = n4.findIndex((t5) => t5.id === e6);
            if (r4 === -1)
              return console.warn("Lock is already freed. This is a bug."), n4;
            const o4 = [...n4];
            return o4.splice(r4, 1, { id: e6, position: [t4, t4 === -1 ? 0 : 1] }), o4;
          });
        }, unlock: () => {
          n3.reduceState(["list"], (t4) => t4.filter((t5) => t5.id !== e6));
        } };
      }, []), a3 = { currentD: r3, getLock: o3 };
      return Rm.default.createElement(Nm.Provider, { value: a3 }, e5);
    }, $m = (e5) => `
  left: ${-e5 / 2}px;
  top: ${-e5 / 2}px;
  width: ${e5}px;
  height: ${e5}px;
`, Bm = { normalColor: "#40AAA4", get selectedColor() {
      return Bi2(0.35, Bm.normalColor);
    } }, Vm = jm.default.div`
  position: absolute;
  background: ${(e5) => e5.isSelected ? Bm.selectedColor : Bm.normalColor};
  transform: rotateZ(45deg);

  z-index: 1;
  pointer-events: none;
  ${(e5) => $m((e5.isSelected, 6))}
`, Um = jm.default.div`
  position: absolute;
  ${$m(12)};

  z-index: 1;

  cursor: ew-resize;

  #pointer-root.draggingPositionInSequenceEditor & {
    pointer-events: auto;
    &:hover:after {
      position: absolute;
      top: calc(50% - ${17}px);
      left: calc(50% - ${17}px);
      width: ${34}px;
      height: ${34}px;
      display: block;
      content: ' ';
      background: url(${"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzQiIGhlaWdodD0iMzQiIHZpZXdCb3g9IjAgMCAzNCAzNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMSA3VjFINyIgc3Ryb2tlPSIjNzRGRkRFIiBzdHJva2Utd2lkdGg9IjAuMjUiIC8+CiAgPHBhdGggZD0iTTcgMzNIMUwxIDI3IiBzdHJva2U9IiM3NEZGREUiIHN0cm9rZS13aWR0aD0iMC4yNSIgLz4KICA8cGF0aCBkPSJNMzMgMjdWMzNIMjciIHN0cm9rZT0iIzc0RkZERSIgc3Ryb2tlLXdpZHRoPSIwLjI1IiAvPgogIDxwYXRoIGQ9Ik0yNyAxTDMzIDFWNyIgc3Ryb2tlPSIjNzRGRkRFIiBzdHJva2Utd2lkdGg9IjAuMjUiIC8+Cjwvc3ZnPg=="}) no-repeat 100% 100%;
      // This icon might also fit: GiConvergenceTarget
    }
  }

  &.beingDragged {
    pointer-events: none !important;
  }

  &:hover + ${Vm}, &.beingDragged + ${Vm} {
    ${$m(11)}
  }
`, Hm = (e5) => {
      const [t3, n3] = sl2(null), [r3] = function(e6, t4) {
        return md2(e6, { items: () => [{ label: t4.selection ? "Delete Selection" : "Delete Keyframe", callback: () => {
          t4.selection ? t4.selection.delete() : me2().transaction(({ stateEditors: e7 }) => {
            e7.coreByProject.historic.sheetsById.sequence.deleteKeyframes(m2(h2({}, t4.leaf.sheetObject.address), { keyframeIds: [t4.keyframe.id], trackId: t4.leaf.trackId }));
          });
        } }] });
      }(n3, e5), [o3] = function(e6, t4) {
        const [n4, r4] = (0, Cm.useState)(false);
        zm(n4, t4.keyframe.position);
        const o4 = (0, Cm.useRef)(t4);
        o4.current = t4;
        const a3 = (0, Cm.useMemo)(() => {
          let t5, n5, a4, i3;
          return { onDragStart(n6) {
            var s3;
            r4(true);
            const l3 = o4.current;
            if (l3.selection) {
              const { selection: t6, leaf: r5 } = l3, { sheetObject: o5 } = r5;
              return i3 = t6.getDragHandlers(m2(h2({}, o5.address), { pathToProp: r5.pathToProp, trackId: r5.trackId, keyframeId: l3.keyframe.id, domNode: e6, positionAtStartOfDrag: l3.trackData.keyframes[l3.index].position })), void ((s3 = i3.onDragStart) == null || s3.call(i3, n6));
            }
            a4 = l3, t5 = (0, Pm.val)(a4.layoutP.scaledSpace.toUnitSpace);
          }, onDrag(r5, o5, s3) {
            if (i3)
              return void i3.onDrag(r5, o5, s3);
            const l3 = a4.trackData.keyframes[a4.index], u3 = t5(r5);
            let c3 = Math.max(l3.position + u3, 0);
            const d2 = s3.composedPath().find((t6) => t6 instanceof Element && t6 !== e6 && t6.hasAttribute("data-pos"));
            if (d2) {
              const e7 = parseFloat(d2.getAttribute("data-pos"));
              isFinite(e7) && (c3 = e7);
            }
            n5 && (n5.discard(), n5 = void 0), n5 = me2().tempTransaction(({ stateEditors: e7 }) => {
              e7.coreByProject.historic.sheetsById.sequence.replaceKeyframes(m2(h2({}, a4.leaf.sheetObject.address), { trackId: a4.leaf.trackId, keyframes: [m2(h2({}, l3), { position: c3 })], snappingFunction: (0, Pm.val)(a4.layoutP.sheet).getSequence().closestGridPosition }));
            });
          }, onDragEnd(e7) {
            var t6;
            r4(false), i3 && ((t6 = i3.onDragEnd) == null || t6.call(i3, e7), i3 = void 0), e7 ? n5 && n5.commit() : n5 && n5.discard(), n5 = void 0;
          } };
        }, []);
        return vp2(e6, a3), hp2(n4, "draggingPositionInSequenceEditor", "ew-resize"), [n4];
      }(n3, e5);
      return Cm.default.createElement(Cm.default.Fragment, null, Cm.default.createElement(Um, m2(h2({ ref: t3, "data-pos": e5.keyframe.position.toFixed(3) }, { [Mm]: e5.keyframe.position.toFixed(3) }), { className: o3 ? "beingDragged" : "" })), Cm.default.createElement(Vm, { isSelected: !!e5.selection }), r3);
    };
    var Wm = { normalColor: "#365b59", get hoverColor() {
      return Bi2(0.1, Wm.normalColor);
    }, get selectedColor() {
      return Bi2(0.2, Wm.normalColor);
    }, get selectedHoverColor() {
      return Bi2(0.4, Wm.normalColor);
    } }, qm = Em.default.div`
  position: absolute;
  background: ${(e5) => e5.isSelected ? Wm.selectedColor : Wm.normalColor};
  height: ${4}px;
  width: ${1e3}px;

  left: 0;
  top: -${2}px;
  transform-origin: top left;
  z-index: 0;
  cursor: ew-resize;

  &:hover {
    background: ${(e5) => e5.isSelected ? Wm.selectedHoverColor : Wm.hoverColor};
  }
`, Km = (e5) => {
      const { index: t3, trackData: n3 } = e5, r3 = n3.keyframes[t3], o3 = n3.keyframes[t3 + 1], a3 = o3.position - r3.position, [i3, s3] = sl2(null), [l3] = md2(s3, { items: () => [{ label: e5.selection ? "Delete Selection" : "Delete both Keyframes", callback: () => {
        e5.selection ? e5.selection.delete() : me2().transaction(({ stateEditors: t4 }) => {
          t4.coreByProject.historic.sheetsById.sequence.deleteKeyframes(m2(h2({}, e5.leaf.sheetObject.address), { keyframeIds: [r3.id, o3.id], trackId: e5.leaf.trackId }));
        });
      } }] });
      return function(e6, t4) {
        const n4 = (0, _m.useRef)(t4);
        n4.current = t4;
        const r4 = (0, _m.useMemo)(() => {
          let t5, r5, o4, a4, i4;
          return { lockCursorTo: "ew-resize", onDragStart(r6) {
            var s4;
            const l4 = n4.current;
            if (l4.selection) {
              const { selection: t6, leaf: n5 } = l4, { sheetObject: o5 } = n5;
              return a4 = t6.getDragHandlers(m2(h2({}, o5.address), { pathToProp: n5.pathToProp, trackId: n5.trackId, keyframeId: l4.keyframe.id, domNode: e6, positionAtStartOfDrag: l4.trackData.keyframes[l4.index].position })), void ((s4 = a4.onDragStart) == null || s4.call(a4, r6));
            }
            o4 = l4, i4 = (0, xm.val)(o4.layoutP.sheet).getSequence(), t5 = (0, xm.val)(o4.layoutP.scaledSpace.toUnitSpace);
          }, onDrag(e7, n5, s4) {
            if (a4)
              return void a4.onDrag(e7, n5, s4);
            const l4 = t5(e7);
            r5 && (r5.discard(), r5 = void 0), r5 = me2().tempTransaction(({ stateEditors: e8 }) => {
              e8.coreByProject.historic.sheetsById.sequence.transformKeyframes(m2(h2({}, o4.leaf.sheetObject.address), { trackId: o4.leaf.trackId, keyframeIds: [o4.keyframe.id, o4.trackData.keyframes[o4.index + 1].id], translate: l4, scale: 1, origin: 0, snappingFunction: i4.closestGridPosition }));
            });
          }, onDragEnd(e7) {
            var t6;
            a4 && ((t6 = a4.onDragEnd) == null || t6.call(a4, e7), a4 = void 0), e7 ? r5 && r5.commit() : r5 && r5.discard(), r5 = void 0;
          } };
        }, []);
        vp2(e6, r4);
      }(s3, e5), Sm.default.createElement(qm, { isSelected: !!e5.selection, ref: i3, onClick: (e6) => {
        if (e6.button !== 0)
          return;
        JSON.stringify([r3.handles[2], r3.handles[3], o3.handles[0], o3.handles[1]]);
      }, style: { transform: `scale3d(calc(var(--unitSpaceToScaledSpaceMultiplier) * ${a3 / 1e3}), 1, 1)` } }, l3);
    };
    var Ym = km.default.div`
  position: absolute;
`, Xm = wm.default.createElement(wm.default.Fragment, null), Gm = (e5) => {
      const { index: t3, trackData: n3 } = e5, r3 = n3.keyframes[t3], o3 = n3.keyframes[t3 + 1], a3 = r3.connectedRight && !!o3;
      return wm.default.createElement(Ym, { style: { top: e5.leaf.nodeHeight / 2 + "px", left: `calc(var(--unitSpaceToScaledSpaceMultiplier) * ${r3.position}px)` } }, wm.default.createElement(Hm, h2({}, e5)), a3 ? wm.default.createElement(Km, h2({}, e5)) : Xm);
    };
    bm.default.div``;
    var Qm = ym.default.memo(({ layoutP: e5, trackData: t3, leaf: n3 }) => {
      const { selectedKeyframeIds: r3, selection: o3 } = Fa2(() => {
        const t4 = (0, gm.val)(e5.selectionAtom), r4 = (0, gm.val)(t4.pointer.current.byObjectKey[n3.sheetObject.address.objectKey].byTrackId[n3.trackId].byKeyframeId);
        return r4 ? { selectedKeyframeIds: r4, selection: (0, gm.val)(t4.pointer.current) } : { selectedKeyframeIds: {}, selection: void 0 };
      }, [e5, n3.trackId]), a3 = t3.keyframes.map((a4, i3) => ym.default.createElement(Gm, { keyframe: a4, index: i3, trackData: t3, layoutP: e5, leaf: n3, key: "keyframe-" + a4.id, selection: r3[a4.id] === true ? o3 : void 0 }));
      return ym.default.createElement(ym.default.Fragment, null, a3);
    }), Jm = Qm, Zm = w2(je.exports), ev = w2(yh), tv = ev.default.li`
  margin: 0;
  padding: 0;
  list-style: none;
  box-sizing: border-box;
  position: relative;
`, nv = ev.default.div`
  box-sizing: border-box;
  width: 100%;
  position: relative;

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    left: -40px;
    top: 0;
    bottom: 0;
    right: 0;
    box-sizing: border-box;
    border-bottom: 1px solid #252b3869;
    background: ${(e5) => e5.isEven ? "transparent" : "#6b8fb505"};
  }
`, rv = ev.default.ul`
  margin: 0;
  padding: 0;
  list-style: none;
`, ov = ({ leaf: e5, children: t3, node: n3 }) => {
      const r3 = Array.isArray(t3) && t3.length > 0;
      return Zm.default.createElement(tv, null, Zm.default.createElement(nv, { style: { height: e5.nodeHeight + "px" }, isEven: e5.n % 2 == 0 }, n3), r3 && Zm.default.createElement(rv, null, t3));
    }, av = ({ leaf: e5, layoutP: t3 }) => Fa2(() => {
      const { sheetObject: n3 } = e5, { trackId: r3 } = e5, o3 = (0, mm.val)(me2().atomP.historic.coreByProject[n3.address.projectId].sheetsById[n3.address.sheetId].sequence.tracksByObject[n3.address.objectKey].trackData[r3]);
      if ((o3 == null ? void 0 : o3.type) !== "BasicKeyframedTrack")
        return console.error(`trackData type ${o3 == null ? void 0 : o3.type} is not yet supported on the sequence editor`), vm.default.createElement(ov, { leaf: e5, node: vm.default.createElement("div", null) });
      {
        const n4 = vm.default.createElement(Jm, { layoutP: t3, trackData: o3, leaf: e5 });
        return vm.default.createElement(ov, { leaf: e5, node: n4 });
      }
    }, [e5, t3]), iv = (e5, t3) => e5.type === "propWithChildren" ? pm.default.createElement(sv, { layoutP: t3, leaf: e5, key: "prop" + e5.pathToProp[e5.pathToProp.length - 1] }) : pm.default.createElement(av, { layoutP: t3, leaf: e5, key: "prop" + e5.pathToProp[e5.pathToProp.length - 1] });
    hm.default.div``;
    var sv = ({ leaf: e5, layoutP: t3 }) => Fa2(() => {
      const n3 = pm.default.createElement("div", null);
      return pm.default.createElement(ov, { leaf: e5, node: n3 }, e5.children.map((e6) => iv(e6, t3)));
    }, [e5, t3]);
    fm.default.div``;
    var lv = ({ leaf: e5, layoutP: t3 }) => Fa2(() => {
      const n3 = dm.default.createElement("div", null);
      return dm.default.createElement(ov, { leaf: e5, node: n3 }, e5.children.map((e6) => iv(e6, t3)));
    }, [e5, t3]);
    cm.default.div``;
    var uv = ({ leaf: e5, layoutP: t3 }) => Fa2(() => um.default.createElement(um.default.Fragment, null, e5.children.map((e6) => um.default.createElement(lv, { layoutP: t3, key: "sheetObject-" + e6.sheetObject.address.objectKey, leaf: e6 }))), [e5, t3]), cv = 1e6, dv = Rh.default.ul`
  margin: 0;
  padding: 0;
  list-style: none;
  position: absolute;
  left: 0;
  width: ${cv}px;
`;
    Rh.default.div`
  position: absolute;
  top: 0;
  right: 0;
  width: ${(e5) => e5.width};
  bottom: 0;
  z-index: ${() => Qy.rightBackground};
  overflow: hidden;
  background: ${Fi2(0.03, Ki2.panel.bg)};
`;
    var fv = ({ layoutP: e5 }) => Fa2(() => {
      const t3 = (0, Ih.val)(e5.tree), n3 = (0, Ih.val)(e5.tree.top) + Math.max((0, Ih.val)(e5.tree.heightIncludingChildren), (0, Ih.val)(e5.dopeSheetDims.height));
      return Dh.default.createElement(Dh.default.Fragment, null, Dh.default.createElement(am, { layoutP: e5, height: n3 }, Dh.default.createElement(Xh, { layoutP: e5 }, Dh.default.createElement(dv, { style: { top: t3.top + "px" } }, Dh.default.createElement(uv, { leaf: t3, layoutP: e5 })))));
    }, [e5]), pv = w2(g), hv = w2(je.exports), mv = w2(yh), vv = w2(je.exports), gv = w2(yh), yv = w2(je.exports), bv = w2(yh), wv = w2(je.exports), kv = w2(yh).default.path`
  stroke-width: 2;
  stroke: var(--main-color);
  fill: none;
  vector-effect: non-scaling-stroke;
`;
    function xv(e5, t3, n3, r3) {
      n3 === 0 && (n3 = 1e-4);
      r3 === 0 && (r3 = 1e-3);
      return `translate(${`calc(var(--unitSpaceToScaledSpaceMultiplier) * ${e5}px)`}, ${`calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ${t3}) * 1px)`}) scale(${`calc(var(--unitSpaceToScaledSpaceMultiplier) * ${n3})`}, ${`calc(var(--graphEditorVerticalSpace) * ${-1 * r3})`})`;
    }
    var Sv = (e5) => {
      const { index: t3, trackData: n3 } = e5, r3 = n3.keyframes[t3], o3 = n3.keyframes[t3 + 1];
      r3.handles[2], r3.handles[3], o3.handles[0], o3.handles[1];
      const a3 = o3.position - r3.position, [i3, s3] = sl2(null), [l3] = function(e6, t4) {
        const { index: n4, trackData: r4 } = t4, o4 = r4.keyframes[n4], a4 = r4.keyframes[n4 + 1];
        return md2(e6, { items: () => [{ label: "Delete", callback: () => {
          me2().transaction(({ stateEditors: e7 }) => {
            const { deleteKeyframes: n5 } = e7.coreByProject.historic.sheetsById.sequence;
            n5(m2(h2({}, t4.sheetObject.address), { trackId: t4.trackId, keyframeIds: [o4.id, a4.id] }));
          });
        } }] });
      }(s3, e5), u3 = e5.extremumSpace.fromValueSpace(r3.value), c3 = e5.extremumSpace.fromValueSpace(o3.value) - u3, d2 = xv(r3.position, u3, a3, c3), f2 = `M 0 0 C ${r3.handles[2]} ${r3.handles[3]} ${o3.handles[0]} ${o3.handles[1]} 1 1`;
      return wv.default.createElement(wv.default.Fragment, null, wv.default.createElement(kv, { ref: i3, d: f2, style: { transform: d2 } }), l3);
    };
    var _v = w2(g), Ev = w2(je.exports), Pv = w2(yh), Cv = Pv.default.circle`
  stroke-width: 1px;
  vector-effect: non-scaling-stroke;
  fill: var(--main-color);
  r: 2px;
  pointer-events: none;
`, jv = Pv.default.circle`
  stroke-width: 6px;
  vector-effect: non-scaling-stroke;
  r: 6px;
  fill: transparent;
  cursor: move;
  ${qi2};
  &:hover {
  }
  &:hover + ${Cv} {
    r: 6px;
  }
`, Ov = Pv.default.path`
  stroke-width: 1;
  stroke: var(--main-color);
  /* stroke: gray; */
  fill: none;
  vector-effect: non-scaling-stroke;
`, Tv = (e5) => {
      const [t3, n3] = sl2(null), { index: r3, trackData: o3 } = e5, a3 = o3.keyframes[r3], i3 = o3.keyframes[r3 + 1], [s3] = function(e6, t4) {
        return md2(e6, { items: () => [{ label: "Delete", callback: () => {
          me2().transaction(({ stateEditors: e7 }) => {
            e7.coreByProject.historic.sheetsById.sequence.deleteKeyframes(m2(h2({}, t4.sheetObject.address), { keyframeIds: [t4.keyframe.id], trackId: t4.trackId }));
          });
        } }] });
      }(n3, e5);
      !function(e6, t4) {
        const n4 = (0, Ev.useRef)(t4);
        n4.current = t4;
        const r4 = (0, Ev.useMemo)(() => {
          let e7, t5, r5, o4, a4;
          return { lockCursorTo: "move", onDragStart() {
            r5 = n4.current, e7 = (0, _v.val)(r5.layoutP.scaledSpace.toUnitSpace), t5 = (0, _v.val)(r5.layoutP.graphEditorVerticalSpace.toExtremumSpace), a4 = r5.extremumSpace.lock();
          }, onDrag(n5, a5) {
            o4 && (o4.discard(), o4 = void 0);
            const { index: i4, trackData: s4 } = r5, l4 = s4.keyframes[i4], u4 = s4.keyframes[i4 + 1];
            let c4 = e7(n5) / (u4.position - l4.position);
            const d3 = t5(-a5), f3 = r5.extremumSpace.deltaToValueSpace(d3) / (u4.value - l4.value);
            if (r5.which === "left") {
              const e8 = Mr2(l4.handles[2] + c4, 0, 1), t6 = l4.handles[3] + f3;
              o4 = me2().tempTransaction(({ stateEditors: n6 }) => {
                n6.coreByProject.historic.sheetsById.sequence.replaceKeyframes(m2(h2({}, r5.sheetObject.address), { snappingFunction: (0, _v.val)(r5.layoutP.sheet).getSequence().closestGridPosition, trackId: r5.trackId, keyframes: [m2(h2({}, l4), { handles: [l4.handles[0], l4.handles[1], e8, t6] })] }));
              });
            } else {
              const e8 = Mr2(u4.handles[0] + c4, 0, 1), t6 = u4.handles[1] + f3;
              o4 = me2().tempTransaction(({ stateEditors: n6 }) => {
                n6.coreByProject.historic.sheetsById.sequence.replaceKeyframes(m2(h2({}, r5.sheetObject.address), { trackId: r5.trackId, snappingFunction: (0, _v.val)(r5.layoutP.sheet).getSequence().closestGridPosition, keyframes: [m2(h2({}, u4), { handles: [e8, t6, u4.handles[2], u4.handles[3]] })] }));
              });
            }
          }, onDragEnd(e8) {
            if (a4) {
              const e9 = a4;
              a4 = void 0, e9();
            }
            e8 ? o4 && o4.commit() : o4 && o4.discard(), o4 = void 0;
          } };
        }, []);
        vp2(e6, r4);
      }(n3, e5);
      const l3 = e5.which === "left" ? a3.handles[2] : i3.handles[0], u3 = a3.position + (i3.position - a3.position) * l3, c3 = e5.which === "left" ? a3.handles[3] : i3.handles[1], d2 = a3.value + (i3.value - a3.value) * c3, f2 = e5.extremumSpace.fromValueSpace(d2), p2 = f2 - e5.extremumSpace.fromValueSpace(e5.which === "left" ? a3.value : i3.value), v3 = xv(e5.which === "left" ? a3.position : i3.position, e5.extremumSpace.fromValueSpace(e5.which === "left" ? a3.value : i3.value), u3 - (e5.which === "left" ? a3.position : i3.position), p2);
      return Ev.default.createElement("g", null, Ev.default.createElement(jv, { ref: t3, style: { cx: `calc(var(--unitSpaceToScaledSpaceMultiplier) * ${u3} * 1px)`, cy: `calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ${f2}) * 1px)` } }), Ev.default.createElement(Cv, { style: { cx: `calc(var(--unitSpaceToScaledSpaceMultiplier) * ${u3} * 1px)`, cy: `calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ${f2}) * 1px)` } }), Ev.default.createElement(Ov, { d: "M 0 0 L 1 1", style: { transform: v3 } }), s3);
    };
    var Iv = w2(g), Dv = w2(je.exports), Rv = w2(yh), Nv = Rv.default.circle`
  fill: var(--main-color);
  stroke-width: 1px;
  vector-effect: non-scaling-stroke;

  r: 2px;
`, Av = Rv.default.circle`
  stroke-width: 6px;
  vector-effect: non-scaling-stroke;
  r: 6px;
  fill: transparent;
  ${qi2};

  &:hover + ${Nv} {
    r: 6px;
  }

  #pointer-root.normal & {
    cursor: move;
  }

  #pointer-root.draggingPositionInSequenceEditor & {
    pointer-events: auto;
  }

  &.beingDragged {
    pointer-events: none !important;
  }
`, zv = (e5) => {
      const [t3, n3] = sl2(null), { index: r3, trackData: o3 } = e5, a3 = o3.keyframes[r3];
      o3.keyframes[r3 + 1];
      const [i3] = function(e6, t4) {
        return md2(e6, { items: () => [{ label: "Delete", callback: () => {
          me2().transaction(({ stateEditors: e7 }) => {
            e7.coreByProject.historic.sheetsById.sequence.deleteKeyframes(m2(h2({}, t4.sheetObject.address), { keyframeIds: [t4.keyframe.id], trackId: t4.trackId }));
          });
        } }] });
      }(n3, e5), s3 = function(e6, t4) {
        const [n4, r4] = (0, Dv.useState)(false);
        zm(n4, t4.keyframe.position);
        const o4 = (0, Dv.useRef)(t4);
        o4.current = t4;
        const a4 = (0, Dv.useMemo)(() => {
          let e7, t5, n5, a5, i4, s4 = false;
          return { lockCursorTo: "move", onDragStart(n6) {
            r4(true), s4 = !!n6.altKey, t5 = o4.current, e7 = (0, Iv.val)(t5.layoutP.scaledSpace.toUnitSpace), a5 = (0, Iv.val)(t5.layoutP.graphEditorVerticalSpace.toExtremumSpace), i4 = t5.extremumSpace.lock();
          }, onDrag(r5, o5) {
            const i5 = t5.trackData.keyframes[t5.index], l4 = e7(r5), u3 = a5(-o5), c3 = t5.extremumSpace.deltaToValueSpace(u3), d2 = [], f2 = m2(h2({}, i5), { position: i5.position + l4, value: i5.value + c3, handles: [...i5.handles] });
            if (d2.push(f2), s4) {
              const e8 = t5.trackData.keyframes[t5.index - 1];
              if (e8 && Math.abs(i5.value - e8.value) > 0) {
                const t6 = m2(h2({}, e8), { handles: [...e8.handles] });
                d2.push(t6), t6.handles[3] = (p2 = e8.handles[3], v3 = e8.value, g2 = e8.value, y3 = i5.value, b3 = f2.value, (y3 - v3) * p2 / (b3 - g2));
              }
              const n6 = t5.trackData.keyframes[t5.index + 1];
              if (n6 && Math.abs(i5.value - n6.value) > 0) {
                const e9 = m2(h2({}, n6), { handles: [...n6.handles] });
                d2.push(e9), e9.handles[1] = function(e10, t6, n7, r6, o6) {
                  return ((t6 - r6) * e10 + r6 - t6 + n7 - o6) / (n7 - o6);
                }(e9.handles[1], e9.value, e9.value, i5.value, f2.value);
              }
            }
            var p2, v3, g2, y3, b3;
            n5 == null || n5.discard(), n5 = me2().tempTransaction(({ stateEditors: e8 }) => {
              e8.coreByProject.historic.sheetsById.sequence.replaceKeyframes(m2(h2({}, t5.sheetObject.address), { trackId: t5.trackId, keyframes: d2, snappingFunction: (0, Iv.val)(t5.layoutP.sheet).getSequence().closestGridPosition }));
            });
          }, onDragEnd(e8) {
            if (r4(false), i4) {
              const e9 = i4;
              i4 = void 0, e9();
            }
            e8 ? n5 == null || n5.commit() : n5 == null || n5.discard(), n5 = void 0;
          } };
        }, []);
        return vp2(e6, a4), hp2(n4, "draggingPositionInSequenceEditor", "move"), n4;
      }(n3, e5), l3 = e5.extremumSpace.fromValueSpace(a3.value);
      return Dv.default.createElement(Dv.default.Fragment, null, Dv.default.createElement(Av, m2(h2({ ref: t3, style: { cx: `calc(var(--unitSpaceToScaledSpaceMultiplier) * ${a3.position} * 1px)`, cy: `calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ${l3}) * 1px)` } }, { [Mm]: a3.position.toFixed(3) }), { "data-pos": a3.position.toFixed(3), className: s3 ? "beingDragged" : "" })), Dv.default.createElement(Nv, { style: { cx: `calc(var(--unitSpaceToScaledSpaceMultiplier) * ${a3.position} * 1px)`, cy: `calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ${l3}) * 1px)` } }), i3);
    };
    var Mv = bv.default.g`
  /* position: absolute; */
`, Lv = yv.default.createElement(yv.default.Fragment, null), Fv = (e5) => {
      const { index: t3, trackData: n3 } = e5, r3 = n3.keyframes[t3], o3 = n3.keyframes[t3 + 1], a3 = r3.connectedRight && !!o3 && o3.value - r3.value != 0;
      return yv.default.createElement(Mv, null, a3 ? yv.default.createElement(yv.default.Fragment, null, yv.default.createElement(Sv, h2({}, e5)), yv.default.createElement(Tv, m2(h2({}, e5), { which: "left" })), yv.default.createElement(Tv, m2(h2({}, e5), { which: "right" }))) : Lv, yv.default.createElement(zv, h2({}, e5)));
    };
    gv.default.div``;
    var $v = vv.default.memo(({ layoutP: e5, trackData: t3, sheetObject: n3, trackId: r3, color: o3 }) => {
      const [a3, i3] = (0, vv.useState)(false), s3 = (0, vv.useMemo)(() => {
        const e6 = /* @__PURE__ */ new Set();
        return function() {
          const t4 = e6.size === 0;
          function n4() {
            const t5 = e6.size > 0;
            e6.delete(n4), t5 && e6.size === 0 && i3(false);
          }
          return e6.add(n4), t4 && i3(true), n4;
        };
      }, []), l3 = (0, vv.useMemo)(() => {
        const e6 = function(e7) {
          let t4 = 1 / 0, n5 = -1 / 0;
          function r4(e8) {
            t4 = Math.min(e8, t4), n5 = Math.max(e8, n5);
          }
          return e7.forEach((t5, n6) => {
            if (r4(t5.value), !t5.connectedRight)
              return;
            const o4 = e7[n6 + 1];
            if (!o4)
              return;
            const a4 = o4.value - t5.value;
            r4(t5.value + t5.handles[3] * a4), r4(t5.value + o4.handles[1] * a4);
          }), [t4, n5];
        }(t3.keyframes), n4 = (t4) => t4 * (e6[1] - e6[0]);
        return { fromValueSpace: (t4) => (t4 - e6[0]) / (e6[1] - e6[0]), toValueSpace: (t4) => e6[0] + n4(t4), deltaToValueSpace: n4, lock: s3 };
      }, [t3.keyframes]), u3 = (0, vv.useRef)(void 0);
      a3 || (u3.current = l3);
      const c3 = t3.keyframes.map((a4, i4) => vv.default.createElement(Fv, { keyframe: a4, index: i4, trackData: t3, layoutP: e5, sheetObject: n3, trackId: r3, key: "keyframe-" + a4.id, extremumSpace: u3.current, color: o3 }));
      return vv.default.createElement("g", { style: { "--main-color": tg[o3].iconColor } }, c3);
    }), Bv = $v;
    mv.default.div``;
    var Vv = (e5) => Fa2(() => {
      const { sheetObject: t3, trackId: n3, pathToProp: r3 } = e5, o3 = (0, pv.val)(me2().atomP.historic.coreByProject[t3.address.projectId].sheetsById[t3.address.sheetId].sequence.tracksByObject[t3.address.objectKey].trackData[n3]);
      return (o3 == null ? void 0 : o3.type) !== "BasicKeyframedTrack" ? (console.error(`trackData type ${o3 == null ? void 0 : o3.type} is not yet supported on the graph editor`), hv.default.createElement(hv.default.Fragment, null)) : hv.default.createElement(Bv, m2(h2({}, e5), { trackData: o3 }));
    }, [e5.trackId, e5.layoutP]), Uv = w2(g), Hv = w2(je.exports), Wv = w2(yh), qv = dr2((e5) => {
      const t3 = [];
      for (let n3 = 1; n3 <= e5; n3++)
        e5 % n3 == 0 && t3.push(n3);
      return t3;
    });
    function Kv({ clippedSpaceRange: e5, clippedSpaceWidth: t3, fps: n3, gapWidth: r3 = 120 }, o3) {
      const a3 = 1 / n3, i3 = t3 / (n3 * (e5.end - e5.start)), s3 = Math.floor(r3 / i3), l3 = (s3 < n3 ? qv(n3).find((e6) => e6 >= s3) : n3 * Math.floor(s3 / n3)) * a3, u3 = Math.floor(e5.start / l3), c3 = Math.ceil(e5.end / l3);
      for (let e6 = u3; e6 <= c3; e6++) {
        const t4 = e6 * l3;
        o3(t4, t4 % 1 == 0);
      }
    }
    var Yv = new (w2(g)).Ticker(), Xv = Yv, Gv = (e5) => {
      Yv.tick(e5), window.requestAnimationFrame(Gv);
    };
    window.requestAnimationFrame(Gv);
    var Qv = Wv.default.div`
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  pointer-events: none;
`, Jv = Wv.default.canvas`
  position: relative;
  left: 0;
`, Zv = (e5) => (window.devicePixelRatio || 1) / ((e6) => {
      const t3 = e6;
      return t3.webkitBackingStorePixelRatio || t3.mozBackingStorePixelRatio || t3.msBackingStorePixelRatio || t3.oBackingStorePixelRatio || t3.backingStorePixelRatio || 1;
    })(e5), eg = ({ layoutP: e5, width: t3, height: n3 }) => {
      const r3 = (0, Hv.useRef)(null), [o3, a3] = (0, Hv.useState)(null), { ctx: i3, ratio: s3 } = (0, Hv.useMemo)(() => {
        if (!o3)
          return {};
        const e6 = o3.getContext("2d");
        return { ctx: e6, ratio: Zv(e6) };
      }, [o3]);
      return (0, Hv.useLayoutEffect)(() => {
        if (!i3)
          return;
        o3.width = t3 * s3, o3.height = n3 * s3;
        const r4 = (0, Uv.prism)(() => {
          const t4 = (0, Uv.val)(e5.sheet).getSequence();
          return { ctx: i3, clippedSpaceRange: (0, Uv.val)(e5.clippedSpace.range), clippedSpaceWidth: (0, Uv.val)(e5.clippedSpace.width), unitSpaceToClippedSpace: (0, Uv.val)(e5.clippedSpace.fromUnitSpace), height: n3, leftPadding: (0, Uv.val)(e5.scaledSpace.leftPadding), fps: t4.subUnitsPerUnit, snapToGrid: (e6) => t4.closestGridPosition(e6) };
        }).tapImmediate(Xv, (e6) => {
          i3.save(), i3.scale(s3, s3), function(e7) {
            const { clippedSpaceWidth: t4, height: n4, ctx: r5, unitSpaceToClippedSpace: o4, snapToGrid: a4 } = e7;
            r5.clearRect(0, 0, t4, n4), Kv(e7, (e8, t5) => {
              const i4 = a4(e8), s4 = Math.floor(o4(i4));
              r5.strokeStyle = t5 ? "rgba(225, 225, 225, 0.04)" : "rgba(255, 255, 255, 0.01)", r5.beginPath(), r5.moveTo(s4, 0), r5.lineTo(s4, n4), r5.stroke(), r5.closePath();
            });
          }(e6), i3.restore();
        });
        return () => {
          r4();
        };
      }, [i3, t3, n3, e5]), Hv.default.createElement(Qv, { ref: r3, style: { width: t3 + "px" } }, Hv.default.createElement(Jv, { ref: a3, style: { width: t3 + "px", height: n3 + "px" } }));
    };
    var tg = { 1: { iconColor: "#b98b08" }, 2: { iconColor: "#70a904" }, 3: { iconColor: "#2e928a" }, 4: { iconColor: "#a943bb" }, 5: { iconColor: "#b90808" }, 6: { iconColor: "#b4bf0e" } }, ng = Th.default.div`
  position: absolute;
  right: 0;
  bottom: 0;
  background: ${Ui2(0.03, "#1a1c1e")};
`, rg = Th.default.svg`
  position: absolute;
  top: 0;
  left: 0;
  margin: 0;
  pointer-events: none;
`, og = ({ layoutP: e5 }) => Fa2(() => {
      const t3 = (0, jh.val)(e5.sheet), n3 = (0, jh.val)(me2().atomP.historic.projects.stateByProjectId[t3.address.projectId].stateBySheetId[t3.address.sheetId].sequenceEditor.selectedPropsByObject), r3 = (0, jh.val)(e5.graphEditorDims.height), o3 = (0, jh.val)(e5.scaledSpace.fromUnitSpace)(1), a3 = [];
      if (n3)
        for (const [r4, o4] of Object.entries(n3)) {
          const n4 = t3.getObject(r4);
          if (!n4)
            continue;
          const s4 = (0, jh.val)(n4.template.getMapOfValidSequenceTracks_forStudio());
          for (const [t4, l3] of Object.entries(o4)) {
            const o5 = (i3 = t4, JSON.parse(i3)), u3 = Cc2(s4, o5);
            u3 && a3.push(Oh.default.createElement(Vv, { key: `graph-${r4}-${t4}`, sheetObject: n4, pathToProp: o5, layoutP: e5, trackId: u3, color: l3 }));
          }
        }
      var i3;
      const s3 = (0, jh.val)(e5.rightDims.width);
      return Oh.default.createElement(ng, { style: { width: s3 + "px", height: r3 + "px", "--unitSpaceToScaledSpaceMultiplier": o3, "--graphEditorVerticalSpace": `${(0, jh.val)(e5.graphEditorVerticalSpace.space)}` } }, Oh.default.createElement(eg, { layoutP: e5, width: s3, height: r3 }), Oh.default.createElement(am, { layoutP: e5, height: r3 }, Oh.default.createElement(rg, { width: cv, height: r3, viewBox: `0 0 1000000 ${r3}` }, Oh.default.createElement("g", { style: { transform: `translate(0, ${(0, jh.val)(e5.graphEditorDims.padding.top)}px)` } }, a3))));
    }, [e5]), ag = { color: "#9a9a9a" }, ig = (0, Ch.default)(hh2)``, sg = (0, Ch.default)(mh2)`
  display: flex;
  color: ${ag.color};
  padding-right: 12px;
  align-items: center;
  justify-content: flex-end;
  box-sizing: border-box;
`, lg = Ch.default.button`
  background: none;
  border: none;
  outline: none;
  display: flex;
  box-sizing: border-box;
  font-size: 14px;
  align-items: center;
  height: 100%;
  margin-left: 12px;
  color: ${(e5) => e5.isSelected ? tg[e5.graphEditorColor].iconColor : Vc2};

  &:hover {
    color: white;
  }
`, ug = () => Ph.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "10", height: "12", viewBox: "0 0 640 512" }, Ph.default.createElement("g", { transform: "translate(0 100)" }, Ph.default.createElement("path", { fill: "currentColor", d: "M368 32h-96c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zM208 88h-84.75C113.75 64.56 90.84 48 64 48 28.66 48 0 76.65 0 112s28.66 64 64 64c26.84 0 49.75-16.56 59.25-40h79.73c-55.37 32.52-95.86 87.32-109.54 152h49.4c11.3-41.61 36.77-77.21 71.04-101.56-3.7-8.08-5.88-16.99-5.88-26.44V88zm-48 232H64c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-96c0-17.67-14.33-32-32-32zM576 48c-26.84 0-49.75 16.56-59.25 40H432v72c0 9.45-2.19 18.36-5.88 26.44 34.27 24.35 59.74 59.95 71.04 101.56h49.4c-13.68-64.68-54.17-119.48-109.54-152h79.73c9.5 23.44 32.41 40 59.25 40 35.34 0 64-28.65 64-64s-28.66-64-64-64zm0 272h-96c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-96c0-17.67-14.33-32-32-32z" }))), cg = Ch.default.span`
  margin-right: 4px;
  ${kd2};
`, dg = ({ leaf: e5 }) => {
      const t3 = function(e6, t4) {
        let n4 = e6;
        for (const e7 of t4)
          n4 = n4[e7];
        return n4;
      }(e5.sheetObject.propsP, e5.pathToProp), n3 = e5.sheetObject, { controlIndicators: r3 } = Gc2(t3, n3, e5.propConf), o3 = Fa2(() => {
        const t4 = e5.sheetObject.address, n4 = _h(e5.pathToProp);
        return (0, Eh.val)(me2().atomP.historic.projects.stateByProjectId[t4.projectId].stateBySheetId[t4.sheetId].sequenceEditor.selectedPropsByObject[t4.objectKey][n4]);
      }, [e5]), a3 = (0, Ph.useRef)(false), i3 = typeof o3 == "string";
      a3.current = i3;
      const s3 = (0, Ph.useCallback)(() => {
        const t4 = e5.sheetObject.address;
        me2().transaction(({ stateEditors: n4 }) => {
          a3.current ? n4.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removePropFromGraphEditor(m2(h2({}, t4), { pathToProp: e5.pathToProp })) : (n4.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.addPropToGraphEditor(m2(h2({}, t4), { pathToProp: e5.pathToProp })), n4.studio.historic.panels.sequenceEditor.graphEditor.setIsOpen({ isOpen: true }));
        });
      }, [e5]), l3 = e5.pathToProp[e5.pathToProp.length - 1];
      return Ph.default.createElement(ig, { depth: e5.depth }, Ph.default.createElement(sg, { isEven: e5.n % 2 == 0, style: { height: e5.nodeHeight + "px" }, isSelected: i3 === true }, Ph.default.createElement(cg, null, l3), r3, Ph.default.createElement(lg, { onClick: s3, isSelected: i3 === true, graphEditorColor: o3 != null ? o3 : "1" }, Ph.default.createElement(ug, null))));
    }, fg = (e5) => e5.type === "propWithChildren" ? xh.default.createElement(pg, { leaf: e5, key: "prop" + e5.pathToProp[e5.pathToProp.length - 1] }) : xh.default.createElement(dg, { leaf: e5, key: "prop" + e5.pathToProp[e5.pathToProp.length - 1] });
    Sh.default.div``;
    var pg = ({ leaf: e5 }) => Fa2(() => xh.default.createElement(kh, { leaf: e5, label: e5.pathToProp[e5.pathToProp.length - 1] }, e5.children.map((e6) => fg(e6))), [e5]);
    dh2.default.div``;
    var hg = ({ leaf: e5 }) => Fa2(() => ch2.default.createElement(kh, { leaf: e5, label: e5.sheetObject.address.objectKey }, e5.children.map((e6) => fg(e6))), [e5]);
    uh2.default.div``;
    var mg = ({ leaf: e5 }) => Fa2(() => lh2.default.createElement(lh2.default.Fragment, null, e5.children.map((e6) => lh2.default.createElement(hg, { key: "sheetObject-" + e6.sheetObject.address.objectKey, leaf: e6 }))), [e5]), vg = sh2.default.div`
  position: absolute;
  left: 0;
  overflow-x: visible;
`, gg = sh2.default.ul`
  margin: 0;
  padding: 0;
  list-style: none;
`, yg = ({ layoutP: e5 }) => Fa2(() => {
      const t3 = (0, ah2.val)(e5.tree), n3 = (0, ah2.val)(e5.leftDims.width);
      return ih2.default.createElement(vg, { style: { width: n3 + "px", top: t3.top + "px" } }, ih2.default.createElement(gg, null, ih2.default.createElement(mg, { leaf: t3 })));
    }, [e5]), bg = w2(je.exports), wg = w2(yh).default.div`
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  z-index: ${() => Qy.rightBackground};
  overflow: hidden;
  background: ${Ui2(0.01, Fi2(0.03, Ki2.panel.bg))};
  pointer-events: none;
`, kg = ({ layoutP: e5 }) => {
      const t3 = $a2(e5.rightDims.width), n3 = $a2(e5.panelDims.height);
      return bg.default.createElement(wg, { style: { width: t3 + "px" } }, bg.default.createElement(eg, { width: t3, height: n3, layoutP: e5 }));
    }, xg = oh2.default.div`
  position: absolute;
  left: 0;
  right: 0;
`, Sg = ({ layoutP: e5 }) => {
      const t3 = $a2(e5.dopeSheetDims.height);
      return rh2.default.createElement(xg, { style: { height: t3 + "px" } }, rh2.default.createElement(kg, { layoutP: e5 }), rh2.default.createElement(nm, null, rh2.default.createElement(yg, { layoutP: e5 }), rh2.default.createElement(fv, { layoutP: e5 })));
    }, _g = w2(g);
    var Eg = w2(g), Pg = w2(g), Cg = 28, jg = (e5) => {
      Pg.prism.ensurePrism();
      let t3 = 20, n3 = 0;
      const r3 = { type: "sheet", sheet: e5, children: [], top: t3, depth: -1, n: n3, nodeHeight: 0, heightIncludingChildren: -1 };
      t3 += r3.nodeHeight, n3 += 1;
      for (const [t4, n4] of Object.entries((0, Pg.val)(e5.objectsP)))
        o3(n4, r3.children, r3.depth + 1);
      function o3(e6, r4, o4) {
        const i4 = (0, Pg.val)(e6.template.getMapOfValidSequenceTracks_forStudio());
        if (Object.keys(i4).length === 0)
          return;
        const s3 = { type: "sheetObject", top: t3, children: [], depth: o4, n: n3, sheetObject: e6, nodeHeight: Cg, heightIncludingChildren: -1 };
        r4.push(s3), n3 += 1, t3 += Cg, a3(e6, i4, [], e6.template.config, s3.children, o4 + 1), s3.heightIncludingChildren = t3 - s3.top;
      }
      function a3(e6, t4, n4, r4, o4, a4) {
        for (const [s3, l3] of Object.entries(t4)) {
          const t5 = r4.props[s3];
          Dd2(t5) || i3(e6, l3, [...n4, s3], t5, o4, a4);
        }
        for (const [s3, l3] of Object.entries(t4)) {
          const t5 = r4.props[s3];
          Dd2(t5) && i3(e6, l3, [...n4, s3], t5, o4, a4);
        }
      }
      function i3(e6, r4, o4, i4, s3, l3) {
        if (i4.type === "compound") {
          !function(e7, r5, o5, i5, s4, l4) {
            const u3 = { type: "propWithChildren", pathToProp: o5, sheetObject: e7, top: t3, children: [], nodeHeight: Cg, heightIncludingChildren: -1, depth: l4, trackMapping: r5, n: n3 };
            t3 += Cg, n3 += 1, s4.push(u3), a3(e7, r5, o5, i5, u3.children, l4 + 1), u3.heightIncludingChildren = t3 - u3.top;
          }(e6, r4, o4, i4, s3, l3);
        } else if (i4.type === "enum")
          ye2.warn("Prop type enum is not yet supported in the sequence editor");
        else {
          !function(e7, r5, o5, a4, i5, s4) {
            const l4 = { type: "primitiveProp", propConf: a4, depth: s4, sheetObject: e7, pathToProp: o5, top: t3, nodeHeight: Cg, heightIncludingChildren: Cg, trackId: r5, n: n3 };
            i5.push(l4), n3 += 1, t3 += Cg;
          }(e6, r4, o4, i4, s3, l3);
        }
      }
      return r3.heightIncludingChildren = t3 - r3.top, r3;
    }, Og = { start: 0, end: 10 };
    function Tg(e5, t3) {
      const n3 = me2(), r3 = n3.atomP.ahistoric.projects.stateByProjectId[e5.address.projectId].stateBySheetId[e5.address.sheetId], o3 = n3.atomP.historic.projects.stateByProjectId[e5.address.projectId].stateBySheetId[e5.address.sheetId];
      return (0, Eg.prism)(() => {
        var a3;
        const i3 = (s3 = "tree", l3 = () => jg(e5), u3 = [], _g.prism.memo(s3, () => (0, _g.prism)(l3), u3).getValue());
        var s3, l3, u3;
        const c3 = (0, Eg.val)(t3), d2 = (0, Eg.val)(n3.atomP.historic.panels.sequenceEditor.graphEditor), f2 = (0, Eg.val)(o3.sequenceEditor.selectedPropsByObject), p2 = !!f2 && Object.keys(f2).length > 0, { leftDims: v3, rightDims: g2, graphEditorDims: y3, dopeSheetDims: b3, horizontalScrollbarDims: w3 } = Eg.prism.memo("leftDims", () => {
          var e6;
          const t4 = { width: Math.floor(0.2 * c3.width), height: c3.height, screenX: c3.screenX, screenY: c3.screenY }, n4 = { width: c3.width - t4.width, height: c3.height, screenX: c3.screenX + t4.width, screenY: c3.screenY }, r4 = p2 && (d2 == null ? void 0 : d2.isOpen) === true, o4 = Math.floor((r4 ? Mr2((e6 = d2 == null ? void 0 : d2.height) != null ? e6 : 0.5, 0.1, 0.7) : 0) * c3.heightWithoutBorder), a4 = 0 + o4, i4 = c3.height - a4, s4 = { width: c3.width, height: i4, screenX: c3.screenX, screenY: c3.screenY };
          return { leftDims: t4, rightDims: n4, graphEditorDims: { isAvailable: p2, isOpen: r4, width: n4.width, height: o4, screenX: c3.screenX, screenY: c3.screenY + i4, padding: { top: 20, bottom: 20 } }, dopeSheetDims: s4, horizontalScrollbarDims: { bottom: 0 } };
        }, [c3, d2, p2]), k3 = Eg.prism.memo("graphEditorVerticalSpace", () => {
          const e6 = y3.height - y3.padding.top - y3.padding.bottom;
          return { space: e6, fromExtremumSpace: (t4) => t4 * e6, toExtremumSpace: (t4) => t4 / e6 };
        }, [y3]), [x3, S3] = Eg.prism.state("isSeeking", false), _3 = { isSeeking: x3, setIsSeeking: S3 }, E3 = (a3 = (0, Eg.val)(r3.sequence.clippedSpaceRange)) != null ? a3 : Og, P3 = Eg.prism.memo("scaledSpace", () => {
          const e6 = E3.end - E3.start, t4 = g2.width, n4 = e6 / t4, r4 = t4 / e6;
          return { fromUnitSpace: (e7) => e7 * r4, toUnitSpace: (e7) => e7 * n4, leftPadding: 10 };
        }, [E3, g2.width]), C3 = Eg.prism.memo("setClippedSpaceRange", () => function(t4) {
          n3.transaction(({ stateEditors: n4 }) => {
            const r4 = h2({}, t4);
            if (r4.end <= r4.start && (r4.end = r4.start + 1), r4.start < 0) {
              const e6 = r4.end - r4.start;
              r4.start = 0, r4.end = e6;
            }
            n4.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.clippedSpaceRange.set(m2(h2({}, e5.address), { range: r4 }));
          });
        }, []), j3 = Eg.prism.memo("clippedSpace", () => ({ range: E3, width: g2.width, fromUnitSpace: (e6) => P3.fromUnitSpace(e6 - E3.start) + P3.leftPadding, toUnitSpace: (e6) => P3.toUnitSpace(e6 - P3.leftPadding) + E3.start, setRange: C3 }), [E3, g2.width, P3, C3]), O3 = Eg.prism.memo("selection.current", () => new Eg.Atom({}), []);
        return Zp2("finalAtom", { sheet: e5, tree: i3, panelDims: c3, leftDims: v3, rightDims: g2, dopeSheetDims: b3, horizontalScrollbarDims: w3, seeker: _3, unitSpace: {}, scaledSpace: P3, clippedSpace: j3, graphEditorDims: y3, graphEditorVerticalSpace: k3, selectionAtom: O3 }).pointer;
      });
    }
    var Ig = w2(g), Dg = w2(je.exports), Rg = w2(yh), Ng = w2(g), Ag = w2(je.exports), zg = w2(yh), Mg = w2(je.exports), Lg = w2(yh), Fg = w2(g), $g = w2(je.exports), Bg = w2(yh), Vg = Bg.default.div`
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  pointer-events: none;
`, Ug = { fullUnitStampColor: "#6a6a6a", stampFontSize: "10px", get subUnitStampColor() {
      return Fi2(0.2, Ug.fullUnitStampColor);
    } }, Hg = Bg.default.div`
  position: absolute;
  top: 0;
  height: 100%;
  left: 0;
  overflow: hidden;
  /* z-index: 2; */
  will-change: transform;
  pointer-events: none;
`, Wg = Bg.default.div`
  position: absolute;
  top: 0;
  left: 0;

  & > span {
    position: absolute;
    display: block;
    top: 9px;
    left: -10px;
    color: ${Ug.fullUnitStampColor};
    text-align: center;
    font-size: ${Ug.stampFontSize};
    width: 20px;

    &.full-unit {
      color: ${Ug.fullUnitStampColor};
    }

    &.sub-unit {
      color: ${Ug.subUnitStampColor};
    }
  }

  pointer-events: none;
`, qg = ({ layoutP: e5, width: t3 }) => {
      const n3 = (0, $g.useRef)(null), [r3, o3] = (0, $g.useState)(null);
      return (0, $g.useLayoutEffect)(() => {
        if (r3)
          return (0, Fg.prism)(() => {
            const t4 = (0, Fg.val)(e5.sheet).getSequence();
            return { fullSecondStampsContainer: r3, clippedSpaceRange: (0, Fg.val)(e5.clippedSpace.range), clippedSpaceWidth: (0, Fg.val)(e5.clippedSpace.width), unitSpaceToClippedSpace: (0, Fg.val)(e5.clippedSpace.fromUnitSpace), leftPadding: (0, Fg.val)(e5.scaledSpace.leftPadding), fps: t4.subUnitsPerUnit, sequencePositionFormatter: t4.positionFormatter, snapToGrid: (e6) => t4.closestGridPosition(e6) };
          }).tapImmediate(Xv, Kg);
      }, [r3, t3, e5]), $g.default.createElement(Vg, { ref: n3, style: { width: t3 + "px" } }, $g.default.createElement(Hg, { style: { width: t3 + "px" } }, $g.default.createElement(Wg, { ref: o3 })));
    };
    function Kg(e5) {
      const { fullSecondStampsContainer: t3, sequencePositionFormatter: n3, snapToGrid: r3, unitSpaceToClippedSpace: o3 } = e5;
      let a3 = "";
      Kv(e5, (e6, t4) => {
        const i3 = r3(e6), s3 = o3(i3);
        a3 += t4 ? Yg(n3.formatFullUnitForGrid(i3), s3, "full-unit") : Yg(n3.formatSubUnitForGrid(i3), s3, "sub-unit");
      }), t3.innerHTML = a3;
    }
    function Yg(e5, t3, n3) {
      return `<span class="${n3}" style="transform: translate3d(${t3.toFixed(1)}px, -50%, 0);">${e5}</span>`;
    }
    var Xg = "#1f2120eb", Gg = "#1c1e21", Qg = (0, Lg.default)(bp2)`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: ${20}px;
  box-sizing: border-box;
  background: ${Xg};
  border-bottom: 1px solid ${Gg};
  ${qi2};
`, Jg = ({ layoutP: e5 }) => {
      const t3 = $a2(e5.rightDims.width);
      return Mg.default.createElement(Qg, h2({}, { [Mm]: "hide" }), Mg.default.createElement(qg, { layoutP: e5, width: t3, height: 20 }));
    }, Zg = w2(je.exports), ey = w2(yh), ty = (e5) => isFinite(e5) && e5 > 0, ny = ey.default.div`
  display: flex;
  gap: 8px;
  padding: 4px 8px;
  height: 28px;
  align-items: center;
`, ry = ey.default.div`
  ${kd2};
  white-space: nowrap;
`, oy = ({ deltaX: e5 }) => 0.25 * e5, ay = ({ layoutP: e5, onRequestClose: t3 }) => {
      const n3 = $a2(e5.sheet), r3 = (0, Zg.useMemo)(() => {
        let e6;
        return { temporarilySetValue(t4) {
          e6 && (e6.discard(), e6 = void 0), e6 = me2().tempTransaction(({ stateEditors: e7 }) => {
            e7.coreByProject.historic.sheetsById.sequence.setLength(m2(h2({}, n3.address), { length: t4 }));
          });
        }, discardTemporaryValue() {
          e6 && (e6.discard(), e6 = void 0);
        }, permenantlySetValue(t4) {
          e6 && (e6.discard(), e6 = void 0), me2().transaction(({ stateEditors: e7 }) => {
            e7.coreByProject.historic.sheetsById.sequence.setLength(m2(h2({}, n3.address), { length: t4 }));
          });
        } };
      }, [e5, n3]), o3 = (0, Zg.useRef)(null);
      return (0, Zg.useLayoutEffect)(() => {
        o3.current.focus();
      }, []), Fa2(() => {
        const e6 = n3.getSequence().length;
        return Zg.default.createElement(ny, null, Zg.default.createElement(ry, null, "Sequence length"), Zg.default.createElement(ef2, m2(h2({ value: e6 }, r3), { isValid: ty, inputRef: o3, onBlur: t3, nudge: oy })));
      }, [n3, r3, o3]);
    }, iy = "#0000006c", sy = "#000000", ly = zg.default.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  z-index: ${() => Qy.lengthIndicatorStrip};
  pointer-events: none;

  &:after {
    display: block;
    content: ' ';
    position: absolute;
    /* top: ${20}px; */
    top: 0;
    bottom: 0;
    left: -1px;
    width: 1px;
    background-color: ${iy};
  }

  &:hover:after,
  &.dragging:after {
    background-color: ${sy};
  }
`, uy = zg.default.div`
  position: absolute;
  top: ${5}px;
  width: 100px;
  left: -50px;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1;
`, cy = zg.default.div`
  margin-top: 8px;
  font-size: 10px;
  white-space: nowrap;
  padding: 2px 8px;
  border-radius: 2px;
  ${qi2};
  cursor: ew-resize;
  color: #464646;
  background-color: #0000004d;
  display: none;

  ${ly}:hover &, ${ly}.dragging & {
    display: block;
    color: white;
    background-color: ${sy};
  }
`, dy = zg.default.div`
  font-size: 10px;
  white-space: nowrap;
  padding: 1px 2px;
  border-radius: 2px;
  ${qi2};
  justify-content: center;
  align-items: center;
  cursor: ew-resize;
  color: #5d5d5d;
  background-color: #191919;

  ${ly}:hover &, ${ly}.dragging & {
    color: white;
    background-color: ${sy};

    & > svg:first-child {
      margin-right: -1px;
    }
  }

  & > svg:first-child {
    margin-right: -4px;
  }
`, fy = zg.default.div`
  position: absolute;
  top: 0;
  left: 0;
  background-color: rgb(23 23 23 / 43%);
  width: ${1e3}px;
  z-index: ${() => Qy.lengthIndicatorCover};
  transform-origin: left top;

  ${ly}.dragging ~ &, ${ly}:hover ~ & {
    background-color: rgb(23 23 23 / 60%);
  }
`;
    var py = ({ layoutP: e5 }) => {
      const [t3, n3] = sl2(null), [r3] = function(e6, t4) {
        const n4 = (0, Ag.useRef)(t4);
        n4.current = t4;
        const [r4, o4] = (0, Ag.useState)(false);
        zm(r4, -1);
        const a4 = (0, Ag.useMemo)(() => {
          let e7, t5, r5, a5, i4;
          return { lockCursorTo: "ew-resize", onDragStart(t6) {
            o4(true), r5 = n4.current, a5 = (0, Ng.val)(n4.current.layoutP.sheet), i4 = a5.getSequence().length, e7 = (0, Ng.val)(r5.layoutP.scaledSpace.toUnitSpace);
          }, onDrag(n5, r6, o5) {
            const s4 = e7(n5);
            t5 && (t5.discard(), t5 = void 0), t5 = me2().tempTransaction(({ stateEditors: e8 }) => {
              e8.coreByProject.historic.sheetsById.sequence.setLength(m2(h2({}, a5.address), { length: i4 + s4 }));
            });
          }, onDragEnd(e8) {
            o4(false), e8 ? t5 && t5.commit() : t5 && t5.discard(), t5 = void 0;
          } };
        }, []);
        return vp2(e6, a4), [r4];
      }(n3, { layoutP: e5 }), [o3, a3, i3, s3] = Of2({}, () => Ag.default.createElement(ic2, null, Ag.default.createElement(ay, { layoutP: e5, onRequestClose: i3 })));
      return Fa2(() => {
        const i4 = (0, Ng.val)(e5.sheet), s4 = (0, Ng.val)(e5.rightDims.height), l3 = i4.getSequence(), u3 = l3.length, c3 = u3;
        let d2, f2, p2 = (0, Ng.val)(e5.clippedSpace.fromUnitSpace)(c3), m3 = (0, Ng.val)(e5.clippedSpace.width);
        return p2 > m3 ? (f2 = 0, d2 = 0) : (p2 < 0 && (p2 = 0), f2 = p2, d2 = (m3 - p2) / 1e3), Ag.default.createElement(Ag.default.Fragment, null, o3, Ag.default.createElement(ly, { style: { height: s4 + "px", transform: `translateX(${f2 === 0 ? -1e3 : f2}px)` }, className: (0, Ng.val)(r3) ? "dragging" : "" }, Ag.default.createElement(uy, null, Ag.default.createElement(dy, h2({ ref: t3, onClick: (e6) => {
          a3(e6, n3);
        } }, { [Mm]: "hide" }), Ag.default.createElement(ms2, null), Ag.default.createElement(vs2, null)), Ag.default.createElement(cy, null, "Sequence length:", " ", l3.positionFormatter.formatBasic(u3)))), Ag.default.createElement(fy, { title: "Length", style: { height: s4 + "px", transform: `translateX(${f2}px) scale(${d2}, 1)` } }));
      }, [e5, t3, r3, o3]);
    }, hy = w2(g), my = w2(je.exports), vy = w2(yh), gy = vy.default.div`
  position: absolute;
  top: 16px;
  font-size: ${Ug.stampFontSize};
  color: ${Ug.fullUnitStampColor};
  text-align: center;
  transform: translateX(-50%);
  background: ${Xg};
  padding: 1px 8px;
  font-variant-numeric: tabular-nums;
  pointer-events: none;
  z-index: ${() => Qy.currentFrameStamp};
`, yy = vy.default.div`
  position: absolute;
  top: 5px;
  left: -0px;
  bottom: 0;
  width: 0.5px;
  background: rgba(100, 100, 100, 0.2);
  pointer-events: none;
`, by = my.default.memo(({ layoutP: e5 }) => {
      const [t3, n3] = $a2((0, Rm.useContext)(Nm).currentD), r3 = $a2(e5.clippedSpace.fromUnitSpace), { sequence: o3, formatter: a3, clippedSpaceWidth: i3 } = Fa2(() => {
        const t4 = (0, hy.val)(e5.sheet).getSequence(), n4 = (0, hy.val)(e5.clippedSpace.width);
        return { sequence: t4, formatter: t4.positionFormatter, clippedSpaceWidth: n4 };
      }, [e5]);
      if (t3 == -1)
        return my.default.createElement(my.default.Fragment, null);
      const s3 = n3 === sm.free ? o3.closestGridPosition(t3) : t3, l3 = r3(s3), u3 = l3 >= 0 && l3 <= i3;
      return my.default.createElement(my.default.Fragment, null, my.default.createElement(gy, { style: { opacity: u3 ? 1 : 0, transform: `translate3d(calc(${l3}px - 50%), 0, 0)` } }, a3.formatForPlayhead(s3)), my.default.createElement(yy, { posType: n3, style: { opacity: u3 ? 1 : 0, transform: `translate3d(${l3}px, 0, 0)` } }));
    }), wy = w2(g), ky = w2(je.exports), xy = w2(yh), Sy = xy.default.div`
  --threadHeight: 6px;
  --bg-inactive: #32353b;
  --bg-active: #5b5c5d;
  position: absolute;
  height: 0;
  width: 100%;
  left: 12px;
  /* bottom: 8px; */
  ${qi2};
  z-index: ${() => Qy.horizontalScrollbar};
`, _y = xy.default.div`
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--threadHeight);
`, Ey = xy.default.div`
  position: absolute;
  height: 5px;
  background: var(--bg-inactive);
  cursor: ew-resize;
  z-index: 2;

  &:hover,
  &:active {
    background: var(--bg-active);
  }

  &:after {
    ${Wi2("absolute", "-4px")};
    display: block;
    content: ' ';
  }
`, Py = xy.default.div`
  position: absolute;
  height: 5px;
  width: 7px;
  left: 0;
  z-index: 2;
  top: 0;
  bottom: 0;
  display: block;

  &:hover:before {
    background: var(--bg-active);
  }

  &:before {
    ${Wi2("absolute", "0")};
    display: block;
    content: ' ';
    background: var(--bg-inactive);
    border-radius: 0 2px 2px 0;
  }

  &:after {
    ${Wi2("absolute", "-4px")};
    display: block;
    content: ' ';
  }
`, Cy = (0, xy.default)(Py)`
  left: calc(-1 * 7px);
  cursor: w-resize;
  &:before {
    transform: scaleX(-1);
  }
`, jy = (0, xy.default)(Py)`
  cursor: e-resize;
  left: 0px;
`, Oy = xy.default.div`
  display: ${(e5) => e5.active ? "block" : "none"};
  position: absolute;
  top: -20px;
  left: 4px;
  padding: 0 4px;
  transform: translateX(-50%);
  background: #131d1f;
  border-radius: 4px;
  color: #fff;
  font-size: 10px;
  line-height: 18px;
  text-align: center;

  ${Cy}:hover &,
  ${jy}:hover &,
  ${Ey}:hover ~ ${Cy} &,
  ${Ey}:hover ~ ${jy} & {
    display: block;
  }
`, Ty = ({ layoutP: e5 }) => {
      const t3 = (0, ky.useCallback)((e6) => e6.toFixed(2), []), n3 = (0, ky.useMemo)(() => (0, wy.prism)(() => {
        const t4 = (0, wy.val)(e5.rightDims.width) - 25, n4 = (0, wy.val)(e5.clippedSpace.range), r4 = (0, wy.val)(e5.sheet).getSequence().length, o4 = Math.max(n4.end, r4);
        return { rightWidth: t4, clippedSpaceRange: n4, sequenceLength: r4, assumedLengthOfSequence: o4, rangeStartX: n4.start / o4 * t4, rangeEndX: n4.end / o4 * t4, bottom: (0, wy.val)(e5.horizontalScrollbarDims.bottom) };
      }), [e5]), { rangeStartX: r3, rangeEndX: o3, clippedSpaceRange: a3, bottom: i3 } = $a2(n3), [s3, l3] = (0, ky.useState)("nothing"), u3 = (0, ky.useMemo)(() => {
        let t4 = (0, wy.val)(n3);
        const r4 = (e6) => e6 / t4.rightWidth * t4.assumedLengthOfSequence;
        return { onDragStart() {
          t4 = (0, wy.val)(n3);
        }, onDragEnd() {
          l3("nothing");
        }, dragRange: (n4) => {
          l3("both");
          const o4 = r4(n4), a4 = ba(t4.clippedSpaceRange, (e6) => e6 + o4);
          (0, wy.val)(e5.clippedSpace.setRange)(a4);
        }, dragRangeStart: (n4) => {
          l3("start");
          const o4 = r4(n4), a4 = { start: t4.clippedSpaceRange.start + o4, end: t4.clippedSpaceRange.end };
          a4.start > a4.end - 1 && (a4.start = a4.end - 1), a4.start <= 0 && (a4.start = 0), (0, wy.val)(e5.clippedSpace.setRange)(a4);
        }, dragRangeEnd: (n4) => {
          l3("end");
          const o4 = r4(n4), a4 = { start: t4.clippedSpaceRange.start, end: t4.clippedSpaceRange.end + o4 };
          a4.end < a4.start + 1 && (a4.end = a4.start + 1), a4.end >= t4.assumedLengthOfSequence && (a4.end = t4.assumedLengthOfSequence), (0, wy.val)(e5.clippedSpace.setRange)(a4);
        } };
      }, [e5, n3]);
      return ky.default.createElement(Sy, h2({ style: { bottom: i3 + 8 + "px" } }, { [Mm]: "hide" }), ky.default.createElement(_y, null, ky.default.createElement(Xd2, { onDragStart: u3.onDragStart, onDragEnd: u3.onDragEnd, onDrag: u3.dragRange, lockCursorTo: "ew-resize" }, ky.default.createElement(Ey, { style: { width: o3 - r3 + "px", transform: `translate3d(${r3}px, 0, 0)` } })), ky.default.createElement(Xd2, { onDragStart: u3.onDragStart, onDrag: u3.dragRangeStart, lockCursorTo: "w-resize" }, ky.default.createElement(Cy, { style: { transform: `translate3d(${r3}px, 0, 0)` } }, ky.default.createElement(Oy, { active: s3 === "both" || s3 === "start" }, t3(a3.start)))), ky.default.createElement(Xd2, { onDragStart: u3.onDragStart, onDrag: u3.dragRangeEnd, lockCursorTo: "e-resize" }, ky.default.createElement(jy, { style: { transform: `translate3d(${o3}px, 0, 0)` } }, ky.default.createElement(Oy, { active: s3 === "both" || s3 === "end" }, t3(a3.end))))));
    }, Iy = w2(je.exports), Dy = w2(yh).default.div`
  position: absolute;
  inset: ${(e5) => -1 * e5.room}px;
`, Ry = (e5) => Iy.default.createElement(Dy, { room: e5.room }), Ny = w2(g), Ay = w2(je.exports), zy = w2(yh), My = zy.default.div`
  --thumbColor: #00e0ff;
  position: absolute;
  top: 0;
  left: 0;
  width: 5px;
  height: 100%;
  z-index: ${() => Qy.playhead};
  pointer-events: none;

  display: ${(e5) => e5.isVisible ? "block" : "none"};
`, Ly = zy.default.div`
  position: absolute;
  top: 8px;
  width: 0;
  height: calc(100% - 8px);
  border-left: 1px solid #27e0fd;
  z-index: 10;

  #pointer-root.draggingPositionInSequenceEditor &:not(.seeking) {
    pointer-events: auto;

    &:after {
      position: absolute;
      inset: -8px;
      display: block;
      content: ' ';
    }
  }
`, Fy = zy.default.div`
  background-color: var(--thumbColor);
  position: absolute;
  width: 5px;
  height: 13px;
  top: -4px;
  left: -2px;
  z-index: 11;
  cursor: ew-resize;
  ${qi2};

  #pointer-root.draggingPositionInSequenceEditor &:not(.seeking) {
    pointer-events: auto;
  }

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    left: -2px;
    width: 0;
    height: 0;
    border-bottom: 4px solid #1f2b2b;
    border-left: 2px solid transparent;
  }

  &:after {
    position: absolute;
    display: block;
    content: ' ';
    right: -2px;
    width: 0;
    height: 0;
    border-bottom: 4px solid #1f2b2b;
    border-right: 2px solid transparent;
  }
`, $y = zy.default.div`
  position: absolute;
  left: 1px;
  right: 1px;
  top: 13px;
  border-top: 3px solid var(--thumbColor);
  border-right: 1px solid transparent;
  border-left: 1px solid transparent;
  pointer-events: none;

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    top: -4px;
    left: -2px;
    height: 8px;
    width: 2px;
    background: none;
    border-radius: 0 100% 0 0;
    border-top: 1px solid var(--thumbColor);
    border-right: 1px solid var(--thumbColor);
  }

  &:after {
    position: absolute;
    display: block;
    content: ' ';
    top: -4px;
    right: -2px;
    height: 8px;
    width: 2px;
    background: none;
    border-radius: 100% 0 0 0;
    border-top: 1px solid var(--thumbColor);
    border-left: 1px solid var(--thumbColor);
  }
`, By = zy.default.div`
  display: none;
  position: absolute;
  top: -20px;
  left: 4px;
  padding: 0 2px;
  transform: translateX(-50%);
  background: #1a1a1a;
  border-radius: 4px;
  color: #fff;
  font-size: 10px;
  line-height: 18px;
  text-align: center;
  ${Fy}:hover &, ${My}.seeking & {
    display: block;
  }
`, Vy = ({ layoutP: e5 }) => {
      const [t3, n3] = sl2(null), r3 = (0, Ay.useMemo)(() => {
        const t4 = (0, Ny.val)(e5.seeker.setIsSeeking);
        let r4, o3, a3 = 0;
        return { onDragStart() {
          r4 = (0, Ny.val)(e5.sheet).getSequence(), a3 = r4.position, o3 = (0, Ny.val)(e5.scaledSpace.toUnitSpace), t4(true);
        }, onDrag(e6, t5, i3) {
          const s3 = o3(e6);
          let l3 = Mr2(a3 + s3, 0, r4.length);
          const u3 = i3.composedPath().find((e7) => e7 instanceof Element && e7 !== n3 && e7.hasAttribute("data-pos"));
          if (u3) {
            const e7 = parseFloat(u3.getAttribute("data-pos"));
            isFinite(e7) && (l3 = e7);
          }
          r4.position = l3;
        }, onDragEnd() {
          t4(false);
        }, lockCursorTo: "ew-resize" };
      }, []);
      return vp2(n3, r3), zm($a2(e5.seeker.isSeeking), -1), Fa2(() => {
        const n4 = (0, Ny.val)(e5.seeker.isSeeking), r4 = (0, Ny.val)(e5.sheet).getSequence(), o3 = r4.positionDerivation.getValue(), a3 = (0, Ny.val)(e5.clippedSpace.fromUnitSpace)(o3), i3 = a3 >= 0 && a3 <= (0, Ny.val)(e5.clippedSpace.width);
        return Ay.default.createElement(My, h2({ isVisible: i3, style: { transform: `translate3d(${a3}px, 0, 0)` }, className: n4 ? "seeking" : "" }, { [Mm]: "hide" }), Ay.default.createElement(Fy, { ref: t3, "data-pos": o3.toFixed(3) }, Ay.default.createElement(Ry, { room: 8 }), Ay.default.createElement($y, null), Ay.default.createElement(By, null, r4.positionFormatter.formatForPlayhead(r4.closestGridPosition(o3)))), Ay.default.createElement(Ly, { "data-pos": o3.toFixed(3), className: n4 ? "seeking" : "" }));
      }, [e5]);
    }, Uy = Rg.default.div`
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  z-index: ${() => Qy.rightOverlay};
  overflow: visible;
  pointer-events: none;
`, Hy = ({ layoutP: e5 }) => Fa2(() => {
      const t3 = (0, Ig.val)(e5.rightDims.width);
      return Dg.default.createElement(Uy, { style: { width: t3 + "px" } }, Dg.default.createElement(Vy, { layoutP: e5 }), Dg.default.createElement(Ty, { layoutP: e5 }), Dg.default.createElement(by, { layoutP: e5 }), Dg.default.createElement(Jg, { layoutP: e5 }), Dg.default.createElement(py, { layoutP: e5 }));
    }, [e5]), Wy = w2(g), qy = w2(je.exports), Ky = w2(yh).default.button`
  outline: none;
  background-color: #1c1d21;
  border: 1px solid #191919;
  border-radius: 2px;
  display: flex;
  bottom: 14px;
  right: 8px;
  z-index: 1;
  position: absolute;

  padding: 4px 8px;
  display: flex;
  color: #656d77;
  line-height: 20px;
  font-size: 10px;

  &:hover {
    color: white;
  }

  & > svg {
    transition: transform 0.3s;
    transform: rotateZ(0deg);
  }

  &:hover > svg {
    transform: rotateZ(-20deg);
  }

  &.open > svg {
    transform: rotateZ(-180deg);
  }

  &.open:hover > svg {
    transform: rotateZ(-160deg);
  }
`, Yy = ({ layoutP: e5 }) => {
      const t3 = $a2(e5.graphEditorDims.isOpen), n3 = (0, qy.useCallback)(() => {
        (0, Wy.val)(e5.sheet);
        const t4 = (0, Wy.val)(e5.graphEditorDims.isOpen);
        me2().transaction(({ stateEditors: e6 }) => {
          e6.studio.historic.panels.sequenceEditor.graphEditor.setIsOpen({ isOpen: !t4 });
        });
      }, [e5]);
      return qy.default.createElement(Ky, h2({ onClick: n3, title: "Toggle graph editor", className: t3 ? "open" : "" }, { [Mm]: "hide" }), qy.default.createElement(ks2, null));
    }, Xy = (0, nh2.default)(Fp2)`
  z-index: ${Xi2.sequenceEditorPanel};
  box-shadow: 2px 2px 0 rgb(0 0 0 / 11%);
`, Gy = nh2.default.div`
  background-color: rgba(40, 43, 47, 0.99);
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  z-index: -1;
  pointer-events: none;
`, Qy = (() => {
      const e5 = { rightBackground: 0, scrollableArea: 0, rightOverlay: 0, lengthIndicatorCover: 0, lengthIndicatorStrip: 0, playhead: 0, currentFrameStamp: 0, horizontalScrollbar: 0 };
      let t3 = -1;
      for (const n3 of Object.keys(e5))
        e5[n3] = t3, t3++;
      return e5;
    })(), Jy = (0, nh2.default)(bp2)`
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1;
`, Zy = { edges: { left: { from: "screenLeft", distance: 0.1 }, right: { from: "screenRight", distance: 0.2 }, top: { from: "screenBottom", distance: 0.4 }, bottom: { from: "screenBottom", distance: 0.01 } } }, eb = { width: 800, height: 200 }, tb = () => {
      const { dims: e5 } = ip2();
      return Fa2(() => {
        const t3 = eh2.prism.memo("panelSize", () => {
          const t4 = e5.width, n4 = e5.height;
          return { width: t4, height: n4, widthWithoutBorder: t4 - 2, heightWithoutBorder: n4 - 4, screenX: e5.left, screenY: e5.top };
        }, [e5]), n3 = Na2(Ns2().filter((e6) => we2(e6) || xe2(e6)).map((e6) => xe2(e6) ? e6.sheet : e6));
        if (Na2(n3.map((e6) => e6.template)).length !== 1)
          return th2.default.createElement(th2.default.Fragment, null);
        const r3 = n3[0];
        if (!r3)
          return th2.default.createElement(th2.default.Fragment, null);
        const o3 = Zp2("panelSizeP", t3).pointer, a3 = eh2.prism.memo("key", () => JSON.stringify(r3.address), [r3]), i3 = eh2.prism.memo("layout", () => Tg(r3, o3), [r3, o3]).getValue();
        if ((0, eh2.val)(i3.tree.children).length === 0)
          return th2.default.createElement(th2.default.Fragment, null);
        const s3 = eh2.prism.memo("containerRef", ob, []), l3 = (0, eh2.val)(i3.graphEditorDims.isAvailable), u3 = (0, eh2.val)(i3.graphEditorDims.isOpen);
        return th2.default.createElement(Xy, { ref: s3 }, th2.default.createElement(Gy, { style: { width: `${(0, eh2.val)(i3.leftDims.width)}px` } }), th2.default.createElement(Fm, { layoutP: i3 }, th2.default.createElement(nb, { layoutP: i3 }), th2.default.createElement(Sg, { key: a3 + "-dopeSheet", layoutP: i3 }), u3 && th2.default.createElement(og, { key: a3 + "-graphEditor", layoutP: i3 }), l3 && th2.default.createElement(Yy, { layoutP: i3 }), th2.default.createElement(Hy, { layoutP: i3 })));
      }, [e5]);
    }, nb = ({ layoutP: e5 }) => Fa2(() => {
      const t3 = (0, eh2.val)(e5.sheet);
      return th2.default.createElement(Jy, { style: { width: (0, eh2.val)(e5.leftDims.width) } }, th2.default.createElement(es2, null, th2.default.createElement(Qi2, null, t3.address.sheetId, " "), th2.default.createElement(Ji2, null, ":", "\xA0"), th2.default.createElement(Qi2, null, t3.address.sheetInstanceId, " "), th2.default.createElement(Ji2, null, "\xA0", ">", "\xA0"), th2.default.createElement(Qi2, null, "Sequence")));
    }, [e5]), rb = (e5) => th2.default.createElement(sp2, { panelId: "sequenceEditor", defaultPosition: Zy, minDims: eb }, th2.default.createElement(tb, null)), ob = () => {
      let e5 = null;
      const t3 = { passive: false, capture: false }, n3 = (e6) => {
        Math.abs(e6.deltaY) < Math.abs(e6.deltaX) && (e6.preventDefault(), e6.stopPropagation());
      };
      return (r3) => {
        e5 !== r3 && e5 && e5.removeEventListener("wheel", n3, t3), e5 = r3, r3 && r3.addEventListener("wheel", n3, t3);
      };
    }, ab = () => {
      const e5 = $a2(me2().paneManager.allPanesD), t3 = Object.entries(e5).map(([e6, t4]) => Jf2.default.createElement(Qp2, { key: `pane-${e6}`, paneInstance: t4 }));
      return Jf2.default.createElement(Jf2.default.Fragment, null, t3, Jf2.default.createElement(wc2, null), Jf2.default.createElement(Qf2, null), Jf2.default.createElement(rb, null));
    }, ib = w2(je.exports), sb = w2(yh).default.div`
  --colors-panel-1: red;
`, lb = (e5) => ib.default.createElement(sb, null, e5.children), ub = w2(je.exports), cb = w2(yh), db = cb.default.div`
  position: fixed;
  z-index: ${Xi2.toolbar};

  top: 12px;
  right: 12px;
  left: 12px;
  height: 36px;
  pointer-events: none;

  display: flex;
  gap: 1rem;
  justify-content: center;
`, fb = cb.default.div`
  display: flex;
  align-items: center;
  gap: 1rem;

  border-radius: 4px;
  padding: 6px 6px;

  ${qi2};

  &:hover {
    background-color: rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(4px);
  }
`, pb = (e5) => {
      const t3 = [], n3 = $a2(me2().atomP.ephemeral.extensions.byId);
      for (const [, e6] of Object.entries(n3))
        e6 && e6.globalToolbar && t3.push(ub.default.createElement(e6.globalToolbar.component, { key: "extensionToolbar-" + e6.id }));
      return t3.length === 0 ? null : ub.default.createElement(db, null, ub.default.createElement(fb, null, t3));
    }, hb = w2(je.exports), mb = navigator && navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    function vb() {
      const e5 = me2();
      (0, hb.useEffect)(() => {
        const t3 = (t4) => {
          const n3 = t4.composedPath()[0];
          if (!n3 || n3.tagName !== "INPUT" && n3.tagName !== "TEXTAREA") {
            if (t4.key === "z" || t4.key === "Z" || t4.code === "KeyZ") {
              if (!((e6) => mb ? e6.metaKey === true : e6.ctrlKey === true)(t4))
                return;
              t4.shiftKey === true ? e5.redo() : e5.undo();
            } else if (t4.key !== " " || t4.shiftKey || t4.metaKey || t4.altKey || t4.ctrlKey) {
              if (!t4.altKey || t4.key !== "\\" && t4.code !== "Backslash" && t4.code !== "IntlBackslash")
                return;
              e5.transaction(({ stateEditors: e6, drafts: t5 }) => {
                e6.studio.ahistoric.setVisibilityState(t5.ahistoric.visibilityState === "everythingIsHidden" ? "everythingIsVisible" : "everythingIsHidden");
              });
            } else {
              const e6 = function() {
                const e7 = Na2(Ns2().filter((e8) => we2(e8) || xe2(e8)).map((e8) => xe2(e8) ? e8.sheet : e8))[0];
                if (e7)
                  return e7.getSequence();
              }();
              if (!e6)
                return;
              e6.playing ? e6.pause() : e6.play({ iterationCount: 1e3 });
            }
            t4.preventDefault(), t4.stopPropagation();
          }
        };
        return window.addEventListener("keydown", t3), () => {
          window.removeEventListener("keydown", t3);
        };
      }, []);
    }
    var gb = Ga2.createGlobalStyle`
  :host {
    contain: strict;
    all: initial;
    color: white;
    font: 11px -apple-system, BlinkMacSystemFont, Segoe WPC, Segoe Editor,
      HelveticaNeue-Light, Ubuntu, Droid Sans, sans-serif;
  }

  * {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
    list-style: none;
  }
`, yb = (0, Ga2.default)(mp2)`
  z-index: 50;
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;

  &.invisible {
    pointer-events: none !important;
    opacity: 0;
    transform: translateX(1000000px);
  }
`, bb = Ga2.default.div`
  z-index: 51;
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  pointer-events: none;
`;
    function wb() {
      const e5 = me2(), [t3, n3] = sl2(void 0);
      sl2(void 0), vb();
      const r3 = $a2(e5.atomP.ahistoric.visibilityState);
      (0, Xa2.useEffect)(() => (r3 === "everythingIsHidden" && console.warn("Theatre Studio is hidden. Use the keyboard shortcut 'alt + \\' to restore the studio, or call studio.ui.restore()."), () => {
      }), [r3]);
      return Fa2(() => {
        const r4 = (0, Ya2.val)(e5.atomP.ahistoric.visibilityState);
        return (0, Ya2.val)(e5.atomP.ephemeral.initialised) ? Xa2.default.createElement(Ga2.StyleSheetManager, { disableVendorPrefixes: true, target: me2().ui.containerShadow }, Xa2.default.createElement(Xa2.default.Fragment, null, Xa2.default.createElement(gb, null), Xa2.default.createElement(lb, null, Xa2.default.createElement(Uu2.Provider, { value: n3 }, Xa2.default.createElement(Dl2, null, Xa2.default.createElement(yb, { className: r4 === "everythingIsHidden" ? "invisible" : "" }, Xa2.default.createElement(bb, { ref: t3 }), Xa2.default.createElement(pb, null), Xa2.default.createElement(ab, null))))))) : null;
      }, [e5, t3, n3]);
    }
    var kb = w2(je.exports), xb = w2(ht.exports), Sb = w2(g), _b = w2(g);
    function Eb(e5) {
      return e5;
    }
    var Pb, Cb = (e5, t3 = Eb) => {
      const n3 = (n4) => ({ type: e5, payload: t3(n4) });
      return n3.type = e5, n3.is = (t4) => t4 && t4.type && t4.type === e5, n3;
    }, jb = w2(Y2()), Ob = w2(he2()), Tb = new Uint8Array(16);
    function Ib() {
      if (!Pb && !(Pb = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto)))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return Pb(Tb);
    }
    var Db = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    for (var Rb = function(e5) {
      return typeof e5 == "string" && Db.test(e5);
    }, Nb = [], Ab = 0; Ab < 256; ++Ab)
      Nb.push((Ab + 256).toString(16).substr(1));
    var zb = function(e5) {
      var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n3 = (Nb[e5[t3 + 0]] + Nb[e5[t3 + 1]] + Nb[e5[t3 + 2]] + Nb[e5[t3 + 3]] + "-" + Nb[e5[t3 + 4]] + Nb[e5[t3 + 5]] + "-" + Nb[e5[t3 + 6]] + Nb[e5[t3 + 7]] + "-" + Nb[e5[t3 + 8]] + Nb[e5[t3 + 9]] + "-" + Nb[e5[t3 + 10]] + Nb[e5[t3 + 11]] + Nb[e5[t3 + 12]] + Nb[e5[t3 + 13]] + Nb[e5[t3 + 14]] + Nb[e5[t3 + 15]]).toLowerCase();
      if (!Rb(n3))
        throw TypeError("Stringified UUID is invalid");
      return n3;
    };
    var Mb = function(e5, t3, n3) {
      var r3 = (e5 = e5 || {}).random || (e5.rng || Ib)();
      if (r3[6] = 15 & r3[6] | 64, r3[8] = 63 & r3[8] | 128, t3) {
        n3 = n3 || 0;
        for (var o3 = 0; o3 < 16; ++o3)
          t3[n3 + o3] = r3[o3];
        return t3;
      }
      return zb(r3);
    }, Lb = { replaceHistory: Cb("@history/replaceHistory"), startHistoryFromScratch: Cb("@history/startHistoryFromScratch"), undo: Cb("@history/undo"), redo: Cb("@history/redo") }, Fb = { type: "@history/unknownAction", payload: "" }, $b = { maxNumberOfCommits: 100 };
    function Bb(e5) {
      return { currentCommitHash: void 0, commitsByHash: {}, listOfCommitHashes: [], innerState: e5 };
    }
    var Vb, Ub, Hb = { ahistoric: { visibilityState: "everythingIsVisible", theTrigger: { position: { closestCorner: "bottomLeft", distanceFromHorizontalEdge: 0.02, distanceFromVerticalEdge: 0.02 } }, coreByProject: {}, projects: { stateByProjectId: {} } }, historic: { projects: { stateByProjectId: {} }, autoKey: true, coreByProject: {}, panelInstanceDesceriptors: {} }, ephemeral: { initialised: false, coreByProject: {}, projects: { stateByProjectId: {} }, extensions: { byId: {}, paneClasses: {} } } }, Wb = Cb("@storeBundle/replacePersistentState", (e5) => e5), qb = Cb("@storeBundle/reduceParts", (e5) => e5), Kb = { historic: Lb, replacePersistentState: Wb, reduceParts: qb }, Yb = Cb("@storeBundle/setInnerHistoricState", (e5) => e5), Xb = ((e5, t3 = $b) => {
      const n3 = Bb(e5(void 0, Fb));
      return function(r3, o3) {
        return Lb.startHistoryFromScratch.is(o3) ? Bb(e5(void 0, o3.payload)) : Lb.replaceHistory.is(o3) ? o3.payload : Lb.undo.is(o3) ? r3 ? function(e6) {
          if (e6.currentCommitHash === void 0)
            return e6;
          const t4 = e6.listOfCommitHashes.findIndex((t5) => t5 === e6.currentCommitHash);
          if (t4 === -1)
            throw new Error("This should never happen");
          const n4 = e6.commitsByHash[e6.currentCommitHash], r4 = (0, Ob.default)(e6.innerState, n4.backwardDiff), o4 = t4 - 1, a3 = o4 === -1 ? void 0 : e6.listOfCommitHashes[o4];
          return m2(h2({}, e6), { currentCommitHash: a3, innerState: r4 });
        }(r3) : n3 : Lb.redo.is(o3) ? r3 ? function(e6) {
          if (e6.listOfCommitHashes.length === 0)
            return e6;
          const t4 = e6.listOfCommitHashes.findIndex((t5) => t5 === e6.currentCommitHash);
          if (t4 === e6.listOfCommitHashes.length - 1)
            return e6;
          const n4 = t4 + 1, r4 = e6.listOfCommitHashes[n4], o4 = e6.commitsByHash[r4], a3 = (0, Ob.default)(e6.innerState, o4.forwardDiff);
          return m2(h2({}, e6), { currentCommitHash: r4, innerState: a3 });
        }(r3) : n3 : r3 ? function(e6, t4, n4) {
          if (t4 === e6.innerState)
            return e6;
          const r4 = function(e7, t5) {
            const n5 = jb.default.diff(e7, t5, { invertible: false }), r5 = jb.default.diff(t5, e7, { invertible: false }), o5 = Date.now(), a4 = Mb();
            return { forwardDiff: n5, backwardDiff: r5, timestamp: o5, hash: a4 };
          }(e6.innerState, t4);
          if (r4.forwardDiff.length === 0)
            return e6;
          const o4 = aa2(e6.listOfCommitHashes), a3 = { currentCommitHash: r4.hash, commitsByHash: h2({}, e6.commitsByHash), listOfCommitHashes: [...e6.listOfCommitHashes], innerState: t4 };
          if (e6.currentCommitHash !== o4) {
            const t5 = e6.listOfCommitHashes.findIndex((t6) => t6 === e6.currentCommitHash);
            e6.listOfCommitHashes.slice(t5 + 1).forEach((e7) => {
              delete a3.commitsByHash[e7];
            }), a3.listOfCommitHashes.splice(t5 + 1, a3.listOfCommitHashes.length);
          }
          if (a3.listOfCommitHashes.push(r4.hash), a3.commitsByHash[r4.hash] = r4, a3.listOfCommitHashes.length > n4.maxNumberOfCommits) {
            const e7 = a3.listOfCommitHashes.length - n4.maxNumberOfCommits;
            a3.listOfCommitHashes.slice(0, e7).forEach((e8) => {
              delete a3.commitsByHash[e8];
            }), a3.listOfCommitHashes.splice(0, e7);
          }
          return a3;
        }(r3, e5(r3.innerState, o3), t3) : Bb(e5(void 0, o3));
      };
    })((e5 = Hb.historic, t3) => Yb.is(t3) ? t3.payload : e5), Gb = (e5, t3) => {
      if (Wb.is(t3)) {
        const { historic: n3, ahistoric: r3 } = t3.payload;
        return { $persistent: { historic: n3, ahistoric: r3 }, ephemeral: (e5 == null ? void 0 : e5.ephemeral) || Hb.ephemeral };
      }
      if (e5) {
        let { historic: n3, ahistoric: r3 } = e5.$persistent, { ephemeral: o3 } = e5;
        if (qb.is(t3)) {
          const a3 = { historic: e5.$persistent.historic.innerState, ahistoric: e5.$persistent.ahistoric, ephemeral: e5.ephemeral }, i3 = t3.payload(a3);
          if (i3 === a3)
            return e5;
          n3.innerState !== i3.historic && (n3 = Xb(n3, Yb(i3.historic))), r3 = i3.ahistoric, o3 = i3.ephemeral;
        } else {
          const r4 = Xb(n3, t3);
          if (r4 === n3)
            return e5;
          n3 = r4;
        }
        return { $persistent: n3 === e5.$persistent.historic && r3 === e5.$persistent.ahistoric ? e5.$persistent : { historic: n3, ahistoric: r3 }, ephemeral: o3 };
      }
      return { $persistent: { historic: Xb(void 0, {}), ahistoric: Hb.ahistoric }, ephemeral: Hb.ephemeral };
    }, Qb = Cb("@history/pushTempAction", (e5) => e5), Jb = Cb("@history/discardTempAction", (e5) => e5), Zb = Cb("@history/commitTempAction", (e5) => e5), ew = 0, tw = (e5, t3) => {
      if (e5) {
        let n3, { tempActions: r3, permanent: o3 } = e5.$temps;
        if (Qb.is(t3))
          r3 = [...r3, t3];
        else if (Zb.is(t3)) {
          const e6 = r3.find((e7) => e7.payload.id === t3.payload);
          e6 ? (n3 = e6.payload.originalAction, r3 = r3.filter((e7) => e7.payload.id !== t3.payload)) : ye2.error(`Comitting temp action group ${t3.payload} isn't possible as this group doesn't exist`);
        } else
          Jb.is(t3) ? r3 = r3.filter((e6) => e6.payload.id !== t3.payload) : n3 = t3;
        n3 && (o3 = Gb(e5.$temps.permanent, n3));
        let a3 = { historic: o3.$persistent.historic.innerState, ahistoric: o3.$persistent.ahistoric, ephemeral: o3.ephemeral };
        for (const e6 of r3) {
          a3 = e6.payload.originalAction.payload(a3);
        }
        return h2({ $temps: { tempActions: r3, permanent: o3 }, $persistent: o3.$persistent }, a3);
      }
      {
        const e6 = Gb(void 0, t3);
        return { $temps: { permanent: e6, tempActions: [] }, $persistent: e6.$persistent, historic: e6.$persistent.historic.innerState, ahistoric: e6.$persistent.ahistoric, ephemeral: e6.ephemeral };
      }
    }, nw = (e5 = 21) => {
      let t3 = "", n3 = e5;
      for (; n3--; )
        t3 += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64 * Math.random() | 0];
      return t3;
    };
    function rw() {
      return nw(10);
    }
    function ow(e5, t3) {
      if (typeof e5 != "object" || e5 === null)
        return;
      if (t3.length === 0) {
        const t4 = Object.keys(e5);
        for (const n4 of t4)
          delete e5[n4];
        return;
      }
      const n3 = t3.slice(0, t3.length - 1);
      let r3 = e5;
      const o3 = /* @__PURE__ */ new WeakMap();
      for (const e6 of n3) {
        const t4 = r3, n4 = t4[e6];
        if (typeof n4 != "object" || n4 === null)
          return;
        o3.set(n4, t4), r3 = n4;
      }
      const a3 = t3.slice().reverse();
      for (const e6 of a3) {
        if (delete r3[e6], Object.keys(r3).length !== 0)
          return;
        r3 = o3.get(r3);
      }
    }
    function aw(e5) {
      for (var t3 = arguments.length, n3 = Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      var o3 = Hw[e5], a3 = o3 ? typeof o3 == "function" ? o3.apply(null, n3) : o3 : "unknown error nr: " + e5;
      throw Error("[Immer] " + a3);
    }
    function iw(e5) {
      return !!e5 && !!e5[Uw];
    }
    function sw(e5) {
      return !!e5 && (function(e6) {
        if (!e6 || typeof e6 != "object")
          return false;
        var t3 = Object.getPrototypeOf(e6);
        if (t3 === null)
          return true;
        var n3 = Object.hasOwnProperty.call(t3, "constructor") && t3.constructor;
        return n3 === Object || typeof n3 == "function" && Function.toString.call(n3) === Ww;
      }(e5) || Array.isArray(e5) || !!e5[Vw] || !!e5.constructor[Vw] || fw(e5) || pw(e5));
    }
    function lw(e5, t3, n3) {
      n3 === void 0 && (n3 = false), uw(e5) === 0 ? (n3 ? Object.keys : qw)(e5).forEach(function(r3) {
        n3 && typeof r3 == "symbol" || t3(r3, e5[r3], e5);
      }) : e5.forEach(function(n4, r3) {
        return t3(r3, n4, e5);
      });
    }
    function uw(e5) {
      var t3 = e5[Uw];
      return t3 ? t3.i > 3 ? t3.i - 4 : t3.i : Array.isArray(e5) ? 1 : fw(e5) ? 2 : pw(e5) ? 3 : 0;
    }
    function cw(e5, t3) {
      return uw(e5) === 2 ? e5.has(t3) : Object.prototype.hasOwnProperty.call(e5, t3);
    }
    function dw(e5, t3, n3) {
      var r3 = uw(e5);
      r3 === 2 ? e5.set(t3, n3) : r3 === 3 ? (e5.delete(t3), e5.add(n3)) : e5[t3] = n3;
    }
    function fw(e5) {
      return Lw && e5 instanceof Map;
    }
    function pw(e5) {
      return Fw && e5 instanceof Set;
    }
    function hw(e5) {
      return e5.o || e5.t;
    }
    function mw(e5) {
      if (Array.isArray(e5))
        return Array.prototype.slice.call(e5);
      var t3 = Kw(e5);
      delete t3[Uw];
      for (var n3 = qw(t3), r3 = 0; r3 < n3.length; r3++) {
        var o3 = n3[r3], a3 = t3[o3];
        a3.writable === false && (a3.writable = true, a3.configurable = true), (a3.get || a3.set) && (t3[o3] = { configurable: true, writable: true, enumerable: a3.enumerable, value: e5[o3] });
      }
      return Object.create(Object.getPrototypeOf(e5), t3);
    }
    function vw(e5, t3) {
      return t3 === void 0 && (t3 = false), yw(e5) || iw(e5) || !sw(e5) || (uw(e5) > 1 && (e5.set = e5.add = e5.clear = e5.delete = gw), Object.freeze(e5), t3 && lw(e5, function(e6, t4) {
        return vw(t4, true);
      }, true)), e5;
    }
    function gw() {
      aw(2);
    }
    function yw(e5) {
      return e5 == null || typeof e5 != "object" || Object.isFrozen(e5);
    }
    function bw(e5) {
      var t3 = Yw[e5];
      return t3 || aw(18, e5), t3;
    }
    function ww() {
      return Ub || aw(0), Ub;
    }
    function kw(e5, t3) {
      t3 && (bw("Patches"), e5.u = [], e5.s = [], e5.v = t3);
    }
    function xw(e5) {
      Sw(e5), e5.p.forEach(Ew), e5.p = null;
    }
    function Sw(e5) {
      e5 === Ub && (Ub = e5.l);
    }
    function _w(e5) {
      return Ub = { p: [], l: Ub, h: e5, m: true, _: 0 };
    }
    function Ew(e5) {
      var t3 = e5[Uw];
      t3.i === 0 || t3.i === 1 ? t3.j() : t3.O = true;
    }
    function Pw(e5, t3) {
      t3._ = t3.p.length;
      var n3 = t3.p[0], r3 = e5 !== void 0 && e5 !== n3;
      return t3.h.g || bw("ES5").S(t3, e5, r3), r3 ? (n3[Uw].P && (xw(t3), aw(4)), sw(e5) && (e5 = Cw(t3, e5), t3.l || Ow(t3, e5)), t3.u && bw("Patches").M(n3[Uw], e5, t3.u, t3.s)) : e5 = Cw(t3, n3, []), xw(t3), t3.u && t3.v(t3.u, t3.s), e5 !== Bw ? e5 : void 0;
    }
    function Cw(e5, t3, n3) {
      if (yw(t3))
        return t3;
      var r3 = t3[Uw];
      if (!r3)
        return lw(t3, function(o4, a3) {
          return jw(e5, r3, t3, o4, a3, n3);
        }, true), t3;
      if (r3.A !== e5)
        return t3;
      if (!r3.P)
        return Ow(e5, r3.t, true), r3.t;
      if (!r3.I) {
        r3.I = true, r3.A._--;
        var o3 = r3.i === 4 || r3.i === 5 ? r3.o = mw(r3.k) : r3.o;
        lw(r3.i === 3 ? new Set(o3) : o3, function(t4, a3) {
          return jw(e5, r3, o3, t4, a3, n3);
        }), Ow(e5, o3, false), n3 && e5.u && bw("Patches").R(r3, n3, e5.u, e5.s);
      }
      return r3.o;
    }
    function jw(e5, t3, n3, r3, o3, a3) {
      if (o3 === n3 && aw(5), iw(o3)) {
        var i3 = Cw(e5, o3, a3 && t3 && t3.i !== 3 && !cw(t3.D, r3) ? a3.concat(r3) : void 0);
        if (dw(n3, r3, i3), !iw(i3))
          return;
        e5.m = false;
      }
      if (sw(o3) && !yw(o3)) {
        if (!e5.h.F && e5._ < 1)
          return;
        Cw(e5, o3), t3 && t3.A.l || Ow(e5, o3);
      }
    }
    function Ow(e5, t3, n3) {
      n3 === void 0 && (n3 = false), e5.h.F && e5.m && vw(t3, n3);
    }
    function Tw(e5, t3) {
      var n3 = e5[Uw];
      return (n3 ? hw(n3) : e5)[t3];
    }
    function Iw(e5, t3) {
      if (t3 in e5)
        for (var n3 = Object.getPrototypeOf(e5); n3; ) {
          var r3 = Object.getOwnPropertyDescriptor(n3, t3);
          if (r3)
            return r3;
          n3 = Object.getPrototypeOf(n3);
        }
    }
    function Dw(e5) {
      e5.P || (e5.P = true, e5.l && Dw(e5.l));
    }
    function Rw(e5) {
      e5.o || (e5.o = mw(e5.t));
    }
    function Nw(e5, t3, n3) {
      var r3 = fw(t3) ? bw("MapSet").N(t3, n3) : pw(t3) ? bw("MapSet").T(t3, n3) : e5.g ? function(e6, t4) {
        var n4 = Array.isArray(e6), r4 = { i: n4 ? 1 : 0, A: t4 ? t4.A : ww(), P: false, I: false, D: {}, l: t4, t: e6, k: null, o: null, j: null, C: false }, o3 = r4, a3 = Xw;
        n4 && (o3 = [r4], a3 = Gw);
        var i3 = Proxy.revocable(o3, a3), s3 = i3.revoke, l3 = i3.proxy;
        return r4.k = l3, r4.j = s3, l3;
      }(t3, n3) : bw("ES5").J(t3, n3);
      return (n3 ? n3.A : ww()).p.push(r3), r3;
    }
    function Aw(e5) {
      return iw(e5) || aw(22, e5), function e6(t3) {
        if (!sw(t3))
          return t3;
        var n3, r3 = t3[Uw], o3 = uw(t3);
        if (r3) {
          if (!r3.P && (r3.i < 4 || !bw("ES5").K(r3)))
            return r3.t;
          r3.I = true, n3 = zw(t3, o3), r3.I = false;
        } else
          n3 = zw(t3, o3);
        return lw(n3, function(t4, o4) {
          r3 && function(e7, t5) {
            return uw(e7) === 2 ? e7.get(t5) : e7[t5];
          }(r3.t, t4) === o4 || dw(n3, t4, e6(o4));
        }), o3 === 3 ? new Set(n3) : n3;
      }(e5);
    }
    function zw(e5, t3) {
      switch (t3) {
        case 2:
          return new Map(e5);
        case 3:
          return Array.from(e5);
      }
      return mw(e5);
    }
    var Mw = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol", Lw = typeof Map != "undefined", Fw = typeof Set != "undefined", $w = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined", Bw = Mw ? Symbol.for("immer-nothing") : ((Vb = {})["immer-nothing"] = true, Vb), Vw = Mw ? Symbol.for("immer-draftable") : "__$immer_draftable", Uw = Mw ? Symbol.for("immer-state") : "__$immer_state", Hw = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(e5) {
      return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e5;
    }, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(e5) {
      return "Cannot apply patch, path doesn't resolve: " + e5;
    }, 16: 'Sets cannot have "replace" patches.', 17: function(e5) {
      return "Unsupported patch operation: " + e5;
    }, 18: function(e5) {
      return "The plugin for '" + e5 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + e5 + "()` when initializing your application.";
    }, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(e5) {
      return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + e5 + "'";
    }, 22: function(e5) {
      return "'current' expects a draft, got: " + e5;
    }, 23: function(e5) {
      return "'original' expects a draft, got: " + e5;
    }, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, Ww = "" + Object.prototype.constructor, qw = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e5) {
      return Object.getOwnPropertyNames(e5).concat(Object.getOwnPropertySymbols(e5));
    } : Object.getOwnPropertyNames, Kw = Object.getOwnPropertyDescriptors || function(e5) {
      var t3 = {};
      return qw(e5).forEach(function(n3) {
        t3[n3] = Object.getOwnPropertyDescriptor(e5, n3);
      }), t3;
    }, Yw = {}, Xw = { get: function(e5, t3) {
      if (t3 === Uw)
        return e5;
      var n3, r3, o3, a3 = hw(e5);
      if (!cw(a3, t3))
        return n3 = e5, (o3 = Iw(a3, t3)) ? "value" in o3 ? o3.value : (r3 = o3.get) === null || r3 === void 0 ? void 0 : r3.call(n3.k) : void 0;
      var i3 = a3[t3];
      return e5.I || !sw(i3) ? i3 : i3 === Tw(e5.t, t3) ? (Rw(e5), e5.o[t3] = Nw(e5.A.h, i3, e5)) : i3;
    }, has: function(e5, t3) {
      return t3 in hw(e5);
    }, ownKeys: function(e5) {
      return Reflect.ownKeys(hw(e5));
    }, set: function(e5, t3, n3) {
      var r3 = Iw(hw(e5), t3);
      if (r3 == null ? void 0 : r3.set)
        return r3.set.call(e5.k, n3), true;
      if (!e5.P) {
        var o3 = Tw(hw(e5), t3), a3 = o3 == null ? void 0 : o3[Uw];
        if (a3 && a3.t === n3)
          return e5.o[t3] = n3, e5.D[t3] = false, true;
        if (function(e6, t4) {
          return e6 === t4 ? e6 !== 0 || 1 / e6 == 1 / t4 : e6 != e6 && t4 != t4;
        }(n3, o3) && (n3 !== void 0 || cw(e5.t, t3)))
          return true;
        Rw(e5), Dw(e5);
      }
      return e5.o[t3] === n3 && typeof n3 != "number" && (n3 !== void 0 || t3 in e5.o) || (e5.o[t3] = n3, e5.D[t3] = true, true);
    }, deleteProperty: function(e5, t3) {
      return Tw(e5.t, t3) !== void 0 || t3 in e5.t ? (e5.D[t3] = false, Rw(e5), Dw(e5)) : delete e5.D[t3], e5.o && delete e5.o[t3], true;
    }, getOwnPropertyDescriptor: function(e5, t3) {
      var n3 = hw(e5), r3 = Reflect.getOwnPropertyDescriptor(n3, t3);
      return r3 ? { writable: true, configurable: e5.i !== 1 || t3 !== "length", enumerable: r3.enumerable, value: n3[t3] } : r3;
    }, defineProperty: function() {
      aw(11);
    }, getPrototypeOf: function(e5) {
      return Object.getPrototypeOf(e5.t);
    }, setPrototypeOf: function() {
      aw(12);
    } }, Gw = {};
    lw(Xw, function(e5, t3) {
      Gw[e5] = function() {
        return arguments[0] = arguments[0][0], t3.apply(this, arguments);
      };
    }), Gw.deleteProperty = function(e5, t3) {
      return isNaN(parseInt(t3)) && aw(13), Xw.deleteProperty.call(this, e5[0], t3);
    }, Gw.set = function(e5, t3, n3) {
      return t3 !== "length" && isNaN(parseInt(t3)) && aw(14), Xw.set.call(this, e5[0], t3, n3, e5[0]);
    };
    var Qw = function() {
      function e5(e6) {
        var t4 = this;
        this.g = $w, this.F = true, this.produce = function(e7, n3, r3) {
          if (typeof e7 == "function" && typeof n3 != "function") {
            var o3 = n3;
            n3 = e7;
            var a3 = t4;
            return function(e8) {
              var t5 = this;
              e8 === void 0 && (e8 = o3);
              for (var r4 = arguments.length, i4 = Array(r4 > 1 ? r4 - 1 : 0), s4 = 1; s4 < r4; s4++)
                i4[s4 - 1] = arguments[s4];
              return a3.produce(e8, function(e9) {
                var r5;
                return (r5 = n3).call.apply(r5, [t5, e9].concat(i4));
              });
            };
          }
          var i3;
          if (typeof n3 != "function" && aw(6), r3 !== void 0 && typeof r3 != "function" && aw(7), sw(e7)) {
            var s3 = _w(t4), l3 = Nw(t4, e7, void 0), u3 = true;
            try {
              i3 = n3(l3), u3 = false;
            } finally {
              u3 ? xw(s3) : Sw(s3);
            }
            return typeof Promise != "undefined" && i3 instanceof Promise ? i3.then(function(e8) {
              return kw(s3, r3), Pw(e8, s3);
            }, function(e8) {
              throw xw(s3), e8;
            }) : (kw(s3, r3), Pw(i3, s3));
          }
          if (!e7 || typeof e7 != "object") {
            if ((i3 = n3(e7)) === Bw)
              return;
            return i3 === void 0 && (i3 = e7), t4.F && vw(i3, true), i3;
          }
          aw(21, e7);
        }, this.produceWithPatches = function(e7, n3) {
          return typeof e7 == "function" ? function(n4) {
            for (var r4 = arguments.length, o4 = Array(r4 > 1 ? r4 - 1 : 0), a3 = 1; a3 < r4; a3++)
              o4[a3 - 1] = arguments[a3];
            return t4.produceWithPatches(n4, function(t5) {
              return e7.apply(void 0, [t5].concat(o4));
            });
          } : [t4.produce(e7, n3, function(e8, t5) {
            r3 = e8, o3 = t5;
          }), r3, o3];
          var r3, o3;
        }, typeof (e6 == null ? void 0 : e6.useProxies) == "boolean" && this.setUseProxies(e6.useProxies), typeof (e6 == null ? void 0 : e6.autoFreeze) == "boolean" && this.setAutoFreeze(e6.autoFreeze);
      }
      var t3 = e5.prototype;
      return t3.createDraft = function(e6) {
        sw(e6) || aw(8), iw(e6) && (e6 = Aw(e6));
        var t4 = _w(this), n3 = Nw(this, e6, void 0);
        return n3[Uw].C = true, Sw(t4), n3;
      }, t3.finishDraft = function(e6, t4) {
        var n3 = e6 && e6[Uw];
        n3 && n3.C || aw(9), n3.I && aw(10);
        var r3 = n3.A;
        return kw(r3, t4), Pw(void 0, r3);
      }, t3.setAutoFreeze = function(e6) {
        this.F = e6;
      }, t3.setUseProxies = function(e6) {
        e6 && !$w && aw(20), this.g = e6;
      }, t3.applyPatches = function(e6, t4) {
        var n3;
        for (n3 = t4.length - 1; n3 >= 0; n3--) {
          var r3 = t4[n3];
          if (r3.path.length === 0 && r3.op === "replace") {
            e6 = r3.value;
            break;
          }
        }
        var o3 = bw("Patches").$;
        return iw(e6) ? o3(e6, t4) : this.produce(e6, function(e7) {
          return o3(e7, t4.slice(n3 + 1));
        });
      }, e5;
    }(), Jw = new Qw();
    Jw.produce, Jw.produceWithPatches.bind(Jw), Jw.setAutoFreeze.bind(Jw), Jw.setUseProxies.bind(Jw), Jw.applyPatches.bind(Jw);
    var Zw, ek, tk, nk, rk, ok, ak, ik, sk, lk, uk, ck, dk, fk, pk, hk = Jw.createDraft.bind(Jw), mk = Jw.finishDraft.bind(Jw), vk = (e5) => (Zw = e5, ek), gk = () => {
      if (Zw === void 0)
        throw new Error("Calling stateEditors outside of a transaction is not allowed.");
      return Zw;
    };
    function yk() {
      let e5, t3;
      const n3 = new Promise((n4, o3) => {
        e5 = (e6) => {
          n4(e6), r3.status = "resolved";
        }, t3 = (e6) => {
          o3(e6), r3.status = "rejected";
        };
      }), r3 = { resolve: e5, reject: t3, promise: n3, status: "pending" };
      return r3;
    }
    tk = ek || (ek = {}), nk = tk.studio || (tk.studio = {}), ((rk = nk.historic || (nk.historic = {})).panelPositions || (rk.panelPositions = {})).setPanelPosition = function(e5) {
      const t3 = gk().historic;
      t3.panelPositions != null || (t3.panelPositions = {}), t3.panelPositions[e5.panelId] = e5.position;
    }, (ok = rk.panels || (rk.panels = {}))._ensure = function() {
      var e5;
      return (e5 = gk().historic).panels != null || (e5.panels = {}), gk().historic.panels;
    }, (ak = ok.outline || (ok.outline = {}))._ensure = function() {
      const e5 = tk.studio.historic.panels._ensure();
      return e5.outlinePanel != null || (e5.outlinePanel = {}), e5.outlinePanel;
    }, (ik = ak.selection || (ak.selection = {})).set = function(e5) {
      const t3 = [];
      for (const n3 of Na2(e5))
        be2(n3) ? t3.push(h2({ type: "Project" }, n3.address)) : we2(n3) ? (t3.push(h2({ type: "Sheet" }, n3.template.address)), tk.studio.historic.projects.stateByProjectId.stateBySheetId.setSelectedInstanceId(n3.address)) : ke2(n3) ? t3.push(h2({ type: "Sheet" }, n3.address)) : xe2(n3) ? (t3.push(h2({ type: "SheetObject" }, n3.template.address)), tk.studio.historic.projects.stateByProjectId.stateBySheetId.setSelectedInstanceId(n3.sheet.address)) : Se2(n3) && t3.push(h2({ type: "SheetObject" }, n3.address));
      ak._ensure().selection = t3;
    }, ik.unset = function() {
      ak._ensure().selection = [];
    }, (sk = ok.sequenceEditor || (ok.sequenceEditor = {}))._ensure = function() {
      const e5 = tk.studio.historic.panels._ensure();
      return e5.sequenceEditor != null || (e5.sequenceEditor = {}), e5.sequenceEditor;
    }, (sk.graphEditor || (sk.graphEditor = {})).setIsOpen = function(e5) {
      (function() {
        const e6 = sk._ensure();
        return e6.graphEditor != null || (e6.graphEditor = { height: 0.5, isOpen: false }), e6.graphEditor;
      })().isOpen = e5.isOpen;
    }, lk = rk.projects || (rk.projects = {}), (uk = lk.stateByProjectId || (lk.stateByProjectId = {}))._ensure = function(e5) {
      const t3 = gk().historic;
      return t3.projects.stateByProjectId[e5.projectId] || (t3.projects.stateByProjectId[e5.projectId] = { stateBySheetId: {} }), t3.projects.stateByProjectId[e5.projectId];
    }, (ck = uk.stateBySheetId || (uk.stateBySheetId = {}))._ensure = function(e5) {
      const t3 = tk.studio.historic.projects.stateByProjectId._ensure(e5);
      return t3.stateBySheetId[e5.sheetId] || (t3.stateBySheetId[e5.sheetId] = { selectedInstanceId: void 0, sequenceEditor: { selectedPropsByObject: {} } }), t3.stateBySheetId[e5.sheetId];
    }, ck.setSelectedInstanceId = function(e5) {
      tk.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(e5).selectedInstanceId = e5.sheetInstanceId;
    }, function(e5) {
      e5.addPropToGraphEditor = function(e6) {
        const { selectedPropsByObject: t3 } = ck._ensure(e6).sequenceEditor;
        t3[e6.objectKey] || (t3[e6.objectKey] = {});
        const n3 = t3[e6.objectKey], r3 = _h(e6.pathToProp), o3 = new Set(Object.keys(tg));
        for (const [e7, n4] of Object.entries(Aw(t3)))
          for (const [e8, t4] of Object.entries(n4))
            o3.delete(t4);
        const a3 = o3.size > 0 ? o3.values().next().value : Object.keys(tg)[0];
        n3[r3] = a3;
      }, e5.removePropFromGraphEditor = function(e6) {
        const { selectedPropsByObject: t3 } = ck._ensure(e6).sequenceEditor;
        if (!t3[e6.objectKey])
          return;
        const n3 = t3[e6.objectKey], r3 = _h(e6.pathToProp);
        n3[r3] && ow(t3, [e6.objectKey, r3]);
      };
    }(ck.sequenceEditor || (ck.sequenceEditor = {})), function(e5) {
      !function(e6) {
        e6._ensure = function(e7) {
          const t3 = gk().ephemeral;
          return t3.projects.stateByProjectId[e7.projectId] || (t3.projects.stateByProjectId[e7.projectId] = { stateBySheetId: {} }), t3.projects.stateByProjectId[e7.projectId];
        }, function(e7) {
          var t3;
          e7._ensure = function(e8) {
            const t4 = tk.studio.ephemeral.projects.stateByProjectId._ensure(e8);
            return t4.stateBySheetId[e8.sheetId] || (t4.stateBySheetId[e8.sheetId] = { stateByObjectKey: {} }), t4.stateBySheetId[e8.sheetId];
          }, (t3 = e7.stateByObjectKey || (e7.stateByObjectKey = {}))._ensure = function(e8) {
            var t4;
            const n3 = tk.studio.ephemeral.projects.stateByProjectId.stateBySheetId._ensure(e8).stateByObjectKey;
            return n3[t4 = e8.objectKey] != null || (n3[t4] = {}), n3[e8.objectKey];
          }, function(e8) {
            function t4(e9) {
              const t5 = tk.studio.ephemeral.projects.stateByProjectId.stateBySheetId.stateByObjectKey._ensure(e9);
              return t5.valuesBeingScrubbed != null || (t5.valuesBeingScrubbed = {}), t5.valuesBeingScrubbed;
            }
            e8._ensure = t4, e8.flag = function(e9) {
              Ta2(t4(e9), e9.pathToProp, true);
            };
          }(t3.propsBeingScrubbed || (t3.propsBeingScrubbed = {}));
        }(e6.stateBySheetId || (e6.stateBySheetId = {}));
      }(e5.stateByProjectId || (e5.stateByProjectId = {}));
    }((dk = nk.ephemeral || (nk.ephemeral = {})).projects || (dk.projects = {})), (fk = nk.ahistoric || (nk.ahistoric = {})).setVisibilityState = function(e5) {
      gk().ahistoric.visibilityState = e5;
    }, function(e5) {
      !function(e6) {
        e6._ensure = function(e7) {
          const t3 = gk().ahistoric;
          return t3.projects.stateByProjectId[e7.projectId] || (t3.projects.stateByProjectId[e7.projectId] = { stateBySheetId: {} }), t3.projects.stateByProjectId[e7.projectId];
        }, function(e7) {
          var t3;
          e7._ensure = function(e8) {
            const t4 = tk.studio.ahistoric.projects.stateByProjectId._ensure(e8);
            return t4.stateBySheetId[e8.sheetId] || (t4.stateBySheetId[e8.sheetId] = {}), t4.stateBySheetId[e8.sheetId];
          }, (t3 = e7.sequence || (e7.sequence = {}))._ensure = function(e8) {
            const t4 = tk.studio.ahistoric.projects.stateByProjectId.stateBySheetId._ensure(e8);
            return t4.sequence || (t4.sequence = {}), t4.sequence;
          }, (t3.clippedSpaceRange || (t3.clippedSpaceRange = {})).set = function(e8) {
            tk.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(e8).clippedSpaceRange = h2({}, e8.range);
          };
        }(e6.stateBySheetId || (e6.stateBySheetId = {}));
      }(e5.stateByProjectId || (e5.stateByProjectId = {}));
    }(fk.projects || (fk.projects = {})), function(e5) {
      var t3, n3;
      (e5.revisionHistory || (e5.revisionHistory = {})).add = function(e6) {
        const t4 = gk().historic.coreByProject[e6.projectId].revisionHistory;
        t4.unshift(e6.revision), t4.length > 50 && (t4.length = 50);
      }, (t3 = e5.sheetsById || (e5.sheetsById = {}))._ensure = function(e6) {
        const t4 = gk().historic.coreByProject[e6.projectId].sheetsById;
        return t4[e6.sheetId] || (t4[e6.sheetId] = { staticOverrides: { byObject: {} } }), t4[e6.sheetId];
      }, function(e6) {
        function t4(e7) {
          const t5 = tk.coreByProject.historic.sheetsById._ensure(e7);
          return t5.sequence != null || (t5.sequence = { subUnitsPerUnit: 30, length: 10, type: "PositionalSequence", tracksByObject: {} }), t5.sequence;
        }
        function n4(e7) {
          var t5;
          const n5 = tk.coreByProject.historic.sheetsById.sequence._ensure(e7).tracksByObject;
          return n5[t5 = e7.objectKey] != null || (n5[t5] = { trackData: {}, trackIdByPropPath: {} }), n5[e7.objectKey];
        }
        function r3(e7) {
          return n4(e7).trackData[e7.trackId];
        }
        function o3(e7) {
          const t5 = r3(e7);
          if (!t5)
            return;
          const n5 = Aw(t5.keyframes), o4 = e7.keyframes.filter((e8) => !!isFinite(e8.value) && !!e8.handles.every((e9) => isFinite(e9))).map((t6) => m2(h2({}, t6), { position: e7.snappingFunction(t6.position) })), a3 = ya(o4, "id"), i3 = n5.filter((e8) => !a3[e8.id]), s3 = ya(i3, "position");
          o4.forEach(({ position: e8 }) => {
            const t6 = s3[e8];
            t6 && ja2(i3, t6);
          });
          const l3 = Ia2([...i3, ...o4], "position");
          t5.keyframes = l3;
        }
        e6._ensure = t4, e6.setLength = function(e7) {
          t4(e7).length = parseFloat(e7.length.toFixed(2));
        }, e6.setPrimitivePropAsSequenced = function(e7) {
          const t5 = n4(e7), r4 = _h(e7.pathToProp);
          if (typeof t5.trackIdByPropPath[r4] == "string")
            return;
          const o4 = nw(10);
          t5.trackData[o4] = { type: "BasicKeyframedTrack", keyframes: [] }, t5.trackIdByPropPath[r4] = o4;
        }, e6.setPrimitivePropAsStatic = function(e7) {
          const t5 = n4(e7), r4 = JSON.stringify(e7.pathToProp), o4 = t5.trackIdByPropPath[r4];
          typeof o4 == "string" && (delete t5.trackIdByPropPath[r4], delete t5.trackData[o4], tk.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfPrimitiveProp(e7));
        }, e6.setCompoundPropAsStatic = function(e7) {
          const t5 = n4(e7);
          for (const n5 of Object.keys(t5.trackIdByPropPath)) {
            const r4 = JSON.parse(n5), o4 = e7.pathToProp.every((e8, t6) => r4[t6] === e8);
            if (o4) {
              const e8 = t5.trackIdByPropPath[n5];
              if (typeof e8 != "string")
                continue;
              delete t5.trackIdByPropPath[n5], delete t5.trackData[e8];
            }
          }
          tk.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfCompoundProp(e7);
        }, e6.setKeyframeAtPosition = function(e7) {
          const t5 = e7.snappingFunction(e7.position), n5 = r3(e7);
          if (!n5)
            return;
          const { keyframes: o4 } = n5, a3 = o4.findIndex((e8) => e8.position === t5);
          if (a3 !== -1)
            return void (o4[a3].value = e7.value);
          const i3 = ca2(o4, (e8) => e8.position < t5);
          if (i3 === -1)
            return void o4.unshift({ id: rw(), position: t5, connectedRight: true, handles: [0.5, 1, 0.5, 0], value: e7.value });
          const s3 = o4[i3];
          o4.splice(i3 + 1, 0, { id: rw(), position: t5, connectedRight: s3.connectedRight, handles: [0.5, 1, 0.5, 0], value: e7.value });
        }, e6.unsetKeyframeAtPosition = function(e7) {
          const t5 = r3(e7);
          if (!t5)
            return;
          const { keyframes: n5 } = t5, o4 = n5.findIndex((t6) => t6.position === e7.position);
          o4 !== -1 && n5.splice(o4, 1);
        }, e6.transformKeyframes = function(e7) {
          const t5 = r3(e7);
          if (!t5)
            return;
          const n5 = Aw(t5.keyframes).filter((t6) => e7.keyframeIds.indexOf(t6.id) !== -1), a3 = n5.map((t6) => {
            const n6 = t6.position, r4 = e7.snappingFunction(function(e8, { scale: t7, origin: n7, translate: r5 }) {
              return r5 + (n7 + (e8 - n7) * t7);
            }(n6, e7));
            return m2(h2({}, t6), { position: r4 });
          });
          o3(m2(h2({}, e7), { keyframes: a3 }));
        }, e6.deleteKeyframes = function(e7) {
          const t5 = r3(e7);
          t5 && (t5.keyframes = t5.keyframes.filter((t6) => e7.keyframeIds.indexOf(t6.id) === -1));
        }, e6.replaceKeyframes = o3;
      }(t3.sequence || (t3.sequence = {})), function(e6) {
        function t4(e7) {
          var t5;
          const n4 = tk.coreByProject.historic.sheetsById._ensure(e7).staticOverrides.byObject;
          return n4[t5 = e7.objectKey] != null || (n4[t5] = {}), n4[e7.objectKey];
        }
        e6.setValueOfCompoundProp = function(e7) {
          const n4 = t4(e7);
          Ta2(n4, e7.pathToProp, e7.value);
        }, e6.setValueOfPrimitiveProp = function(e7) {
          const n4 = t4(e7);
          Ta2(n4, e7.pathToProp, e7.value);
        }, e6.unsetValueOfPrimitiveProp = function(e7) {
          const t5 = tk.coreByProject.historic.sheetsById._ensure(e7).staticOverrides.byObject[e7.objectKey];
          t5 && ow(t5, e7.pathToProp);
        };
      }((n3 = t3.staticOverrides || (t3.staticOverrides = {})).byObject || (n3.byObject = {}));
    }((pk = tk.coreByProject || (tk.coreByProject = {})).historic || (pk.historic = {}));
    var bk, wk = w2(g);
    bk = typeof self != "undefined" ? self : typeof window != "undefined" || typeof window != "undefined" ? window : e4;
    var kk, xk, Sk = (typeof (xk = bk.Symbol) == "function" ? xk.observable ? kk = xk.observable : (kk = xk("observable"), xk.observable = kk) : kk = "@@observable", kk), _k = "@@redux/INIT";
    function Ek(e5, t3, n3) {
      var r3;
      if (typeof t3 == "function" && n3 === void 0 && (n3 = t3, t3 = void 0), n3 !== void 0) {
        if (typeof n3 != "function")
          throw new Error("Expected the enhancer to be a function.");
        return n3(Ek)(e5, t3);
      }
      if (typeof e5 != "function")
        throw new Error("Expected the reducer to be a function.");
      var o3 = e5, a3 = t3, i3 = [], s3 = i3, l3 = false;
      function u3() {
        s3 === i3 && (s3 = i3.slice());
      }
      function c3() {
        return a3;
      }
      function d2(e6) {
        if (typeof e6 != "function")
          throw new Error("Expected listener to be a function.");
        var t4 = true;
        return u3(), s3.push(e6), function() {
          if (t4) {
            t4 = false, u3();
            var n4 = s3.indexOf(e6);
            s3.splice(n4, 1);
          }
        };
      }
      function f2(e6) {
        if (!Dr2(e6))
          throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
        if (e6.type === void 0)
          throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
        if (l3)
          throw new Error("Reducers may not dispatch actions.");
        try {
          l3 = true, a3 = o3(a3, e6);
        } finally {
          l3 = false;
        }
        for (var t4 = i3 = s3, n4 = 0; n4 < t4.length; n4++) {
          (0, t4[n4])();
        }
        return e6;
      }
      return f2({ type: _k }), (r3 = { dispatch: f2, subscribe: d2, getState: c3, replaceReducer: function(e6) {
        if (typeof e6 != "function")
          throw new Error("Expected the nextReducer to be a function.");
        o3 = e6, f2({ type: _k });
      } })[Sk] = function() {
        var e6, t4 = d2;
        return (e6 = { subscribe: function(e7) {
          if (typeof e7 != "object")
            throw new TypeError("Expected the observer to be an object.");
          function n4() {
            e7.next && e7.next(c3());
          }
          return n4(), { unsubscribe: t4(n4) };
        } })[Sk] = function() {
          return this;
        }, e6;
      }, r3;
    }
    function Pk() {
    }
    function Ck(e5) {
      const t3 = [];
      {
        const n4 = typeof window == "object" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__(e5.devtoolsOptions) : ct2;
        t3.push(n4);
      }
      const n3 = function() {
        for (var e6 = arguments.length, t4 = Array(e6), n4 = 0; n4 < e6; n4++)
          t4[n4] = arguments[n4];
        return t4.length === 0 ? function(e7) {
          return e7;
        } : t4.length === 1 ? t4[0] : t4.reduce(function(e7, t5) {
          return function() {
            return e7(t5.apply(void 0, arguments));
          };
        });
      }(...t3);
      return Ek(e5.rootReducer, void 0, n3);
    }
    typeof Pk.name == "string" && Pk.name !== "isCrushed" && function(e5) {
      typeof console != "undefined" && typeof console.error == "function" && console.error(e5);
      try {
        throw new Error(e5);
      } catch (e6) {
      }
    }("You are currently using minified code outside of NODE_ENV === 'production'. This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) to ensure you have the correct code for your production build.");
    var jk = w2(g), Ok = (e5, t3, n3) => {
      const r3 = n3 + ".persistent", o3 = () => e5.getState().$persistent;
      !function() {
        const n4 = localStorage.getItem(r3);
        if (n4) {
          let r4, a4 = true;
          try {
            r4 = JSON.parse(n4), a4 = false;
          } catch (e6) {
            ye2.warn("Could not parse Theatre's persisted state. This must be a bug. Please report it.");
          } finally {
            a4 || (o4 = r4, e5.dispatch(Kb.replacePersistentState(o4))), t3();
          }
        } else
          t3();
        var o4;
      }();
      let a3 = o3();
      const i3 = () => {
        const e6 = o3();
        e6 !== a3 && (a3 = e6, localStorage.setItem(r3, JSON.stringify(e6)));
      };
      e5.subscribe(ra2(i3, 1e3)), window && window.addEventListener("beforeunload", i3);
    }, Tk = w2(g), Ik = class {
      constructor() {
        k2(this, "_values", {});
      }
      get(e5, t3) {
        if (this.has(e5))
          return this._values[e5];
        {
          const n3 = t3();
          return this._values[e5] = n3, n3;
        }
      }
      has(e5) {
        return this._values.hasOwnProperty(e5);
      }
    }, Dk = w2(g), Rk = "__TheatreJS_StudioBundle", Nk = w2(je.exports), Ak = w2(yh), zk = (0, Ak.default)(cc2)``;
    function Mk({ value: e5, label: t3, icon: n3, onClick: r3, isSelected: o3 }) {
      return Nk.default.createElement(Nk.default.Fragment, null, Nk.default.createElement(zk, { forwardedAs: Fu2, className: o3 ? "selected" : void 0, "aria-label": t3, onClick: r3, title: t3 }, n3));
    }
    var Lk = (0, Ak.default)($u2)`
  display: flex;
  gap: 5px;
`, Fk = ({ value: e5, onChange: t3, options: n3 }) => Nk.default.createElement(Lk, null, n3.map(({ label: n4, icon: r3, value: o3 }) => Nk.default.createElement(Mk, { key: o3, value: o3, isSelected: e5 === o3, label: n4, icon: r3, onClick: () => t3(o3) }))), $k = w2(je.exports), Bk = w2(yh).default.div``, Vk = (e5) => $k.default.createElement(Bk, null), Uk = new class {
      constructor() {
        k2(this, "ui"), k2(this, "publicApi"), k2(this, "address"), k2(this, "_projectsProxy", new _b.PointerProxy(new _b.Atom({}).pointer)), k2(this, "projectsP", this._projectsProxy.pointer), k2(this, "_store", new class {
          constructor() {
            k2(this, "_reduxStore"), k2(this, "_atom"), k2(this, "atomP"), this._reduxStore = Ck({ rootReducer: tw, devtoolsOptions: { name: "Theatre.js Studio" } }), this._atom = function(e5) {
              let t3 = e5.getState();
              const n3 = new wk.Atom(t3);
              return e5.subscribe(() => {
                const r3 = e5.getState();
                n3.setState(r3), t3 = r3;
              }), n3;
            }(this._reduxStore), this.atomP = this._atom.pointer;
          }
          initialize(e5) {
            const t3 = yk();
            return e5.usePersistentStorage === true ? Ok(this._reduxStore, () => {
              this.tempTransaction(({ drafts: e6 }) => {
                e6.ephemeral.initialised = true;
              }).commit(), t3.resolve();
            }, e5.persistenceKey) : (this.tempTransaction(({ drafts: e6 }) => {
              e6.ephemeral.initialised = true;
            }).commit(), t3.resolve()), t3.promise;
          }
          getState() {
            return this._reduxStore.getState();
          }
          __dev_startHistoryFromScratch(e5) {
            this._reduxStore.dispatch(Kb.historic.startHistoryFromScratch(Kb.reduceParts((t3) => m2(h2({}, t3), { historic: e5 }))));
          }
          tempTransaction(e5) {
            const t3 = (() => {
              const e6 = ew++;
              return { push: (t4) => Qb({ id: e6, originalAction: t4 }), discard: () => Jb(e6), commit: () => Zb(e6) };
            })();
            let n3;
            const r3 = t3.push(Kb.reduceParts((t4) => {
              const r4 = { historic: hk(t4.historic), ahistoric: hk(t4.ahistoric), ephemeral: hk(t4.ephemeral) };
              let o3 = true, a3 = () => {
                if (!o3)
                  throw new Error("You seem to have called the transaction api after studio.transaction() has finished running");
              };
              const i3 = { set: (e6, t5) => {
                a3();
                const { root: n4 } = (0, jk.getPointerParts)(e6);
                if (!xe2(n4))
                  throw new Error("Only setting props of SheetObject-s is supported in a transaction so far");
                {
                  n4.validateValue(e6, t5);
                  const r5 = (0, jk.val)(n4.template.getMapOfValidSequenceTracks_forStudio().getValue());
                  ve2(t5, (e7, t6) => {
                    if (e7 == null)
                      return;
                    const o4 = m2(h2({}, n4.address), { pathToProp: t6 }), a4 = kr2(r5, t6);
                    if (typeof a4 == "string") {
                      const t7 = n4.sheet.getSequence();
                      t7.position = t7.closestGridPosition(t7.position), s3.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(m2(h2({}, o4), { trackId: a4, position: t7.position, value: e7, snappingFunction: t7.closestGridPosition }));
                    } else
                      s3.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfPrimitiveProp(m2(h2({}, o4), { value: e7 }));
                  }, (0, jk.getPointerParts)(e6).path);
                }
              }, unset: (e6) => {
                a3();
                const { root: t5, path: n4 } = (0, jk.getPointerParts)(e6);
                if (!xe2(t5))
                  throw new Error("Only setting props of SheetObject-s is supported in a transaction so far");
                {
                  const r5 = (0, jk.val)(t5.template.getMapOfValidSequenceTracks_forStudio().getValue());
                  ve2(Cc2(t5.template.getDefaultValues().getValue(), n4), (e7, n5) => {
                    const o4 = m2(h2({}, t5.address), { pathToProp: n5 }), a4 = kr2(r5, n5);
                    typeof a4 == "string" ? s3.coreByProject.historic.sheetsById.sequence.unsetKeyframeAtPosition(m2(h2({}, o4), { trackId: a4, position: t5.sheet.getSequence().positionSnappedToGrid })) : s3.coreByProject.historic.sheetsById.staticOverrides.byObject.unsetValueOfPrimitiveProp(o4);
                  }, (0, jk.getPointerParts)(e6).path);
                }
              }, get drafts() {
                return a3(), r4;
              }, get stateEditors() {
                return s3;
              } }, s3 = vk(r4);
              try {
                return e5(i3), o3 = false, { historic: mk(r4.historic), ahistoric: mk(r4.ahistoric), ephemeral: mk(r4.ephemeral) };
              } catch (e6) {
                return n3 = e6, t4;
              } finally {
                vk(void 0);
              }
            }));
            if (this._reduxStore.dispatch(r3), n3)
              throw this._reduxStore.dispatch(t3.discard()), n3;
            return { commit: () => {
              this._reduxStore.dispatch(t3.commit());
            }, discard: () => {
              this._reduxStore.dispatch(t3.discard());
            } };
          }
          undo() {
            this._reduxStore.dispatch(Kb.historic.undo());
          }
          redo() {
            this._reduxStore.dispatch(Kb.historic.redo());
          }
          createContentOfSaveFile(e5) {
            if (!this._reduxStore.getState().$persistent.historic.innerState.coreByProject[e5])
              throw new Error(`Project ${e5} has not been initialized.`);
            const t3 = Nf2();
            this.tempTransaction(({ stateEditors: n4 }) => {
              n4.coreByProject.historic.revisionHistory.add({ projectId: e5, revision: t3 });
            }).commit();
            const n3 = this._reduxStore.getState().$persistent.historic.innerState.coreByProject[e5];
            return h2({}, n3);
          }
        }()), k2(this, "_corePrivateApi"), k2(this, "_cache", new Ik()), k2(this, "paneManager"), k2(this, "_coreAtom", new _b.Atom({})), k2(this, "_initializedDeferred", yk()), k2(this, "_initializeFnCalled", false), this.address = { studioId: nw(10) }, this.publicApi = new class {
          constructor(e5) {
            k2(this, "ui", { hide() {
              me2().ui.hide();
            }, get isHidden() {
              return me2().ui.isHidden;
            }, restore() {
              me2().ui.restore();
            } }), k2(this, "_cache", new Ik());
          }
          initialize(e5) {
            return me2().initialize(e5);
          }
          extend(e5) {
            me2().extend(e5);
          }
          transaction(e5) {
            return me2().transaction(({ set: t3, unset: n3 }) => e5({ set: t3, unset: n3 }));
          }
          _getSelectionDerivation() {
            return this._cache.get("_getStateDerivation()", () => (0, Tk.prism)(() => Ns2().filter((e5) => e5.type === "Theatre_SheetObject" || e5.type === "Theatre_Sheet").map((e5) => e5.publicApi)));
          }
          _getSelection() {
            return this._getSelectionDerivation().getValue();
          }
          setSelection(e5) {
            const t3 = [...e5].filter((e6) => Ee2(e6) || _e2(e6)).map((e6) => me2().corePrivateAPI(e6));
            me2().transaction(({ stateEditors: e6 }) => {
              e6.studio.historic.panels.outline.selection.set(t3);
            });
          }
          onSelectionChange(e5) {
            return this._getSelectionDerivation().tapImmediate(Xv, e5);
          }
          get selection() {
            return this._getSelection();
          }
          scrub() {
            return me2().scrub();
          }
          getStudioProject() {
            const e5 = me2().core;
            if (!e5)
              throw new Error("You're calling studio.getStudioProject() before `@theatre/core` is loaded. To fix this:\n1. Check if `@theatre/core` is import/required in your bundle.\n2. Check the stack trace of this error and make sure the funciton that calls getStudioProject() is run after `@theatre/core` is loaded.");
            return me2().getStudioProject(e5);
          }
          debouncedScrub(e5 = 1e3) {
            let t3;
            const n3 = ra2(() => {
              const e6 = t3;
              e6 && (t3 = void 0, e6.commit());
            }, e5);
            return { capture: (e6) => {
              t3 || (t3 = this.scrub());
              let r3 = true;
              try {
                t3.capture(e6), r3 = false;
              } finally {
                if (r3) {
                  const e7 = t3;
                  t3 = void 0, e7.discard();
                } else
                  n3();
              }
            } };
          }
          createPane(e5) {
            return me2().paneManager.createPane(e5);
          }
          destroyPane(e5) {
            return me2().paneManager.destroyPane(e5);
          }
          createContentOfSaveFile(e5) {
            return me2().createContentOfSaveFile(e5);
          }
        }(this), this.ui = new class {
          constructor(e5) {
            this.studio = e5, k2(this, "containerEl", document.createElement("div")), k2(this, "_rendered", false), k2(this, "_renderTimeout"), k2(this, "_documentBodyUIIsRenderedIn"), k2(this, "containerShadow"), this.containerEl.id = "theatrejs-studio-root", this.containerEl.style.cssText = "\n      position: fixed;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      pointer-events: none;\n      z-index: 100;\n    ", this.containerShadow = this.containerEl.attachShadow({ mode: "open" });
          }
          render() {
            this._rendered || (this._rendered = true, this._render());
          }
          _render() {
            const e5 = () => {
              document.body ? (this._renderTimeout = void 0, this._documentBodyUIIsRenderedIn = document.body, this._documentBodyUIIsRenderedIn.appendChild(this.containerEl), xb.default.render(kb.default.createElement(wb), this.containerShadow)) : this._renderTimeout = setTimeout(e5, 5);
            };
            this._renderTimeout = setTimeout(e5, 10);
          }
          hide() {
            this.studio.transaction(({ drafts: e5 }) => {
              e5.ahistoric.visibilityState = "everythingIsHidden";
            });
          }
          restore() {
            this.render(), this.studio.transaction(({ drafts: e5 }) => {
              e5.ahistoric.visibilityState = "everythingIsVisible";
            });
          }
          get isHidden() {
            return (0, Sb.val)(this.studio.atomP.ahistoric.visibilityState) === "everythingIsHidden";
          }
        }(this), this._attachToIncomingProjects(), this.paneManager = new class {
          constructor(e5) {
            this._studio = e5, k2(this, "_cache", new Ik()), this._instantiatePanesAsTheyComeIn();
          }
          _instantiatePanesAsTheyComeIn() {
            const e5 = this._getAllPanes();
            e5.changesWithoutValues().tap(() => {
              e5.getValue();
            });
          }
          _getAllPanes() {
            return this._cache.get("_getAllPanels()", () => (0, Dk.prism)(() => {
              if (!(0, Dk.val)(this._studio.coreP))
                return {};
              const e5 = (0, Dk.val)(this._studio.atomP.historic.panelInstanceDesceriptors), t3 = (0, Dk.val)(this._studio.atomP.ephemeral.extensions.paneClasses), n3 = {};
              for (const [, r3] of Object.entries(e5)) {
                const e6 = t3[r3.paneClass];
                if (!e6)
                  continue;
                const { instanceId: o3 } = r3, { extensionId: a3, classDefinition: i3 } = e6, s3 = Dk.prism.memo(`instance-${r3.instanceId}`, () => ({ extensionId: a3, instanceId: o3, definition: i3 }), qd2);
                n3[o3] = s3;
              }
              return n3;
            }));
          }
          get allPanesD() {
            return this._getAllPanes();
          }
          createPane(e5) {
            if (!this._studio.core)
              throw new Error("Can't create a pane because @theatre/core is not yet loaded");
            const t3 = (0, Dk.val)(this._studio.atomP.ephemeral.extensions.paneClasses[e5].extensionId), n3 = (0, Dk.val)(this._studio.atomP.historic.panelInstanceDesceriptors);
            let r3;
            for (let t4 = 1; t4 < 1e3 && (r3 = `${e5} #${t4}`, n3[r3]); t4++)
              ;
            if (!t3)
              throw new Error(`Pance class "${e5}" is not registered.`);
            return this._studio.transaction(({ drafts: t4 }) => {
              t4.historic.panelInstanceDesceriptors[r3] = { instanceId: r3, paneClass: e5 };
            }), this._getAllPanes().getValue()[r3];
          }
          destroyPane(e5) {
            if (!this._studio.core)
              throw new Error("Can't do this yet because @theatre/core is not yet loaded");
            this._studio.transaction(({ drafts: t3 }) => {
              delete t3.historic.panelInstanceDesceriptors[e5];
            });
          }
        }(this);
      }
      get atomP() {
        return this._store.atomP;
      }
      initialize(e5) {
        return t3 = this, n3 = null, r3 = function* () {
          if (this._initializeFnCalled)
            return this._initializedDeferred.promise;
          const t4 = { persistenceKey: "theatre-0.4", usePersistentStorage: true };
          typeof (e5 == null ? void 0 : e5.persistenceKey) == "string" && (t4.persistenceKey = e5.persistenceKey), (e5 == null ? void 0 : e5.usePersistentStorage) === false && (t4.usePersistentStorage = false);
          try {
            yield this._store.initialize(t4);
          } catch (e6) {
            return void this._initializedDeferred.reject(e6);
          }
          this._initializedDeferred.resolve(), this.ui.render();
        }, new Promise((e6, o3) => {
          var a3 = (e7) => {
            try {
              s3(r3.next(e7));
            } catch (e8) {
              o3(e8);
            }
          }, i3 = (e7) => {
            try {
              s3(r3.throw(e7));
            } catch (e8) {
              o3(e8);
            }
          }, s3 = (t4) => t4.done ? e6(t4.value) : Promise.resolve(t4.value).then(a3, i3);
          s3((r3 = r3.apply(t3, n3)).next());
        });
        var t3, n3, r3;
      }
      get initialized() {
        return this._initializedDeferred.promise;
      }
      _attachToIncomingProjects() {
        const e5 = (0, _b.valueDerivation)(this.projectsP), t3 = (e6) => {
          for (const t4 of Object.values(e6))
            t4.isAttachedToStudio || t4.attachToStudio(this);
        };
        e5.changesWithoutValues().tap(() => {
          t3(e5.getValue());
        }), t3(e5.getValue());
      }
      setCoreBits(e5) {
        this._corePrivateApi = e5.privateAPI, this._coreAtom.setIn(["core"], e5.coreExports), this._setProjectsP(e5.projectsP);
      }
      _setProjectsP(e5) {
        this._projectsProxy.setPointer(e5);
      }
      scrub() {
        return new class {
          constructor(e5) {
            this._studio = e5, k2(this, "_id"), k2(this, "_state", { type: "Ready" }), this._id = String(Ce2++);
          }
          get status() {
            return this._state.type;
          }
          reset() {
            const { _state: e5 } = this;
            if (e5.type !== "Ready") {
              if (e5.type !== "Captured")
                throw e5.type === "Committed" ? new Error("This scrub is already committed and can't be reset.") : new Error("This scrub is already discarded and can't be reset.");
              this._state = { type: "Ready" }, e5.transaction.discard(), e5.flagsTransaction.discard();
            }
          }
          commit() {
            const { _state: e5 } = this;
            if (e5.type !== "Captured") {
              if (e5.type === "Ready")
                return void ye2.warn("Scrub is empty. Nothing to commit.");
              throw e5.type === "Committed" ? new Error("This scrub is already committed.") : new Error("This scrub is already discarded and can't be comitted.");
            }
            e5.transaction.commit(), e5.flagsTransaction.discard(), this._state = { type: "Committed" };
          }
          capture(e5) {
            if (this._state.type === "Captured" && this.reset(), this._state.type !== "Ready")
              throw this._state.type === "Committed" ? new Error("This scrub is already committed and cannot capture again.If you wish to capture more, you can start a new studio.scrub() or do so before scrub.commit()") : new Error("This scrub is already discarded and cannot capture again.If you wish to capture more, you can start a new studio.scrub() or do so before scrub.discard()");
            {
              let t3 = true;
              try {
                this._state = h2({ type: "Captured" }, this._capture(e5)), t3 = false;
              } finally {
                t3 && (this._state = { type: "Discarded" });
              }
            }
          }
          _capture(e5) {
            const t3 = [];
            return { transaction: this._studio.tempTransaction((n3) => {
              let r3 = true;
              const o3 = { set: (e6, o4) => {
                if (!r3)
                  throw new Error("You seem to have called the scrub api after scrub.capture()");
                const { root: a3, path: i3 } = (0, ge2.getPointerParts)(e6);
                if (!xe2(a3))
                  throw new Error("We can only scrub props of Sheet Objects for now");
                n3.set(e6, o4), t3.push(e6);
              } };
              try {
                e5(o3);
              } finally {
                r3 = false;
              }
            }), flagsTransaction: this._studio.tempTransaction(({ stateEditors: e6 }) => {
              t3.forEach((t4) => {
                const { root: n3, path: r3 } = (0, ge2.getPointerParts)(t4);
                xe2(n3) && ve2(n3.template.getDefaultsAtPointer(t4), (t5, r4) => {
                  e6.studio.ephemeral.projects.stateByProjectId.stateBySheetId.stateByObjectKey.propsBeingScrubbed.flag(m2(h2({}, n3.address), { pathToProp: r4 }));
                }, r3);
              });
            }) };
          }
          discard() {
            const { _state: e5 } = this;
            if (e5.type !== "Captured" && e5.type !== "Ready")
              throw e5.type === "Committed" ? new Error("This scrub is already committed and can't be discarded.") : new Error("This scrub is already discarded");
            e5.type === "Captured" && (e5.transaction.discard(), e5.flagsTransaction.discard()), this._state = { type: "Discarded" };
          }
        }(this);
      }
      tempTransaction(e5) {
        return this._store.tempTransaction(e5);
      }
      transaction(e5) {
        return this.tempTransaction(e5).commit();
      }
      __dev_startHistoryFromScratch(e5) {
        return this._store.__dev_startHistoryFromScratch(e5);
      }
      get corePrivateAPI() {
        return this._corePrivateApi;
      }
      get core() {
        return this._coreAtom.getState().core;
      }
      get coreP() {
        return this._coreAtom.pointer.core;
      }
      extend(e5) {
        if (!e5 || typeof e5 != "object")
          throw new Error("Extensions must be JS objects");
        if (typeof e5.id != "string")
          throw new Error("extension.id must be a string");
        this.transaction(({ drafts: t3 }) => {
          var n3;
          if (t3.ephemeral.extensions.byId[e5.id])
            throw new Error(`Extension id "${e5.id}" is already defined`);
          t3.ephemeral.extensions.byId[e5.id] = e5;
          const r3 = t3.ephemeral.extensions.paneClasses;
          (n3 = e5.panes) == null || n3.forEach((t4) => {
            if (typeof t4.class != "string")
              throw new Error("pane.class must be a string");
            if (t4.class.length < 3)
              throw new Error("pane.class should be a string with 3 or more characters");
            const n4 = r3[t4.class];
            if (n4)
              throw new Error(`Pane class "${t4.class}" already exists and is supplied by extension ${n4}`);
            r3[t4.class] = { extensionId: e5.id, classDefinition: t4 };
          });
        });
      }
      getStudioProject(e5) {
        return this._cache.get("getStudioProject", () => e5.getProject("Studio"));
      }
      getExtensionSheet(e5, t3) {
        return this._cache.get("extensionSheet-" + e5, () => this.getStudioProject(t3).sheet("Extension " + e5));
      }
      undo() {
        this._store.undo();
      }
      redo() {
        this._store.redo();
      }
      createContentOfSaveFile(e5) {
        return this._store.createContentOfSaveFile(e5);
      }
    }();
    n2 = Uk;
    var Hk = Uk.publicApi;
    !function() {
      if (typeof window == "undefined")
        return;
      const e5 = window[Rk];
      if (e5 !== void 0)
        throw typeof e5 == "object" && e5 && typeof e5.version == "string" ? new Error("It seems that the module '@theatre/studio' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of theatre in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre/studio' multiple times. But those imports should point to the same module.") : new Error(`The variable window.${Rk} seems to be already set by a module other than @theatre/core.`);
      const t3 = new class {
        constructor(e6) {
          this._studio = e6, k2(this, "_coreBundle");
        }
        get type() {
          return "Theatre_StudioBundle";
        }
        registerCoreBundle(e6) {
          if (this._coreBundle)
            throw new Error("StudioBundle.coreBundle is already registered. This is a bug.");
          let t4;
          this._coreBundle = e6, e6.getBitsForStudio(this._studio, (e7) => {
            t4 = e7;
          }), this._studio.setCoreBits(t4);
        }
      }(Uk);
      window[Rk] = t3;
      const n3 = window.__TheatreJS_CoreBundle;
      n3 && n3 !== null && n3.type === "Theatre_CoreBundle" && t3.registerCoreBundle(n3);
    }();
  }(Ce, Ce.exports);
  var bh = h(Ce.exports);

  // divine_objects/VisaTools.js
  var import_paper = __toESM(require_paper_full());
  function hitTestItem(evt) {
    return import_paper.default.project.getItems({
      match: function(item) {
        return item.contains(evt.point);
      }
    }).pop();
  }
  function VisaTools() {
    const selected = [];
    const CircleAction = new import_paper.default.Tool();
    const CircleActionButton = document.getElementById("CircleAction");
    CircleActionButton.addEventListener("click", (evt) => {
      console.log("Casting Circle Spell Action...");
      cleanSelected();
      CircleAction.activate();
    });
    CircleAction.on("mouseup", (evt) => {
      const circle = this.createCircle([evt.point.x, evt.point.y]);
      this.world.pantheon["Communi"].act((god) => {
        god.communeIdea("circle", {
          position: {
            x: circle.position.x,
            y: circle.position.y
          },
          ...circle.data
        });
      });
      circle.remove();
    });
    const LineAction = new import_paper.default.Tool();
    const LineActionButton = document.getElementById("LineAction");
    LineActionButton.addEventListener("click", (evt) => {
      console.log("Casting Line Spell Action...");
      cleanSelected();
      LineAction.activate();
    });
    LineAction.on("mouseup", (evt) => {
      const item = hitTestItem(evt);
      if (!!item && selected.length < 2 && (item.data.type === "outline" || item.data.type === "circle") && !item.data.selected) {
        item.strokeWidth = 5;
        item.data.selected = true;
        selected.push(item);
      }
      if (selected.length === 2) {
        const line = this.createLineFromCircles(selected[0], selected[1]);
        this.world.pantheon["Communi"].act((god) => {
          god.communeIdea("line", {
            positions: {
              start: [line.firstSegment.point.x, line.firstSegment.point.y],
              end: [line.lastSegment.point.x, line.lastSegment.point.y]
            },
            ...line.data
          });
        });
        line.remove();
        cleanSelected();
      }
    });
    const OutlineAction = new import_paper.default.Tool();
    const OutlineActionButton = document.getElementById("OutlineAction");
    OutlineActionButton.addEventListener("click", (evt) => {
      console.log("Casting Outline Spell Action...");
      cleanSelected();
      OutlineAction.activate();
    });
    OutlineAction.on("mouseup", (evt) => {
      const item = evt.item || hitTestItem(evt);
      if (!!item && !item.data.selected && (item.data.type === "circle" || item.data.type === "line" || item.data.type === "outline")) {
        selected.push(item);
        item.data.selected = true;
        const outline = this.createOutline(item);
        this.world.pantheon["Communi"].act((god) => {
          god.communeIdea("outline", {
            position: outline.position,
            ...outline.data
          });
        });
        outline.remove();
      }
      cleanSelected();
    });
    const LabelAction = new import_paper.default.Tool();
    const LabelActionButton = document.getElementById("LabelAction");
    LabelActionButton.addEventListener("click", (evt) => {
      console.log("Casting Label Spell Action...");
      cleanSelected();
      LabelAction.activate();
    });
    LabelAction.on("mouseup", (evt) => {
      const item = evt.item || hitTestItem(evt);
      if (!!item && !item.data.selected && !item.data.label && (item.data.type === "circle" || item.data.type === "line" || item.data.type === "outline")) {
        selected.push(item);
        item.data.selected = true;
        const text = prompt("Speak your words");
        if (!text) {
          return;
        }
        item.data.label = text;
        this.world.pantheon["Communi"].act((god) => {
          god.communeIdea("label", {
            path: item.exportJSON(),
            ...item.data,
            scale: item.data.scale,
            type: "label"
          });
        });
      }
      cleanSelected();
    });
    function cleanSelected() {
      while (selected.length > 0) {
        const item = selected[selected.length - 1];
        item.strokeWidth = 1;
        item.data.selected = false;
        selected.pop();
      }
    }
    import_paper.default.tool = void 0;
  }

  // gods/Visio.js
  var import_paper2 = __toESM(require_paper_full());
  var Visio = class extends u {
    constructor() {
      super("Visio");
      this.canvas = document.getElementById("canvas");
      import_paper2.default.setup(this.canvas);
    }
    createOutlineFromPoint(point) {
      const item = hitTestItem({ point });
      return this.createOutline(item);
    }
    createOutline(item) {
      const outline = item.clone();
      outline.data.label = void 0;
      outline.data.selected = false;
      outline.data.scale = item.data.scale + 0.3;
      if (outline.data.type === "circle" || outline.data.type === "outline") {
        outline.scale(outline.data.scale);
      }
      outline.data.type = "outline";
      return outline;
    }
    createCircle(point) {
      const newCircle = new import_paper2.default.Path.Circle(new import_paper2.default.Point(point), 32);
      newCircle.strokeColor = (0, 0, 0);
      newCircle.closed = true;
      newCircle.data.type = "circle";
      newCircle.data.selected = false;
      newCircle.data.scale = 1.15;
      return newCircle;
    }
    createLine(start, end) {
      const line = import_paper2.default.Path.Line(new import_paper2.default.Point(start), new import_paper2.default.Point(end));
      line.strokeColor = (0, 0, 0);
      return line;
    }
    createLineFromCircles(startCircle, endCircle) {
      const line = import_paper2.default.Path.Line(startCircle.position, endCircle.position);
      const intersect1 = line.getIntersections(startCircle);
      const intersect2 = line.getIntersections(endCircle);
      const finalLine = import_paper2.default.Path.Line(intersect1[0].point.clone(), intersect2[0].point.clone());
      finalLine.strokeColor = (0, 0, 0);
      line.remove();
      finalLine.data.scale = 1.15;
      finalLine.data.type = "line";
      return finalLine;
    }
    createPointText(str, style) {
      const text = new import_paper2.default.PointText();
      text.content = str;
      if (style) {
        if (style.font)
          text.font = style.font;
        if (style.fontFamily)
          text.fontFamily = style.fontFamily;
        if (style.fontSize)
          text.fontSize = style.fontSize;
        if (style.fontWieght)
          text.fontWeight = style.fontWeight;
      }
      return text;
    }
    createPathFromJSON(path) {
      const tmpPath = import_paper2.default.Path.importJSON(path);
      tmpPath.strokeColor = (0, 0, 0);
      return tmpPath;
    }
    createAlignedText(str, path, style, scale) {
      const pathClone = path.clone();
      if (path.data.type !== "line")
        pathClone.scale(scale);
      if (str && str.length > 0 && path) {
        const glyphTexts = [];
        for (let i2 = 0; i2 < str.length; i2++) {
          glyphTexts[i2] = this.createPointText(str.substring(i2, i2 + 1), style);
          glyphTexts[i2].justification = "center";
        }
        const xOffsets = [0];
        for (let i2 = 1; i2 < str.length; i2++) {
          const pairText = this.createPointText(str.substring(i2 - 1, i2 + 1), style);
          pairText.remove();
          xOffsets[i2] = xOffsets[i2 - 1] + pairText.bounds.width - glyphTexts[i2 - 1].bounds.width / 2 - glyphTexts[i2].bounds.width / 2;
        }
        for (let i2 = 0; i2 < str.length; i2++) {
          let centerOffs = xOffsets[i2];
          if (pathClone.length < centerOffs) {
            if (pathClone.closed) {
              centerOffs = centerOffs % pathClone.length;
            } else {
              centerOffs = void 0;
            }
          }
          if (centerOffs === void 0) {
            glyphTexts[i2].remove();
          } else {
            const pathPoint = pathClone.getPointAt(centerOffs);
            glyphTexts[i2].point = pathPoint;
            const tan = pathClone.getTangentAt(centerOffs);
            glyphTexts[i2].rotate(tan.angle, pathPoint);
            pathClone.remove();
            path.data.label = str;
          }
        }
      }
    }
  };

  // gods/Communi.js
  var Communi = class extends u {
    constructor() {
      super("Communi");
      const websocketPrefix = "wss";
      this.telepathy = new WebSocket(`${websocketPrefix}://${window.location.host}/circle`);
      this.telepathy.addEventListener("message", (ev) => {
        console.log(ev.data);
        const data = JSON.parse(ev.data);
        if (!!data.action) {
          this.manifest(data.action, data.data);
        }
      });
      this.initialize();
    }
    initialize() {
      fetch("/circle/initialize").then((res) => res.json()).then((data) => {
        data.data.forEach((action) => {
          this.manifest(action.type, action);
        });
      });
    }
    communeWords(message) {
      this.telepathy.send(JSON.stringify({ message }));
    }
    communeIdea(action, idea) {
      this.telepathy.send(JSON.stringify({ action, data: idea }));
    }
    manifest(action, data) {
      this.world.pantheon["Visio"].act((god) => {
        switch (action) {
          case "circle":
            const circle = god.createCircle([data.position.x, data.position.y]);
            circle.data = data;
            break;
          case "line":
            const line = god.createLine(data.positions.start, data.positions.end);
            line.data = data;
            break;
          case "outline":
            const outline = god.createOutlineFromPoint(data.position);
            outline.data = data;
            break;
          case "label":
            const tempPath = god.createPathFromJSON(data.path);
            god.createAlignedText(data.label, tempPath, { fontSize: 10 }, data.scale);
            tempPath.remove();
            break;
        }
      });
    }
  };

  // divine_objects/Gestura.js
  var import_paper3 = __toESM(require_paper_full());
  var import_alloyfinger = __toESM(require_alloy_finger());
  function Gestura() {
    let zoom = 1;
    let rotation = 0;
    const gestures = new import_alloyfinger.default(canvas, {
      rotate: function(evt) {
        let delta = evt.angle + rotation;
        import_paper3.default.view.rotation += delta;
        rotation = evt.angle;
      },
      pinch: function(evt) {
        let delta = evt.zoom - zoom;
        import_paper3.default.view.zoom += delta;
        zoom = evt.zoom;
      },
      pressMove: (evt) => {
        let evtDelta = new import_paper3.default.Point(evt.deltaX, evt.deltaY);
        evtDelta = evtDelta.rotate(-import_paper3.default.view.rotation);
        import_paper3.default.view.center = import_paper3.default.view.center.subtract(evtDelta);
      }
    });
    return gestures;
  }

  // main.js
  window.addEventListener("load", () => {
    const MainWorld = new c();
    MainWorld.assignGod(new Visio());
    MainWorld.assignGod(new Communi());
    MainWorld.pantheon["Visio"].god.useTool(Gestura);
    MainWorld.pantheon["Visio"].god.useTool(VisaTools);
  });
})();
/*!
 * Paper.js v0.12.15 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jrg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Mar 17 10:49:48 2021 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jrg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
